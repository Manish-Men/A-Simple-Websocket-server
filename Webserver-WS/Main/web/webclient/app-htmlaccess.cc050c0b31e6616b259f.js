webpackJsonp([0],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * get caller details, such as caller function name, line num, file name
 *
 * @return Object detail JSON
 */
function getCallerDetail() {
   // now support Firefox 3.5 or higher, IE 8 or higher, Chrome 3 or higher,
   // Safari 5.0 or higher IE before version 10 and Safari don't support
   // Error.stack, so no caller detail will be showed
   var callerDetail = {}; // caller detail JSON to return
   var err = void 0,
       callerLine = void 0,
       index = void 0,
       content = void 0,
       str = void 0,
       callStack = void 0,
       callerIndex = void 0;
   var functionName = "",
       fileName = "",
       lineNum = "";
   var fileNameAndLineNumStr = void 0,
       fileNameAndLineNumArray = void 0;
   var objFuncRegExp = void 0,
       funcRegExp = void 0,
       lineNumRegExp = void 0;

   // throw error to get caller details
   try {
      throw new Error('');
   } catch (error) {
      err = error;
   }

   if (!err || !err.stack) {
      return callerDetail;
   }

   try {
      if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
         // the index of line containing caller's detail is 3
         callerLine = err.stack.split('\n')[3];
         fileNameAndLineNumStr = _jquery2.default.trim(callerLine.substring(callerLine.lastIndexOf('/') + 1, callerLine.length));
         fileNameAndLineNumArray = fileNameAndLineNumStr.split(":");
         // the array only has two elements
         fileName = fileNameAndLineNumArray[0];
         lineNum = fileNameAndLineNumArray[1];
         // there is no function name in error stack other than some function
         // related data, so put empty string to it
         functionName = "";
      } else {
         /**
          * For error stack information is used here, details of direct
          * caller of JSCDKLogger are on the line with index 4 or 5,
          * depending on the browser.
          */
         callStack = err.stack.split('\n');
         if (callStack.length < 2) {
            return callerDetail;
         }
         callerIndex = 3; // set default value
         var ua = window.navigator.userAgent.toLowerCase();
         var isIE = ua.indexOf('msie') !== -1 || ua.indexOf('trident') !== -1 || ua.indexOf('edge') !== -1;
         if (navigator.userAgent.toLowerCase().indexOf('AppleWebKit') > -1) {
            // Chrome puts Error in the callstack, however, error stack on
            // chrome may contains "at Error..." in the second line or not,
            // so add a branch to determine callerIndex
            if (callStack[1].indexOf("at Error") !== -1) {
               callerIndex = 5;
            } else {
               callerIndex = 4;
            }
         } else if (isIE) {
            // old-version IE except IE10 don't support Error.stack, so this
            // branch will not be entered by them IE10 doesn't put Error in
            // the callstack, so we look at index 4.
            callerIndex = 4;
         }
         if (callStack.length <= callerIndex) {
            return callerDetail;
         }
         callerLine = callStack[callerIndex];
         index = callerLine.indexOf('at ');
         // 3 represents the length of 'at '
         content = callerLine.slice(index + 3, callerLine.length);

         objFuncRegExp = /Object\.(.*?)\(/; // regexp to handle function in
         // Object
         funcRegExp = /(.*?)\(/; // regexp to handle normal function

         // get function name
         str = objFuncRegExp.exec(content);
         // handle functions in object and normal functions below
         functionName = _jquery2.default.trim(str ? str[1] : funcRegExp.exec(content)[1]) + "()";

         // get line number
         lineNumRegExp = /(.*?):(.*?):(.*?):/;
         // 3 represents index of lineNum in results which match this regular
         // expression
         lineNum = _jquery2.default.trim(lineNumRegExp.exec(content)[3]);

         // get file name
         // 2 represents index of string which contains file name to be
         // parsed
         str = lineNumRegExp.exec(content)[2];
         fileName = _jquery2.default.trim(str.substring(str.lastIndexOf('/') + 1, str.length));
      }
   } catch (e) {}

   callerDetail.functionName = functionName;
   callerDetail.fileName = fileName;
   callerDetail.lineNum = lineNum;

   return callerDetail;
}

/**
 * Helper function used to create a string with a desired length by padding
 * it with preceding zeroes, if necessary.
 *   pad(1, 5) will return "00001".
 *   pad("100", 1) will return "100".
 *   pad(-1, 5) will return "-00001".
 *   pad("-10", 4) will return "-0010".
 *
 * @param value[in] value that will be padded, if necessary.
 * @param maxLen[in] length that will be used to pad zeroes, if necessary.
 * @return string padded to appropriate length.
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * jscdkLogger.js --
 *
 *      Log class for the web client.
 */

function pad(value, maxLen) {
   var string = value.toString(),
       negative = string.indexOf("-") === 0,
       length = negative ? string.length - 1 : string.length;
   return length < maxLen ? pad(negative ? "-0" + string.slice(1) : "0" + string, maxLen) : string;
}

var JSCDKLogger = {
   LEVEL_TRACE: 0,
   LEVEL_DEBUG: 1,
   LEVEL_INFO: 2,
   LEVEL_WARNING: 3,
   LEVEL_ERROR: 4,

   LEVEL_DESC: ["Trace", "Debug", "Info", "Warning", "Error"],

   // Default log level is set to DEBUG.
   LOG_LEVEL: 1,

   logAppender: null,

   logFunction: null,

   trace: function trace(args) {
      this.log(args, this.LEVEL_TRACE);
   },
   debug: function debug(args) {
      this.log(args, this.LEVEL_DEBUG);
   },
   info: function info(args) {
      this.log(args, this.LEVEL_INFO);
   },
   warning: function warning(args) {
      this.log(args, this.LEVEL_WARNING);
   },
   error: function error(args) {
      this.log(args, this.LEVEL_ERROR);
   },

   log: function log(args, level) {
      var logTime = void 0,
          logString = void 0,
          callerDetail = {},
          functionName = void 0,
          fileName = void 0,
          lineNum = void 0;

      if (level >= this.LOG_LEVEL) {
         if (args) {
            logTime = new Date();
            callerDetail = getCallerDetail();
            functionName = !!callerDetail.functionName ? callerDetail.functionName : "";
            fileName = !!callerDetail.fileName ? callerDetail.fileName : "";
            lineNum = !!callerDetail.lineNum ? callerDetail.lineNum : "";
            logString = "[" + logTime.getFullYear() + "-" + pad(logTime.getMonth() + 1, 2) + "-" + pad(logTime.getDate(), 2) + "T" + pad(logTime.getHours(), 2) + ":" + pad(logTime.getMinutes(), 2) + ":" + pad(logTime.getSeconds(), 2) + "." + pad(logTime.getMilliseconds(), 3) + "][" + this.LEVEL_DESC[level] + "]";
            if (!(functionName === "" && fileName === "" && lineNum === "")) {
               logString += "[" + functionName + " " + fileName + ":" + lineNum + "]";
            }
            logString += ": " + args;
         }

         if (this.logAppender) {
            (0, _jquery2.default)(this.logAppender).append(logString + "<br />");
         }
         if (typeof this.logFunction === "function") {
            this.logFunction(logString);
         }
         if (!!window.console && typeof window.console.log === "function") {
            window.console.log(logString);
         }
      }
   },

   /**
    * Set the log level.
    *
    * @param logLevel [in] the log level of the application.
    */
   setLogLevel: function setLogLevel(logLevel) {
      this.LOG_LEVEL = logLevel;
   },

   /**
    * Set the log appender.
    *
    * @param logAppender [in] a div object to show the logs.
    */
   setLogAppender: function setLogAppender(logAppender) {
      this.logAppender = logAppender;
   },

   /**
    * Set the custom log function.
    *
    * @param logFn [in] a function used to log.
    */
   setLogFunction: function setLogFunction(logFn) {
      this.logFunction = logFn;
   }
};

exports.default = JSCDKLogger;

/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.globalArray = undefined;
exports.jscdkClientSetUIController = jscdkClientSetUIController;
exports.UIEventToJSCDK = UIEventToJSCDK;
exports.JSCDKSetUI = JSCDKSetUI;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClientController = __webpack_require__(52);

var _jscdkClientController2 = _interopRequireDefault(_jscdkClientController);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var globalArray = exports.globalArray = {
  // set 6.0 as the API version of supporting setClientInfo
  clientInfoAPIVersion: "6.0",

  // set 9.0 as the API version of supporting getLaunchItems and idle timeout
  applicationAPIVersion: "9.0",
  applicationParamVersion: "12.0",
  /* set >=6.0  to support clientInfo,
   *     >=7.0  to support SAML,
   *     >=9.0  to further support applications and idle timeout,
   *     >=10.0 to support disconnect session,
   *     >=12.0 to support RDSH application launching params,
   *     >=13.0 to support restart desktop,
   * this value will be rewrite according to response of XML
   */
  brokerVersion: "13.0",
  // whether broker is set to ws1 mode
  ws1Mode: false,
  workspaceOneServerHostname: ''
};

/**
 * Set the UI controller to JSCDK library to let UI response to JSCDK's
 * events.
 *
 * @param controller [in] the main UI controller.
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * jscdkClient.js --
 *
 *      Interfaces between UI and JSCDK.
 */

function jscdkClientSetUIController(controller) {
  // if (!globalArray["uiController"]) {
  globalArray["uiController"] = controller;
  //    JSCDKLogger.debug("UI Controller is set to JSCDK.");
  // } else {
  //    JSCDKLogger.warning("UI Controller has already been set.");
  // }
}

/**
 * Interface from UI to JSCDK.
 *
 * @param action [in] a JSON string describes the action content.
 */
function UIEventToJSCDK(action) {
  var actionArray = _jquery2.default.parseJSON(action);
  _jscdkClientController2.default.getInstance().execute(actionArray);
}

/**
 * Interface from JSCDK to UI.
 *
 * @param action [in] a JSON string describes the action content.
 */
function JSCDKSetUI(action) {
  var mainUIController = _util2.default.getObject(globalArray, "uiController");
  if (mainUIController) {
    mainUIController.responseToJSCDKEvent(action);
  }
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*global XMLSerializer, chrome, document */

var util = {
   /**
    * check whether broker version support application and idel timeout
    *
    * @return bool satisfied
    */
   brokerSupportApplication: function brokerSupportApplication() {
      if (!!_jscdkClient.globalArray["brokerVersion"] && !!_jscdkClient.globalArray["applicationAPIVersion"] && parseFloat(_jscdkClient.globalArray["brokerVersion"]) >= parseFloat(_jscdkClient.globalArray["applicationAPIVersion"])) {
         return true;
      }
      return false;
   },

   /**
    * check whether broker version support restart desktop.
    * this was supported from broker 13.0
    * @return bool satisfied
    */
   brokerSupportRestartDesktop: function brokerSupportRestartDesktop() {
      if (!!_jscdkClient.globalArray["brokerVersion"] && parseFloat(_jscdkClient.globalArray["brokerVersion"]) > 12) {
         return true;
      }
      return false;
   },

   /**
    * find the first element in the given list that contains the given property
    *
    * @param propertyName[in]: of type "string"
    *   the compare will be done for this preperty for each element
    * @param targetValue[in]: of type "any class that support ==="
    *   the property value of the searching target
    * @param list[in]: of type "Array/Object"
    *   the list that search alone with.
    */
   findFirstItemWithPropertyInList: function findFirstItemWithPropertyInList(propertyName, targetValue, list) {
      var key = void 0;
      for (key in list) {
         if (list.hasOwnProperty(key) && !!list[key] && list[key][propertyName] === targetValue) {
            return list[key];
         }
      }
      return null;
   },

   /**
    * create a new xml element
    *
    * We don't use the document object because the "param" node can't be add to
    * the document object correctly in Javascript.
    * @param name[in]  the name of the XML node
    * @param content[in]  the content of the XML node, can be nested XML
    * @param attrArray[in]  key-value pairs for xml attributes
    * @return a new element
    */
   createElement: function createElement(name, content, attrArray) {
      // Length of parameters defined in function below
      var defParamLength = util.createElement.length;
      // Length of actual parameters below
      var actParamLength = arguments.length;
      var xmlText = "";
      var attrText = "";
      var attrKey = void 0;
      var attrValue = void 0;

      if (defParamLength === actParamLength) {
         for (attrKey in attrArray) {
            if (attrArray.hasOwnProperty(attrKey)) {
               attrValue = attrArray[attrKey];
               attrText += " " + attrKey + "='" + attrValue + "'";
            }
         }
      }
      if (typeof content === "undefined" || content === "") {
         xmlText = "<" + name + attrText + "/>";
      } else {
         if (util.validateXML(content) === true) {
            xmlText = "<" + name + attrText + ">" + content + "</" + name + ">";
         } else {
            // if content is pure text, escape content
            xmlText = "<" + name + attrText + ">" + util.escapeElement(content) + "</" + name + ">";
         }
      }

      return xmlText;
   },

   /**
    * compose messages for handlerList using jQuery
    *
    * @param handlerList[in] list including handlers whose messages can be sent
    *    together
    * @param brokerVersion[in]  broker version used in xml
    * @return the xml message composed
    */
   createXML: function createXML(handlerList, brokerVersion) {
      var composedMessage = ""; // the composed message to be returned
      var handlerKey = void 0;
      var handler = void 0;
      var content = void 0;
      composedMessage += "<?xml version='1.0' encoding='UTF-8'?><broker version='" + brokerVersion + "'>";
      for (handlerKey in handlerList) {
         if (handlerList.hasOwnProperty(handlerKey)) {
            handler = handlerList[handlerKey];
            content = handler.requestXML;
            if (typeof content === "undefined" || content === "") {
               composedMessage += "<" + handler.messageText + "/>";
            } else {
               composedMessage += "<" + handler.messageText + ">";
               composedMessage += content;
               composedMessage += "</" + handler.messageText + ">";
            }
         }
      }
      composedMessage += "</broker>";
      return composedMessage;
   },

   /**
    * Find whether one handler is in the target array using handler's message
    * name as the key.
    *
    * @param handler[in] the handler to find.
    * @param targetArray[in] the target array to find.
    * @return -1 if not found, else the position of the handler in the target
    *         array.
    */
   findHandlerInArray: function findHandlerInArray(handler, targetArray) {
      var index = 0;
      for (index = 0; index < targetArray.length; index++) {
         if (targetArray[index].messageName === handler.messageName) {
            return index;
         }
      }
      return -1;
   },

   /**
    * Convert XML document to string
    *
    * @param xmlDoc[in] the XML document needs to be converted.
    * @return the converted string.
    */
   XMLToString: function XMLToString(xmlDoc) {
      var xmlString = "",
          serializer = void 0;

      try {
         if (typeof XMLSerializer === 'function') {
            serializer = new XMLSerializer();
            xmlString = serializer.serializeToString(xmlDoc);
         }
      } catch (error) {
         // For IE browsers which don't support XMLSerializer.
         xmlString = xmlDoc.xml || '';
      }

      return xmlString;
   },

   /**
    * get object from array named "name"
    *
    * @param array[in] the array to look for
    * @param name[in] the object's name
    * @return the object named "name"
    */
   getObject: function getObject(array, name) {
      if (!array) {
         return null;
      } else {
         return array[name];
      }
   },

   /**
    * get child element node named "name",
    set idx to 0 if only 2 parameters exist
    *
    * @param parentNode[in] whose child to be got
    * @param name[in] child's name
    * @param idx[in] child's index
    * @return the available child node
    */
   getChildNode: function getChildNode(parentNode, name, idx) {
      var childNode = void 0;
      // Length of parameters defined in function below
      var defParamLength = util.getChildNode.length;
      // Length of actual parameters below
      var actParamLength = arguments.length;
      if (defParamLength === actParamLength) {
         if (!parentNode) {
            return null;
         } else {
            childNode = parentNode.getElementsByTagName(name);
            if (!childNode) {
               return null;
            } else {
               if (childNode.length <= idx) {
                  return null;
               } else {
                  return childNode[idx];
               }
            }
         }
      } else if (defParamLength - 1 === actParamLength) {
         // only 2 parameter, set idx to 0 by default
         util.getChildNode(parentNode, name, 0);
      }
   },

   /**
    * add new key-value item for jsonObject
    *
    * @param jsonObject[in] the json object to be handled
    * @param key[in] new item's key to be added
    * @param value[in] new item's value to be added
    * @return the status of this operation, true/false
    */
   addItemForJson: function addItemForJson(jsonObject, key, value) {
      if (!jsonObject) {
         return false;
      } else {
         jsonObject[key] = value;
         return true;
      }
   },

   /**
    * get the value of param named paramName from url
    *
    * @param url[in] the url to be handled
    * @param paramName[in] param name in url to be used
    * @return param value of param named paramName in url
    */
   getUrlParam: function getUrlParam(url, paramName) {
      var param = void 0,
          paramKey = void 0,
          paramValue = void 0,
          i = void 0;
      var ret = null;
      var params = url.slice(url.indexOf('?') + 1).split('&');
      for (i = 0; i < params.length; i++) {
         param = params[i].split('=');
         paramKey = param[0];
         paramValue = param[1];
         if (paramKey === paramName) {
            ret = paramValue;
         }
      }
      return ret;
   },

   /**
    * get decoded value of param named paramName from url
    *
    * @param url[in] the url to be handled
    * @param paramName[in] param name in url to be used
    * @return decoded value of param named paramName in url
    */
   getDecodedUrlParam: function getDecodedUrlParam(url, paramName) {
      var ret = null;
      var urlParam = util.getUrlParam(url, paramName);
      if (!!urlParam) {
         ret = decodeURIComponent(urlParam);
      }
      return ret;
   },

   /**
    * escape illegal characters in XML element string, such as '&', '<'
    * @param text[in] XML element string containing illegal characters
    * @return escaped XML element string
    */

   escapeElement: function escapeElement(text) {
      // Characters like "<" and "&" are illegal in XML elements.
      // see
      // https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references
      if (!!text) {
         return text.replace(/["&'<>]/g, function (c) {
            if (c === '"') {
               return "&quot;";
            } else if (c === "'") {
               return "&apos;";
            } else if (c === "<") {
               return "&lt;";
            } else if (c === ">") {
               return "&gt;";
            } else if (c === "&") {
               return "&amp;";
            } else {
               return '&#' + c.charCodeAt(0) + ';';
            }
         });
      }
      return text;
   },

   /**
    * unescape characters in XML element string, such as '&amp;', '&lt;'
    * @param text[in] XML element string to unescape
    * @return unescaped XML element string
    */

   unescapeElement: function unescapeElement(text) {
      // Characters like "<" and "&" are illegal in XML elements.
      // refer to: http://www.w3schools.com/xml/xml_cdata.asp
      if (!!text) {
         text = text.replace(/\&quot;/g, '"');
         text = text.replace(/\&apos;/g, "'");
         text = text.replace(/\&lt;/g, "<");
         text = text.replace(/\&gt;/g, ">");
         text = text.replace(/\&amp;/g, "&");
      }
      return text;
   },

   /**
    * validate xmlString whether it is pure text without xml elements
    * @param xmlString[in] xmlString to be validated
    * @return true/false, whether xmlString is pure text without xml elements
    */

   validateXML: function validateXML(xmlString) {
      var xmlDoc = void 0;
      var isValid = void 0;
      var len = void 0;

      try {
         /**
          * add a root element "<validate></validate>" to avoid XML validation
          * error caused by mutiple XML elements (this case is valid) in
          * xmlString
          */
         xmlDoc = _jquery2.default.parseXML('<validate>' + xmlString + '</validate>');
         len = (0, _jquery2.default)(xmlDoc).find("validate").children().length;
         if (len === 0) {
            /**
             * "len === 0" indicates that xmlString is a text string,
             * without XML elements in it.
             */
            isValid = false;
         } else {
            /**
             * xmlString has one or mutiple XML elements but it is valid.
             * For example,
             * "<name>username</name><values><value>haijiang</value></values>".
             * It is valid as a part of final xml string, because
             * createElement() has been called three times to generate this
             * string
             */
            isValid = true;
         }
      } catch (e) {
         /**
          * "validate error" indicates that xmlString has special characters to
          * escape
          */
         isValid = false;
         _jscdkLogger2.default.error("validate XML error: " + e);
      }
      return isValid;
   },

   /**
    * Parses a URL into its components
    * XXX TODO: Potentially rewrite this.
    *
    * @param url[in] URL to parse
    * @return object containing information about the URL
    */
   parseURL: function parseURL(url) {
      var a = document.createElement('a');

      try {
         /*
          * IE10 (possibly among others) has problems parsing a link if there is no protocol
          * attached to it.
          */
         if (url.indexOf("://") !== -1) {
            a.href = url;
         } else {
            a.href = "https://" + url;
         }
         return {
            source: url,
            protocol: a.protocol.replace(':', ''),
            host: a.hostname,
            port: a.port,
            query: a.search,
            params: function () {
               var ret = {},
                   seg = a.search.replace(/^\?/, '').split('&'),
                   len = seg.length,
                   i = 0,
                   s = void 0;
               for (i = 0; i < len; i++) {
                  if (!seg[i]) {
                     continue;
                  }
                  s = seg[i].split('=');
                  ret[s[0]] = s[1];
               }
               return ret;
            }(),
            file: (a.pathname.match(/\/([^\/?#]+)$/i) || ['', ''])[1],
            hash: a.hash.replace('#', ''),
            path: a.pathname.replace(/^([^\/])/, '/$1'),
            relative: (a.href.match(/tps?:\/\/[^\/]+(.+)/) || ['', ''])[1],
            segments: a.pathname.replace(/^\//, '').split('/')
         };
      } catch (e) {
         /*
          * Browsers may throw an exception if the URL is not valid.  Return an object
          * with the expected members all empty so the applications don't have to check
          * whether a member exists before using it.
          */
         return {
            source: url,
            protocol: "",
            host: "",
            port: "",
            query: "",
            params: {},
            file: "",
            hash: "",
            path: "",
            relative: "",
            segments: ""
         };
      }
   },

   /**
    * Check whether the code is running under Chrome Extension enviroment.
    * If chrome.extension APIs are defined, it is running in Chrome Extension
    * enviroment.
    *
    * @return true if it is in Chrome Extension enviroment, else false.
    */

   isChromeExtension: function isChromeExtension() {
      if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
         if (!!chrome && !!chrome.extension) {
            return true;
         }
      }
      return false;
   },

   /**
    * Compute a random 128-bit string to use as the random token in the direct
    * connect case. Returns the result a string in the following format:
    * xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
    *
    * This UUID follows RFC 4122 type 4. 'x's map to random hex digits and 'y'
    * maps to 8, 9, a, or b.
    *
    * This code is based on BSG code for generating routing tokens.
    */
   getUuid: function getUuid() {
      /**
       * Generate random numbers between 0 and 1 seeded using the current time.
       */
      var random = function random() {
         var d = new Date();
         var seed = Math.abs(1000 * d.getSeconds() + d.getMilliseconds());
         var r = seed * Math.random();
         return r - Math.floor(r);
      };

      /**
       * Generate a version 4 UUID using the random() function to generate
       * each hex digit.
       */
      var token = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
         var r = random() * 16 | 0,
             v = c === 'x' ? r : r & 0x3 | 0x8;

         return v.toString(16);
      }).toUpperCase();

      return token;
   },

   /**
    * Replace the secret field's value such as password before logging it.
    *
    * @param message [in] message needs to be censored.
    * @param type    [in] message type: XML or JSON, default type is XML.
    * @return the censored string, or "CENSORING FAILED" when translation fails.
    */
   censorMessage: function censorMessage(message, type) {
      var censoredMessage = message,
          secretParams = ["framework-channel-ticket", "newPassword1", "newPassword2", "oldPassword", "passcode", "password", "pin1", "pin2", "smartCardPIN", "secret", "token", "tokencode", "url"],
          messageType = type || 'XML',
          xmlDoc = void 0,
          xml = void 0,
          secretNode = void 0,
          secretKey = void 0,
          obj = void 0,
          i = void 0;

      try {
         if (messageType.toLowerCase() === 'xml') {
            xmlDoc = _jquery2.default.parseXML(censoredMessage);
            xml = (0, _jquery2.default)(xmlDoc);
            secretNode = xml.find('param');
            secretNode = Array.prototype.slice.call(secretNode);
            for (secretKey in secretNode) {
               // Skip non-properties to avoid bugs like 1732807
               if (!secretNode.hasOwnProperty(secretKey)) {
                  continue;
               }
               if (_jquery2.default.inArray((0, _jquery2.default)(secretNode[secretKey]).children('name').text(), secretParams) !== -1) {
                  (0, _jquery2.default)(secretNode[secretKey]).find('value').text("[REDACTED]");
               }
            }
            censoredMessage = util.XMLToString(xmlDoc);
         } else {
            obj = _jquery2.default.parseJSON(censoredMessage);
            for (i = 0; i < secretParams.length; i++) {
               secretKey = secretParams[i];
               if (obj.hasOwnProperty(secretKey)) {
                  obj[secretKey] = '[REDACTED]';
               }
            }
            censoredMessage = JSON.stringify(obj);
         }

         return censoredMessage;
      } catch (e) {
         // Parse document fail
         return "CENSORING FAILED";
      }
   },

   /**
    * Serializes information about an error into a string.  I used to just
    * stringify the entire error object but sometimes it would have circular
    * references which would throw its own exception.  The next best thing
    * is to just log the top-level items in the error object.
    *
    * @param e[in] error object to serialize.
    * @return string containing error serialization.
    */
   serializeError: function serializeError(e) {
      var key = void 0,
          detail = "";
      for (key in e) {
         if (e.hasOwnProperty(key)) {
            detail += "\r\n   " + key + ": " + e[key];
         }
      }
      return detail;
   },

   getSelfDefinedErrorObjectBy: function getSelfDefinedErrorObjectBy(xmlHandler, errorMessage, errorDetail) {
      var ErrorObj = {};
      var errorKey = void 0;

      errorKey = xmlHandler.name || xmlHandler.messageName || "self-defined error";
      _jscdkLogger2.default.error("error from " + errorKey + ": " + errorMessage);

      ErrorObj.errorType = errorKey;
      ErrorObj.errorText = errorMessage;
      if (!!errorDetail) {
         ErrorObj.errorDetail = errorDetail;
      }
      return ErrorObj;
   },

   /**
    * Deals with some of the L10N features like using display text based on
    * user's locale.
    */
   l10N: {

      // Mapping of supported locales to the corresponding JSON file.
      supportedLocale: {
         "en": "en",
         "es": "es",
         "de": "de",
         "fr": "fr",
         "ja": "ja",
         "ko": "ko",
         "zh": "zh_CN",
         "en-us": "en",
         "es-es": "es",
         "de-de": "de",
         "fr-fr": "fr",
         "ja-jp": "ja",
         "ko-kr": "ko",
         "zh-cn": "zh_CN",
         "zh-hans": "zh_CN",
         "zh-hant": "zh_TW",
         "zh-tw": "zh_TW",
         "zh-hk": "en",
         "zh-mo": "en",
         "zh-hans-hk": "en",
         "zh-hant-hk": "en",
         "zh-hans-mo": "en",
         "zh-hant-mo": "en"
      },

      // Locale to be used during translation. Default is English.
      locale: 'en',

      // JSON object containing the translated text.
      translatedTable: null,

      // Get Locale info
      getLocale: function getLocale() {
         if (!this.translatedTable) {
            // Set locale and load JSON translation table.
            this.setLocaleAndLoad();
         }

         return this.locale;
      },

      // Set the locale and load the corresponding JSON translation table.
      setLocaleAndLoad: function setLocaleAndLoad(acceptLanguage) {
         var self = this,
             url = void 0,
             selectedLocale = void 0,
             data = void 0;

         if (!acceptLanguage) {
            // The language version of the platform
            acceptLanguage = navigator.language || navigator.userLanguage;
         }

         if (!!acceptLanguage) {
            // Determine the corresponding JSON translation file.
            selectedLocale = this.getBestLocale(acceptLanguage);
            if (!!selectedLocale) {
               this.locale = selectedLocale;
            }
         }

         _jscdkLogger2.default.debug('Load translation table for locale: ' + this.locale);
         if (this.locale === 'en') {
            // There is no need to load the English translation table.
            this.translatedTable = {};
            return;
         }

         /**
          * Load language JSON file according to browser's locale setting using
          * AJAX synchronous call.
          */
         url = '../locale/' + this.locale + '.json';
         _jquery2.default.ajax({
            type: "GET",
            url: url,
            dataType: "json",
            cache: false,
            success: function success(data) {
               if (!!data) {
                  self.translatedTable = data;
               } else {
                  _jscdkLogger2.default.error('Invalid translation data from url: ' + url);
               }
            },
            error: function error(jqXHR, textStatus, errorThrown) {
               _jscdkLogger2.default.error('Failed to load translation data, url: ' + url + ', status: ' + textStatus + ', errorThrown: ' + errorThrown);
            }
         });
      },

      translate: function translate(msgid, args) {
         var translatedStr = void 0;

         /**
          * If the translated msgid exists, return the translated string, else
          * return the original string.
          */
         if (!!this.translatedTable[msgid] && this.translatedTable[msgid][1].length > 0) {
            /**
             * The tool po2json used for converting po to json puts the
             * translated string to an array and the translated result is in
             * the second element.
             */
            translatedStr = this.translatedTable[msgid][1];
         } else {
            translatedStr = msgid;
         }

         return translatedStr.replace(/\{(\d+)\}/g, function (match, mNum, offset, fullStr) {
            var retStr = void 0;
            var intNum = parseInt(mNum, 10);
            // For escaped case, remove the duplicated "{" and "}".
            if (fullStr.charAt(offset - 1) === "{" && fullStr.charAt(offset + match.length) === "}") {
               return mNum;
            }
            if (!!args[intNum + 1]) {
               retStr = args[intNum + 1];
            } else {
               retStr = match;
            }

            return retStr;
         });
      },

      /**
       * For a given list of desired locales, determine which language out of
       * our supported languages we should display.
       */
      getBestLocale: function getBestLocale(acceptLanguage) {
         var matchedLocale = null,
             matchedRank = 0,
             accepted = void 0,
             i = void 0,
             kv = void 0,
             parts = void 0,
             thisRank = void 0,
             localeAndRank = void 0;

         if (!acceptLanguage) {
            return null;
         }

         /**
          * For each of the languages in the acceptLanguage param, see
          * if getSupportedLocale likes it. If so, set the currently
          * preferred language and its rank ('q=' value.) Do this for
          * all languages.
          */
         accepted = acceptLanguage.split(',');
         for (i = 0; i < accepted.length; i++) {
            if (accepted[i].indexOf('*') >= 0) {
               // Ignore the wildcard.
               continue;
            }

            /*
             * There may be a 'q=' section with a rank for this language.
             * Set rank value to 1 by default.
             */
            thisRank = 1;
            parts = _jquery2.default.trim(accepted[i]).split(';', 2);
            if (parts.length === 2) {
               kv = parts[1].split('=', 2);
               if (kv[0] === 'q' && kv.length === 2) {
                  thisRank = parseFloat(kv[1]);
               }
            } else if (parts.length < 1) {
               continue;
            }

            /**
             * If this locale entry is supported, compare its rank to the
             * highest matched rank thus far.
             */
            localeAndRank = this.getSupportedLocale(parts[0], thisRank);
            if (!!localeAndRank) {
               if (localeAndRank[1] > matchedRank) {
                  matchedLocale = localeAndRank[0];
                  matchedRank = localeAndRank[1];
               }
            }
         }

         return matchedLocale;
      },

      /**
       * For a given locale, determine the best supported localization
       * fit for that language using the supportedLocale dictionary.
       */
      getSupportedLocale: function getSupportedLocale(locale, returnRank) {
         var langCode = void 0,
             selectedLocale = void 0,
             specifiers = void 0;

         // Convert to lower-case.
         locale = locale.toLowerCase();

         if (this.supportedLocale.hasOwnProperty(locale)) {
            // The full locale is specifically supported.
            selectedLocale = this.supportedLocale[locale];
         } else {
            specifiers = locale.split('-');
            if (specifiers.length > 2) {
               // Locale string like 'zh-hant' or 'zh-hant'.
               langCode = specifiers[0] + '-' + specifiers[1];
               if (this.supportedLocale.hasOwnProperty(langCode)) {
                  // The language is zh-hans or zh-hant
                  selectedLocale = this.supportedLocale[langCode];
               }
            }
            if (!selectedLocale && specifiers.length > 0) {
               // Locale string like 'en-us' or 'zh-tw'.
               langCode = specifiers[0];
               if (this.supportedLocale.hasOwnProperty(langCode)) {
                  /**
                   * The language is supported, but not in the desired locale,
                   * the request is generic (xx instead of xx-YY)
                   */
                  selectedLocale = this.supportedLocale[langCode];
               }
            }
         }

         if (!!selectedLocale) {
            return [selectedLocale, returnRank];
         }

         return null;
      }
   },

   /**
    * Get the translated strings for user's current language with printable
    * style. The {number} tags are replaced by the order of the arguments
    * followed. The number should start from 0 and continously. The arguments
    * followed are printed in the number orders to support different orders for
    * the same sentence in different languages. Use {{number}} to print
    * {number} in the string.
    *
    * A tutorial for English strings:
    *     Input                          Output
    * _("Test text.")                "Test text."
    * _("{0} text.", "Test")         "Test text."
    * _("{1} {0}.", "text", "Test")  "Test text."
    * _("Test text {{0}}", "fail")   "Test text {0}"
    * _("Test text {0}")             "Test text {0}"
    * @param msgid[in] key for the translated string.
    * @param arguments...[in] variable arguments for printf style strings, use
    *    {0}, {1}, etc as the format parameters.
    * @return the translated string if found, else the original string.
    */

   _: function _(msgid) {
      var args = arguments;

      /**
       * Load the resources when the _ function first called.
       */
      if (!util.l10N.translatedTable) {
         // Load translation table according to the desired locale.
         util.l10N.setLocaleAndLoad();
      }

      return util.l10N.translate(msgid, args);
   },

   /**
    * workflow control class for info merging.
    *
    * @param waitNumber: of int
    *    if the input info number is greater or equal to this number,
    *    the merging will be preformed
    * @param mergingFunc: of function
    */
   InfoCombiner: function InfoCombiner(waitNumber, mergingFunc, callbackParam) {
      // private:
      var mergingThreshold = waitNumber,
          mergingFunction = mergingFunc,
          mergingCallbackParam = callbackParam,
          containerList = [];

      // privileged:
      this.onInfoReceived = function (infoObj) {
         containerList.push(infoObj);
         if (containerList.length >= mergingThreshold) {
            mergingFunction(containerList, mergingCallbackParam);
            containerList = [];
         }
      };
   },

   isWS1Mode: function isWS1Mode() {
      return _jscdkClient.globalArray.ws1Mode;
   },

   getWS1Hostname: function getWS1Hostname() {
      return _jscdkClient.globalArray.workspaceOneServerHostname;
   }
}; /*********************************************************
    * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
    *********************************************************/

/**
 * util.js --
 *
 *      common functions used in jscdk
 *      may replace the current utils.js in the future
 */

exports.default = util;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.StateEnum = undefined;
exports.MessageHandler = MessageHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkBrokerError = __webpack_require__(15);

var _jscdkBrokerError2 = _interopRequireDefault(_jscdkBrokerError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// all states of a message handler
/**********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * messageHandler.js --
 *
 *      Implementation of the prototype of all message handlers.
 */

var StateEnum = exports.StateEnum = {
   INIT: "init",
   PENDING: "pending",
   DONE: "done",
   FAIL: "fail"
};

MessageHandler.prototype = new MessageHandler(); // MessageHandler prototype
MessageHandler.constructor = MessageHandler; // constructor

function MessageHandler() {
   this.messageName = ""; // name of this message’s handler, using XML
   // protocol’s message
   this.messageText = ""; // the text needed to send to the broker
   this.responseTag = ""; // indicate which response this handler should handle
   this.content = {}; // data generated (key-value) by current handler,
   // including response result, local info, etc.
   this.requestXML = ""; // XML document needs to send.
   this.state = StateEnum.INIT; // the state of the current handler, set to
   // INIT firstly
   this.dependencyList = []; // list of other handlers who current handler
   // depends on
   this.observerList = []; // list of handlers who depend on current handler
   this.subHandlerList = []; // one message handler may have some sub messages,
   // such as "do-submit-authentication"
   this.parentHandler = null; // when setting a handler's sub handler, we also
   // set it as the sub handler's parent handler
   this.composedHandlerList = []; // list of handlers who can be sent together
   // in a single message
   this.requestId = 0; // suffix of responseTag to distinguish mutiple
   // instances of a handler
   this.requestIdKV = {}; // key-value pairs, value is requestId, key can be
   // responseTag+desktopId or other
   this.xhrObject = {}; // XHR object for the http request
}

MessageHandler.prototype.setMessageName = function (messageName) {
   this.messageName = messageName;
};

MessageHandler.prototype.getMessageName = function () {
   return this.messageName;
};

MessageHandler.prototype.getMessageText = function () {
   return this.messageText;
};

MessageHandler.prototype.setRequestXML = function (requestXML) {
   this.requestXML = requestXML;
};

MessageHandler.prototype.getRequestXML = function () {
   return this.requestXML;
};

MessageHandler.prototype.setState = function (state) {
   var key = void 0;
   var handler = void 0;
   var parentHandler = void 0;

   if (state === StateEnum.DONE) {
      if (this.hasSubHandler()) {
         _jscdkLogger2.default.error("Failed to set " + this.getMessageName() + "'s state to DONE because it has sub handlers to execute.");
         return;
      }
   }

   _jscdkLogger2.default.trace("Set " + this.getMessageName() + "'s state from " + this.state + " to " + state);
   this.state = state;

   if (this.state === StateEnum.DONE || this.state === StateEnum.FAIL) {
      parentHandler = this.parentHandler;
      if (!!parentHandler) {
         parentHandler.removeSubHandler(this);
         if (this.state === StateEnum.FAIL) {
            parentHandler.setState(StateEnum.FAIL);
         } else {
            parentHandler.onUpdated();
         }
      }

      if (!!this.observerList["state"]) {
         for (key in this.observerList["state"]) {
            if (this.observerList["state"].hasOwnProperty(key)) {
               handler = this.observerList["state"][key];
               if (this.state === StateEnum.FAIL) {
                  if (!!this.content["error"]) {
                     handler.appendContent(this.content["error"]);
                  }
               }
               handler.onUpdated();
            }
         }
      }
   }
};

MessageHandler.prototype.getState = function () {
   return this.state;
};

MessageHandler.prototype.getXhrObject = function () {
   return this.xhrObject;
};

MessageHandler.prototype.setXhrObject = function (xhrObject) {
   this.xhrObject = xhrObject;
};

/**
 * Reset the handler's state and content which can't be reused twice.
 *
 */

MessageHandler.prototype.resetData = function () {
   this.setState(StateEnum.INIT);
   this.content = {};
   this.subHandlerList = [];
   this.parentHandler = null;
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
MessageHandler.prototype.onUpdated = function () {
   // XXX TODO: branches here, such as state transition
   // XXX TODO: check attribute "content" whether all dependencies are ready
   var parsedResult = void 0;
   var i = void 0;
   var handler = void 0;
   var doneCnt = void 0;
   var msgerror = {};
   var error = {};
   var subError = {};
   var msgError = {};
   var errorCode = void 0;
   var errorKey = void 0;
   var jscdkError = void 0;
   var key = void 0;
   if (this.getState() === StateEnum.INIT) {
      this.setState(StateEnum.PENDING);
   }
   // check parsed result in property "content"
   if (!!this.content["parsedResult"]) {
      parsedResult = this.content["parsedResult"];
      if (!!parsedResult["result"]) {
         if (parsedResult["result"] === "ok") {
            if (this.hasSubHandler()) {
               // trigger all sub handlers' executions.
               for (key in this.subHandlerList) {
                  if (this.subHandlerList.hasOwnProperty(key)) {
                     handler = this.subHandlerList[key];
                     handler.triggerExecution();
                  }
               }
            }

            // check all dependencies' status
            if (!!this.dependencyList["state"]) {
               doneCnt = 0;
               for (i = 0; i < this.dependencyList["state"].length; ++i) {
                  handler = this.dependencyList["state"][i];
                  _jscdkLogger2.default.debug(this.messageName + " depends on " + handler.messageName);
                  if (handler.getState() === StateEnum.DONE) {
                     _jscdkLogger2.default.debug(handler.messageName + "'s state is DONE.");
                     ++doneCnt;
                  }
                  if (handler.getState() === StateEnum.FAIL) {
                     _jscdkLogger2.default.debug(handler.messageName + "'s state is FAIL.");
                     this.setState(StateEnum.FAIL);
                     break;
                  }
               }
               if (doneCnt === this.dependencyList["state"].length) {
                  this.setState(StateEnum.DONE);
               }
            } else {
               this.setState(StateEnum.DONE);
            }
         } else if (parsedResult["result"] === "error") {
            /**
             * if result from broker is error, it should not be triggered by
             * any dependency; reset data to avoid entering this branch for
             * multiple times if error occurs
             */
            this.content = {};

            // handle general errors
            if (!!parsedResult["error-code"]) {
               errorCode = parsedResult["error-code"];
               errorKey = this.messageName;
               subError.errorCode = errorCode;
               if (!!parsedResult["error-message"]) {
                  subError.errorMessage = parsedResult["error-message"];
               }
               if (!!parsedResult["user-message"]) {
                  subError.userMessage = parsedResult["user-message"];
               }
               if (!!parsedResult["workspaceOneServerHostname"]) {
                  subError.workspaceOneServerHostname = parsedResult["workspaceOneServerHostname"];
               }
               msgError[errorKey] = subError;
               error["error"] = msgError;
               this.appendContent(error);
               this.setState(StateEnum.FAIL);
            }
         }
      } else {
         /**
          * if result from broker doesn't exist, it should not be triggered by
          * any dependency; reset data to avoid entering this branch for
          * multiple times if error occurs
          */
         this.content = {};

         _jscdkLogger2.default.error("no result in parsed result of " + this.getMessageName());
         msgerror[this.getMessageName()] = _jscdkBrokerError2.default.getError(_jscdkBrokerError2.default.JSCDK_BROKER_ERROR_UNKNOWN).toString();
         error["error"] = msgerror;
         this.appendContent(error);
         this.setState(StateEnum.FAIL);
      }
   } else {
      _jscdkLogger2.default.debug("no parsed result for " + this.getMessageName() + " yet");
   }
   _jscdkLogger2.default.debug(this.getMessageName() + "'s state: " + this.getState());
};

/**
 * Broadcast here, such as doLogout, etc.
 *
 * @param msg [in] the message to be broadcast, such as "doLogout", etc.
 */
MessageHandler.prototype.onBroadcast = function (msg) {
   if (msg === "doLogout" || msg === "doCancelAuthentication") {
      _jscdkLogger2.default.debug(this.messageName + " reset data");
      // Reset data on logout or authentication cancellation.
      this.resetData();
   }
};

/**
 * add a new observer into observerList
 *
 * @param  inputHandler [in] the observer handler to be added
 * @param  attributeName [in] name of the attribute whose observerList is
 *    handled
 */
MessageHandler.prototype.addObserver = function (inputHandler, attributeName) {
   if (this.observerList[attributeName] !== null) {
      if (typeof this.observerList[attributeName] === "undefined") {
         this.observerList[attributeName] = [];
      }
      if (_util2.default.findHandlerInArray(inputHandler, this.observerList[attributeName]) === -1) {
         this.observerList[attributeName].push(inputHandler);
      } else {
         _jscdkLogger2.default.warning("Adding twice to the observer list for handler " + inputHandler.messageName);
      }
   }
};

/**
 * remove a specific observer from observerList
 *
 * @param  inputHandler [in] the observer handler to be removed
 * @param  attributeName [in] name of the attribute whose observerList is
 *    handled
 */
MessageHandler.prototype.removeObserver = function (inputHandler, attributeName) {
   var list = this.observerList[attributeName];
   if (!!list) {
      var index = list.indexOf(inputHandler);
      if (index > -1) {
         list.splice(index, 1);
      }
   }
};

/**
 * register the router and handlers here
 *
 * @param  inputHandler [in | out] the handler to be handled, update current
 *    handler's dependencyList and inputHandler's observerList
 * @param  attributeName [in] name of the attribute whose observerList is
 *    handled
 */
MessageHandler.prototype.registerHandler = function (inputHandler, attributeName) {
   // handle inputHandler's observer
   inputHandler.addObserver(this, attributeName);
   // handle its dependency
   if (!this.dependencyList[attributeName]) {
      this.dependencyList[attributeName] = [];
   }
   this.dependencyList[attributeName].push(inputHandler);
};

/**
 * unregister the router and handlers here
 *
 * @param  inputHandler [in | out] the handler to be handled, update current
 *    handler's dependencyList and inputHandler's observerList
 * @param  attributeName [in] name of the attribute whose observerList is
 *    handled
 */
MessageHandler.prototype.unregisterHandler = function (inputHandler, attributeName) {
   var index = void 0;
   var list = void 0;
   // handle inputHandler's observer
   inputHandler.removeObserver(this, attributeName);
   // handle its dependency
   list = this.dependencyList[attributeName];

   if (!!list) {
      index = list.indexOf(inputHandler);
      if (index > -1) {
         list.splice(index, 1);
      }
   }
};

/**
 * append relative content(key-value pairs) to the content of current handler
 *
 * @param content[in] key-value pair to be appended
 */
MessageHandler.prototype.appendContent = function (content) {
   var key = void 0;
   for (key in content) {
      if (content.hasOwnProperty(key)) {
         this.content[key] = content[key];
         _jscdkLogger2.default.debug(this.messageName + " this.content[" + key + "]: " + _util2.default.censorMessage(JSON.stringify(this.content[key]), 'JSON'));
      }
   }
};

/**
 * remove corresponding content(key-value pairs) from this.content of this
 * handler
 * @param key[in] key of the item to remove
 */
MessageHandler.prototype.removeFromContent = function (key) {
   if (this.content.hasOwnProperty(key)) {
      delete this.content[key];
   }
};

/**
 * compose list of message handlers who can be sent together in a single message
 *
 */
MessageHandler.prototype.composeHandlerList = function () {
   if (this.composedHandlerList.length === 0) {
      this.composedHandlerList.push(this);
   }
   return this.composedHandlerList;
};

/**
 * Cancel http request for the handler.
 *
 */

MessageHandler.prototype.cancelRequest = function () {
   if (!!this.xhrObject && _jquery2.default.isFunction(this.xhrObject.abort)) {
      this.xhrObject.abort();
   }
   this.resetData();
};

/**
 * Clear sub handler list.
 *
 */
MessageHandler.prototype.clearSubHandlers = function () {
   var subHandler = void 0,
       i = void 0;

   for (i = 0; i < this.subHandlerList.length; i++) {
      subHandler = this.subHandlerList[i];
      subHandler.resetData();
   }

   this.subHandlerList = [];
};

/*
 * Checks whether the current handler has any sub handler.
 *
 * @return true if it has, false otherwise.
 */
MessageHandler.prototype.hasSubHandler = function () {
   if (this.subHandlerList.length > 0) {
      return true;
   }

   return false;
};

/**
 * Append a new sub handler into subHandlerList
 *
 * @param  subHandler [in] the sub handler to be appended
 */
MessageHandler.prototype.appendSubHandler = function (subHandler) {
   var list = this.subHandlerList;

   if (!list) {
      this.subHandlerList = [];
      list = this.subHandlerList;
   }

   if (_util2.default.findHandlerInArray(subHandler, list) === -1) {
      list.push(subHandler);
      subHandler.parentHandler = this;
      _jscdkLogger2.default.trace(this.messageName + ": adding one sub handler: " + subHandler.messageName);
   } else {
      _jscdkLogger2.default.error("Adding " + subHandler.messageName + "twice to " + this.messageName + "'s sub handler list");
   }
};

/**
 * Remove a sub handler from subHandlerList
 *
 * @param  inputHandler [in] the sub handler to be removed
 */
MessageHandler.prototype.removeSubHandler = function (subHandler) {
   var index = void 0,
       list = this.subHandlerList;

   if (!!list) {
      index = list.indexOf(subHandler);
      if (index > -1) {
         list.splice(index, 1);
         subHandler.parentHandler = null;
      }
   }
};

/**
 * Trigger a handler to begin execution
 *
 */
MessageHandler.prototype.triggerExecution = function () {
   /**
    * Here we just provide an interface.
    * It should be overwitten by derived class when needed.
    */
   _jscdkLogger2.default.trace("Calling " + this.messageName + "'s triggerExecution function.");
};

/***/ }),
/* 5 */,
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = Router;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _jscdkBrokerError = __webpack_require__(15);

var _jscdkBrokerError2 = _interopRequireDefault(_jscdkBrokerError);

var _timerUtil = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * router.js --
 *
 *      Implementation of the router for posting to the view broker and parsing
 * the response.
 */

function Router() {
   // member variables
   this.name = "router";
   this.doLogout = "doLogout"; // attribute "doLogout" to be registered
   this.doCancelAuthentication = "doCancelAuthentication";
   this.receiver = "receiver"; // attribute "receiver" to be registered
   this.observerList = [];
   this.brokerUrl = "";
   this.brokerUrlWithTimestamp = false;
   this.content = {}; // data generated (key-value) by router, such as error,
   // etc.
   this.recentXhrObject = {}; // Recent XHR object for AJAX request.
}

Router.prototype.ajaxWasAborted = false;

Router.prototype.setDoLogout = function () {
   // traverse the observerList of attribute "doLogout", and call each
   // handler's onBroadcast()
   var key = void 0,
       handler = void 0;
   if (!!this.observerList[this.doLogout]) {
      for (key in this.observerList[this.doLogout]) {
         if (this.observerList[this.doLogout].hasOwnProperty(key)) {
            handler = this.observerList[this.doLogout][key];
            handler.onBroadcast(this.doLogout); // onBroadcast callback here
         }
      }
   }
};

Router.prototype.setDoCancelAuthentication = function () {
   /*
    * Traverse the observerList of attribute "doCancelAuthentication", and call
    * each handler's onBroadcast().
    */
   var key = void 0;
   var handler = void 0;
   if (!!this.observerList[this.doCancelAuthentication]) {
      for (key in this.observerList[this.doCancelAuthentication]) {
         if (this.observerList[this.doCancelAuthentication].hasOwnProperty(key)) {
            handler = this.observerList[this.doCancelAuthentication][key];
            handler.onBroadcast(this.doCancelAuthentication); // onBroadcast
            // callback
            // here
         }
      }
   }
};

/**
 * Set the request URL of the broker and specify
 * whether timestamp is needed to appended to each request.
 *
 * Appending a timestamp to the URL is to fix a iOS6 Ajax cache problem.
 *
 * @param brokerUrl [in] The URL address of the broker
 * @param appendTimestamp [in] Optional. A boolean value indicating whether to
 *                               append a timestamp. If undefined, the value is
 *    false.
 */
Router.prototype.setBrokerUrl = function (brokerUrl, appendTimestamp) {
   this.brokerUrl = brokerUrl;

   // only enable in DEV MODE
   // this.brokerUrl = "https://localhost/portal/broker/xml";


   // For iOS6 system, a timestamp is appended to each post request, so that
   // browser doesn't cache the response.
   this.brokerUrlWithTimestamp = !!appendTimestamp;
};

/**
 * Replace the secret field's value when logging get-destop-connection resposne
 *
 * @param message [in] XML response from broker.
 * @return the censored string, or "CENSORING FAILED" when translation fails.
 */

Router.prototype.censorResponse = function (message) {
   try {
      var censoredMessage = message,
          secretParams = ["framework-channel-ticket", "password", "token"],
          xmlDoc = _jquery2.default.parseXML(censoredMessage),
          $xml = (0, _jquery2.default)(xmlDoc),
          i = void 0,
          secretNode = void 0,
          secretKey = void 0;
      secretNode = $xml.find('desktop-connection');
      secretNode = Array.prototype.slice.call(secretNode);
      for (i = 0; i < secretParams.length; i++) {
         secretKey = secretParams[i];
         if (typeof (0, _jquery2.default)(secretNode).find(secretParams[secretKey]).text() !== 'undefined' && (0, _jquery2.default)(secretNode).find(secretParams[secretKey]).text() !== "" && (0, _jquery2.default)(secretNode).find(secretParams[secretKey]).text() !== null) {
            (0, _jquery2.default)(secretNode).find(secretParams[secretKey]).text("[REDACTED]");
         }
      }

      return _util2.default.XMLToString(xmlDoc);
   } catch (e) {
      // Parse document fail
      return "CENSORING FAILED";
   }
};

/**
 * Get the qurey parameter value
 * @param url the URL
 * @param name the parameter name
 * @returns the parameter value if the url has the parameter.  Otherwise,
 * return null
 */
Router.prototype.getParameterByName = function (url, name) {
   var param = void 0,
       regex = void 0,
       results = void 0;

   param = name.replace(/[\[\]]/g, "\\$&");
   regex = new RegExp("[?&]" + param + "(=([^&#]*)|&|#|$)");
   results = regex.exec(url);
   if (!results) {
      return null;
   }
   if (!results[2]) {
      return '';
   }
   return decodeURIComponent(results[2].replace(/\+/g, " "));
};

/**
 * post messages using xmlhttprequest here, if response is ready, callback
 * onResponse() will be called
 *
 * @param handlerList[in] handlerList is list of handlers who can be sent
 *    together in a single message
 */
Router.prototype.postMessage = function (handlerList, async, timeout) {
   var postMessageText = this.composeMessages(handlerList),
       handler = void 0,
       i = void 0,
       contextInfo = {},
       xhrObject = void 0,
       brokerUrl = void 0,
       connector = void 0;

   if (this.brokerUrlWithTimestamp) {
      connector = !!this.getParameterByName(this.brokerUrl, "mid") ? '&' : '?';
      brokerUrl = this.brokerUrl + connector + '_ab=' + _jquery2.default.now();
   } else {
      brokerUrl = this.brokerUrl;
   }

   if (!!postMessageText) {
      for (i = 0; i < handlerList.length; ++i) {
         handler = handlerList[i];
         handler.setState(_messageHandler.StateEnum.PENDING);
      }
   }

   contextInfo.messageText = postMessageText;
   contextInfo.requestId = handlerList[0].requestId;
   contextInfo.requestHandlerList = handlerList;
   if (async !== undefined && !!timeout) {
      xhrObject = this.jscdkPost(brokerUrl, contextInfo, this.jscdkSuccess, async, timeout);
   } else if (async !== undefined) {
      xhrObject = this.jscdkPost(brokerUrl, contextInfo, this.jscdkSuccess, async);
   } else {
      xhrObject = this.jscdkPost(brokerUrl, contextInfo, this.jscdkSuccess);
   }
   this.recentXhrObject = xhrObject;
   for (i = 0; i < handlerList.length; i++) {
      handler = handlerList[i];
      handler.setXhrObject(xhrObject);
   }
   _jscdkLogger2.default.trace(_util2.default.censorMessage(postMessageText));
};

/**
 * compose all messages of handlers in handlerList to a single message
 *
 * @param handlerList[in] handlerList is list of handlers who can be sent
 *    together in a single message
 * @return the single message composed
 */
Router.prototype.composeMessages = function (handlerList) {
   var composedMessage = "";
   var brokerVersion = "";
   if (!!_jscdkClient.globalArray) {
      brokerVersion = _jscdkClient.globalArray["brokerVersion"];
   }
   composedMessage = _util2.default.createXML(handlerList, brokerVersion);
   return composedMessage;
};

/**
 * when router receives messages, it will notify message handlers who are
 * registered to it and own these responses.
 *
 * @param responseText [in] responseText to be handled and distributed to
 *    corresponding handlers
 */
Router.prototype.onResponse = function (responseData) {
   var i = void 0,
       j = void 0,
       handler = void 0,
       requestId = responseData.requestId,
       responseText = responseData.data,
       requestHandlerList = responseData.requestHandlerList,
       requestHandler = void 0,
       responseTag = void 0,
       foundHandler = false;

   _jscdkLogger2.default.trace(this.censorResponse(_util2.default.XMLToString(responseText)));
   var responseTagList = this.parseResponseTagList(responseText);
   for (i = 0; i < responseTagList.length; ++i) {
      responseTag = responseTagList[i];
      // get the request handler
      for (j = 0; j < requestHandlerList.length; j++) {
         requestHandler = requestHandlerList[j];
         if (requestHandler.responseTag === responseTag) {
            // The handler's responseTag equals that of the XML reponse.
            handler = requestHandler;
            break;
         }
      }
      if (!handler) {
         // if a handler is not allow to have mutiple instances, just use
         // responseTag with no suffix to locate this handler in global array
         handler = _util2.default.getObject(_jscdkClient.globalArray, responseTag);
      }
      if (!handler) {
         // for handlers who can have mutiple instances
         // locate this handler by responseTag with requestId suffixed
         handler = _util2.default.getObject(_jscdkClient.globalArray, responseTag + requestId);
      }
      if (!!handler) {
         this.pushResponseToHandler(handler, responseText);
         foundHandler = true;
      }
   }
   if (!foundHandler) {
      requestHandler = requestHandlerList[0];
      if (!!requestHandler) {
         this.pushResponseToHandler(requestHandler, responseText);
      } else {
         _jscdkLogger2.default.error("Unable to locate any handler for response.");
      }
   }
   /*
    * Don't clear the handler here because if we do, canceling a broker request and
    * canceling authentication at about the same time will not be handled correctly.
    */
};

/**
 * handles a response from the broker by pushing the response text to the
 * specified handler.
 *
 * @param  handler [in] the handler to be updated with the response
 * @param  responseText [in] the parsed response text to send to the handler.
 */
Router.prototype.pushResponseToHandler = function (handler, responseText) {
   var parsedResult = void 0,
       content = {};

   parsedResult = handler.parseResult(responseText);
   // XXX TODO: append relative content to properties
   if (!!parsedResult["result"]) {
      _jscdkLogger2.default.debug(handler.messageName + " result: " + parsedResult["result"]);
   }
   content["parsedResult"] = parsedResult;
   handler.appendContent(content); // store key-value information(state, etc.)
   // in relative handler's "content"
   handler.onUpdated(); // handlers' onUpdated callback here
};

/**
 * add a new observer into observerList
 *
 * @param  inputHandler [in] the observer handler to be added
 * @param  attributeName [in] name of the attribute whose observerList is
 *    handled
 */
Router.prototype.addObserver = function (inputHandler, attributeName) {
   if (this.observerList[attributeName] !== null) {
      if (typeof this.observerList[attributeName] === "undefined") {
         this.observerList[attributeName] = [];
      }
      this.observerList[attributeName].push(inputHandler);
   }
};

/**
 * remove a specific observer from observerList
 *
 * @param  inputHandler [in] the observer handler to be removed
 * @param  attributeName [in] name of the attribute whose observerList is
 *    handled
 */
Router.prototype.removeObserver = function (inputHandler, attributeName) {
   var index = void 0;
   var list = this.observerList[attributeName];
   if (!!list) {
      index = list.indexOf(inputHandler);
      if (index > -1) {
         list.splice(index, 1);
      }
   }
};

/**
 * parse response tags from the response XML
 *
 * @param responseText[in]  response XML of xmlhttprequest
 * @return a list containing all response tags
 */

Router.prototype.parseResponseTagList = function (responseText) {
   if (!responseText || responseText === "") {
      return null;
   }
   var responseTagList = [];
   var responseBody = (0, _jquery2.default)(responseText);
   var brokerElem = responseBody.find("broker");
   if (!brokerElem) {
      _jscdkLogger2.default.error("parse response tag error.");
      return null;
   }

   var responseTagElems = brokerElem[0].childNodes;
   var i = void 0;
   var currentElem = void 0;
   var responseTag = void 0;
   for (i = 0; i < responseTagElems.length; ++i) {
      currentElem = responseTagElems[i];
      responseTag = currentElem.nodeName;
      if (responseTag !== "#text") {
         responseTagList.push(responseTag);
      }
   }
   return responseTagList;
};

/**
 * post data to server
 *
 * @param  brokerUrl  broker URL
 * @param  contextInfo context data for posting message.
 * @param  jscdkSuccess  callback which will be called
 * @param  async  true(default) represents async, while false(used in test)
 *    represents sync
 * @param  timeout limit of the request posted
 * @return the post status for test
 */
Router.prototype.jscdkPost = function (brokerUrl, contextInfo, jscdkSuccess, async, timeout) {
   var defParamLength = Router.prototype.jscdkPost.length; // Length of
   // parameters
   // defined in
   // function
   var actParamLength = arguments.length; // Length of actual parameters
   var settings = void 0;
   var ret = void 0; // for test
   var cacheThis = this;
   var messageText = contextInfo.messageText;
   var requestId = contextInfo.requestId;
   var requestHandlerList = contextInfo.requestHandlerList;

   if (typeof messageText === "undefined" || typeof requestId === "undefined") {
      _jscdkLogger2.default.error("ContextInfo struct illegal.");
      return null;
   }

   try {
      if (defParamLength === actParamLength) {
         settings = {
            "type": "POST",
            "url": brokerUrl,
            "data": messageText,
            "cache": false,
            "success": function success(data, textStatus, jscdkXHR) {
               var successData = {};
               successData.data = data;
               successData.requestId = requestId;
               successData.requestHandlerList = requestHandlerList;
               ret = textStatus;
               if (textStatus === "success") {
                  _jscdkLogger2.default.debug("jscdkPost with 5 parameters success");
                  jscdkSuccess(cacheThis, successData, textStatus, jscdkXHR);
               } else if (textStatus === "error") {
                  _jscdkLogger2.default.debug("receive response of xmlhttprequest error");
               }
            },
            "error": function error(jscdkXHR, textStatus, errorThrown) {
               cacheThis.jscdkPostError(messageText, jscdkXHR, textStatus, errorThrown);
            },
            "async": async,
            "timeout": timeout
         };
      } else if (actParamLength === defParamLength - 1) {
         settings = {
            "type": "POST",
            "url": brokerUrl,
            "data": messageText,
            "cache": false,
            "success": function success(data, textStatus, jscdkXHR) {
               var successData = {};
               successData.data = data;
               successData.requestId = requestId;
               successData.requestHandlerList = requestHandlerList;
               ret = textStatus;
               if (textStatus === "success") {
                  _jscdkLogger2.default.debug("jscdkPost with 4 parameters success");
                  jscdkSuccess(cacheThis, successData, textStatus, jscdkXHR);
               } else if (textStatus === "error") {
                  _jscdkLogger2.default.debug("receive response of xmlhttprequest error");
               }
            },
            "error": function error(jscdkXHR, textStatus, errorThrown) {
               cacheThis.jscdkPostError(messageText, jscdkXHR, textStatus, errorThrown);
            },
            "async": async
         };
      } else if (actParamLength === defParamLength - 2) {
         settings = {
            "type": "POST",
            "url": brokerUrl,
            "data": messageText,
            "cache": false,
            "success": function success(data, textStatus, jscdkXHR) {
               var successData = {};
               successData.data = data;
               successData.requestId = requestId;
               successData.requestHandlerList = requestHandlerList;
               ret = textStatus;
               if (textStatus === "success") {
                  _jscdkLogger2.default.debug("jscdkPost with 3 parameters success");
                  jscdkSuccess(cacheThis, successData, textStatus, jscdkXHR);
               } else if (textStatus === "error") {
                  _jscdkLogger2.default.debug("receive response of xmlhttprequest error");
               }
            },
            "error": function error(jscdkXHR, textStatus, errorThrown) {
               cacheThis.jscdkPostError(messageText, jscdkXHR, textStatus, errorThrown);
            }
         };
      } else {
         _jscdkLogger2.default.error("post parameter error.");
         return null;
      }
      if (this.ajaxWasAborted) {
         ret = null;
         this.ajaxWasAborted = false;
      } else {
         ret = _jquery2.default.ajax(settings);
      }
   } catch (err) {
      _jscdkLogger2.default.error("post request error: " + err);
      ret = null;
   }
   return ret;
};

/**
 * delete the cookie with specified key for one url.
 * @param url [in] url for the cookie
 * @param key [in] key for the cookie
 *
 * NOTE: not used now.
 */

// Router.prototype.deleteCookie = function(url, key) {
//    let detail = {};
//    /*
//     * XXX TODO: Only implement for Chrome now, add more browsers support
// when
//     * needed.
//     */
//    if (util.isChromeExtension()) {
//       detail.url = url;
//       detail.name = key;
//       chrome.cookies.remove(detail, function(details) {
//          JSCDKLogger.debug("Cookie is deleted: " + JSON.stringify(details));
//       });
//    } else {
//       JSCDKLogger.error("Delete cookie not implemented for the current
// browser yet."); } };


/**
 * callback for the successful response
 *
 * @param  reference[in]  reference of object to call
 * @param  data[in]  a JSON data contains requestId, the reference of request
 *    handler and resposne data.
 * @param  textStatus  response status, can be "timeout", "error",
 *    "notmodified", "success", "parsererror"
 * @param  jscdkXHR  a super class of XMLHttpRequest
 */
Router.prototype.jscdkSuccess = function (reference, data, textStatus, jscdkXHR) {
   reference.recentXhrObject = {};
   reference.onResponse(data); // onResponse callback here
};

/**
 * set handlers' state to FAIL when jscdkPost error occurs
 * @param contextInfo[in] contextInfo for jscdkPost
 * @return null if request message is invalid, else return "done"
 */
Router.prototype.jscdkPostError = function (contextInfo, jscdkXHR, textStatus, errorThrown) {
   var error = {},
       subError = {},
       msgerror = {},
       errorObject = void 0,
       messageText = contextInfo.messageText;

   this.recentXhrObject = {};

   /*
    * If user cancels http request, don't treat it as an error. In this case,
    * UI should be controlled by UI layer, so just return "done" here.
    */
   if (textStatus === "abort") {
      _jscdkLogger2.default.debug("User aborts http request.");
      return "done";
   }

   if (textStatus === "timeout") {
      errorObject = _jscdkBrokerError2.default.getError(_jscdkBrokerError2.default.JSCDK_BROKER_ERROR_TIMEOUT);
   } else if (textStatus === "error") {
      errorObject = _jscdkBrokerError2.default.getError(_jscdkBrokerError2.default.JSCDK_BROKER_ERROR_CONNECT_TO_BROKER_ERROR);
   } else {
      errorObject = _jscdkBrokerError2.default.getError(_jscdkBrokerError2.default.JSCDK_BROKER_ERROR_CONNECT_TO_BROKER_UNKNOWN);
   }

   _jscdkLogger2.default.debug("jscdkPostError: " + this.name);
   subError.errorCode = errorObject.getErrorCode();
   subError.errorMessage = errorObject.getErrorMessage();
   subError.userMessage = errorObject.getErrorMessage();
   msgerror[this.name] = subError;
   error["error"] = msgerror;
   this.appendContent(error);
   this.pushErrorToUser(this);
   return "done";
};

function ensureTimerStopped() {
   var idleTimerObject = void 0;
   if (_util2.default.brokerSupportApplication()) {
      idleTimerObject = _util2.default.getObject(_jscdkClient.globalArray, "idle-timeout-timer");
      if (!!idleTimerObject) {
         idleTimerObject.ensureStopped();
      }
   }
}

/**
 * push coresponding error to user if its condition is satisfied
 * @param handler[in] which handler's error to push
 */
Router.prototype.pushErrorToUser = function (handler) {
   // if the error is special for this handler, alert
   var messageText = void 0,
       errorAction = {},
       actionContent = {},
       cacheThis = this,
       authInfoObject = void 0,
       getDesktopsObject = void 0,
       getLaunchItemsObject = void 0,
       getTunnelConnObject = void 0,
       getConfigObject = void 0,
       setlocaleAndGetConfiguration = function setlocaleAndGetConfiguration() {
      var handlerList,
          setLocaleObject = _jscdkClient.globalArray["set-locale"],
          getConfigurationObject = _jscdkClient.globalArray["get-configuration"],
          router = _jscdkClient.globalArray["router"];

      if (!getConfigurationObject) {
         _jscdkLogger2.default.error("getConfigurationObject do not exist when calling setlocaleAndGetConfiguration()");
         return;
      }
      getConfigurationObject.setRequestXML();
      handlerList = getConfigurationObject.composeHandlerList();
      router.postMessage(handlerList);
   };

   if (!!handler.content["error"]) {
      _jscdkLogger2.default.info("pushErrorToUser: " + JSON.stringify(handler.content["error"]));
      _jquery2.default.each(handler.content["error"], function (errorKey, errorValue) {
         if (!!handler.name) {
            actionContent.brokerUrl = encodeURIComponent(cacheThis.brokerUrl);
         } else if (handler.getMessageName() === "get-configuration") {
            if (errorValue.errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_CONNECT_TO_BROKER_ERROR) {
               actionContent.brokerUrl = encodeURIComponent(cacheThis.brokerUrl);
            }
         } else if (handler.getMessageName() === "do-submit-authentication") {
            if (errorValue.errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_AUTHENTICATION_FAILED) {
               getConfigObject = _jscdkClient.globalArray["get-configuration"];
               ensureTimerStopped();
            }
         } else if (handler.getMessageName() === "get-authentication-status") {
            // broker with new version but session is not authed
            if (errorValue.errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_NOT_AUTHENTICATED) {
               if (handler.needCallbackFlag) {
                  handler.needCallbackFlag = false;
                  _jscdkLogger2.default.log("tab sync fail, the session is expired now");
               } else if (handler.workForSilentModeFlag) {
                  handler.workForSilentModeFlag = false;
                  _jscdkLogger2.default.log("deal with getAuthenticationStatus response before act in desktop-select page failed, the session is expired now");
               } else {
                  setlocaleAndGetConfiguration();
                  return;
               }
            }
            // broker with old version
            if (errorValue.errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_UNRECOGNIZED_CONTENT || errorValue.errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_UNSUPPORTED_VERSION) // ToCheck:
               // need
               // this
               // condition?
               {
                  if (!_util2.default.brokerSupportApplication()) {
                     //ignore this error and work as old version
                     setlocaleAndGetConfiguration();
                     return;
                  } else {
                     _jscdkLogger2.default.debug("with new broker but meet error when sending <get-authentication-status>");
                  }
               }
         }

         if (errorValue.errorCode === "OUT_OF_SEQUENCE_ERROR") {
            // ignore this error. "OUT_OF_SEQUENCE_ERROR" is only used in
            // JSCDk, so have no need to be added in JSCDKBrokerError
            return;
         } else if (errorValue.errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_ALREADY_AUTHENTICATED) {
            (0, _timerUtil.prepareForAlreadyAuthenticated)();
         } else if (errorValue.errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_NOT_AUTHENTICATED) {
            // Not authenticated
            if (!!_jscdkClient.globalArray) {
               // Get DoSubmitAuthenticationHandler
               authInfoObject = _jscdkClient.globalArray["do-submit-authentication"];
               if (!!authInfoObject) {
                  // Initialize DoSubmitAuthenticationHandler
                  authInfoObject.resetData();
               }
            }
            ensureTimerStopped();
         }

         _jscdkLogger2.default.error("error from " + errorKey + ": " + errorValue.errorMessage);
         if (!!errorValue.userMessage || !!errorValue.errorMessage) {
            if (!!errorValue.userMessage) {
               messageText = errorValue.userMessage;
            } else {
               if (errorValue.errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_DESKTOPS_ERROR) {
                  // The error message of 'DESKTOPS_ERROR' is not user
                  // friendly. Reterm the error message here.
                  messageText = _util2.default._("The connection to the Connection Server has timed out.");
               } else {
                  messageText = errorValue.errorMessage;
               }
            }
            actionContent.errorType = errorValue.errorCode;
            actionContent.errorText = messageText;
            actionContent.errorMessage = errorValue.errorMessage;
            if (!!errorValue.errorDetail) {
               actionContent.errorDetail = errorValue.errorDetail;
            }
            if (!!errorValue.workspaceOneServerHostname) {
               actionContent.workspaceOneServerHostname = errorValue.workspaceOneServerHostname;
            }
            actionContent.srcHandlerName = errorKey;
            errorAction.name = "ShowError";
            errorAction.content = actionContent;
            (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(errorAction));
            handler.removeFromContent("error"); // clear error data after error
            // is pushed to user
         }
         /**
          * XXX TODO: if userMessage in error doesn't exist, the whole page
          * will be disabled it should be discussed and updated further
          */
      });
   }
};

/**
 * append relative content(key-value pairs) to the content of router
 *
 * @param content[in] key-value pair to be appended
 */
Router.prototype.appendContent = function (content) {
   var key = void 0;
   for (key in content) {
      if (content.hasOwnProperty(key)) {
         this.content[key] = content[key];
         _jscdkLogger2.default.debug(this.name + " this.content[" + key + "]: " + JSON.stringify(this.content[key]));
      }
   }
};

/**
 * remove corresponding content(key-value pairs) from this.content of router
 * @param key[in] key of the item to remove
 */
Router.prototype.removeFromContent = function (key) {
   if (this.content.hasOwnProperty(key)) {
      delete this.content[key];
   }
};

/**
 * get handler by responseTag and suffix
 * @param responseTag[in] responseTag of handler
 * @param suffix[in] desktopId or other to be combined with responseTag
 * @return the available handler
 */
Router.prototype.getHandler = function (responseTag, suffix) {
   var requestId = void 0;
   var handler = void 0;
   requestId = _messageHandler.MessageHandler.prototype.requestIdKV[responseTag + suffix];
   if (!!requestId) {
      handler = _util2.default.getObject(_jscdkClient.globalArray, responseTag + requestId);
   }
   return handler;
};

/**
 * push self-defined errors to UI which are not returned from broker.
 * @param object[in] object instance who generates this error
 * @param userMessage[in] user message to push
 * @param errorDetail[in] extra info, could be of type object(not including
 *    null)
 */
Router.prototype.pushSelfDefinedError = function (object, userMessage, errorDetail) {
   var errorAction = {};
   var actionContent = {};
   var errorKey = void 0;

   errorKey = object.name || object.messageName || "self-defined error";
   _jscdkLogger2.default.error("error from " + errorKey + ": " + userMessage);

   actionContent.errorType = errorKey;
   actionContent.errorText = userMessage;
   if (!!errorDetail) {
      actionContent.errorDetail = errorDetail;
   }
   errorAction.name = "ShowError";
   errorAction.content = actionContent;
   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(errorAction));
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/
/**
 * @fileoverview logservice.js -- logService
 * service to handle logs, depend on log which is defined in
 * appblast-log.js
 */

/**
 *  NOTE: this is the workaround for RTAV workers.
 *  We don't use webpack for these workers as there are many complex function
 *  in them. As a result, we have to use this ugly way to expose 'log' to other
 *  webpack module, but not for worker context.
 */
var log;
if (true) {
   log = __webpack_require__(47);
}

var RTAV = {};

var logService = function () {
   var ret = {},
       coreServer = log,
       functionMap = {
      "trace": "trace",
      "debug": "debug",
      "log": "info",
      "warn": "warn",
      "devError": "error",
      "error": "error"
   };

   /**
    * Helper function used to create a string with a desired length by padding
    * it with preceding zeroes, if necessary.
    *   pad(1, 5) will return "00001".
    *   pad("100", 1) will return "100".
    *   pad(-1, 5) will return "-00001".
    *   pad("-10", 4) will return "-0010".
    *
    * @param  {number} value  The number need to be padded
    * @param  {number} maxLen The padding max length
    * @return {number}        This returns the number which is padded to the
    *     appropriate length.
    */
   function pad(value, maxLen) {
      var string = value.toString(),
          negative = string.indexOf("-") === 0,
          length = negative ? string.length - 1 : string.length;
      return length < maxLen ? pad(negative ? "-0" + string.slice(1) : "0" + string, maxLen) : string;
   }

   /**
    * Get current time as string
    * @return {string} This returns the current time
    */
   function getDataString() {
      var logTime = new Date();

      return "[" + logTime.getFullYear() + "-" + pad(logTime.getMonth() + 1, 2) + "-" + pad(logTime.getDate(), 2) + "T" + pad(logTime.getHours(), 2) + ":" + pad(logTime.getMinutes(), 2) + ":" + pad(logTime.getSeconds(), 2) + "." + pad(logTime.getMilliseconds(), 3) + "]: ";
   }

   /**
    * Determind whether a object need to be stringified
    * @param  {any} arg The param we need to print out in the log
    * @return {boolean} This returns whether the arg will looks better in the
    *    stringified format
    */
   function needStringify(arg) {
      var needList = ['Event', 'Object'],
          argType = Object.prototype.toString.call(arg),
          i;

      for (i = 0; i < needList.length; i++) {
         if (argType === '[object ' + needList[i] + ']') {
            return true;
         }
      }
      return false;
   }

   /**
    * Return the log function which will print log with current time with
    * logName
    * @param  {string} logName The name of log function in the logService
    * @return {function} This returns the log function corresponding to logName
    */
   function getLogFunction(logName) {
      return function (arg) {
         var logFunction = coreServer[functionMap[logName]].bind(coreServer),
             logtext;
         // stringfy only for real Object, array or other data has better look
         // in the non-json format
         if (needStringify(arg)) {
            logtext = getDataString() + JSON.stringify(arg);
         } else {
            logtext = getDataString() + arg;
         }
         logFunction(logtext);
      };
   }

   /**
    * Define log functions with key in functionMap
    */
   function defineFunctions() {
      var key;
      for (key in functionMap) {
         if (functionMap.hasOwnProperty(key)) {
            ret[key] = getLogFunction(key);
         }
      }
   }

   /**
    * Sets the current log level for coreServer.
    * @param {number} level A interger from [0,4]
    */
   ret.setLevel = function (level) {
      if (!coreServer) {
         console.error("the coreServer is not defined in the RTAV.logService when set log level");
      }
      coreServer.setLevel(level);
      this.debug("the rtav log service is ready, while level is as " + level);
   };

   /**
    * Gets the current log level for coreServer.
    * @return {number} This returns a interger from [0,4]
    */
   ret.getLevel = function () {
      if (!coreServer) {
         console.error("the coreServer is not defined in the RTAV.logService when get log level");
         return 2;
      }
      return coreServer.logLevel;
   };

   defineFunctions();

   return ret;
}();

RTAV.logService = logService;

/**
 *  NOTE: this is the workaround for RTAV workers.
 */
if (typeof module !== "undefined" && module.exports) {
   module.exports = RTAV;
}

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

var _WMKS = __webpack_require__(43);

var _WMKS2 = _interopRequireDefault(_WMKS);

var _appblastLog = __webpack_require__(47);

var _appblastLog2 = _interopRequireDefault(_appblastLog);

var _iconApp282x = __webpack_require__(252);

var _iconApp282x2 = _interopRequireDefault(_iconApp282x);

var _iconApp202x = __webpack_require__(251);

var _iconApp202x2 = _interopRequireDefault(_iconApp202x);

var _spinner2x = __webpack_require__(255);

var _spinner2x2 = _interopRequireDefault(_spinner2x);

var _attention2x = __webpack_require__(250);

var _attention2x2 = _interopRequireDefault(_attention2x);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/******************************************************************************
 * Copyright 2013-2017 VMware, Inc.  All rights reserved.
 *****************************************************************************/

/**
 * appblast-util.js
 *
 *    Initialize a top level namespace for Appblast. This file should be loaded
 *    before others can initialize.
 *
 *    This contains the following:
 *    1. Global constants (AB.CONST)
 *    2. Utility and helper functions that are not appblast specific.
 *       a. AB.LOGGER:  Logging with different log levels.
 *       b. AB.L10N:    String translation with parameter substitution.
 *       c. AB.BASE_64: Base64 encoding and decoding.
 *       d. AB.UTIL:    Utility helper functions.
 *
 *    NOTE: Namespace should be in upper case.
 */

var AB = {
   /*
    * AB.LOGGER
    *
    *    Namespace for log utility. See appblast-log.js.
    */
   LOGGER: _appblastLog2.default,

   /*
    * AB.initialize()
    *
    *    This is an initialization function that overwrites default values
    *    args - IN: json object containing init values.
    *        .LOG_LEVEL - See appblast-log.js
    *        .LOCALE - Locale for locale specific messages. (default: 'en')
    */
   initialize: function initialize(args) {
      if (args) {
         if (args.LOG_LEVEL !== undefined) {
            this.LOGGER.setLevel(args.LOG_LEVEL);
         }
      }
   }
}; // End of AB namespace.

/*
 * AB.CONST
 *
 *    Namespace that holds common constants.
 */
AB.CONST = {
   // Based on bug: 958148#2 update.
   MIN_VERSION: {
      'IE': 9,
      'Gecko': 15,
      'Chrome': 22,
      'WebKit': 510
   },

   // See http://api.jquery.com/event.which/
   CLICK: {
      'left': 1,
      'middle': 2,
      'right': 3
   },

   // Like Click, but what AppBlast/Windows wants to see
   RAW_MOUSE: {
      'leftDown': 0x2,
      'leftUp': 0x4,
      'rightDown': 0x8,
      'rightUp': 0x10,
      'middleDown': 0x20,
      'middleUp': 0x40,
      'wheelmove': 0x800
   },

   /*
    * Compensating for JavaScript's lack of enumerated values for the AJAX Ready
    * State.  Maintenance of this enum does not occur against our own code.
    * Rather, as the XML HTTP Request object changes over time (thankfully, not
    * often), this enum must be kept in sync.
    */
   XHR_READY_STATE: {
      'NOT_INITIALIZED': 0,
      'CONNECTION_ESTABLISHED': 1,
      'REQUEST_RECEIVED': 2,
      'PROCESSING_REQUEST': 3,
      'RESPONSE_READY': 4
   },

   // Shared between touch and session
   INVALID_CARET_POS: 0x7fffffff,

   KEY_CODE: {
      'Shift': 16,
      'Ctrl': 17,
      'Alt': 18
   },

   FORCE_RAW_KEY_CODE: {
      8: true, // backspace
      9: true, // tab
      13: true // newline
   },

   /*
    * Compensating for JavaScript's lack of enumerated values for HTTP response codes.
    */
   HTTP_RESPONSE_CODE: {
      'OK': 200,
      'CREATED': 201,
      'ACCEPTED': 202,
      'NON_AUTHORITATIVE_INFORMATION': 203,
      'NO_CONTENT': 204,
      'RESET_CONTENT': 205,
      'PARTIAL_CONTENT': 206,

      'MULTIPLE_CHOICES': 300,
      'MOVED_PERMANENTLY': 301,
      'FOUND': 302,
      'SEE_OTHER': 303,
      'NOT_MODIFIED': 304,
      'USE_PROXY': 305,
      'RESERVED_UNUSED': 306,
      'TEMPORARY_REDIRECT': 307,

      'BAD_REQUEST': 400,
      'UNAUTHORIZED': 401,
      'PAYMENT_REQUIRED': 402,
      'FORBIDDEN': 403,
      'NOT_FOUND': 404,
      'METHOD_NOT_ALLOWED': 405,
      'NOT_ACCEPTABLE': 406,
      'PROXY_AUTHENTICATION_REQUIRED': 407,
      'REQUEST_TIMEOUT': 408,
      'CONFLICT': 409,
      'GONE': 410,
      'LENGTH_REQUIRED': 411,
      'PRECONDITION_FAILED': 412,
      'REQUEST_ENTITY_TOO_LARGE': 413,
      'REQUEST_URI_TOO_LONG': 414,
      'UNSUPPORTED_MEDIA_TYPE': 415,
      'REQUESTED_RANGE_NOT_SATISFIABLE': 416,
      'EXPECTATION_FAILED': 417,
      /* STORY OF MY LIFE */

      'INTERNAL_SERVER_ERROR': 500,
      'NOT_IMPLEMENTED': 501,
      'BAD_GATEWAY': 502,
      'SERVICE_UNAVAILABLE': 503,
      'GATEWAY_TIMEOUT': 504,
      'HTTP_VERSION_NOT_SUPPORTED': 505
   },

   // Common event click names to be triggered.
   EVENT_NAME: {
      // NOTE: We are not using a click event as it closes an open keyboard.
      // This event trigger toggles the nav item selection.
      TOGGLE_NAV_SELECTION: 'touchend.toggle_nav_select',
      // This event trigger launches the menu item.
      START_NAV_ITEM: 'touchend',
      // This event triggers a request to send webmks keycodes.
      BLAST_SEND_KEYCODE: 'blast.send_keycode',
      // Event triggers a request to send a string input to blast.
      BLAST_SEND_STRING: 'blast.send_string',
      // Event triggers a request to toggle high-resolution mode.
      BLAST_HIGH_RES_MODE: 'blast.toggle_high_res_mode',
      // Event to request html element repositioning so it stays within the canvas region.
      BLAST_ELEMENT_REPOSITION: 'blast.reposition',
      // This event trigger invokes handlePageFlow() which either closes the window or takes user to the previous page.
      // and if non existant, it closes with window.
      CLOSE_WINDOW: 'close_window.toolbar',
      // This event trigger a toggle request on the gesture guide.
      TOGGLE_GESTURE_HELP: 'toolbar.toggle_gesture_guide'
   },

   ZOOM_TYPE: {
      CUSTOM: 'custom',
      NATIVE: 'native'
   },

   // Constants related to cookies.
   COOKIE: {
      cookieName: 'VMwareBlast', // Name of a cookie - store user state / pref.
      delimitter: '||', // Use to separate the cookie key=value pairs.
      gestureHelp: 'gH', // Gesture guide is only shown the first time.
      audioWarn: 'aW', // Audio warning shown first time.
      clipboardHelp: 'cpH' // copy/paste help dialog shown.
   },

   /*
    * Defines disconnection codes for all of our expected disconnection cases.
    * The codes 3000-3999 are reserved for client use, so we can define our own
    * error codes.
    */
   DISCONNECT_REASON: {
      RECONNECT_FAILED: 3000,
      HEARTBEAT_TIMEOUT: 3001,
      DISCONNECT_REQUEST_TIMEOUT: 3002,
      IDLE_TIMEOUT: 3003
   },

   /*
    * Defines the different types of running/available items, in order of priority
    * on the sidebar display. These numbers will be used to sort the lists of running
    * and available items for display, with 0 displayed first, then 1, and such
    */
   ITEMS_TYPE: {
      LOADING_ITEM: 0, // placeholder item that holds all connecting sessions
      LOADING_APP: 1, // placeholder for apps that have not received app data
      NEED_ATTENTION: 2, // session placeholders for unity paused sessions
      DESKTOP: 3,
      APP: 4
   },

   /*
    * Defines the different running item states. States are only assigned on actual
    * running items as opposed to placeholder items (LOADING_ITEM, NEED_ATTENTION)
    * to signal the UI to display them differently on the sidebar.
    */
   ITEMS_STATE: {
      CONNECTED: 0,
      CONNECTING: 1,
      DISCONNECTED: 2
   },

   ICONS: {
      BIG_DEFAULT_ICON: _iconApp282x2.default,
      SMALL_DEFAULT_ICON: _iconApp202x2.default,
      LOADING_ICON: _spinner2x2.default,
      ATTENTION_ICON: _attention2x2.default
   },

   // Miscellaneous constants.
   DIALOG_PARENT_ID: '#dialog-holder', // The div id where dialogs/event triggers are tied to.
   CANVAS_PARENT_ID: '#canvas-container', // This is used to position dialogs.
   CANVAS_ID: 'canvas' // Canvas id to be used globally.
}; // End of AB.CONST namespace

/*
 * AB.UTIL
 *
 *    Namespace that holds helper functions that are globally used.
 */
AB.UTIL = {
   // Stores the server side global information in JSON.
   // Ex: version, build number, deployMode, etc.
   // TODO: Its better to sync up with Blast server for min screen size.
   INFO: {
      copyEnabled: false,
      pasteEnabled: false,
      clipboardMaxSize: 5000, // Max size of copy paste dialog to use.
      minScreenWidth: 320, // Min screen width thats allowed.
      minScreenHeight: 240, // Min screen height thats allowed.
      version: "4.6.0", // Display version, defined in defs.mk.
      buildNum: "1",
      acceptLanguage: 'en-US',
      deployMode: 'default'
   },

   conversionCanvas: null,

   /**
    * isLoadingItem
    *
    * Checks if a running/entitled item is the loading sessions item
    *
    * @param item: the item instance to be checked
    */
   isLoadingItem: function isLoadingItem(item) {
      return item.type === AB.CONST.ITEMS_TYPE.LOADING_ITEM;
   },

   /**
    * isLoadingApp
    *
    * Checks if a running/entitled item is a loading app
    *
    * @param item: the item instance to be checked
    */
   isLoadingApp: function isLoadingApp(item) {
      return item.type === AB.CONST.ITEMS_TYPE.LOADING_APP;
   },

   /**
    * isNeedAttention
    *
    * Checks if a running/entitled item is a need attention item
    *
    * @param item: the item instance to be checked
    */
   isNeedAttention: function isNeedAttention(item) {
      return item.type === AB.CONST.ITEMS_TYPE.NEED_ATTENTION;
   },

   /**
    * isDesktop
    *
    * Checks if a running/entitled item is a desktop
    *
    * @param item: the item instance to be checked
    */
   isDesktop: function isDesktop(item) {
      return item.type === AB.CONST.ITEMS_TYPE.DESKTOP;
   },

   /**
    * WMKS does not provide a method to tell if it's iPhone device.
    * Add this one here.
    */
   isIPhone: function isIPhone() {
      return window.navigator.userAgent.toLowerCase().indexOf('iphone') > -1;
   },

   /**
    * isApp
    *
    * Checks if a running/entitled item is an app. Loading apps are considered as apps
    * that have not yet received attribute data, but can otherwise be treated as a
    * functional app item.
    *
    * @param item: the item instance to be checked
    */
   isApp: function isApp(item) {
      return item.type === AB.CONST.ITEMS_TYPE.LOADING_APP || item.type === AB.CONST.ITEMS_TYPE.APP;
   },

   /**
    * isConnected
    *
    * Checks if a running item is connected
    *
    * @param item: the item instance to be checked
    */
   isConnected: function isConnected(item) {
      return item.state === AB.CONST.ITEMS_STATE.CONNECTED;
   },

   /**
    * isConnecting
    *
    * Checks if a running item is connecting
    *
    * @param item: the item instance to be checked
    */
   isConnecting: function isConnecting(item) {
      return item.state === AB.CONST.ITEMS_STATE.CONNECTING;
   },

   /**
    * isDisconnected
    *
    * Checks if a running item is disconnected
    *
    * @param item: the item instance to be checked
    */
   isDisconnected: function isDisconnected(item) {
      return item.state === AB.CONST.ITEMS_STATE.DISCONNECTED;
   },

   /**
    * isUsingWebcam
    *
    * Checks if a running item is using the rtav devices
    * Only show icons for Desktops
    *
    * @param item: the item instance to be checked
    */
   isUsingWebcam: function isUsingWebcam(item) {
      return this.isDesktop(item) && _logservice2.default.resourceManager.hasOccupiedResources(item.wmksKey) && _logservice2.default.wmksAdapter.isUsingDevices(item.wmksKey, 'video');
   },

   /**
    * isAskingWebcam
    *
    * Checks if the premission of a device is being asked.
    *
    * @param item: the item instance to be checked
    */
   isAskingWebcam: function isAskingWebcam(item) {
      return _logservice2.default.wmksAdapter.isAskingPremission(item.wmksKey, 'video');
   },

   /**
    * isUsingMicrophone
    *
    * Checks if a running item is owning the rtav devices
    * Only show icons for Desktops
    *
    * @param item: the item instance to be checked
    */
   isUsingMicrophone: function isUsingMicrophone(item) {
      return this.isDesktop(item) && _logservice2.default.resourceManager.hasOccupiedResources(item.wmksKey) && _logservice2.default.wmksAdapter.isUsingDevices(item.wmksKey, 'audio');
   },

   /**
    * isAskingMicrophone
    *
    * Checks if the premission of a device is being asked.
    *
    * @param item: the item instance to be checked
    */
   isAskingMicrophone: function isAskingMicrophone(item) {
      return _logservice2.default.wmksAdapter.isAskingPremission(item.wmksKey, 'audio');
   },

   /**
    * closeRTAVDevices
    *
    * close the devices RTAV is using
    */
   closeRTAVDevices: function closeRTAVDevices(item) {
      _logservice2.default.resourceManager.closeDevices(item.wmksKey);
   },

   /*
    * bgraMapToPNG
    *
    *    Converts a bgra bitmap (Uint8ClampedArray) to a PNG format
    *
    *    returns a PNG formatted data string for web (data:image/png;base64...)
    */
   bgraMapToPNG: function bgraMapToPNG(bgra, width, height) {
      var canvas = void 0,
          context = void 0,
          imageData = void 0,
          x = void 0,
          y = void 0,
          bgraIndex = void 0,
          imageIndex = void 0;
      try {
         // Use a canvas to convert the bitmap image format to png
         if (!this.conversionCanvas) {
            this.conversionCanvas = document.createElement('canvas');
            if (!this.conversionCanvas.getContext) {
               this.conversionCanvas = null;
               return "";
            }
         }

         canvas = this.conversionCanvas;

         canvas.width = width;
         canvas.height = height;
         context = canvas.getContext("2d");
         imageData = context.createImageData(width, height);

         // Individually write each pixel to canvas data
         for (x = 0; x < width; x++) {
            for (y = 0; y < height; y++) {
               // format is bottom-to-top, convert to top-to-bottom
               bgraIndex = 4 * (x + width * y);
               imageIndex = 4 * (x + width * (height - 1 - y));

               // convert bgra pixel to rgba
               imageData.data[imageIndex] = bgra[bgraIndex + 2];
               imageData.data[imageIndex + 1] = bgra[bgraIndex + 1];
               imageData.data[imageIndex + 2] = bgra[bgraIndex];
               imageData.data[imageIndex + 3] = bgra[bgraIndex + 3];
            }
         }
         context.putImageData(imageData, 0, 0);
         // extracts image data in 'data:image/png;base64' format
         return canvas.toDataURL('image/png');
      } catch (e) {
         return "";
      }
   },

   /*
    * getClipboardText
    *
    *    Gets text data from the user's clipboard.
    *    e - a copy or paste event from the browser, is required for non-IE
    *    browsers because they store clipboard data on the event
    *
    * @param windowObject the window object to use, if undefined the global window
    *                     object will be used. The normal use case is for this to be
    *                     undefined, but we use the parameter for unit tests where we
    *                     do not want to manipulate the actual window object.
    */
   getClipboardText: function getClipboardText(e, windowObject) {

      /* istanbul ignore if */
      if (!windowObject) {
         windowObject = window;
      }

      if (e && e.originalEvent && e.originalEvent.clipboardData) {
         // For non-IE browsers
         return e.originalEvent.clipboardData.getData("text/plain");
      } else if (windowObject.clipboardData) {
         // For IE
         return windowObject.clipboardData.getData("text");
      }
      return "";
   },

   /*
    * setClipboardText
    *
    *    Sets text data on the user's clipboard.
    *    e - a copy or paste event from the browser, is required for non-IE
    *    browsers because they store clipboard data on the event
    *    text - the text to be pasted to clipboard
    *
    * @param windowObject the window object to use, if undefined the global window
    *                     object will be used. The normal use case is for this to be
    *                     undefined, but we use the parameter for unit tests where we
    *                     do not want to manipulate the actual window object.
    */
   setClipboardText: function setClipboardText(e, text, windowObject) {

      /* istanbul ignore if */
      if (!windowObject) {
         windowObject = window;
      }

      if (e && e.originalEvent && e.originalEvent.clipboardData) {
         // For non-IE browsers
         e.originalEvent.clipboardData.setData("text/plain", text);
      } else if (windowObject.clipboardData) {
         // For IE
         windowObject.clipboardData.setData("text", text);
      }
   },

   /*
    * getAppIconIndex
    *
    *    return a proper icon index from an icon set.
    *    If we have target size icon, we will use it.
    *    Otherwise, use the next larger icon.
    *    Otherwise, use the next smaller icon.
    *    Otherwise, we return -1 to index there is no icon found.
    *
    * param icons a set of icon candidate.
    * param targetIconSize icon size we are looking for.
    */
   getAppIconIndex: function getAppIconIndex(icons, targetIconSize) {
      var iconIndex = -1,
          i = void 0,
          currentSelectedIconSize = 0,
          currentIconSize = 0;
      for (i in icons) {
         /* istanbul ignore else */
         if (icons.hasOwnProperty(i)) {
            // Assume the width is always equal to height;
            currentIconSize = parseInt(icons[i].width, 10);
            if (currentIconSize === targetIconSize) {
               currentSelectedIconSize = currentIconSize;
               iconIndex = i;
               break;
            } else if (currentIconSize > targetIconSize) {
               // Find the closest larger icon.
               if (currentSelectedIconSize < targetIconSize || currentIconSize < currentSelectedIconSize) {
                  currentSelectedIconSize = currentIconSize;
                  iconIndex = i;
               }
            } else {
               // Find the closest smaller icon
               if (currentIconSize > currentSelectedIconSize && currentSelectedIconSize < targetIconSize) {
                  currentSelectedIconSize = currentIconSize;
                  iconIndex = i;
               }
            }
         }
      }
      return iconIndex;
   },

   /**
    *
    * getDesiredResolution
    *
    * This function computes the desired resolution for the desktop for all
    * device and desktop browsers.
    *
    * @param windowObject the window object to use, if undefined the global window
    *                     object will be used. The normal use case is for this to be
    *                     undefined, but we use the parameter for unit tests where we
    *                     do not want to manipulate the actual window object.
    *
    * @param wmks the wmks Object to use, if undefined the global wmks object will be
    *             used. This is for unit testing purposes to avoid modifying a global
    *             object.
    *
    * return a JSON object containing width and height.
    */
   getDesiredResolution: function getDesiredResolution(windowObject, wmks) {
      var w = void 0,
          h = void 0,
          scale = void 0;

      /* istanbul ignore if */
      if (!windowObject) {
         windowObject = window;
      }

      /* istanbul ignore if */
      if (!wmks) {
         wmks = _WMKS2.default;
      }

      if (wmks.BROWSER.isIOS() || wmks.BROWSER.isAndroid()) {
         /*
            For more information please refer 1572136
            For iOS 9, we need to use document.documentElement.clientWidth/clientHeight
         */
         w = windowObject.document.documentElement.clientWidth;
         h = windowObject.document.documentElement.clientHeight;
      } else if (wmks.BROWSER.isTouchDevice()) {

         if (wmks.UTIL.TOUCH.isPortraitOrientation()) {
            w = windowObject.screen.width;
         } else {
            w = windowObject.screen.height;
         }

         // Calculate the viewport scale.
         scale = w / windowObject.innerWidth;
         // Calculate the screen height.
         h = Math.floor(windowObject.innerHeight * scale);
      } else {
         /*
          * In desktop mode on a desktop, resize the desktop to fit the browser
          * window, not the size of the whole local screen.
          */
         w = windowObject.innerWidth;
         h = windowObject.innerHeight;
      }

      return [w, h];
   },

   /**
    * getTouchDeviceDesiredResolution
    *
    * orientationchange is fired after window.orientation
    * property has changed, but before the orientation is reflected in the UI.
    * Inspecting dimensions of elements (e.g. window.innerWidth or window.innerHeight)
    * gives the dimensions of the elements in the pre-orientation change state.
    *
    * There is no way to capture the end of the orientation change event because
    * handling of the orientation change varies from browser to browser. Drawing
    * a balance between the most reliable and the fastest way to detect the end
    * of orientation change requires racing interval and timeout.
    *
    */
   getTouchDeviceDesiredResolution: function getTouchDeviceDesiredResolution(callback, windowObject) {
      var noChangeCountToEnd = 100,
          noEndTimeout = 1000,
          interval = void 0,
          timeout = void 0,
          end = void 0,
          lastClientWidth = void 0,
          lastClientHeight = void 0,
          noChangeCount = void 0;

      /* istanbul ignore if */
      if (!windowObject) {
         windowObject = window;
      }

      end = function end() {
         clearInterval(interval);
         clearTimeout(timeout);

         interval = null;
         timeout = null;
         // "orientationchangeend"
         callback([lastClientWidth, lastClientHeight]);
      };

      interval = setInterval(function () {
         if (windowObject.document.documentElement.clientWidth === lastClientWidth && windowObject.document.documentElement.clientHeight === lastClientHeight) {
            noChangeCount++;

            if (noChangeCount === noChangeCountToEnd) {
               end();
            }
         } else {
            lastClientWidth = windowObject.document.documentElement.clientWidth;
            lastClientHeight = windowObject.document.documentElement.clientHeight;
            noChangeCount = 0;
         }
      });
      timeout = setTimeout(function () {
         // The timeout happened first.
         end();
      }, noEndTimeout);
   },

   /*
    * isMP4Supported
    *
    * Test if media source object is supported on this browser.
    * For EA, we only support Chrome browser for now.
    *
    *
    * @param windowObject the window object to use, if undefined the global window
    *                     object will be used. The normal use case is for this to be
    *                     undefined, but we use the parameter for unit tests where we
    *                     do not want to manipulate the actual window object.
    *
    * @param wmks the wmks Object to use, if undefined the global wmks object will be
    *             used. This is for unit testing purposes to avoid modifying a global
    *             object.
    *
    */
   isMP4Supported: function isMP4Supported(windowObject, wmks) {
      var isMediaSourceSupported = true,
          testObject = null;

      /* istanbul ignore if */
      if (!windowObject) {
         windowObject = window;
      }

      /* istanbul ignore if */
      if (!wmks) {
         wmks = _WMKS2.default;
      }

      // For MP4 feature, we only support Chrome browser 45 and above.
      if (!wmks.BROWSER.isChrome() || wmks.BROWSER.version.major < 45 || _WMKS2.default.BROWSER.isAndroid()) {
         return false;
      }

      try {
         windowObject.MediaSource = windowObject.MediaSource || windowObject.WebKitMediaSource;
         testObject = new windowObject.MediaSource();
         testObject = null;
      } catch (e) {
         isMediaSourceSupported = false;
      }

      return isMediaSourceSupported;
   },

   /*
    * isRTAVSupported
    *
    * We donn't support RTAV on IE and Safari
    *
    * @param wmks the wmks Object to use, if undefined the global wmks object will be
    *             used. This is for unit testing purposes to avoid modifying a global
    *             object.
    */
   isRTAVSupported: function isRTAVSupported(wmks) {
      /* istanbul ignore if */
      if (!wmks) {
         wmks = _WMKS2.default;
      }

      // For RTAV feature, we don't support IE and Safari.
      return !(wmks.BROWSER.isIE() && wmks.BROWSER.version.major <= 11 || wmks.BROWSER.isSafari());
   },

   /*
    * loadConfigInfo
    *
    *    Loads server side info containing the following.
    *    0. Internal version (1.0.0)
    *    1. Version (2.2)
    *    2. Build number (123456)
    *    3. toolbar type - Identifies the toolbar to load.
    */
   loadConfigInfo: function loadConfigInfo(ajaxMethod) {
      var self = this;

      ajaxMethod({
         type: 'GET',
         url: '../info.jsp',
         dataType: 'json',
         cache: false,
         async: false,
         success: function success(infoData) {
            if (infoData) {
               if (infoData.acceptLanguage) {
                  self.INFO.acceptLanguage = infoData.acceptLanguage;
               }

               if (infoData.clientVersion) {
                  self.INFO.internalVersion = infoData.clientVersion;
                  var splitVersionInfo = infoData.clientVersion.split('-');
                  self.INFO.version = splitVersionInfo[0];
                  self.INFO.buildNum = splitVersionInfo[1];

                  // Todo: Replace with real data
                  self.INFO.deployMode = "view";
                  self.INFO.clipboardMaxSize = 5000;
                  self.INFO.copyEnabled = false;
                  self.INFO.pasteEnabled = false;
               }
            } else {
               AB.LOGGER.error('Invalid /info json response.');
            }
         },
         error: function error() {
            AB.LOGGER.error('Error loading /info from server.');
         }
      });
   },

   /*
    * clamp
    *
    *    Given three parameters value, minValue, maxValue returns:
    *       minValue if value < minValue
    *       maxValue if min > maxValue
    *       otherwise returns value
    *    In the case where minValue > maxValue the behavior is undefined
    */
   clamp: function clamp(value, minValue, maxValue) {
      return Math.min(maxValue, Math.max(value, minValue));
   },

   /*
    * returnToLauncher
    *
    *    Redirects the client back to the launcher page
    *
    * @param windowObject the window object to use, if undefined the global window
    *                     object will be used. The normal use case is for this to be
    *                     undefined, but we use the parameter for unit tests where we
    *                     do not want to manipulate the actual window object.
    */
   returnToLauncher: function returnToLauncher(windowObject) {
      var launchPageURL = void 0;

      /* istanbul ignore if */
      if (!windowObject) {
         windowObject = window;
      }

      // Redirect us back to main launcher page. We cannot use
      // window.document.referrer because if the user came in here by using a URI
      // then the referrer will just return us to the client
      if (!windowObject.location.origin) {
         launchPageURL = windowObject.location.protocol + "//" + windowObject.location.hostname + (windowObject.location.port ? ':' + windowObject.location.port : '');
      } else {
         launchPageURL = windowObject.location.origin;
      }

      windowObject.location.href = launchPageURL;
   },

   /*
    * itemNameContainsQuery
    *
    *    Predicate that returns where an item's name property matches a query
    *    string. Returns true if query === "" or if the item name contains query.
    *    This does a case insensitive comparison.
    */
   itemNameContainsQuery: function itemNameContainsQuery(item, query) {
      if (query === "") {
         return true;
      }

      // Use indexOf along with toLocaleLowerCase() to see if the search string
      // is in the item
      return item.name.toLocaleLowerCase().indexOf(query.toLocaleLowerCase()) !== -1;
   },

   /*
    * itemSortHelper
    *
    *    Help function is used in Array.sort(). We always put desktop item on the
    *    top of list. If it is the same type, follow the alphabet order.
    */
   itemSortHelper: function itemSortHelper(item1, item2) {
      if (item1.type === item2.type) {
         // If it is the same type, sort the item by alphabet order.
         if (item1.name === item2.name) {
            return 0;
         } else {
            return item1.name > item2.name ? 1 : -1;
         }
      } else {
         return item1.type > item2.type ? 1 : -1;
      }
   },

   /**
    * @return {Boolean} This returns whether current browser is IE with version equal
    *    or lower than 11 which doesn't postMessage well.
    */
   supportPostMessage: function supportPostMessage() {
      var ua = window.navigator.userAgent.toLowerCase();
      var isIE = ua.indexOf('msie') > -1 || ua.indexOf('trident') > -1;
      var isEdge = ua.indexOf('edge') > -1;
      return !isIE || isEdge;
   }

}; // End of AB.UTIL namespace

/*
 * Initialize the AB namespace with dynamic content from the server side.
 */

// Load and store the server info data including version, build, etc.
AB.UTIL.loadConfigInfo(_jquery2.default.ajax);

exports.default = AB;

/***/ }),
/* 9 */,
/* 10 */
/***/ (function(module, exports) {

var path = 'common/commondialog/dialog_service_error.html';
var html = "<div class=\"dialog-title\">{{(ngDialogData.title) || ('ERROR' | i18n)}}</div>\n<div class=\"dialog-content\">\n   <div class=\"session-ops-window-text\">{{ngDialogData.errorMessage}}</div>\n</div>\n<div class=\"dialog-button-row\" dialog-tab-scope>\n   <button class=\"modal-button-base modal-button-right modal-button-blue\" ng-click=\"close() || closeThisDialog()\"  id=\"closeDialogBtn\" dialog-tabindex=\"1\" dialog-prevent-key-up>\n      {{(ngDialogData.buttonLabel) || ('OK' | i18n)}}\n   </button>\n</div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 11 */,
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _WMKS = __webpack_require__(43);

var _WMKS2 = _interopRequireDefault(_WMKS);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _vdpservice = __webpack_require__(22);

var _vdpservice2 = _interopRequireDefault(_vdpservice);

var _stringUtils = __webpack_require__(32);

var _stringUtils2 = _interopRequireDefault(_stringUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * mksvchan.js --
 *
 * Interface used to send and receive MKSVchan RPCs and updates.
 */

var MKSVchan = {
   // Some constants copied from bora/apps/rde/mksvchan
   PACKET_TYPE: {
      CLIPBOARD_DATA_TEXT: 0,
      CLIPBOARD_REQUEST: 1,
      CLIPBOARD_DATA_CP: 2,
      CLIPBOARD_CAPABILITIES: 3,
      CLIPBOARD_LOCALE: 4,
      FILE_TRANSFER_REQUEST: 5,
      FILE_TRANSFER_DATA_FILE: 6,
      FILE_TRANSFER_CONFIG: 7,
      FILE_TRANSFER_ERROR: 8
   },

   CAPABILITY_CLIPBOARD: {
      TEXT: 0,
      IMAGE_AND_RTF: 1,
      NOTIFY_ON_CHANGE: 2
   },

   CLIPBOARD_ERROR: {
      NONE: 0,
      MAX_LIMIT_EXCEEDED: 1
   },

   FILE_TRANSFER_FILE_TYPE: {
      FILE: 0,
      DIRECTORY: 1,
      SYMLINK: 2
   },

   FILE_TRANSFER_POLICY: {
      MIN: 0,
      DISABLED: 0,
      DEFAULT: 0,
      BIDIRECTIONAL: 1,
      ONLY_TO_SERVER: 2,
      ONLY_TO_CLIENT: 3,
      MAX: 3
   },

   FILE_TRANSFER_ERROR: {
      NO_ENOUGH_DISK: 0,
      IS_TRANSFERRING: 1,
      UNKNOWN_ERROR: 2,
      PRINT_TIMEOUT: 3
   },

   FILE_TRANSFER_REQUEST: {
      SEND_FILES: 0,
      CANCEL_SEND_FILES: 1,
      SEND_SPECIFIC_FILES: 2,
      CANCEL_SEND_SPECIFIC_FILES: 3,
      CANCEL_RECEIVE_SPECIFIC_FILE: 4,
      // New added file list format
      FILE_LIST: 5,
      PRINT_CONFIG: 6
   },

   FILE_TRANSFER_CLIENT: {
      WINDOWS: 0,
      MAC: 1,
      LINUX: 2,
      WEB: 3,
      ANDROID: 4,
      IOS: 5
   },

   FILE_TRANSFER_CONSUMER: {
      FT: 0,
      PRINT: 1,
      DEFAULT: 0,
      MIN: 0,
      MAX: 1
   },

   FILE_TRANSFER_MAX_FILE_SIZE: 1024 * 1024 * 500,
   FILE_TRANSFER_MAX_TOTAL_SIZE: 1024 * 1024 * 1000,

   /**
    * The capability bit that enables automatic mksVchan updates on clipboard
    * change. When this capability is enabled, we will listen to mksVchan's
    * automatic updates, rather than the old updates from Blast, which will be
    * disabled by agent.
    */
   ENABLE_NOTIFY_ON_CHANGE: 1 << 8,

   /*
    * The current limit for MAX_BYTES_TEXT comes from the mksVchanPlugin, see
    * MKSVchanPlugin_GetCapsMaxClipboardBytes. The limit is 1mb (minus header)
    * since the new clipboard functionality was added.
    */
   MAX_BYTES_TEXT: 1024 * 1024 - 100,
   MAX_BYTES_IMAGE_AND_RTF: 1024 * 1024,
   MAX_KBYTES_IMAGE_AND_RTF: 1024,

   CHANNEL_NAME_PREFIX: "RPC#MKSVchan#",
   CHANNEL_DATA_OBJECT: "MKSVchanDataObj",
   CHANNEL_CTRL_OBJECT: "MKSVchanControlObj",

   /**
    * List of data formats that the clipboard supports
    * Copied from bora/lib/public/dnd.h
    * NOTE: View does not support all of these
    * @enum {Number}
    */
   CP_FORMAT: {
      UNKNOWN: 0,
      MIN: 1,
      TEXT: 1,
      FILELIST: 2,
      RTF: 3,
      FILELIST_URI: 4,
      FILECONTENTS: 5,
      IMG_PNG: 6,
      FILEATTRIBUTES: 7,
      BIFF12: 8,
      ART_GVML_CLIPFORMAT: 9,
      HTML_FORMAT: 10,
      MAX: 11
   },

   /**
    * Create a new clipboard object
    *
    * @classdesc
    *    A clipboard object which handles every data format.
    *    Mimics lib/dnd/dndClipboard CPClipboard_x
    * @constructor
    * @return {MKSVchan.Clipboard}
    */
   Clipboard: function Clipboard() {
      var items = void 0,
          changed = void 0;

      /**
       * Clear the data in the clipboard.
       */
      this.clear = function () {
         var i = void 0;
         items = [];
         changed = false;

         for (i = MKSVchan.CP_FORMAT.MIN; i < MKSVchan.CP_FORMAT.MAX; ++i) {
            items[i] = null;
         }
      };

      // Call this.clear to initialise the clipboard
      this.clear();

      /**
       * Return the total size of the data stored in the clipboard.
       *
       * @return {Number} size
       *    Size of all data in the clipboard.
       */
      this.getTotalSize = function () {
         var size = 0,
             i = void 0;

         for (i = 0; i < items.length; ++i) {
            size += items[i] ? items[i].byteLength : 0;
         }

         return size;
      };

      /**
       * Return the clipboard item for the specified format.
       *
       * @param  {MKSVchan.CP_FORMAT} format
       *    The item format.
       * @return {Uint8Array?} data
       *    The data in the clipboard, or null.
       */
      this.getItem = function (format) {
         if (format < MKSVchan.CP_FORMAT.MIN || format > MKSVchan.CP_FORMAT.MAX) {
            _jscdkLogger2.default.error('Clipboard.getItem invalid format');
            return null;
         }

         return items[format];
      };

      /**
       * Set the clipboard data for a specific format.
       *
       * Will automatically attempt to trim text data to fit, or attempt to
       * trim the clipboard's existing text data to fit non-text data.
       *
       * @param {MKSVchan.CP_FORMAT} format
       *    The format of the data to set.
       * @param {Uint8Array} data
       *    The actual data to set.
       * @return {Boolean} success
       *    Returns true on success, false on failure
       */
      this.setItem = function (format, data) {
         var size = void 0,
             excess = void 0,
             text = void 0;

         if (format < MKSVchan.CP_FORMAT.MIN || format > MKSVchan.CP_FORMAT.MAX) {
            _jscdkLogger2.default.error('Clipboard.setItem invalid format');
            return false;
         }

         if (data && !(data instanceof Uint8Array)) {
            _jscdkLogger2.default.error('Clipboard.setItem expects data to be a Uint8Array');
            return false;
         }

         // Get size of current clipboard contents
         size = this.getTotalSize();

         // If we are replacing an item, subtract size of item we are replacing
         if (!!items[format]) {
            size -= items[format].byteLength;
         }

         // Add size of new clipboard contents
         if (data) {
            size += data.byteLength;
         }

         // Ensure we do not exceed the maximum clipboard data size
         if (size >= MKSVchan.MAX_BYTES_IMAGE_AND_RTF) {
            excess = size - MKSVchan.MAX_BYTES_IMAGE_AND_RTF;

            if (format === MKSVchan.CP_FORMAT.TEXT) {
               // Attempt to trim excess from the new text data
               if (excess < data.byteLength) {
                  _jscdkLogger2.default.debug('Clipboard.setItem has trimmed ' + excess + ' bytes from the new text data');
                  data = data.subarray(0, data.byteLength - excess);
                  excess = 0;
               }
            } else if (items[MKSVchan.CP_FORMAT.TEXT]) {
               // Attempt to trim excess from existing text item to fit new data
               text = items[MKSVchan.CP_FORMAT.TEXT];

               if (excess < text.byteLength) {
                  _jscdkLogger2.default.debug('Clipboard.setItem has trimmed ' + excess + ' bytes from existing text data');
                  items[MKSVchan.CP_FORMAT.TEXT] = text.subarray(0, text.byteLength - excess);
                  excess = 0;
               }
            }

            if (excess > 0) {
               _jscdkLogger2.default.debug('Clipboard.setItem will cause clipboard to exceed maximum size.' + ' data size: ' + data.byteLength + ' clipboard size: ' + this.getTotalSize() + ' maximum size: ' + MKSVchan.MAX_BYTES_IMAGE_AND_RTF);
               return false;
            }
         }

         changed = true;
         items[format] = data;
         return true;
      };

      /**
       * Returns the clipboard's text value as a string.
       *
       * @param format: clipboard format, default value text
       */
      this.getText = function (format) {
         if (format < MKSVchan.CP_FORMAT.MIN || format > MKSVchan.CP_FORMAT.MAX) {
            _jscdkLogger2.default.error('Clipboard.getText invalid format');
            return null;
         }
         var clipboardFormat = format || MKSVchan.CP_FORMAT.TEXT,
             text = this.getItem(clipboardFormat);

         if (text == null) {
            return null;
         }
         if (text.length > 0 && text[text.length - 1] === 0) {
            text = text.subarray(0, text.length - 1);
         }

         /**
          * Replace \n with \r\n if it is MKSVchan.CP_FORMAT.TEXT
          * See bug 1512956
          * mksvchan server will trim \r\n to \n. Client need to add it back.
          */
         var textStr = _stringUtils2.default.uint8ArrayToString(text);
         if (clipboardFormat === MKSVchan.CP_FORMAT.TEXT) {
            textStr = textStr.replace(/\r?\n/g, "\r\n");
         }
         return textStr;
      };

      /**
       * Sets the clipboard's text value.
       *
       * @param text: a string of text to set the clipboard to.
       * @param format: clipboard format, default value text
       */
      this.setText = function (text, format) {
         if (format < MKSVchan.CP_FORMAT.MIN || format > MKSVchan.CP_FORMAT.MAX) {
            _jscdkLogger2.default.error('Clipboard.setText invalid format');
            return;
         }
         var clipboardFormat = format || MKSVchan.CP_FORMAT.TEXT;
         this.setItem(clipboardFormat, _stringUtils2.default.stringToUint8Array(text, true));
      };

      /**
       * Set the value of the changed flag.
       *
       * @parameter {Boolean} value
       *    New value of the changed flag.
       */
      this.setChanged = function (value) {
         changed = value;
      };

      /**
       * Gets the value of the changed flag.
       *
       * @return {Boolean} changed
       *    Value of the changed flag.
       */
      this.getChanged = function (value) {
         return changed;
      };
   },

   /**
    * Create a new file transfer util
    *
    * @classdesc
    *    File transfer util. Each MKSVchan client should keep its own one.
    *
    * @constructor
    * @return {MKSVchan.FTUtil}
    */
   FTUtil: function FTUtil() {
      this.downloadList = {};
      this.downloadList[MKSVchan.FILE_TRANSFER_CONSUMER.FT] = [];
      this.downloadList[MKSVchan.FILE_TRANSFER_CONSUMER.PRINT] = [];
      this.uploadList = [];
      this.fileChunkQueue = [];
      this.currentDownloadService = null;

      this.config = {
         // Second release version, set it to 1 as default
         serverVersion: 1,
         clientVersion: 1,
         // For file transfer download only
         downloadEnabled: 0,
         // For print file download only
         printDownloadEnabled: 0,
         uploadEnabled: 0,
         // Default chunk size is 32KB
         chunkSize: 1024 * 32,
         // Largest chunk size for HTML Access
         maxChunkSize: 65535,
         // Largest chunk number for HTML Access
         maxChunkNum: 65535
      };

      this.parseDownloadListString = function (fileList) {
         if (!fileList) {
            _jscdkLogger2.default.info("parseFileListString: empty string found.");
            return [];
         }

         var resList = [],
             fileListArray = fileList.split('\0'),
             fileNum = fileListArray.length / 5,
             fileInfoObj = void 0,
             fileType = void 0,
             fileSize = void 0,
             i = void 0;

         if (fileListArray.length % 5 !== 0) {
            _jscdkLogger2.default.error("parseFileListString: string format is not right.");
            return [];
         }

         for (i = 0; i < fileNum; i++) {
            fileType = parseInt(fileListArray[fileNum * 3 + i]);
            fileSize = parseInt(fileListArray[fileNum * 2 + i]);
            fileInfoObj = {
               fullPath: fileListArray[i],
               relPath: fileListArray[fileNum + i],
               uuid: fileListArray[fileNum * 4 + i],
               size: fileSize,
               readableSize: this.getReadableSize(fileListArray[fileNum * 2 + i]),
               fileType: fileType,
               contentData: null,
               progress: 0,
               transferError: fileType !== 0 || fileSize === 0 || fileSize > MKSVchan.FILE_TRANSFER_MAX_FILE_SIZE,
               stopTransfer: false
            };
            resList.push(fileInfoObj);
         }

         return resList;
      };

      this.getReadableSize = function (size) {
         size = parseInt(size);
         if (typeof size !== 'number') {
            _jscdkLogger2.default.error(size + "is not legal number");
            return 0;
         }

         var kb = 1024,
             mb = 1024 * 1024,
             gb = 1024 * 1024 * 1024;

         if (size === 0) {
            return '0 byte';
         } else if (size < kb) {
            return size.toFixed(2) + 'bytes';
         } else if (size >= kb && size < mb) {
            return (size / kb).toFixed(2) + 'KB';
         } else if (size >= mb && size < gb) {
            return (size / mb).toFixed(2) + 'MB';
         } else if (size >= gb) {
            return (size / gb).toFixed(2) + 'GB';
         } else {
            _jscdkLogger2.default.info("getReadableSize: file is too large.");
         }
      };

      this.downloadServiceSwitcher = function (services, chunkNum, chunkFileIdentifier) {
         if (!services || services.length < 1 || !chunkFileIdentifier) {
            _jscdkLogger2.default.debug("Params illegal");
            return null;
         }

         // No need to switch service if there is only one.
         if (services.length === 1) {
            return services[0];
         }

         // Only run service detection for the first packet.
         if (chunkNum > 0 && !!this.currentDownloadService) {
            return this.currentDownloadService;
         }

         var i = void 0,
             service = null;
         for (i = 0; i < services.length; i++) {
            service = services[i];
            if (!!service.searchReceiveFile && !!service.searchReceiveFile(chunkFileIdentifier)) {
               this.currentDownloadService = service;
               return service;
            }
         }
         _jscdkLogger2.default.error('Cannot find appropriate download service for' + ' the packet!');
         return null;
      };

      this.updateConfig = function (serverVersion, policy, chunkSize) {
         if (serverVersion !== this.config.clientVersion) {
            _jscdkLogger2.default.warning('File transfer server version is: ' + serverVersion + '. But the client version is: ' + this.config.clientVersion + '. Only part of functionality can be used');
            this.config.serverVersion = serverVersion;
         }

         if (policy < MKSVchan.FILE_TRANSFER_POLICY.MIN || policy > MKSVchan.FILE_TRANSFER_POLICY.MAX) {
            _jscdkLogger2.default.error('Wrong file transfer policy, use default setting.');
            return;
         }

         if (chunkSize < 0 || chunkSize > this.config.maxChunkSize) {
            _jscdkLogger2.default.error('Wrong file transfer chunk size, use default setting.');
            return;
         }

         // If parameter is right, set it to env
         this.config.chunkSize = chunkSize;
         this.config.uploadEnabled = policy === MKSVchan.FILE_TRANSFER_POLICY.BIDIRECTIONAL || policy === MKSVchan.FILE_TRANSFER_POLICY.ONLY_TO_SERVER;
         this.config.downloadEnabled = policy === MKSVchan.FILE_TRANSFER_POLICY.BIDIRECTIONAL || policy === MKSVchan.FILE_TRANSFER_POLICY.ONLY_TO_CLIENT;
      };

      this.searchFileFromList = function (fileList, file) {
         if (!fileList || !file || !file.fullPath) {
            return null;
         }

         var i = void 0;
         for (i = 0; i < fileList.length; i++) {
            if (fileList[i].fullPath === file.fullPath) {
               return fileList[i];
            }
         }
         return null;
      };

      this.tryNormalizeUnicodeForMac = function (string) {
         if (!string) {
            return "";
         }

         // Try to normalize filename for Mac, see bug 1655526 for detail
         if (window.navigator.platform.toLowerCase().indexOf('mac') >= 0) {
            try {
               string = string.normalize('NFC');
            } catch (e) {
               _jscdkLogger2.default.warning('Failed to normalize filename: ' + e);
            }
         }
         return string;
      };
   },

   Client: function Client(vdpService) {
      var self = this,


      // Private variables
      vdpChannel = null,
          vdpControlObject = null,
          vdpDataObject = null,


      // Private functions
      sendRPC = null,
          sendClipboardCapabilities = null,
          sendClipboardLocale = null,
          sendFileTransferConfig = null,
          handleRPCFromServer = null,
          handleClipboardCapabilities = null,
          handleClipboardDataText = null,
          handleClipboardDataCP = null,
          handleFileTransferData = null,
          handleFileTransferRequest = null,
          handleFileTransferConfig = null,
          handleFileTransferError = null;

      /**
       * The locale of text in the clipboard.
       * @type {Number}
       */
      this.locale = 0;

      /**
       * The local copy of the remote clipboard.
       * @type {MKSVchan.Clipboard}
       */
      this.clipboard = new MKSVchan.Clipboard();

      /**
       * The local copy of file transfer util.
       * @type {MKSVchan.FTUtil}
       */
      this.FTUtil = new MKSVchan.FTUtil();

      /**
       * Called when the vdp channel becomes ready
       */
      this.onReady = null;

      /**
       * Called when the local clipboard has been changed by the remote.
       * @callback MKSVchan~onClipboardChanged
       * @param {MKSVchan.Clipboard} clipboard
       * @type {MKSVchan.onClipboardChanged}
       */
      this.onClipboardChanged = null;

      /**
       * Called when the download files are changed by the remote.
       * @callback MKSVchan~onDownloadFilesChange
       * @param {Array} Download file list
       * @type {MKSVchan.onDownloadFilesChange}
       */
      this.onDownloadFilesChange = null;

      /**
       * Called when the print download files are changed by the remote.
       * @callback MKSVchan~onPrintDownloadFilesChange
       * @param {Array} Download file list
       * @type {MKSVchan.onPrintDownloadFilesChange}
       */
      this.onPrintDownloadFilesChange = null;

      /**
       * Called when the receive file chunks.
       * @callback MKSVchan~onFileChunkReceived
       * @param {Number} Chunk params
       * @type {MKSVchan.onFileChunkReceived}
       */
      this.onFileChunkReceived = null;

      /**
       * Called when the server return file transfer
       * configuration.
       * @callback MKSVchan~onFileTransferConfigChange
       * @param {Object} Error object
       * @type {MKSVchan.onFileTransferConfigChange}
       */
      this.onFileTransferConfigChange = null;

      /**
       * Called when the server return file transfer
       * error number.
       * @callback MKSVchan~onFileTransferError
       * @param {Number} Error number
       * @type {MKSVchan.onFileTransferError}
       */
      this.onFileTransferError = null;

      /**
       * Called when the server return printer takes too long time to convert
       * PDF.
       * @callback MKSVchan~onPrintError
       * @param {Number} Error number
       * @type {MKSVchan.onPrintError}
       */
      this.onPrintError = null;

      /**
       * The supported capabilites of MKSVchan.Client.
       * @type {Object}
       */
      this.capabilities = {
         version: MKSVchan.CAPABILITY_CLIPBOARD.NOTIFY_ON_CHANGE,
         notifyOnChangeEnabled: true,
         size: MKSVchan.MAX_KBYTES_IMAGE_AND_RTF
      };

      // Reference service for file transfer
      this.uploadService = null;
      this.downloadServices = {};
      this.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.FT] = null;
      this.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.PRINT] = null;

      /**
       * Initialize the MKSVchan client.
       *
       * Adds a listener on vdpService for channel created.
       */
      this.initialize = function () {
         if (!vdpService) {
            _jscdkLogger2.default.error('mksVchan init failed: no vdpService specified');
            return;
         }
         vdpService.addChannelCreatedListener(function (channel) {
            if (channel.name.indexOf(MKSVchan.CHANNEL_NAME_PREFIX) === 0) {
               if (vdpService.connectChannel(channel)) {
                  _jscdkLogger2.default.debug('Successfully accepted MKSVchan main channel');
               } else {
                  _jscdkLogger2.default.error('Failed to open MKSVchan main channel');
                  return;
               }

               vdpChannel = channel;

               channel.onReady = function (object) {
                  if (object.name === MKSVchan.CHANNEL_DATA_OBJECT) {
                     vdpDataObject = object;
                     _jscdkLogger2.default.debug('MKSVchan data channel is ready for traffic.');
                  } else if (object.name === MKSVchan.CHANNEL_CTRL_OBJECT) {
                     vdpControlObject = object;
                     _jscdkLogger2.default.debug('MKSVchan control channel is ready for traffic.');
                  }
                  if (self.onReady) {
                     self.onReady();
                  }
               };

               channel.onDisconnect = function (object) {
                  if (object) {
                     if (vdpControlObject && vdpControlObject.id === object.id) {
                        vdpControlObject = null;
                        _jscdkLogger2.default.debug('MKSVchan control channel was closed by ' + 'the remote desktop.');
                     } else if (vdpDataObject && vdpDataObject.id === object.id) {
                        vdpDataObject = null;
                        _jscdkLogger2.default.debug('MKSVchan data channel was closed by ' + 'the remote desktop.');
                     }
                  } else {
                     // If object is not specified, everything disconnected!
                     vdpDataObject = null;
                     vdpControlObject = null;
                     _jscdkLogger2.default.debug('MKSVchan control and data channel was ' + 'closed by the remote desktop.');
                  }
               };

               channel.onInvoke = function (rpc) {
                  handleRPCFromServer(rpc);
               };
            }
         });
      };

      /**
       * Send request to receive remote clipboard.
       *
       * @param {Function} onDone
       *    Called when the request clipboard rpc has completed.
       * @param {Function} onAbort
       *    Called if the request clipboard rpc has aborted.
       * @return {Boolean} success
       *    Returns true on success, false on failure
       */
      this.sendClipboardRequest = function (onDone, onAbort) {
         return sendRPC(MKSVchan.PACKET_TYPE.CLIPBOARD_REQUEST, null, onDone, onAbort);
      };

      /**
       * Send request to receive remote files.
       *
       * @param {Integer} consumer
       *    Ft consumer
       * @param {Function} onDone
       *    Called when the request files rpc has completed.
       * @param {Function} onAbort
       *    Called if the request files rpc has aborted.
       */
      this.sendFileTransferRequest = function (consumer, onDone, onAbort) {
         // Default request all the files from server
         var packet = _WMKS2.default.Packet.createNewPacketLE(),
             uint8Consumer = _stringUtils2.default.stringToUint8Array(consumer, true);

         packet.writeUint16(MKSVchan.FILE_TRANSFER_REQUEST.SEND_FILES);

         if (self.FTUtil.config.serverVersion === 0) {
            // old ft request
            packet.writeUint16(0);
         } else if (self.FTUtil.config.serverVersion === 1) {
            // new ft request
            packet.writeUint16(uint8Consumer.length);
            packet.writeArray(uint8Consumer);
         }

         return sendRPC(MKSVchan.PACKET_TYPE.FILE_TRANSFER_REQUEST, packet, onDone, onAbort);
      };

      /**
       * Send file chunk to MKSVchan server.
       */
      this.sendFileChunk = function (chunkNum, totalChunkNum, chunkSize, chunkIdentifier, chunkData, fileSize, onDone, onAbort) {
         chunkIdentifier = this.FTUtil.tryNormalizeUnicodeForMac(chunkIdentifier);

         var packet = _WMKS2.default.Packet.createNewPacketLE(),
             uint8IdArray = _stringUtils2.default.stringToUint8Array(chunkIdentifier, true);
         packet.writeUint16(chunkNum);
         packet.writeUint16(totalChunkNum);
         packet.writeUint16(chunkSize);
         packet.writeUint16(uint8IdArray.length);
         packet.writeUint32(fileSize);
         packet.writeArray(uint8IdArray);
         packet.writeArray(chunkData);

         sendRPC(MKSVchan.PACKET_TYPE.FILE_TRANSFER_DATA_FILE, packet, onDone, onAbort);
      };

      /**
       * Send text to remote clipboard.
       *
       * @param {String} text
       *    The text to upload to remote clipboard.
       * @param {Function} onDone
       *    Called when the send clipboard rpc has completed.
       * @param {Function} onAbort
       *    Called if the send clibpoard rpc has aborted.
       * @return {Boolean} success
       *    Returns true on success, false on failure
       */
      this.sendClipboardText = function (text, onDone, onAbort) {
         var packet = _WMKS2.default.Packet.createNewPacketLE(),
             error = MKSVchan.CLIPBOARD_ERROR.NONE,
             utf8Text = _stringUtils2.default.stringToUint8Array(text, true),
             rpcDone = void 0;

         if (utf8Text.length > MKSVchan.MAX_BYTES_TEXT) {
            utf8Text = utf8Text.subarray(0, MKSVchan.MAX_BYTES_TEXT);
            utf8Text[MKSVchan.MAX_BYTES_TEXT - 1] = 0;
            error = MKSVchan.CLIPBOARD_ERROR.MAX_LIMIT_EXCEEDED;
         }

         rpcDone = function rpcDone() {
            onDone(text, error);
         };

         packet.writeArray(utf8Text);
         return sendRPC(MKSVchan.PACKET_TYPE.CLIPBOARD_DATA_TEXT, packet, rpcDone, onAbort);
      };

      /**
       * Upload a MKSVchan.Clipboard object.
       *
       * Equivalent to the format in bora/lib/dnd:
       *    uint32 max_formats
       *    for i = 1 -> max_formats
       *       uint8 exists
       *       uint32 size
       *       uint8 data[size]
       *    uint8 changed
       *
       * @param  {MKSVchan.Clipboard} clipboard
       *    The clipboard data to upload
       * @param  {Function} onDone
       *    Called when the send clipboard rpc has completed.
       * @param  {Function} onAbort
       *    Called if the send clipboard rpc has aborted.
       * @return {Boolean} success
       *    Returns true on success, false on failure
       */
      this.sendClipboard = function (clipboard, onDone, onAbort) {
         var packet = _WMKS2.default.Packet.createNewPacketLE(),
             data = void 0,
             i = void 0;

         packet.writeUint32(MKSVchan.CP_FORMAT.MAX);

         if (!(clipboard instanceof MKSVchan.Clipboard)) {
            _jscdkLogger2.default.error('MKSVchan.sendClipboard expects a MKSVchan.Clipboard object');
            return false;
         }

         if (clipboard.getTotalSize() > MKSVchan.MAX_BYTES_IMAGE_AND_RTF) {
            _jscdkLogger2.default.error('MKSVchan.sendClipboard clipboard exceeds maximum size. ' + 'Clipboard data must only be modified using the clipboard.setItem method');
            return false;
         }

         for (i = MKSVchan.CP_FORMAT.MIN; i < MKSVchan.CP_FORMAT.MAX; ++i) {
            data = clipboard.getItem(i);

            if (!!data) {
               _jscdkLogger2.default.debug('Sending clipboard data format: ' + i + ', length: ' + data.byteLength);
               packet.writeUint8(1);
               packet.writeUint32(data.byteLength);
               packet.writeArray(data);
            } else {
               packet.writeUint8(0);
               packet.writeUint32(0);
            }
         }

         packet.writeUint8(clipboard.getChanged());
         return sendRPC(MKSVchan.PACKET_TYPE.CLIPBOARD_DATA_CP, packet, onDone, onAbort);
      };

      this.sendStopUploadRequest = function (fileName, onDone, onAbort) {
         fileName = this.FTUtil.tryNormalizeUnicodeForMac(fileName);

         // Default request all the files from server
         var packet = _WMKS2.default.Packet.createNewPacketLE(),
             uint8FileName = _stringUtils2.default.stringToUint8Array(fileName, true);
         packet.writeUint16(MKSVchan.FILE_TRANSFER_REQUEST.CANCEL_RECEIVE_SPECIFIC_FILE);
         packet.writeUint16(uint8FileName.length);
         packet.writeArray(uint8FileName);

         return sendRPC(MKSVchan.PACKET_TYPE.FILE_TRANSFER_REQUEST, packet, onDone, onAbort);
      };

      this.sendStopDownloadRequest = function (fileIdentifier, onDone, onAbort) {
         // Default request all the files from server
         var packet = _WMKS2.default.Packet.createNewPacketLE(),
             uint8Id = _stringUtils2.default.stringToUint8Array(fileIdentifier, true);
         packet.writeUint16(MKSVchan.FILE_TRANSFER_REQUEST.CANCEL_SEND_SPECIFIC_FILES);
         packet.writeUint16(uint8Id.length);
         packet.writeArray(uint8Id);

         return sendRPC(MKSVchan.PACKET_TYPE.FILE_TRANSFER_REQUEST, packet, onDone, onAbort);
      };

      /**
       * Utility wrapper around vdpChannel invoke for sending RPCs.
       *
       * @param {PACKET_TYPE} command
       *    The command to invoke over rpc.
       * @param {WMKS.Packet} [packet]
       *    The packet of data to send with the command.
       * @param {Function} [onDone]
       *    Called when the rpc has completed.
       * @param {Function} [onAbort]
       *    Called if the rpc has aborted.
       * @return {Boolean} success
       *    Returns true on success, false on failure
       */
      sendRPC = function sendRPC(command, packet, onDone, onAbort) {
         if (!vdpChannel) {
            _jscdkLogger2.default.error('RPC send failed: vdpChannel not initialized');
            onAbort();
            return;
         }
         return !!vdpChannel.invoke({
            object: vdpControlObject,
            command: command,
            type: _vdpservice2.default.RPC_TYPE.REQUEST,
            params: packet ? [packet.getData()] : [],
            onDone: onDone,
            onAbort: onAbort
         });
      };

      /**
       * Send the capabilities of the client clipboard.
       *
       * @param {Number} capabilities
       *    The capabilities supported by the client clipboard.
       * @param {Function} onDone
       *    Called when the clipboard capabilities rpc has completed.
       * @param {Function} onAbort
       *    Called if the clipboard capabilities rpc has aborted.
       * @return {Boolean} success
       *    Returns true on success, false on failure
       */
      sendClipboardCapabilities = function sendClipboardCapabilities(caps, onDone, onAbort) {
         var packet = _WMKS2.default.Packet.createNewPacketLE();
         packet.writeUint32(caps);
         return sendRPC(MKSVchan.PACKET_TYPE.CLIPBOARD_CAPABILITIES, packet, onDone, onAbort);
      };

      /**
       * Sends the locale of the client clipboard.
       *
       * @param {Number} locale
       *    The locale of client clipboard.
       * @param {Function} onDone
       *    Called when the clipboard locale rpc has completed.
       * @param {Function} onAbort
       *    Called if the clipboard locale rpc has aborted.
       * @return {Boolean} success
       *    Returns true on success, false on failure
       */
      sendClipboardLocale = function sendClipboardLocale(locale, onDone, onAbort) {
         var packet = _WMKS2.default.Packet.createNewPacketLE();
         packet.writeUint32(locale);
         return sendRPC(MKSVchan.PACKET_TYPE.CLIPBOARD_LOCALE, packet, onDone, onAbort);
      };

      /**
       * Send final file transfer config to MKSVchan server.
       */
      sendFileTransferConfig = function sendFileTransferConfig(clientVersion, clientType, chunkSize) {
         clientType = clientType << 4;

         var packet = _WMKS2.default.Packet.createNewPacketLE();
         packet.writeUint8(clientVersion);
         packet.writeUint8(clientType);
         packet.writeUint16(chunkSize);
         return sendRPC(MKSVchan.PACKET_TYPE.FILE_TRANSFER_CONFIG, packet, function () {
            _jscdkLogger2.default.debug('File transfer caps sent successfully');
         }, function () {
            _jscdkLogger2.default.debug('File transfer caps cannot be sent.');
         });
      };

      /**
       * Handle the remote clipboard capabilities.
       *
       * As a client, we must reply with our capabilities and locale.
       *
       * @param {Object} rpc
       *    The incoming RPC object.
       */
      handleClipboardCapabilities = function handleClipboardCapabilities(rpc) {
         var packet = _WMKS2.default.Packet.createFromBufferLE(rpc.params[0]),
             caps = packet.readUint32(),
             version = caps & 0xffff,
             size = caps >> 16,
             notifyOnChangeEnabled = false,
             capabilities = null;

         // Negotiate minimum common version and size
         version = Math.min(version, self.capabilities.version);

         if (version >= MKSVchan.CAPABILITY_CLIPBOARD.IMAGE_AND_RTF) {
            size = Math.min(size, self.capabilities.size);
         } else {
            size = 0;
         }

         if (version >= MKSVchan.CAPABILITY_CLIPBOARD.NOTIFY_ON_CHANGE) {
            notifyOnChangeEnabled = true;
         } else {
            _jscdkLogger2.default.debug('mksVchan version does not support clipboard auto notifications, copying will be broken');
         }

         self.capabilities.version = version;
         self.capabilities.notifyOnChangeEnabled = notifyOnChangeEnabled;
         self.capabilities.size = size;

         capabilities = version | size << 16;
         if (notifyOnChangeEnabled) {
            capabilities = capabilities | MKSVchan.ENABLE_NOTIFY_ON_CHANGE;
         }

         // Reply with our capabilities and locale
         sendClipboardCapabilities(capabilities);
         sendClipboardLocale(self.locale);
      };

      /**
       * Handle the remote clipboard text data.
       *
       * @param {Object} rpc
       *    The incoming RPC object.
       */
      handleClipboardDataText = function handleClipboardDataText(rpc) {
         self.clipboard.setItem(MKSVchan.CP_FORMAT.TEXT, rpc.params[0]);

         if (self.onClipboardChanged) {
            self.onClipboardChanged(self.clipboard);
         }
      };

      /**
       * Handle the remote clipboard binary data.
       *
       * @param {Object} rpc
       *    The incoming RPC object.
       */
      handleClipboardDataCP = function handleClipboardDataCP(rpc) {
         var packet = null,
             error = MKSVchan.CLIPBOARD_ERROR.NONE,
             formats = null,
             exists = void 0,
             size = void 0,
             data = void 0,
             i = void 0;

         // If first parameter is a number, it is an error code.
         if (typeof rpc.params[0] === 'number') {
            error = rpc.params[0];
         } else {
            if (rpc.params[1]) {
               error = rpc.params[1];
            }
            packet = _WMKS2.default.Packet.createFromBufferLE(rpc.params[0]);
            formats = packet.readUint32();

            // Limit to our known formats
            formats = Math.max(formats, MKSVchan.CP_FORMAT.MAX);

            // Read clipboard data for all format types
            for (i = MKSVchan.CP_FORMAT.MIN; i < formats; ++i) {
               exists = packet.readUint8();
               size = packet.readUint32();
               data = packet.readArray(size);
               self.clipboard.setItem(i, data);
            }

            // If we have only 1 byte left, it's the changed flag
            if (packet.bytesRemaining() === 1) {
               self.clipboard.setChanged(packet.readUint8());
            } else {
               self.clipboard.setChanged(true);
            }
         }

         var fileListStr = self.clipboard.getText(MKSVchan.CP_FORMAT.FILELIST),
             fileList = self.FTUtil.parseDownloadListString(fileListStr);

         if (!!fileList && fileList.length > 0 && self.onDownloadFilesChange) {
            // Update download list
            self.onDownloadFilesChange(fileList, error);
         }

         if (self.onClipboardChanged) {
            self.onClipboardChanged(self.clipboard, error);
         }
      };

      /**
       * Handle the file chunk data.
       *
       * @param {Object} rpc
       *    The incoming RPC object.
       */
      handleFileTransferData = function handleFileTransferData(rpc) {
         var packet = null,
             error = MKSVchan.CLIPBOARD_ERROR.NONE,
             chunkNum = null,
             totalChunkNum = null,
             chunkDataSize = null,
             chunkIdentifierSize = null,
             fileSize = null,
             chunkIdentifierData = null,
             chunkIdentifier = void 0,
             chunkData = void 0,
             downloadService = null,
             services = [];

         // If first parameter is a number, it is an error code.
         if (typeof rpc.params[0] === 'number') {
            error = rpc.params[0];
         } else {
            if (rpc.params[1]) {
               error = rpc.params[1];
            }
            packet = _WMKS2.default.Packet.createFromBufferLE(rpc.params[0]);

            chunkNum = packet.readUint16();
            totalChunkNum = packet.readUint16();
            chunkDataSize = packet.readUint16();
            chunkIdentifierSize = packet.readUint16();
            fileSize = packet.readUint32();

            chunkIdentifierData = packet.readArray(chunkIdentifierSize);
            chunkIdentifier = _stringUtils2.default.uint8ArrayToString(chunkIdentifierData);
            chunkData = packet.readArray(chunkDataSize);

            if (!!self.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.FT]) {
               services.push(self.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.FT]);
            }
            if (!!self.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.PRINT]) {
               services.push(self.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.PRINT]);
            }

            downloadService = self.FTUtil.downloadServiceSwitcher(services, chunkNum, chunkIdentifier);
            /**
             * If cannot find download service, choose a default one by the
             * order:
             * 1. File transfer
             * 2. Print
             */
            if (!downloadService) {
               downloadService = self.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.FT] || self.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.PRINT];
            }

            // If still cannot find, throw error
            if (!downloadService) {
               throw 'Cannot find download service!';
            }

            downloadService.reassembleChunks(chunkNum, totalChunkNum, chunkIdentifier, chunkData, fileSize, error);
         }
      };

      /**
       * Handle the file transfer request.
       *
       * @param {Object} rpc
       *    The incoming RPC object.
       */
      handleFileTransferRequest = function handleFileTransferRequest(rpc) {
         var packet = null,
             error = MKSVchan.CLIPBOARD_ERROR.NONE,
             requestType = null;

         // If first parameter is a number, it is an error code.
         if (typeof rpc.params[0] === 'number') {
            error = rpc.params[0];
         } else {
            if (rpc.params[1]) {
               error = rpc.params[1];
            }
            packet = _WMKS2.default.Packet.createFromBufferLE(rpc.params[0]);
            requestType = packet.readUint16();
            switch (requestType) {
               case MKSVchan.FILE_TRANSFER_REQUEST.SEND_FILES:
               case MKSVchan.FILE_TRANSFER_REQUEST.CANCEL_SEND_FILES:
               case MKSVchan.FILE_TRANSFER_REQUEST.SEND_SPECIFIC_FILES:
               case MKSVchan.FILE_TRANSFER_REQUEST.CANCEL_SEND_SPECIFIC_FILES:
               case MKSVchan.FILE_TRANSFER_REQUEST.CANCEL_RECEIVE_SPECIFIC_FILE:
                  _jscdkLogger2.default.debug('Not support the requests yet.');
                  break;
               case MKSVchan.FILE_TRANSFER_REQUEST.FILE_LIST:
                  {
                     var consumer = packet.readUint8(),
                         fileListLength = null,
                         fileListData = null,
                         fileListStr = null,
                         fileList = null;

                     if (consumer > MKSVchan.FILE_TRANSFER_CONSUMER.MAX || consumer < MKSVchan.FILE_TRANSFER_CONSUMER.MIN) {
                        _jscdkLogger2.default.debug('Invalid consumer type.');
                        return;
                     }

                     // We don't need the last null terminate.
                     fileListLength = packet.readUint32() - 1;
                     fileListData = packet.readArray(fileListLength);
                     fileListStr = _stringUtils2.default.uint8ArrayToString(fileListData);
                     fileList = self.FTUtil.parseDownloadListString(fileListStr);

                     if (!fileList || fileList.length < 1) {
                        _jscdkLogger2.default.error('Cannot find download files from server msg');
                        return;
                     }

                     switch (consumer) {
                        case MKSVchan.FILE_TRANSFER_CONSUMER.FT:
                           {
                              // Treat it as normal file transfer case
                              if (!!self.onDownloadFilesChange) {
                                 // Update download list
                                 self.onDownloadFilesChange(fileList, error);
                              }
                              break;
                           }
                        case MKSVchan.FILE_TRANSFER_CONSUMER.PRINT:
                           {
                              // Send the data to print service
                              if (!!self.onPrintDownloadFilesChange) {
                                 // Update download list
                                 self.onPrintDownloadFilesChange(fileList, error);
                              }
                              break;
                           }
                        default:
                           _jscdkLogger2.default.error('Unsupported file transfer consumer');
                     }
                     break;
                  }
               case MKSVchan.FILE_TRANSFER_REQUEST.PRINT_CONFIG:
                  {
                     var version = packet.readUint8();
                     _jscdkLogger2.default.debug('Print version is: ' + version);
                     // If no print config received, it is not enabled on agent.
                     self.FTUtil.config.printDownloadEnabled = true;
                     break;
                  }
               default:
                  _jscdkLogger2.default.debug('Illegal request found.');
            }
         }
      };

      /**
       * Handle the file transfer config change.
       *
       * @param {Object} rpc
       *    The incoming RPC object.
       */
      handleFileTransferConfig = function handleFileTransferConfig(rpc) {
         var packet = null,
             error = MKSVchan.CLIPBOARD_ERROR.NONE,
             serverVersion = null,
             policy = null,
             chunkSize = null,
             clientVersionSentToServer = self.FTUtil.config.clientVersion;

         // If first parameter is a number, it is an error code.
         if (typeof rpc.params[0] === 'number') {
            error = rpc.params[0];
         } else {
            if (rpc.params[1]) {
               error = rpc.params[1];
            }
            packet = _WMKS2.default.Packet.createFromBufferLE(rpc.params[0]);
            serverVersion = packet.readUint8();
            policy = packet.readUint8();
            chunkSize = packet.readUint16();

            _jscdkLogger2.default.debug('File transfer version from server: ' + serverVersion);
            _jscdkLogger2.default.debug('File transfer policy from server: ' + policy);
            _jscdkLogger2.default.debug('File transfer chunk size from server: ' + chunkSize);

            self.FTUtil.updateConfig(serverVersion, policy, chunkSize);
            if (serverVersion < self.FTUtil.config.clientVersion) {
               // Adjust client version to server's for backward compatibility
               clientVersionSentToServer = serverVersion;
            }
            sendFileTransferConfig(clientVersionSentToServer, MKSVchan.FILE_TRANSFER_CLIENT.WEB, chunkSize);
         }

         if (self.onFileTransferConfigChange) {
            self.onFileTransferConfigChange(error);
         }
      };

      /**
       * Handle the file transfer error from server.
       *
       * @param {Object} rpc
       *    The incoming RPC object.
       */
      handleFileTransferError = function handleFileTransferError(rpc) {
         var packet = null,
             error = MKSVchan.CLIPBOARD_ERROR.NONE,
             ftError = null;

         // If first parameter is a number, it is an error code.
         if (typeof rpc.params[0] === 'number') {
            error = rpc.params[0];
         } else {
            if (rpc.params[1]) {
               error = rpc.params[1];
            }
            packet = _WMKS2.default.Packet.createFromBufferLE(rpc.params[0]);
            ftError = packet.readUint8();

            _jscdkLogger2.default.debug('File transfer error from server: ' + ftError);
         }

         switch (ftError) {
            case MKSVchan.FILE_TRANSFER_ERROR.NO_ENOUGH_DISK:
            case MKSVchan.FILE_TRANSFER_ERROR.IS_TRANSFERRING:
            case MKSVchan.FILE_TRANSFER_ERROR.UNKNOWN_ERROR:
               {
                  if (self.onFileTransferError) {
                     self.onFileTransferError(ftError);
                  }
                  break;
               }
            case MKSVchan.FILE_TRANSFER_ERROR.PRINT_TIMEOUT:
               {
                  if (self.onPrintError) {
                     self.onPrintError(ftError);
                  }
                  break;
               }
            default:
               _jscdkLogger2.default.error('Unknown error number: ' + ftError);
         }
      };

      /**
       * Handle incoming RPCs and redirect them based on command.
       *
       * @param {Object} rpc
       *    The incoming RPC object.
       */
      handleRPCFromServer = function handleRPCFromServer(rpc) {
         switch (rpc.command) {
            case MKSVchan.PACKET_TYPE.CLIPBOARD_DATA_TEXT:
               handleClipboardDataText(rpc);
               break;
            case MKSVchan.PACKET_TYPE.CLIPBOARD_DATA_CP:
               handleClipboardDataCP(rpc);
               break;
            case MKSVchan.PACKET_TYPE.CLIPBOARD_CAPABILITIES:
               handleClipboardCapabilities(rpc);
               break;
            case MKSVchan.PACKET_TYPE.FILE_TRANSFER_DATA_FILE:
               handleFileTransferData(rpc);
               break;
            case MKSVchan.PACKET_TYPE.FILE_TRANSFER_REQUEST:
               handleFileTransferRequest(rpc);
               break;
            case MKSVchan.PACKET_TYPE.FILE_TRANSFER_CONFIG:
               handleFileTransferConfig(rpc);
               break;
            case MKSVchan.PACKET_TYPE.FILE_TRANSFER_ERROR:
               handleFileTransferError(rpc);
               break;
            default:
               _jscdkLogger2.default.error('MKSVchan received unexpected command: ' + rpc.command);
         }
      };
   }
};

exports.default = MKSVchan;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SetUserGlobalPrefHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SetUserGlobalPrefHandler() {
   // member variables
   this.messageName = "set-user-global-preferences";
   this.messageText = "set-user-global-preferences";

   this.responseTag = "set-user-global-preferences";

   this.subHandlerList = [];
   this.composedHandlerList = [];
   this.favoriteIds = [];
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * setUserGlobalPrefCommand.js --
 *    Implementation of the message handler to set user global setting.
 */

SetUserGlobalPrefHandler.prototype = new _messageHandler.MessageHandler();
SetUserGlobalPrefHandler.constructor = SetUserGlobalPrefHandler;

/**
 * Reset handler's state and content.
 *
 */
SetUserGlobalPrefHandler.prototype.resetData = function () {
   _messageHandler.MessageHandler.prototype.resetData.apply(this);
};

/**
 * Set the request XML for global preferece.
 *
 * @param pref [in] preference json object
 */
SetUserGlobalPrefHandler.prototype.setRequestXML = function (pref) {
   var key = void 0,
       prefElements = "";

   for (key in pref) {
      if (pref.hasOwnProperty(key)) {
         prefElements += _util2.default.createElement('preference', pref[key], {
            name: key
         });
      }
   }

   this.requestXML = _util2.default.createElement('user-preferences', prefElements);
};

/**
 * parse user global preference information from the response XML
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
SetUserGlobalPrefHandler.prototype.parseResult = function (responseXML) {
   var responseBody = responseXML,
       brokerTag = _util2.default.getChildNode(responseBody, "broker", 0),
       result = void 0,
       errorCodeNode = void 0,
       errorMessageNode = void 0,
       resultElem = void 0,
       favoriteItems = {},
       prefNodes = void 0,
       resp = {},
       i = void 0,
       pref = {},
       value = "",
       len = void 0,
       name = void 0,
       key = void 0;

   if (!brokerTag) {
      _jscdkLogger2.default.error("response of SetUserGlobalPref error.");
      return null;
   }

   resultElem = _util2.default.getChildNode(brokerTag, this.responseTag, 0);
   resultElem = _util2.default.getChildNode(resultElem, 'result', 0);
   if (!resultElem || !resultElem.hasChildNodes()) {
      return null;
   }
   result = resultElem.childNodes[0].nodeValue;
   resp["result"] = result;
   if (result === "error") {
      errorCodeNode = _util2.default.getChildNode(responseBody, "error-code", 0);
      if (!!errorCodeNode) {
         resp["error-code"] = (0, _jquery2.default)(errorCodeNode).text();
      }
      errorMessageNode = _util2.default.getChildNode(responseBody, "error-message", 0);
      if (!!errorMessageNode) {
         resp["error-message"] = (0, _jquery2.default)(errorMessageNode).text();
      }
   }
   return resp;
};

SetUserGlobalPrefHandler.prototype.onUpdated = function () {
   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify({
      ignoreData: true,
      name: 'SetUserGlobalPref'
   }));
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

/**
 * getLaunchItems.js --
 *
 *      Implementation of the message handler to get launchItems.
 */

exports.default = GetLaunchItemsHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _doLogoutHandler = __webpack_require__(39);

var _doLogoutHandler2 = _interopRequireDefault(_doLogoutHandler);

var _killSessionHandler = __webpack_require__(24);

var _killSessionHandler2 = _interopRequireDefault(_killSessionHandler);

var _resetDesktopHandler = __webpack_require__(41);

var _resetDesktopHandler2 = _interopRequireDefault(_resetDesktopHandler);

var _restartDesktopHandler = __webpack_require__(53);

var _restartDesktopHandler2 = _interopRequireDefault(_restartDesktopHandler);

var _getUserGlobalPrefHandler = __webpack_require__(51);

var _getUserGlobalPrefHandler2 = _interopRequireDefault(_getUserGlobalPrefHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GetLaunchItemsHandler(skipTunnelAndPref, skipTimer) {
   var router = void 0,
       getTunnelConnObject = void 0,
       getUserGlobalPref = void 0;

   // member variables
   this.messageName = "get-launch-items";
   this.messageText = "get-launch-items";
   this.responseTag = "launch-items";

   // whether to notify UI on get-launchItems response.
   this.notifyUI = true;
   this.skipTimer = skipTimer || false;

   this.subHandlerList = [];
   this.observerList = [];

   if (!skipTunnelAndPref) {
      if (!_jscdkClient.globalArray["get-user-global-preferences"]) {
         getUserGlobalPref = new _getUserGlobalPrefHandler2.default();
         _jscdkClient.globalArray["get-user-global-preferences"] = getUserGlobalPref;
      } else {
         getUserGlobalPref = _jscdkClient.globalArray["get-user-global-preferences"];
      }
      getUserGlobalPref.registerHandler(this, "state");

      this.composedHandlerList = [this, getUserGlobalPref];

      // register dependencies here
      getTunnelConnObject = _util2.default.getObject(_jscdkClient.globalArray, "get-tunnel-connection");
      if (!!getTunnelConnObject) {
         this.registerHandler(getTunnelConnObject, "state");
      } else {
         _jscdkLogger2.default.error("The get-tunnel-connection object is null!");
      }
   } else {
      this.composedHandlerList = [];
   }
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

GetLaunchItemsHandler.prototype = new _messageHandler.MessageHandler(); // inherits
// MessageHandler
// prototype
GetLaunchItemsHandler.constructor = GetLaunchItemsHandler;

/**
 * Reset handler's state and content.
 *
 */
GetLaunchItemsHandler.prototype.resetData = function () {
   _messageHandler.MessageHandler.prototype.resetData.apply(this);

   this.notifyUI = true;
};

/**
 * Set the request XML for getLaunchItems.
 *
 * @param supportedDesktopProtocols [in] array for supported protocols.
 * @param supportedAppTypes [in] array of supported app types.  Each app type
 *    is an object with .name and optionally .protocols.
 * @param notifyUI [in] whether to notify the UI on XML-API response.
 */
GetLaunchItemsHandler.prototype.setRequestXML = function (supportedDesktopProtocols, supportedAppTypes, notifyUI) {
   var nameElement = void 0,
       protocolElement = void 0,
       sessionElement = void 0,
       protocolsElement = "",
       desktopsElement = "",
       typeElement = void 0,
       typeNameElement = void 0,
       typesElement = "",
       applicationElement = "",
       shadowSessionElement = "",
       launchItemsElement = "",
       protocols = "",
       launchItems = "",
       type = "",
       types = "",
       i = void 0,
       l = void 0,
       urlHandler = null;

   for (i = 0; i < supportedDesktopProtocols.length; i++) {
      nameElement = _util2.default.createElement("name", supportedDesktopProtocols[i]);
      protocolElement = _util2.default.createElement("protocol", nameElement);
      protocols += protocolElement;
   }
   protocolsElement = _util2.default.createElement("supported-protocols", protocols);
   desktopsElement = _util2.default.createElement("desktops", protocolsElement);
   launchItemsElement += desktopsElement;

   for (i = 0; i < supportedAppTypes.length; i++) {
      protocols = "";
      typeNameElement = _util2.default.createElement("name", supportedAppTypes[i]["name"]);
      for (l = 0; l < supportedAppTypes[i].protocols.length; l++) {
         nameElement = _util2.default.createElement("name", supportedAppTypes[i].protocols[l]);
         protocolElement = _util2.default.createElement("protocol", nameElement);
         protocols += protocolElement;
      }
      protocolsElement = _util2.default.createElement("supported-protocols", protocols);
      type = typeNameElement + protocolsElement;
      typeElement = _util2.default.createElement("type", type);
      types += typeElement;
   }
   typesElement = _util2.default.createElement("supported-types", types);
   applicationElement = _util2.default.createElement("applications", typesElement);
   launchItemsElement += applicationElement;

   urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");
   if (!!urlHandler && urlHandler.params.allowCollaboration === "1") {
      // Todo: add requested session id from URI to support CPA.
      for (i = 0; i < supportedDesktopProtocols.length; i++) {
         nameElement = _util2.default.createElement("name", supportedDesktopProtocols[i]);
         protocolElement = _util2.default.createElement("protocol", nameElement);
         protocols += protocolElement;
      }
      protocolsElement = _util2.default.createElement("supported-protocols", protocols);
      shadowSessionElement = _util2.default.createElement("shadow-sessions", protocolsElement);
      launchItemsElement += shadowSessionElement;
   }

   sessionElement = _util2.default.createElement("application-sessions");
   launchItemsElement += sessionElement;

   /**
    * Generate the <environment-info> section if it was specified to support:
    * https://jira-hzn.eng.vmware.com/browse/DPM-1211
    */
   var environmentInfo = _jscdkClient.globalArray['environment-information'];
   if ((typeof environmentInfo === 'undefined' ? 'undefined' : _typeof(environmentInfo)) === "object") {
      var infoElements = "";
      for (var key in environmentInfo) {
         if (environmentInfo.hasOwnProperty(key)) {
            infoElements += _util2.default.createElement("info", environmentInfo[key], { "name": key });
         }
      }
      var environmentElement = _util2.default.createElement("environment-information", infoElements);
      launchItemsElement += environmentElement;
   }

   this.requestXML = launchItemsElement;

   if (typeof notifyUI === 'boolean') {
      // Whether to notify UI on get-launchItems response.
      this.notifyUI = notifyUI;
   } else {
      // Always notify UI on get-launchItems response.
      this.notifyUI = true;
   }
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
GetLaunchItemsHandler.prototype.onUpdated = function () {
   var getLaunchItemsAction = {},
       actionContent = {},
       router = void 0,
       urlHandler = void 0,
       urlParams = void 0,
       idleTimerObject = void 0,
       idleTimeout = void 0,
       userActivityXMLSendingInterval = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (this.notifyUI) {
         // Compose refresh UI request.
         getLaunchItemsAction.name = "GetLaunchItems";
         if (!!_jscdkClient.globalArray) {
            router = _jscdkClient.globalArray["router"];
            if (!!router) {
               actionContent.brokerUrl = router.brokerUrl;
            }
         }
         if (!!this.content["parsedResult"]) {
            actionContent.desktops = this.content.parsedResult.desktops;
            actionContent.applications = this.content.parsedResult.applications;
            actionContent.applicationSessions = this.content.parsedResult["application-sessions"];
            actionContent.shadowSessions = this.content.parsedResult["shadow-sessions"];
         }
         // Handle the desktopId passed through URI.
         urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");
         if (!!urlHandler) {
            urlParams = urlHandler.params;
            if (!!urlParams.desktopId) {
               actionContent.desktopId = urlParams.desktopId;
               actionContent.action = urlParams.action;
               if (!!urlParams.desktopProtocol) {
                  actionContent.targetProtocol = urlParams.desktopProtocol.toUpperCase();
               }
            }
         }
         if (_util2.default.brokerSupportApplication() && !this.skipTimer) {
            //launch idle timer
            idleTimerObject = _jscdkClient.globalArray["idle-timeout-timer"];
            if (!idleTimerObject) {
               _jscdkLogger2.default.error("timer don't exist when displaying apps & desktops");
               return;
            }
            idleTimeout = idleTimerObject.getIdleTimeoutValue();
            userActivityXMLSendingInterval = idleTimerObject.getSendIntervalValue();
         } else {
            // for older broker, just set value to -1;
            idleTimeout = -1;
            userActivityXMLSendingInterval = -1;
         }
         getLaunchItemsAction.timerInfo = {
            "idleTimeout": idleTimeout,
            "userActivityXMLSendingInterval": userActivityXMLSendingInterval
         };

         getLaunchItemsAction.content = actionContent;
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(getLaunchItemsAction));
      }
   }
   // if the error is special for this handler, alert
   _router2.default.prototype.pushErrorToUser(this);
};

/**
 * parse launchItems information from the response XML
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
GetLaunchItemsHandler.prototype.parseResult = function (responseXML) {
   var responseBody = responseXML;
   var launchItemsResponse = {};
   var result = void 0;
   var resultElem = void 0;
   var desktops = {};
   var desktopsNodes = void 0;
   var desktopsLength = void 0;
   var applications = {};
   var applicationsNodes = void 0;
   var applicationsLength = void 0;
   var sessions = {};
   var applicationSessionsNodes = void 0;
   var applicationSessionsLength = void 0;
   var shadowSessions = {};
   var shadowSessionsNodes = void 0;
   var shadowSessionsLength = void 0;
   var errorCodeNode = void 0;
   var errorMessageNode = void 0;
   var desktop = void 0;
   var application = void 0;
   var session = void 0;
   var i = void 0;
   var len = void 0;
   var brokerTag = _util2.default.getChildNode(responseBody, "broker", 0);

   // Make sure brokerVersion will be set even without getAuthencationStatus
   _jscdkClient.globalArray["brokerVersion"] = (0, _jquery2.default)(brokerTag).attr("version");

   if (!brokerTag) {
      _jscdkLogger2.default.error("response of GetLaunchItems error.");
      return null;
   }
   resultElem = _util2.default.getChildNode(brokerTag, this.responseTag, 0);
   resultElem = _util2.default.getChildNode(resultElem, 'result', 0);
   if (!resultElem || !resultElem.hasChildNodes()) {
      return null;
   }
   result = resultElem.childNodes[0].nodeValue;
   launchItemsResponse["result"] = result;
   if (result === "ok") {
      desktopsNodes = brokerTag.getElementsByTagName("desktop");
      desktopsLength = desktopsNodes.length;
      for (i = 0; i < desktopsLength; i++) {
         var aDesktopInstance = {};

         // set desktop name
         this.setLaunchItemName(aDesktopInstance, desktopsNodes[i]);

         // set desktop id
         this.setLaunchItemId(aDesktopInstance, desktopsNodes[i]);

         // set response state
         this.setResponseState(aDesktopInstance, desktopsNodes[i]);

         // set sessionId
         this.setSessionId(aDesktopInstance, desktopsNodes[i]);

         // set inMaintenanceMode
         this.setInMaintenanceMode(aDesktopInstance, desktopsNodes[i]);

         // set protocol match
         this.setProtocolMatch(aDesktopInstance, desktopsNodes[i]);

         // set preferred protocol, defaultProtocol and supportedProtocol
         this.setProtocols(aDesktopInstance, desktopsNodes[i]);

         // set desktop user preferences
         this.setDesktopUserPrefs(aDesktopInstance, desktopsNodes[i]);

         // set canLogoff: whether the desktop can logoff
         this.setCanLogoff(aDesktopInstance, desktopsNodes[i]);

         // set resetAllowed
         this.setResetAllowed(aDesktopInstance, desktopsNodes[i]);

         // set resetAllowedOnSession
         this.setResetAllowedOnSession(aDesktopInstance, desktopsNodes[i]);

         // set canRollback: whether the desktop can rollback
         this.setCanRollback(aDesktopInstance, desktopsNodes[i]);

         if (this.isDisabledItem(desktopsNodes[i])) {
            _jscdkLogger2.default.debug("DesktopInstance disabled: " + JSON.stringify(aDesktopInstance));
         } else {
            _util2.default.addItemForJson(desktops, i, aDesktopInstance);
            _jscdkLogger2.default.debug("aDesktopInstance: " + JSON.stringify(aDesktopInstance));
         }
      }
      // XXX TODO: more desktop properties to handle
      _jscdkLogger2.default.debug("desktops: " + JSON.stringify(desktops));
      _util2.default.addItemForJson(launchItemsResponse, "desktops", desktops);

      applicationsNodes = brokerTag.getElementsByTagName("application");
      applicationsLength = applicationsNodes.length;
      for (i = 0; i < applicationsLength; i++) {
         var aApplicationInstance = {};

         // set desktop name
         this.setLaunchItemName(aApplicationInstance, applicationsNodes[i]);

         // set application id
         this.setLaunchItemId(aApplicationInstance, applicationsNodes[i]);

         // set application type
         this.setApplicationType(aApplicationInstance, applicationsNodes[i]);

         // set application origin id
         this.setLaunchItemOriginId(aApplicationInstance, applicationsNodes[i]);

         // set application version
         this.setApplicationVersion(aApplicationInstance, applicationsNodes[i]);

         // set application publisher
         this.setApplicationPublisher(aApplicationInstance, applicationsNodes[i]);

         // set launch-path
         this.setApplicationLaunchPath(aApplicationInstance, applicationsNodes[i]);

         // set protocol match
         this.setProtocolMatch(aApplicationInstance, applicationsNodes[i]);

         // set preferred protocol, defaultProtocol and supportedProtocol
         this.setProtocols(aApplicationInstance, applicationsNodes[i]);

         // set application icons
         this.setApplicationIcons(aApplicationInstance, applicationsNodes[i]);

         if (this.isDisabledItem(applicationsNodes[i])) {
            _jscdkLogger2.default.debug("ApplicationInstance disabled: " + JSON.stringify(aApplicationInstance));
         } else {
            _util2.default.addItemForJson(applications, i, aApplicationInstance);
            _jscdkLogger2.default.debug("aApplicationInstance: " + JSON.stringify(aApplicationInstance));
         }
      }
      // XXX TODO: more application properties to handle
      _jscdkLogger2.default.debug("applications: " + JSON.stringify(applications));
      _util2.default.addItemForJson(launchItemsResponse, "applications", applications);

      applicationSessionsNodes = brokerTag.getElementsByTagName("application-session");
      applicationSessionsLength = applicationSessionsNodes.length;
      for (i = 0; i < applicationSessionsLength; i++) {
         var aApplicationSessionInstance = {};

         this.setLaunchItemId(aApplicationSessionInstance, applicationSessionsNodes[i]);

         // set application session origin id
         this.setLaunchItemOriginId(aApplicationSessionInstance, applicationSessionsNodes[i]);

         // set application session state
         this.setResponseState(aApplicationSessionInstance, applicationSessionsNodes[i]);

         // set application sessin asset info
         this.setApplicationSessionRemoteAssetsType(aApplicationSessionInstance, applicationSessionsNodes[i]);

         // set protocol match
         this.setProtocolMatch(aApplicationSessionInstance, applicationSessionsNodes[i]);

         // set preferred protocol, defaultProtocol and supportedProtocol
         this.setProtocols(aApplicationSessionInstance, applicationSessionsNodes[i]);

         if (this.isDisabledItem(applicationSessionsNodes[i])) {
            _jscdkLogger2.default.debug("ApplicationSessionInstance disabled: " + JSON.stringify(aApplicationSessionInstance));
         } else {
            _util2.default.addItemForJson(sessions, i, aApplicationSessionInstance);
            _jscdkLogger2.default.debug("aApplicationSessionInstance: " + JSON.stringify(aApplicationSessionInstance));
         }
      }
      // XXX TODO: more application properties to handle
      _jscdkLogger2.default.debug("application-sessions: " + JSON.stringify(sessions));
      _util2.default.addItemForJson(launchItemsResponse, "application-sessions", sessions);

      shadowSessionsNodes = brokerTag.getElementsByTagName("shadow-session");
      shadowSessionsLength = shadowSessionsNodes.length;
      for (i = 0; i < shadowSessionsLength; i++) {
         var aShadowSessionInstance = {};

         this.setLaunchItemId(aShadowSessionInstance, shadowSessionsNodes[i]);

         this.setLaunchItemName(aShadowSessionInstance, shadowSessionsNodes[i]);

         this.setProtocols(aShadowSessionInstance, shadowSessionsNodes[i]);

         this.setProtocolMatch(aShadowSessionInstance, shadowSessionsNodes[i]);

         this.setApplicationType(aShadowSessionInstance, shadowSessionsNodes[i]);

         _util2.default.addItemForJson(shadowSessions, i, aShadowSessionInstance);
      }

      _jscdkLogger2.default.debug("shadow-sessions: " + JSON.stringify(shadowSessions));
      _util2.default.addItemForJson(launchItemsResponse, "shadow-sessions", shadowSessions);
   } else if (result === "error") {
      errorCodeNode = _util2.default.getChildNode(responseBody, "error-code", 0);
      if (!!errorCodeNode) {
         _util2.default.addItemForJson(launchItemsResponse, "error-code", (0, _jquery2.default)(errorCodeNode).text());
      }
      errorMessageNode = _util2.default.getChildNode(responseBody, "error-message", 0);
      if (!!errorMessageNode) {
         _util2.default.addItemForJson(launchItemsResponse, "error-message", (0, _jquery2.default)(errorMessageNode).text());
      }
   }
   return launchItemsResponse;
};

/**
 * set protocol match or not
 *
 * @param aDesktopInstance[out] a launchItem instance to store corresponding
 *    info
 * @param launchItemNode[in] get information from this launchItem node
 */
GetLaunchItemsHandler.prototype.setProtocolMatch = function (aLaunchItemInstance, launchItemNode) {
   var matchNode = _util2.default.getChildNode(launchItemNode, 'protocol-match', 0),
       match = !!matchNode ? (0, _jquery2.default)(matchNode).text() : 'true';

   _util2.default.addItemForJson(aLaunchItemInstance, 'protocol-match', match);
};

/**
 * set preferredProtocol, defaultProtocol and supportedProtocol
 *
 * @param aLaunchItemInstance[out] a launchItem instance to store corresponding
 *    info
 * @param launchItemNode[in] get information from this launchItem node
 */
GetLaunchItemsHandler.prototype.setProtocols = function (aLaunchItemInstance, launchItemNode) {
   var userPreferencesNode = void 0;
   var preferenceNode = void 0;
   var j = void 0;
   var hasDefault = false;
   var protocolsNode = void 0;
   var protocolNode = void 0;
   var protocolName = void 0;
   var protocols = {};
   var preferenceNameAttr = void 0;
   var isDefaultNode = void 0;
   var supportPreferredProtocol = false;
   userPreferencesNode = _util2.default.getChildNode(launchItemNode, "user-preferences", 0);
   if (!!userPreferencesNode) {
      preferenceNode = userPreferencesNode.getElementsByTagName("preference");
   }
   if (!!preferenceNode) {
      for (j = 0; j < preferenceNode.length; j++) {
         preferenceNameAttr = preferenceNode[j].getAttribute("name");
         // set preferred protocol here
         if (preferenceNameAttr === "protocol") {
            _util2.default.addItemForJson(aLaunchItemInstance, "preferredProtocol", (0, _jquery2.default)(preferenceNode[j]).text());
         }
      }
   }
   protocolsNode = _util2.default.getChildNode(launchItemNode, "protocols", 0);
   if (!!protocolsNode) {
      protocolNode = protocolsNode.getElementsByTagName("protocol");
   }
   if (!!protocolNode) {
      for (j = 0; j < protocolNode.length; j++) {
         protocolName = (0, _jquery2.default)(_util2.default.getChildNode(protocolNode[j], "name", 0)).text();
         protocols[j] = protocolName;
         if (protocolName === aLaunchItemInstance["preferredProtocol"]) {
            supportPreferredProtocol = true;
         }
         isDefaultNode = _util2.default.getChildNode(protocolNode[j], "is-default", 0);
         if (!!isDefaultNode && (0, _jquery2.default)(isDefaultNode).text() === "true") {
            // set default protocol if "is-default" is not null
            hasDefault = true;
            _util2.default.addItemForJson(aLaunchItemInstance, "defaultProtocol", protocolName);
         }
      }
   }
   // if "is-default" is null, set first protocol as default protocol
   if (!hasDefault && !!protocolNode && protocolNode.length > 0) {
      aLaunchItemInstance["defaultProtocol"] = (0, _jquery2.default)(_util2.default.getChildNode(protocolNode[0], "name", 0)).text();
   }
   // if no preferred protocol in user preference, set default protocol as it
   if (!aLaunchItemInstance["preferredProtocol"] || !supportPreferredProtocol) {
      _util2.default.addItemForJson(aLaunchItemInstance, "preferredProtocol", aLaunchItemInstance["defaultProtocol"]);
   }
   // set supported protocols here
   _util2.default.addItemForJson(aLaunchItemInstance, "protocols", protocols);
};

/**
 * set desktop user preferences
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetLaunchItemsHandler.prototype.setDesktopUserPrefs = function (aDesktopInstance, desktopNode) {
   var preferenceNameAttr = void 0;
   var j = void 0;
   var userPreferencesNode = void 0;
   var preferenceNode = void 0;
   userPreferencesNode = _util2.default.getChildNode(desktopNode, "user-preferences", 0);
   if (!!userPreferencesNode) {
      preferenceNode = userPreferencesNode.getElementsByTagName("preference");
   }
   if (!!preferenceNode) {
      for (j = 0; j < preferenceNode.length; j++) {
         preferenceNameAttr = preferenceNode[j].getAttribute("name");
         if (preferenceNameAttr === "alwaysConnect") {
            // set alwaysConnect
            _util2.default.addItemForJson(aDesktopInstance, "alwaysConnect", (0, _jquery2.default)(preferenceNode[j]).text());
         }
         if (preferenceNameAttr === "screenSize") {
            // set screenSize
            _util2.default.addItemForJson(aDesktopInstance, "screenSize", (0, _jquery2.default)(preferenceNode[j]).text());
         }
      }
   }
};

/**
 * set launchItem id
 *
 * @param aDesktopInstance[out] a launchItem instance to store corresponding
 *    info
 * @param launchItemNode[in] get information from this launchItem node
 */
GetLaunchItemsHandler.prototype.setLaunchItemId = function (aLaunchItemInstance, launchItemNode) {
   var launchItemIdNode = _util2.default.getChildNode(launchItemNode, "id", 0),
       launchItemId = !!launchItemIdNode ? (0, _jquery2.default)(launchItemIdNode).text() : "";

   _util2.default.addItemForJson(aLaunchItemInstance, "id", launchItemId);
};

/**
 * set launchItem name
 *
 * @param aDesktopInstance[out] a launchItem instance to store corresponding
 *    info
 * @param launchItemNode[in] get information from this launchItem node
 */
GetLaunchItemsHandler.prototype.setLaunchItemName = function (aLaunchItemInstance, launchItemNode) {
   var launchItemNameNode = _util2.default.getChildNode(launchItemNode, "name", 0),
       launchItemName = !!launchItemNameNode ? (0, _jquery2.default)(launchItemNameNode).text() : "";

   _jscdkLogger2.default.debug("launchItemName: " + launchItemName);
   _util2.default.addItemForJson(aLaunchItemInstance, "name", launchItemName);
};

/**
 * is accessable item
 *
 * @param launchItemNode[in] get information from this launchItem node
 */
GetLaunchItemsHandler.prototype.isDisabledItem = function (launchItemNode) {
   var launchItemDisabledNode = _util2.default.getChildNode(launchItemNode, "html-access-disabled", 0);
   return !!launchItemDisabledNode;
};

/**
 * set canLogoff
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetLaunchItemsHandler.prototype.setCanLogoff = function (aDesktopInstance, desktopNode) {
   var inMaintenanceModeNode = _util2.default.getChildNode(desktopNode, "in-maintenance-mode", 0),
       inMaintenanceMode = !!inMaintenanceModeNode ? (0, _jquery2.default)(inMaintenanceModeNode).text() : "false",
       responseStateNode = _util2.default.getChildNode(desktopNode, "state", 0),
       responseState = !!responseStateNode ? (0, _jquery2.default)(responseStateNode).text() : "No Session",
       responseStateLower = responseState.toLowerCase();

   if (inMaintenanceMode === "true" || responseStateLower !== "connected" && responseStateLower !== "disconnected") {
      /*
       * Logoff of a desktop from the desktop selector is not possible if it is
       * in maintenance mode, if it is checked out by another machine, or if
       * the desktop state is something other than "connected" or "disconnected".
       */
      _util2.default.addItemForJson(aDesktopInstance, "canLogoff", "false");
   } else {
      _util2.default.addItemForJson(aDesktopInstance, "canLogoff", "true");
   }
};

/**
 * set reset-allowed
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetLaunchItemsHandler.prototype.setResetAllowed = function (aDesktopInstance, desktopNode) {
   var resetAllowedNode = _util2.default.getChildNode(desktopNode, "reset-allowed", 0),
       resetAllowed = !!resetAllowedNode ? (0, _jquery2.default)(resetAllowedNode).text() : "false";

   _util2.default.addItemForJson(aDesktopInstance, "reset-allowed", resetAllowed);
};

/**
 * set reset-allowed-on-session
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetLaunchItemsHandler.prototype.setResetAllowedOnSession = function (aDesktopInstance, desktopNode) {
   var resetAllowedOnSessionNode = _util2.default.getChildNode(desktopNode, "reset-allowed-on-session", 0),
       resetAllowedOnSession = !!resetAllowedOnSessionNode ? (0, _jquery2.default)(resetAllowedOnSessionNode).text() : "false";

   _util2.default.addItemForJson(aDesktopInstance, "reset-allowed-on-session", resetAllowedOnSession);
};

/**
 * set in-maintenance-mode
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetLaunchItemsHandler.prototype.setInMaintenanceMode = function (aDesktopInstance, desktopNode) {
   var inMaintenanceModeNode = _util2.default.getChildNode(desktopNode, "in-maintenance-mode", 0),
       inMaintenanceMode = !!inMaintenanceModeNode ? (0, _jquery2.default)(inMaintenanceModeNode).text() : "false";

   _util2.default.addItemForJson(aDesktopInstance, "in-maintenance-mode", inMaintenanceMode);
};

/**
 * set response state
 *
 * @param aDesktopInstance[out] a launchItem instance to store corresponding
 *    info
 * @param launchItemNode[in] get information from this launchItem node
 */
GetLaunchItemsHandler.prototype.setResponseState = function (aDesktopInstance, launchItemNode) {
   var responseStateNode = _util2.default.getChildNode(launchItemNode, "state", 0),
       responseState = !!responseStateNode ? (0, _jquery2.default)(responseStateNode).text() : "No Session";

   _util2.default.addItemForJson(aDesktopInstance, "state", responseState);
};

/**
 * set session-id
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetLaunchItemsHandler.prototype.setSessionId = function (aDesktopInstance, desktopNode) {
   var sessionIdNode = _util2.default.getChildNode(desktopNode, "session-id", 0),
       sessionId = !!sessionIdNode ? (0, _jquery2.default)(sessionIdNode).text() : "";

   _util2.default.addItemForJson(aDesktopInstance, "session-id", sessionId);
};

/**
 * set canRollback
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetLaunchItemsHandler.prototype.setCanRollback = function (aDesktopInstance, desktopNode) {
   var offlineStateNode = _util2.default.getChildNode(desktopNode, "offline-state", 0),
       offlineState = !!offlineStateNode ? (0, _jquery2.default)(offlineStateNode).text() : "";

   if (offlineState === "checked out") {
      _util2.default.addItemForJson(aDesktopInstance, "canRollback", "true");
   } else {
      _util2.default.addItemForJson(aDesktopInstance, "canRollback", "false");
   }
};

/**
 * set application type
 *
 * @param aApplicationInstance[out] a application instance to store
 *    corresponding info
 * @param applicationNode[in] get information from this application node
 */
GetLaunchItemsHandler.prototype.setApplicationType = function (aApplicationInstance, applicationNode) {
   var applicationTypeNode = _util2.default.getChildNode(applicationNode, "type", 0),
       applicationType = !!applicationTypeNode ? (0, _jquery2.default)(applicationTypeNode).text() : "";

   _util2.default.addItemForJson(aApplicationInstance, "type", applicationType);
};

/**
 * set application type
 *
 * @param aApplicationInstance[out] a application instance to store
 *    corresponding info
 * @param applicationNode[in] get information from this application node
 */
GetLaunchItemsHandler.prototype.setLaunchItemOriginId = function (aLaunchItemInstance, launchItemNode) {
   var launchItemOriginIdNode = _util2.default.getChildNode(launchItemNode, "origin-id", 0),
       launchItemOriginId = !!launchItemOriginIdNode ? (0, _jquery2.default)(launchItemOriginIdNode).text() : "";

   _util2.default.addItemForJson(aLaunchItemInstance, "origin-id", launchItemOriginId);
};

/**
 * set application type
 *
 * @param aApplicationInstance[out] a application instance to store
 *    corresponding info
 * @param applicationNode[in] get information from this application node
 */
GetLaunchItemsHandler.prototype.setApplicationVersion = function (aApplicationInstance, applicationNode) {
   var applicationVersionNode = _util2.default.getChildNode(applicationNode, "version", 0),
       applicationVersion = !!applicationVersionNode ? (0, _jquery2.default)(applicationVersionNode).text() : "";

   _util2.default.addItemForJson(aApplicationInstance, "version", applicationVersion);
};

/**
 * set application type
 *
 * @param aApplicationInstance[out] a application instance to store
 *    corresponding info
 * @param applicationNode[in] get information from this application node
 */
GetLaunchItemsHandler.prototype.setApplicationPublisher = function (aApplicationInstance, applicationNode) {
   var applicationPublisherNode = _util2.default.getChildNode(applicationNode, "publisher", 0),
       applicationPublisher = !!applicationPublisherNode ? (0, _jquery2.default)(applicationPublisherNode).text() : "";

   _util2.default.addItemForJson(aApplicationInstance, "publisher", applicationPublisher);
};

/**
 * set application type
 *
 * @param aApplicationInstance[out] a application instance to store
 *    corresponding info
 * @param applicationNode[in] get information from this application node
 */
GetLaunchItemsHandler.prototype.setApplicationLaunchPath = function (aApplicationInstance, applicationNode) {
   var applicationLaunchPathNode = _util2.default.getChildNode(applicationNode, "launch-path", 0),
       applicationLaunchPath = !!applicationLaunchPathNode ? (0, _jquery2.default)(applicationLaunchPathNode).text() : "";

   _util2.default.addItemForJson(aApplicationInstance, "launch-path", applicationLaunchPath);
};

/**
 * set application type
 *
 * @param aApplicationInstance[out] a application instance to store
 *    corresponding info
 * @param applicationNode[in] get information from this application node
 */
GetLaunchItemsHandler.prototype.setApplicationIcons = function (aApplicationInstance, applicationNode) {
   var iconsNode = void 0;
   var iconNode = void 0;
   var iconPath = void 0;
   var iconWidth = void 0;
   var iconHeight = void 0;
   var icon = void 0;
   var icons = {};
   var j = void 0;

   iconsNode = _util2.default.getChildNode(applicationNode, "icons", 0);
   if (!!iconsNode) {
      iconNode = iconsNode.getElementsByTagName("icon");
   }
   if (!!iconNode) {
      for (j = 0; j < iconNode.length; j++) {
         icon = {};
         iconPath = (0, _jquery2.default)(_util2.default.getChildNode(iconNode[j], "path", 0)).text();
         iconWidth = (0, _jquery2.default)(_util2.default.getChildNode(iconNode[j], "width", 0)).text();
         iconHeight = (0, _jquery2.default)(_util2.default.getChildNode(iconNode[j], "height", 0)).text();
         _util2.default.addItemForJson(icon, "path", iconPath);
         _util2.default.addItemForJson(icon, "width", iconWidth);
         _util2.default.addItemForJson(icon, "height", iconHeight);
         icons[j] = icon;
      }
   }

   _util2.default.addItemForJson(aApplicationInstance, "icons", icons);
};

/**
 * set application type
 *
 * @param aApplicationInstance[out] a application instance to store
 *    corresponding info
 * @param applicationNode[in] get information from this application node
 */
GetLaunchItemsHandler.prototype.setApplicationSessionRemoteAssetsType = function (aApplicationSessionInstance, applicationSessionNode) {
   var applicationSessionRemoteAssetNode = _util2.default.getChildNode(applicationSessionNode, "has-remotable-assets", 0),
       applicationSessionRemoteAsset = !!applicationSessionRemoteAssetNode ? (0, _jquery2.default)(applicationSessionRemoteAssetNode).text() : "false";

   _util2.default.addItemForJson(aApplicationSessionInstance, "has-remotable-assets", applicationSessionRemoteAsset);
};

/**
 * action to disconnect desktop
 *
 */
GetLaunchItemsHandler.prototype.disconnectDesktop = function () {
   var logoutBrokerObject = void 0;
   var router = void 0;
   var handlerList = void 0;

   logoutBrokerObject = _util2.default.getObject(_jscdkClient.globalArray, "do-logout");
   if (!logoutBrokerObject) {
      logoutBrokerObject = new _doLogoutHandler2.default();
      _jscdkClient.globalArray[logoutBrokerObject.messageName] = logoutBrokerObject;
      _jscdkClient.globalArray[logoutBrokerObject.responseTag] = logoutBrokerObject;
   } else {
      logoutBrokerObject.resetData();
   }

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");

   if (!!logoutBrokerObject && !!router) {
      handlerList = logoutBrokerObject.composeHandlerList();
      router.postMessage(handlerList);
   }
};

/**
 * action to reset desktop
 *
 * @param desktopId [in] desktop's id used to reset desktop
 */
GetLaunchItemsHandler.prototype.resetDesktop = function (desktopId) {
   var resetDesktopObject = void 0;
   var router = void 0;
   var handlerList = void 0;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router && !!desktopId) {
      /**
       * each reset-desktop object corresponds to a desktop-id
       * if the object already exists, reset data; otherwise create a new
       * instance firstly locate handler from
       * MessageHandler.prototype.requestIdKV
       */
      resetDesktopObject = router.getHandler("reset-desktop", desktopId);
      if (!resetDesktopObject) {
         resetDesktopObject = new _resetDesktopHandler2.default();
         _jscdkClient.globalArray[resetDesktopObject.messageName + resetDesktopObject.requestId] = resetDesktopObject;
         _jscdkClient.globalArray[resetDesktopObject.responseTag + resetDesktopObject.requestId] = resetDesktopObject;
         /**
          * update MessageHandler.prototype.requestIdKV
          * the format is {responseTag1+desktop-id1 : requestId1,
          * responseTag2+desktop-id2 : requestId2} such as key of
          * ResetDesktopHandler is "reset-desktop"+desktopId
          */
         _messageHandler.MessageHandler.prototype.requestIdKV[resetDesktopObject.responseTag + desktopId] = resetDesktopObject.requestId;
      } else {
         resetDesktopObject.resetData();
      }

      if (!!resetDesktopObject && !!router) {
         resetDesktopObject.setRequestXML(desktopId);
         handlerList = resetDesktopObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }
};

/**
 * action to restart desktop
 *
 * @param desktopId [in] desktop's id used to restart desktop
 */
GetLaunchItemsHandler.prototype.restartDesktop = function (desktopId) {
   var restartDesktopObject = void 0;
   var router = void 0;
   var handlerList = void 0;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router && !!desktopId) {
      /**
       * each restart-desktop object corresponds to a desktop-id
       * if the object already exists, restart data; otherwise create a new
       * instance firstly locate handler from
       * MessageHandler.prototype.requestIdKV
       */
      restartDesktopObject = router.getHandler("restart-desktop", desktopId);
      if (!restartDesktopObject) {
         restartDesktopObject = new _restartDesktopHandler2.default();
         _jscdkClient.globalArray[restartDesktopObject.messageName + restartDesktopObject.requestId] = restartDesktopObject;
         _jscdkClient.globalArray[restartDesktopObject.responseTag + restartDesktopObject.requestId] = restartDesktopObject;
         /**
          * update MessageHandler.prototype.requestIdKV
          * the format is {responseTag1+desktop-id1 : requestId1,
          * responseTag2+desktop-id2 : requestId2} such as key of
          * RestartDesktopHandler is "restart-desktop"+desktopId
          */
         _messageHandler.MessageHandler.prototype.requestIdKV[restartDesktopObject.responseTag + desktopId] = restartDesktopObject.requestId;
      } else {
         restartDesktopObject.restartData();
      }

      if (!!restartDesktopObject && !!router) {
         restartDesktopObject.setRequestXML(desktopId);
         handlerList = restartDesktopObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }
};

/**
 * action to logoff desktop
 *
 * @param desktopId [in] desktop's id used to log off desktop
 * @param sessionId [in] desktop's sessionId to use
 */
GetLaunchItemsHandler.prototype.logoffDesktop = function (desktopId, sessionId) {
   var killSessionObject = void 0;
   var router = void 0;
   var handlerList = void 0;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");

   if (!!router && !!desktopId && !!sessionId && sessionId.trim() !== "") {
      /**
       * each kill-session object corresponds to a desktop-id
       * if the object already exists, reset data; otherwise create a new
       * instance firstly locate handler from
       * MessageHandler.prototype.requestIdKV
       */
      killSessionObject = router.getHandler("kill-session", desktopId);
      if (!killSessionObject) {
         killSessionObject = new _killSessionHandler2.default();
         _jscdkClient.globalArray[killSessionObject.messageName + killSessionObject.requestId] = killSessionObject;
         _jscdkClient.globalArray[killSessionObject.responseTag + killSessionObject.requestId] = killSessionObject;
         /**
          * update MessageHandler.prototype.requestIdKV
          * the format is {responseTag1+desktop-id1 : requestId1,
          * responseTag2+desktop-id2 : requestId2} such as key of
          * KillSessionHandler is "kill-session"+desktopId
          */
         _messageHandler.MessageHandler.prototype.requestIdKV[killSessionObject.responseTag + desktopId] = killSessionObject.requestId;
      } else {
         killSessionObject.resetData();
      }

      if (!!killSessionObject && !!router) {
         killSessionObject.setRequestXML(sessionId);
         handlerList = killSessionObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }
};

/**
 * find desktop by desktopId(desktop id or desktop name)
 *
 * @param desktopId [in] desktop id to use.
 * @param desktops [in] desktop list to be located.
 * @return target desktop whose id equals desktopId
 */
GetLaunchItemsHandler.prototype.findDesktop = function (desktopId, desktops) {
   var targetDesktop = void 0;
   var oneDesktop = void 0;

   if (!!desktopId) {
      for (oneDesktop in desktops) {
         /*
          * Use normalized (URL encoded and lower case) DN as the desktop
          * ID to follow Horizon's new rule.
          * Also, user may use the desktop as the desktop ID.
          */
         if (encodeURIComponent(desktops[oneDesktop].id.toLowerCase()) === encodeURIComponent(desktopId.toLowerCase()) || desktops[oneDesktop].name.toLowerCase() === desktopId.toLowerCase()) {
            targetDesktop = desktops[oneDesktop];
            break;
         }
      }
   }
   return targetDesktop;
};
// add more functions here

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkError = __webpack_require__(219);

var _jscdkError2 = _interopRequireDefault(_jscdkError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * jscdkBrokerError.js --
 *
 * Enums JSCDK broker errors.
 *
 */

var JSCDKBrokerError = {

   JSCDK_BROKER_ERROR_ALREADY_AUTHENTICATED: "ALREADY_AUTHENTICATED",
   JSCDK_BROKER_ERROR_AUTHENTICATION_FAILED: "AUTHENTICATION_FAILED",
   JSCDK_BROKER_ERROR_BROKER_DISABLED: "BROKER_DISABLED",
   JSCDK_BROKER_ERROR_DESKTOP_LAUNCH_ERROR: "DESKTOP_LAUNCH_ERROR",
   JSCDK_BROKER_ERROR_DESKTOP_MAINTENANCE_ERROR: "DESKTOP_MAINTENANCE_ERROR",
   JSCDK_BROKER_ERROR_DESKTOP_ROLLBACK_CHECKOUT_ERROR: "DESKTOP_ROLLBACK_CHECKOUT_ERROR",
   JSCDK_BROKER_ERROR_APPLICATION_LAUNCH_ERROR: "APPLICATION_LAUNCH_ERROR",
   JSCDK_BROKER_ERROR_DESKTOPS_ERROR: "DESKTOPS_ERROR",
   JSCDK_BROKER_ERROR_LAUNCH_ITEMS_ERROR: "LAUNCH_ITEMS_ERROR",
   JSCDK_BROKER_ERROR_INVALID_ROOT_ELEMENT: "INVALID_ROOT_ELEMENT",
   JSCDK_BROKER_ERROR_INVALID_VERSION: "INVALID_VERSION",
   JSCDK_BROKER_ERROR_INVALID_XML: "INVALID_XML",
   JSCDK_BROKER_ERROR_KILL_SESSION_ERROR: "KILL_SESSION_ERROR",
   JSCDK_BROKER_ERROR_MISSING_CONTENT: "MISSING_CONTENT",
   JSCDK_BROKER_ERROR_MISSING_VERSION: "MISSING_VERSION",
   JSCDK_BROKER_ERROR_NOT_AUTHENTICATED: "NOT_AUTHENTICATED",
   JSCDK_BROKER_ERROR_NOT_ENTITLED: "NOT_ENTITLED",
   JSCDK_BROKER_ERROR_PREFERENCES_ERROR: "PREFERENCES_ERROR",
   JSCDK_BROKER_ERROR_READ_ERROR: "READ_ERROR",
   JSCDK_BROKER_ERROR_RESET_DESKTOP_ERROR: "RESET_DESKTOP_ERROR",
   JSCDK_BROKER_ERROR_TUNNEL_ERROR: "TUNNEL_ERROR",
   JSCDK_BROKER_ERROR_UNRECOGNIZED_CONTENT: "UNRECOGNIZED_CONTENT",
   JSCDK_BROKER_ERROR_UNSUPPORTED_VERSION: "UNSUPPORTED_VERSION",
   JSCDK_BROKER_ERROR_TIMEOUT: "TIMEOUT",
   JSCDK_BROKER_ERROR_CONNECT_TO_BROKER_ERROR: "CONNECT_TO_BROKER_ERROR",
   JSCDK_BROKER_ERROR_UNKNOWN: "UNKNOWN",

   getError: function getError(errorCode) {
      var error = null;

      if (errorCode === this.JSCDK_BROKER_ERROR_TIMEOUT) {
         error = new _jscdkError2.default('TIMEOUT', _util2.default._("AJAX post request timeout."));
      } else if (errorCode === this.JSCDK_BROKER_ERROR_CONNECT_TO_BROKER_ERROR) {
         error = new _jscdkError2.default('CONNECT_TO_BROKER_ERROR', _util2.default._("Failed to connect to the Connection Server."));
      } else if (errorCode === this.JSCDK_BROKER_ERROR_UNKNOWN) {
         error = new _jscdkError2.default('UNKNOWN', _util2.default._("An unknown error occurred."));
      }

      return error;
   }
};

exports.default = JSCDKBrokerError;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var signal = function () {
   /**
    * dispatch
    *
    * Returns a function which proxies for a call on the named method
    * on an object found in the given dispatch table. The first
    * parameter of the returned function is a 'name', which is used to
    * index into the dispatch table. All other parameters are passed
    * to the underlying method.
    *
    * @param table         The dispatch table, a map from string -> object
    * @param method        The name of the method to invoke on the found object.
    * @param errNoInstance Error to throw if instance name isn't found
    * @param errNoMethod   Error to throw if instance method isn't found.
    */

   function dispatch(table, method, errNoInstance, errNoMethod) {
      return function (name) {
         // strip off the first argument, which is used as the key.
         var args = Array.prototype.slice.call(arguments, 1);

         if (table.hasOwnProperty(name)) {
            /* istanbul ignore else */
            if (table[name] !== undefined) {
               table[name][method].apply(table[name], args);
            } else {
               throw (/* istanbul ignore next */errNoMethod || 'MethodNotFound'
               );
            }
         } else {
            _appblastUtil2.default.LOGGER.log(name, 'not one of', table);
            throw (/* istanbul ignore next */errNoInstance || 'InstanceNotFound'
            );
         }
      };
   }

   return {
      /**
       * createSignal
       *
       * Returns a new 'signal' object, which represents an observable
       * event on an object.
       */
      createSignal: function createSignal() {
         var handlers = [];
         var i = void 0;

         return {
            /*
             * emit
             *
             * Calls all registered listeners. All arguments passed
             * to emit() are passed to each listener.
             */
            emit: function emit() {
               for (i = 0; i < handlers.length; i++) {
                  handlers[i].apply(null, arguments);
               }
            },

            /*
             * addEventListener
             *
             * Register a new signal handler to the signal. If the
             * function is already registered, an error is raised.
             *
             * @param handler A signal handler callback
             */
            addEventListener: function addEventListener(handler) {
               if (handlers.indexOf(handler) === -1) {
                  handlers.push(handler);
               } else {
                  throw 'Duplicate event listener';
               }
            }
         };
      },

      /**
       * makeObservable
       *
       * Makes an arbitrary object conform to the 'observable' pattern by
       * implementing 'addEventListener', 'emit', and 'addSignal'
       * methods.
       *
       * @param object The object to be made observable.
       */
      makeObservable: function makeObservable(object) {
         var signals = {};

         /**
          * addEventListener
          *
          * Register a handler for the named signal.
          *
          * @param name The signal name to observe.
          */
         object.addEventListener = dispatch(signals, 'addEventListener', 'InvalidSignal');

         /**
          * emit
          *
          * Emit the named signal on an observable object. All
          * handlers registered with that signal will be invoked. Each
          * handler will be invoked with the extra arguments passed to
          * emit() (all arguments after 'name').
          *
          * @param name The signal name to emit.
          */
         object.emit = dispatch(signals, 'emit', 'InvalidSignal');

         /**
          * addSignal
          *
          * Register a new signal with an observable object. After
          * calling this, handlers may be connected to the named signal
          * via 'addEventListener'. If the signal has already been
          * registered, an error is thrown.
          *
          * @param name The signal to create.
          */
         object.addSignal = function (name) {
            if (signals.hasOwnProperty(name)) {
               throw "DuplicateSignal";
            }

            signals[name] = signal.createSignal(name);
         };
      }
   };
}(); /*********************************************************
      * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
      *********************************************************/

/**
 * signal.js --
 *
 * Make arbitrary objects follow the observer pattern.
 */

exports.default = signal;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = GetDesktopsHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _doLogoutHandler = __webpack_require__(39);

var _doLogoutHandler2 = _interopRequireDefault(_doLogoutHandler);

var _killSessionHandler = __webpack_require__(24);

var _killSessionHandler2 = _interopRequireDefault(_killSessionHandler);

var _resetDesktopHandler = __webpack_require__(41);

var _resetDesktopHandler2 = _interopRequireDefault(_resetDesktopHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * getDesktopsHandler.js --
 *
 *      Implementation of the message handler to get desktops.
 */

function GetDesktopsHandler() {
   var doSubmitAuthenticationObject = void 0;
   var router = void 0;
   var getTunnelConnObject = void 0;

   // member variables
   this.messageName = "get-desktops";
   this.messageText = "get-desktops";
   this.responseTag = "desktops";

   // whether to notify UI on get-desktops response.
   this.notifyUI = true;

   this.subHandlerList = [];
   this.composedHandlerList = [];

   // register dependencies here
   getTunnelConnObject = _util2.default.getObject(_jscdkClient.globalArray, "get-tunnel-connection");
   if (!!getTunnelConnObject) {
      this.registerHandler(getTunnelConnObject, "state");
   } else {
      _jscdkLogger2.default.error("The get-tunnel-connection object is null!");
   }
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
GetDesktopsHandler.prototype = new _messageHandler.MessageHandler();
GetDesktopsHandler.constructor = GetDesktopsHandler;

/**
 * Reset handler's state and content.
 *
 */
GetDesktopsHandler.prototype.resetData = function () {
   _messageHandler.MessageHandler.prototype.resetData.apply(this);

   this.notifyUI = true;
};

/**
 * Set the request XML for getDesktops.
 *
 * @param supportedProtocols [in] array for supported protocols.
 */
GetDesktopsHandler.prototype.setRequestXML = function (supportedProtocols, notifyUI) {
   var nameElement = void 0,
       protocolElement = void 0,
       protocolsElement = "",
       i = void 0;
   for (i = 0; i < supportedProtocols.length; i++) {
      nameElement = _util2.default.createElement("name", supportedProtocols[i]);
      protocolElement = _util2.default.createElement("protocol", nameElement);
      protocolsElement += protocolElement;
   }
   this.requestXML = _util2.default.createElement("supported-protocols", protocolsElement);

   if (typeof notifyUI === 'boolean') {
      // Whether to notify UI on get-desktops response.
      this.notifyUI = notifyUI;
   } else {
      // Always notify UI on get-desktops response.
      this.notifyUI = true;
   }
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
GetDesktopsHandler.prototype.onUpdated = function () {
   var getDesktopsAction = {},
       actionContent = {},
       router = void 0,
       urlHandler = void 0,
       urlParams = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (this.notifyUI) {
         // Compose refresh UI request.
         getDesktopsAction.name = "GetLaunchItems"; //this whole handler will be
         // merged to getLuanchItems
         // later( TODO: ), the
         // interface of this file is
         // changed just for now,
         // later there will be no
         // more get desktops
         if (!!_jscdkClient.globalArray) {
            router = _jscdkClient.globalArray["router"];
            if (!!router) {
               actionContent.brokerUrl = router.brokerUrl;
            }
         }
         if (!!this.content["parsedResult"]) {
            actionContent.desktops = this.content.parsedResult.desktops;
         }
         // Handle the desktopId passed through URI.
         urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");
         if (!!urlHandler) {
            urlParams = urlHandler.params;
            if (!!urlParams.desktopId) {
               actionContent.desktopId = urlParams.desktopId;
               actionContent.action = urlParams.action;
               if (!!urlParams.desktopProtocol) {
                  actionContent.targetProtocol = urlParams.desktopProtocol.toUpperCase();
               }
            }
         }

         getDesktopsAction.content = actionContent;
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(getDesktopsAction));
      }
   }
   // if the error is special for this handler, alert
   _router2.default.prototype.pushErrorToUser(this);
};

/**
 * parse desktops information from the response XML
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
GetDesktopsHandler.prototype.parseResult = function (responseXML) {
   var responseBody = responseXML;
   var desktopResponse = {};
   var result = void 0;
   var resultElem = void 0;
   var desktops = {};
   var desktopsNodes = void 0;
   var desktopsLength = void 0;
   var errorCodeNode = void 0;
   var errorMessageNode = void 0;
   var desktop = void 0;
   var i = void 0;
   var brokerTag = _util2.default.getChildNode(responseBody, "broker", 0);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of GetDesktops error.");
      return null;
   }
   resultElem = _util2.default.getChildNode(brokerTag, "result", 0);
   if (!resultElem || !resultElem.hasChildNodes()) {
      return null;
   }
   result = resultElem.childNodes[0].nodeValue;
   desktopResponse["result"] = result;
   if (result === "ok") {
      desktopsNodes = brokerTag.getElementsByTagName("desktop");
      desktopsLength = desktopsNodes.length;
      for (i = 0; i < desktopsLength; i++) {
         var aDesktopInstance = {};

         // set desktop name
         this.setDesktopName(aDesktopInstance, desktopsNodes[i]);

         // set desktop id
         this.setDesktopId(aDesktopInstance, desktopsNodes[i]);

         // set response state
         this.setResponseState(aDesktopInstance, desktopsNodes[i]);

         // set sessionId
         this.setSessionId(aDesktopInstance, desktopsNodes[i]);

         // set checkedOut
         this.setCheckedOut(aDesktopInstance, desktopsNodes[i]);

         // set inMaintenanceMode
         this.setInMaintenanceMode(aDesktopInstance, desktopsNodes[i]);

         // set protocol match
         this.setProtocolMatch(aDesktopInstance, desktopsNodes[i]);

         // set preferred protocol, defaultProtocol and supportedProtocol
         this.setProtocols(aDesktopInstance, desktopsNodes[i]);

         // set desktop user preferences
         this.setDesktopUserPrefs(aDesktopInstance, desktopsNodes[i]);

         // set canLogoff: whether the desktop can logoff
         this.setCanLogoff(aDesktopInstance, desktopsNodes[i]);

         // set resetAllowed
         this.setResetAllowed(aDesktopInstance, desktopsNodes[i]);

         // set resetAllowedOnSession
         this.setResetAllowedOnSession(aDesktopInstance, desktopsNodes[i]);

         // set canRollback: whether the desktop can rollback
         this.setCanRollback(aDesktopInstance, desktopsNodes[i]);

         _util2.default.addItemForJson(desktops, i, aDesktopInstance);
         _jscdkLogger2.default.debug("aDesktopInstance: " + JSON.stringify(aDesktopInstance));
      }
      // XXX TODO: more desktop properties to handle
      _jscdkLogger2.default.debug("desktops: " + JSON.stringify(desktops));
      _util2.default.addItemForJson(desktopResponse, "desktops", desktops);
   } else if (result === "error") {
      errorCodeNode = _util2.default.getChildNode(responseBody, "error-code", 0);
      if (!!errorCodeNode) {
         _util2.default.addItemForJson(desktopResponse, "error-code", (0, _jquery2.default)(errorCodeNode).text());
      }
      errorMessageNode = _util2.default.getChildNode(responseBody, "error-message", 0);
      if (!!errorMessageNode) {
         _util2.default.addItemForJson(desktopResponse, "error-message", (0, _jquery2.default)(errorMessageNode).text());
      }
   }
   return desktopResponse;
};

/**
 * set protocol match or not
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setProtocolMatch = function (aDesktopInstance, desktopNode) {
   var matchNode = _util2.default.getChildNode(desktopNode, 'protocol-match', 0),
       match = !!matchNode ? (0, _jquery2.default)(matchNode).text() : 'true';

   _util2.default.addItemForJson(aDesktopInstance, 'protocol-match', match);
};

/**
 * set preferredProtocol, defaultProtocol and supportedProtocol
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setProtocols = function (aDesktopInstance, desktopNode) {
   var userPreferencesNode = void 0;
   var preferenceNode = void 0;
   var j = void 0;
   var hasDefault = false;
   var protocolsNode = void 0;
   var protocolNode = void 0;
   var protocolName = void 0;
   var protocols = {};
   var preferenceNameAttr = void 0;
   var isDefaultNode = void 0;
   var supportPreferredProtocol = false;
   userPreferencesNode = _util2.default.getChildNode(desktopNode, "user-preferences", 0);
   if (!!userPreferencesNode) {
      preferenceNode = userPreferencesNode.getElementsByTagName("preference");
   }
   if (!!preferenceNode) {
      for (j = 0; j < preferenceNode.length; j++) {
         preferenceNameAttr = preferenceNode[j].getAttribute("name");
         // set preferred protocol here
         if (preferenceNameAttr === "protocol") {
            _util2.default.addItemForJson(aDesktopInstance, "preferredProtocol", (0, _jquery2.default)(preferenceNode[j]).text());
         }
      }
   }
   protocolsNode = _util2.default.getChildNode(desktopNode, "protocols", 0);
   if (!!protocolsNode) {
      protocolNode = protocolsNode.getElementsByTagName("protocol");
   }
   if (!!protocolNode) {
      for (j = 0; j < protocolNode.length; j++) {
         protocolName = (0, _jquery2.default)(_util2.default.getChildNode(protocolNode[j], "name", 0)).text();
         protocols[j] = protocolName;
         if (protocolName === aDesktopInstance["preferredProtocol"]) {
            supportPreferredProtocol = true;
         }
         isDefaultNode = _util2.default.getChildNode(protocolNode[j], "is-default", 0);
         if (!!isDefaultNode && (0, _jquery2.default)(isDefaultNode).text() === "true") {
            // set default protocol if "is-default" is not null
            hasDefault = true;
            _util2.default.addItemForJson(aDesktopInstance, "defaultProtocol", protocolName);
         }
      }
   }
   // if "is-default" is null, set first protocol as default protocol
   if (!hasDefault && !!protocolNode && protocolNode.length > 0) {
      aDesktopInstance["defaultProtocol"] = (0, _jquery2.default)(_util2.default.getChildNode(protocolNode[0], "name", 0)).text();
   }
   // if no preferred protocol in user preference, set default protocol as it
   if (!aDesktopInstance["preferredProtocol"] || !supportPreferredProtocol) {
      _util2.default.addItemForJson(aDesktopInstance, "preferredProtocol", aDesktopInstance["defaultProtocol"]);
   }
   // set supported protocols here
   _util2.default.addItemForJson(aDesktopInstance, "protocols", protocols);
};

/**
 * set desktop user preferences
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setDesktopUserPrefs = function (aDesktopInstance, desktopNode) {
   var preferenceNameAttr = void 0;
   var j = void 0;
   var userPreferencesNode = void 0;
   var preferenceNode = void 0;
   userPreferencesNode = _util2.default.getChildNode(desktopNode, "user-preferences", 0);
   if (!!userPreferencesNode) {
      preferenceNode = userPreferencesNode.getElementsByTagName("preference");
   }
   if (!!preferenceNode) {
      for (j = 0; j < preferenceNode.length; j++) {
         preferenceNameAttr = preferenceNode[j].getAttribute("name");
         if (preferenceNameAttr === "alwaysConnect") {
            // set alwaysConnect
            _util2.default.addItemForJson(aDesktopInstance, "alwaysConnect", (0, _jquery2.default)(preferenceNode[j]).text());
         }
         if (preferenceNameAttr === "screenSize") {
            // set screenSize
            _util2.default.addItemForJson(aDesktopInstance, "screenSize", (0, _jquery2.default)(preferenceNode[j]).text());
         }
      }
   }
};

/**
 * set desktop id
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setDesktopId = function (aDesktopInstance, desktopNode) {
   var desktopIdNode = _util2.default.getChildNode(desktopNode, "id", 0),
       desktopId = !!desktopIdNode ? (0, _jquery2.default)(desktopIdNode).text() : "";

   _util2.default.addItemForJson(aDesktopInstance, "id", desktopId);
};

/**
 * set desktop name
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setDesktopName = function (aDesktopInstance, desktopNode) {
   var desktopNameNode = _util2.default.getChildNode(desktopNode, "name", 0),
       desktopName = !!desktopNameNode ? (0, _jquery2.default)(desktopNameNode).text() : "";

   _jscdkLogger2.default.debug("desktopName: " + desktopName);
   _util2.default.addItemForJson(aDesktopInstance, "name", desktopName);
};

/**
 * set canLogoff
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setCanLogoff = function (aDesktopInstance, desktopNode) {
   var inMaintenanceModeNode = _util2.default.getChildNode(desktopNode, "in-maintenance-mode", 0),
       checkoutGuid = _util2.default.getChildNode(desktopNode, "checkout-guid", 0),
       inMaintenanceMode = !!inMaintenanceModeNode ? (0, _jquery2.default)(inMaintenanceModeNode).text() : "false",
       checkedOut = !!checkoutGuid && (0, _jquery2.default)(checkoutGuid).text() !== "" ? "true" : "false",
       responseStateNode = _util2.default.getChildNode(desktopNode, "state", 0),
       responseState = !!responseStateNode ? (0, _jquery2.default)(responseStateNode).text() : "No Session",
       responseStateLower = responseState.toLowerCase();

   if (inMaintenanceMode === "true" || checkedOut === "true" || responseStateLower !== "connected" && responseStateLower !== "disconnected") {
      /*
       * Logoff of a desktop from the desktop selector is not possible if it is
       * in maintenance mode, if it is checked out by another machine, or if
       * the desktop state is something other than "connected" or "disconnected".
       */
      _util2.default.addItemForJson(aDesktopInstance, "canLogoff", "false");
   } else {
      _util2.default.addItemForJson(aDesktopInstance, "canLogoff", "true");
   }
};

/**
 * set reset-allowed
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setResetAllowed = function (aDesktopInstance, desktopNode) {
   var resetAllowedNode = _util2.default.getChildNode(desktopNode, "reset-allowed", 0),
       resetAllowed = !!resetAllowedNode ? (0, _jquery2.default)(resetAllowedNode).text() : "false";

   _util2.default.addItemForJson(aDesktopInstance, "reset-allowed", resetAllowed);
};

/**
 * set reset-allowed-on-session
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setResetAllowedOnSession = function (aDesktopInstance, desktopNode) {
   var resetAllowedOnSessionNode = _util2.default.getChildNode(desktopNode, "reset-allowed-on-session", 0),
       resetAllowedOnSession = !!resetAllowedOnSessionNode ? (0, _jquery2.default)(resetAllowedOnSessionNode).text() : "false";

   _util2.default.addItemForJson(aDesktopInstance, "reset-allowed-on-session", resetAllowedOnSession);
};

/**
 * set in-maintenance-mode
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setInMaintenanceMode = function (aDesktopInstance, desktopNode) {
   var inMaintenanceModeNode = _util2.default.getChildNode(desktopNode, "in-maintenance-mode", 0),
       inMaintenanceMode = !!inMaintenanceModeNode ? (0, _jquery2.default)(inMaintenanceModeNode).text() : "false";

   _util2.default.addItemForJson(aDesktopInstance, "in-maintenance-mode", inMaintenanceMode);
};

/**
 * set checkedOut
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setCheckedOut = function (aDesktopInstance, desktopNode) {
   var checkedOut = "false";
   var checkedOutNode = _util2.default.getChildNode(desktopNode, "checkout-guid", 0);
   if (!!checkedOutNode && (0, _jquery2.default)(checkedOutNode).text().length > 0) {
      checkedOut = "true";
   }

   _util2.default.addItemForJson(aDesktopInstance, "checkedOut", checkedOut);
};

/**
 * set response state
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setResponseState = function (aDesktopInstance, desktopNode) {
   var responseStateNode = _util2.default.getChildNode(desktopNode, "state", 0),
       responseState = !!responseStateNode ? (0, _jquery2.default)(responseStateNode).text() : "No Session";

   _util2.default.addItemForJson(aDesktopInstance, "state", responseState);
};

/**
 * set session-id
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setSessionId = function (aDesktopInstance, desktopNode) {
   var sessionIdNode = _util2.default.getChildNode(desktopNode, "session-id", 0),
       sessionId = !!sessionIdNode ? (0, _jquery2.default)(sessionIdNode).text() : "";

   _util2.default.addItemForJson(aDesktopInstance, "session-id", sessionId);
};

/**
 * set canRollback
 *
 * @param aDesktopInstance[out] a desktop instance to store corresponding info
 * @param desktopNode[in] get information from this desktop node
 */
GetDesktopsHandler.prototype.setCanRollback = function (aDesktopInstance, desktopNode) {
   var offlineStateNode = _util2.default.getChildNode(desktopNode, "offline-state", 0),
       offlineState = !!offlineStateNode ? (0, _jquery2.default)(offlineStateNode).text() : "";

   if (offlineState === "checked out") {
      _util2.default.addItemForJson(aDesktopInstance, "canRollback", "true");
   } else {
      _util2.default.addItemForJson(aDesktopInstance, "canRollback", "false");
   }
};

/**
 * action to disconnect desktop
 *
 */
GetDesktopsHandler.prototype.disconnectDesktop = function () {
   var logoutBrokerObject = void 0;
   var router = void 0;
   var handlerList = void 0;

   logoutBrokerObject = _util2.default.getObject(_jscdkClient.globalArray, "do-logout");
   if (!logoutBrokerObject) {
      logoutBrokerObject = new _doLogoutHandler2.default();
      _jscdkClient.globalArray[logoutBrokerObject.messageName] = logoutBrokerObject;
      _jscdkClient.globalArray[logoutBrokerObject.responseTag] = logoutBrokerObject;
   } else {
      logoutBrokerObject.resetData();
   }

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");

   if (!!logoutBrokerObject && !!router) {
      handlerList = logoutBrokerObject.composeHandlerList();
      router.postMessage(handlerList);
   }
};

/**
 * action to reset desktop
 *
 * @param desktopId [in] desktop's id used to reset desktop
 */
GetDesktopsHandler.prototype.resetDesktop = function (desktopId) {
   var resetDesktopObject = void 0;
   var router = void 0;
   var handlerList = void 0;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router && !!desktopId) {
      /**
       * each reset-desktop object corresponds to a desktop-id
       * if the object already exists, reset data; otherwise create a new
       * instance firstly locate handler from
       * MessageHandler.prototype.requestIdKV
       */
      resetDesktopObject = router.getHandler("reset-desktop", desktopId);
      if (!resetDesktopObject) {
         resetDesktopObject = new _resetDesktopHandler2.default();
         _jscdkClient.globalArray[resetDesktopObject.messageName + resetDesktopObject.requestId] = resetDesktopObject;
         _jscdkClient.globalArray[resetDesktopObject.responseTag + resetDesktopObject.requestId] = resetDesktopObject;
         /**
          * update MessageHandler.prototype.requestIdKV
          * the format is {responseTag1+desktop-id1 : requestId1,
          * responseTag2+desktop-id2 : requestId2} such as key of
          * ResetDesktopHandler is "reset-desktop"+desktopId
          */
         _messageHandler.MessageHandler.prototype.requestIdKV[resetDesktopObject.responseTag + desktopId] = resetDesktopObject.requestId;
      } else {
         resetDesktopObject.resetData();
      }

      if (!!resetDesktopObject && !!router) {
         resetDesktopObject.setRequestXML(desktopId);
         handlerList = resetDesktopObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }
};

/**
 * action to logoff desktop
 *
 * @param desktopId [in] desktop's id used to log off desktop
 * @param sessionId [in] desktop's sessionId to use
 */
GetDesktopsHandler.prototype.logoffDesktop = function (desktopId, sessionId) {
   var killSessionObject = void 0;
   var router = void 0;
   var handlerList = void 0;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");

   if (!!router && !!desktopId && !!sessionId && sessionId.trim() !== "") {
      /**
       * each kill-session object corresponds to a desktop-id
       * if the object already exists, reset data; otherwise create a new
       * instance firstly locate handler from
       * MessageHandler.prototype.requestIdKV
       */
      killSessionObject = router.getHandler("kill-session", desktopId);
      if (!killSessionObject) {
         killSessionObject = new _killSessionHandler2.default();
         _jscdkClient.globalArray[killSessionObject.messageName + killSessionObject.requestId] = killSessionObject;
         _jscdkClient.globalArray[killSessionObject.responseTag + killSessionObject.requestId] = killSessionObject;
         /**
          * update MessageHandler.prototype.requestIdKV
          * the format is {responseTag1+desktop-id1 : requestId1,
          * responseTag2+desktop-id2 : requestId2} such as key of
          * KillSessionHandler is "kill-session"+desktopId
          */
         _messageHandler.MessageHandler.prototype.requestIdKV[killSessionObject.responseTag + desktopId] = killSessionObject.requestId;
      } else {
         killSessionObject.resetData();
      }

      if (!!killSessionObject && !!router) {
         killSessionObject.setRequestXML(sessionId);
         handlerList = killSessionObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }
};

/**
 * find desktop by desktopId(desktop id or desktop name)
 *
 * @param desktopId [in] desktop id to use.
 * @param desktops [in] desktop list to be located.
 * @return target desktop whose id equals desktopId
 */
GetDesktopsHandler.prototype.findDesktop = function (desktopId, desktops) {
   var targetDesktop = void 0;
   var oneDesktop = void 0;

   if (!!desktopId) {
      for (oneDesktop in desktops) {
         /*
          * Use normalized (URL encoded and lower case) DN as the desktop
          * ID to follow Horizon's new rule.
          * Also, user may use the desktop as the desktop ID.
          */
         if (encodeURIComponent(desktops[oneDesktop].id.toLowerCase()) === encodeURIComponent(desktopId.toLowerCase()) || desktops[oneDesktop].name.toLowerCase() === desktopId.toLowerCase()) {
            targetDesktop = desktops[oneDesktop];
            break;
         }
      }
   }
   return targetDesktop;
};
// add more functions here

/***/ }),
/* 18 */,
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

exports.default = angular.module("com.vmware.vdi.htmlaccess.template", []).name;

/***/ }),
/* 20 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 21 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _stringUtils = __webpack_require__(32);

var _stringUtils2 = _interopRequireDefault(_stringUtils);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**********************************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 **********************************************************************/

/**
 * VDPService.js
 *
 *   Interface that lies between the View Virtual Channel(VVC) APIs and the Unity client
 *   plugin providing easy communication with the remote application using Remote
 *   Procedure Calls. Tbe server side VDPService written in C++ can be found at
 *   bora/apps/rde/vdpservice.
 *
 *   A root VDPService.Service instance needs to be created. Then listeners can be added
 *   which are called when a channel is opened by the remote application:
 *      .addChannelCreatedListener This listener is called when the server creates a new
 *                                 channel.
 *
 *   Please refer to VDPService.Service documentation.
 *
 *   A VDPService.Channel instance is a RPC wrapper to VVCChannel. The following listeners
 *   must be added:
 *      .onReady                 Called when the VDPService.Channel instance is ready to
 *                               send RPCs.
 *      .onDisconnect            Called when the VDPService.Channel is disconnected and
 *                               can no longer send RPCs.
 *      .onInvoke                Called when the server on the other end of the channel
 *                               called Invoke(), that is, when there is a new RPC message
 *                               received.
 *
 *   Please refer to VDPService.Channel documentation.
 */

var VDPService = Object.freeze({
   /**
    * VDPService.Channel state.
    *
    * @enum {Integer}
    * @readonly
    */
   CHANNEL_STATE: {
      CLOSED: 0, // Channel has been closed.
      CLOSING: 1, // Channel has been requested to close.
      OPEN: 2, // Channel open.
      NOT_READY: 3, // Channel accepted but a Channel Object is PENDING.
      READY: 4 // Channel is ready to send RPCs.
   },

   /**
    * RPC type.
    *    REQUEST: A response will be sent back with the return parameters.
    *    POST: The RPC does not have a response.
    *
    * @enum {String}
    * @readonly
    */
   RPC_TYPE: {
      REQUEST: "REQUEST",
      POST: "POST"
   },

   /*
    * Used internally to read/set the RPC data types
    * used by the RPC Encoder/Decoder.
    * https://opengrok.eng.vmware.com/source/xref/bfg-main.perforce.1666/bora/apps/rde/vdpservice/public/vdprpc_defines.h#95
    * @type {Integer}
    * @readonly
    */
   VARIANT_TYPE: {
      SIGNED_INTEGER: 3,
      CHAR: 16,
      UNSIGNED_INTEGER: 19,
      UNSIGNED_INTEGER_8: 21, //64bits
      STRING: 30,
      BLOB: 65
   },

   /*
    * Used internally to inform the server about the required action to be taken
    * for the RPC and also process incoming RPCs accordingly.
    *
    * @enum {Integer}
    * @readonly
    */
   RPC_ACTION: {
      REQUEST: 1,
      RESPONSE: 3,
      POST: 4
   },

   /*
    * The command IDs of channel RPCs.
    *
    * @enum {Integer}
    * @readonly
    */
   CHANNEL_COMMANDS: {
      CREATE_OBJECT: 0xffffff9c,
      DESTROY_OBJECT: 0x65,
      EXCHANGE_SECRET: 0x66,
      SEND_PCOIP_SIDECHANNAME: 0x67,
      BEAT_REQUEST: 0x68,
      BEAT_REPLY: 0x69
   },

   /*
    * Identifier of internal RPC messages.
    *
    * @type {Integer}
    * @readonly
    */
   RPC_DATA_FORMAT: 0xffffff9c,

   /*
    * The invalid RPC Channel Object ID.
    *
    * @type {Integer}
    * @readonly
    */
   INVALID_CHANNEL_OBJECT_ID: 0xfffffffe,

   /*
    * The starting RPC request ID.
    *
    * @type {Integer}
    * @readonly
    */
   START_REQUEST_ID: 1,

   /*
    * The minimum length of the RESPONSE section of an encoded header.
    *
    * @type {Integer}
    * @readonly
    */
   MINIMUM_RETURN_SECTION_LENGTH: 20,

   /*
    * This version of VDPService supports POST RPCs and side channel
    * is disabled. Set the last two bits of the 32-bit capability
    * field. (capability = 0x3)
    *
    * @type {Integer}
    * @readonly
    */
   CAPABILITY: 3,

   /*
    * The length of the RPC header.
    *
    * @type {Integer}
    * @readonly
    */
   RPC_HEADER_SIZE: 24,

   /**
    * Interface to encode/decode RPCs in External Data Representation.
    * Reference:
    * https://www.ietf.org/rfc/rfc1832.txt
    *
    * @constructor
    */
   XDRBuffer: function XDRBuffer() {
      var self = this,


      /**
       * The read position of the encoded buffer.
       *
       * @private
       * @type {Integer}
       */
      readPosition = 0,


      /**
       * Avoid JSLINT warning by forward defining the
       * functions here.
       */
      ensureWrite = null,
          ensureRead = null,
          setUint8Array = null,
          seekToNextBlock = null;

      /**
       * The encoded buffer.
       *
       * @type {Uint8Array}
       */
      this.data = null;

      /**
       * The current length of the contents in the buffer.
       *
       * @type {Integer}
       */
      this.length = 0;

      /**
       * Initializes the encoder with the given size of the buffer with the default as
       * 512 bytes.
       *
       * @param {Integer} size -  Initial size of the Uint8Array buffer.
       */
      this.initEncoder = function (size) {
         this.length = 0;
         this.data = new Uint8Array(size || 512);
      };

      /**
       * Initializes the decoder with the given encoded buffer.
       *
       * @param {Uint8Array} encodedArrayBuffer - The XDR encoded buffer format to
       *                                          be decoded.
       * @returns {Boolean} true if successful.
       */
      this.initDecoder = function (encodedArrayBuffer) {
         if (!(encodedArrayBuffer instanceof Uint8Array)) {
            return false;
         }

         this.data = encodedArrayBuffer;
         this.length = encodedArrayBuffer.length;
         readPosition = 0;

         return true;
      };

      /**
       * Returns the internal buffer contents splicing the unused buffer.
       *
       * @returns {Uint8Array} - The buffer.
       */
      this.getData = function () {
         var data = null;

         if (this.data) {
            data = this.data.subarray(0, this.length);
         }

         return data;
      };

      /**
       * Get the read position of XDRBuffer.
       * @returns {Integer} the read position of the XDRBuffer.
       */
      this.getReadPosition = function () {
         return readPosition;
      };

      /**
       * Generic function to write a variable to the buffer.  Uses the
       * variable's type to determine which write function to use.
       *
       * @param value - The value to be written.
       * @return {Boolean} - true if the write was successful, false otherwise.
       */
      this.write = function (value) {
         return this.writeVariant(value, true, false);
      };

      /**
       * Writes a string at the end of the buffer in XDR format.  The string is
       * converted from the native JavaScript UTF-16 to UTF-8 before putting it
       * on the buffer.
       *          0     1     2     3     4     5   ...
       *       +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+
       *       |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |
       *       +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+
       *       |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|
       *                               |<----n+r (where (n+r) mod 4 = 0)---->|
       *
       * @param {String} value - The value to be written.
       */
      this.writeString = function (value) {
         var utf8Array = _stringUtils2.default.stringToUint8Array(value);

         /*
          * If the string wasn't empty but the conversion result is, that means
          * that it wasn't able to be converted.
          */
         if (utf8Array.length === 0 && value.length > 0) {
            _jscdkLogger2.default.error('XDRBuffer: Failed to convert string ' + value + ' to UTF-8.');
            return;
         }

         // Now write the resulting UTF-8 data.
         this.writeBlob(utf8Array);
      };

      /**
       * Writes a Uint8Array at the end of the buffer in XDR format.
       *          0     1     2     3     4     5   ...
       *       +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+
       *       |        length n       |byte0|byte1|...| n-1 |  0  |...|  0  |
       *       +-----+-----+-----+-----+-----+-----+...+-----+-----+...+-----+
       *       |<-------4 bytes------->|<------n bytes------>|<---r bytes--->|
       *                               |<----n+r (where (n+r) mod 4 = 0)---->|
       *
       * @param {Uint8Array} value - The value to be written.
       */
      this.writeBlob = function (value) {
         this.writeUint32(value.length);
         setUint8Array(value);
      };

      /**
       * Writes a 8-bit unsigned integer at the end of the buffer in XDR format.
       * XDR operates on a boundary of 4 bytes so the value is added at byte 3
       * with leading 0s.
       *            (MSB)                   (LSB)
       *       +-------+-------+-------+-------+
       *       |byte 0 |byte 1 |byte 2 |byte 3 |
       *       +-------+-------+-------+-------+
       *       <------------32 bits------------>
       *
       * @param {Integer} value - The value to be written.
       */
      this.writeUint8 = function (value) {
         ensureWrite(4);
         this.length += 3;
         this.data[this.length++] = value & 0xff;
      };

      /**
       * Writes a 32-bit unsigned integer at the end of the buffer
       * in XDR format.
       *
       *            (MSB)                   (LSB)
       *       +-------+-------+-------+-------+
       *       |byte 0 |byte 1 |byte 2 |byte 3 |
       *       +-------+-------+-------+-------+
       *       <------------32 bits------------>
       *
       * @param {Integer} value - The value to be written.
       */
      this.writeUint32 = function (value) {
         this.setInt32(this.length, value);
      };

      /**
       * Writes a 32-bit signed integer at the end of the buffer
       * in XDR format.
       *
       *            (MSB)                   (LSB)
       *       +-------+-------+-------+-------+
       *       |byte 0 |byte 1 |byte 2 |byte 3 |
       *       +-------+-------+-------+-------+
       *       <------------32 bits------------>
       *
       * @param {Integer} value - The value to be written.
       */
      this.writeInt32 = function (value) {
         this.setInt32(this.length, value);
      };

      /**
       * Writes a 32-bit integer at the specified position
       * of the buffer in XDR format.
       *
       * @param {Integer} position - The write position.
       * @param {Integer} value - The value to be written.
       */
      this.setInt32 = function (position, value) {
         var reqBytes = position - this.length + 4;

         if (reqBytes > 0) {
            ensureWrite(reqBytes);
            this.length += reqBytes;
         }

         this.data[position++] = value >> 24 & 0xff;
         this.data[position++] = value >> 16 & 0xff;
         this.data[position++] = value >> 8 & 0xff;
         this.data[position++] = value & 0xff;
      };

      /**
       * Writes the variant type and the value at the end of the buffer in XDR format.
       *
       * @param {Number|String|Uint8Array} value - The value to be written.
       * @param {Boolean} signed - true if the value should be interpreted by the server
       *                           as a signed integer.
       * @param {Boolean} writeType - true (default) if the type header should be written
       * @returns {Boolean} true if the value was successfully written.
       */
      this.writeVariant = function (value, signed, writeType) {
         var vt = void 0;

         if (writeType === undefined) {
            writeType = true;
         }

         if (typeof value === 'string') {
            if (writeType) {
               this.writeUint32(VDPService.VARIANT_TYPE.STRING);
            }
            this.writeString(value);
         } else if (typeof value === 'number') {
            vt = VDPService.VARIANT_TYPE.UNSIGNED_INTEGER;

            if (signed || false) {
               vt = VDPService.VARIANT_TYPE.SIGNED_INTEGER;
            }

            if (writeType) {
               this.writeUint32(vt);
            }
            this.writeUint32(value);
         } else if (value instanceof Uint8Array) {
            if (writeType) {
               this.writeUint32(VDPService.VARIANT_TYPE.BLOB);
            }
            this.writeBlob(value);
         } else {
            return false;
         }

         return true;
      };

      /**
       * Reads the encoded 8-bit unsigned integer from the current position
       * skipping 3 bytes.
       *
       * @returns {Integer} The value read or null if data was not available.
       */
      this.readUint8 = function () {
         var param = null;

         if (ensureRead(4)) {
            readPosition += 3;
            param = this.data[readPosition++];
         }

         return param;
      };

      /**
       * Reads the 32-bit unsigned integer from the current position.
       *
       * @returns {Integer} The value read or null if data was not available.
       */
      this.readUint32 = function () {
         var param = this.readInt32();

         if (param) {
            param = param >>> 0;
         }

         return param;
      };

      /**
       * Reads the 32-bit unsigned integer from the current position.
       *
       * @returns {Integer} The value read or null if data was not available.
       */
      this.readUint64 = function () {
         var param = this.readInt64();

         if (param) {
            param = param >>> 0;
         }

         return param;
      };

      /**
       * Reads the 32-bit signed integer from the current position.
       *
       * @returns {Integer} The value read or null if data was not available.
       */
      this.readInt64 = function () {
         var param = null;

         if (ensureRead(8)) {
            param = (0xff & this.data[readPosition++]) << 56 | (0xff & this.data[readPosition++]) << 48 | (0xff & this.data[readPosition++]) << 40 | (0xff & this.data[readPosition++]) << 32 | (0xff & this.data[readPosition++]) << 24 | (0xff & this.data[readPosition++]) << 16 | (0xff & this.data[readPosition++]) << 8 | 0xff & this.data[readPosition++];
         }

         return param;
      };

      /**
       * Reads the 64-bit signed integer from the current position.
       *
       * @returns {Integer} The value read or null if data was not available.
       */
      this.readInt32 = function () {
         var param = null;

         if (ensureRead(4)) {
            param = (0xff & this.data[readPosition++]) << 24 | (0xff & this.data[readPosition++]) << 16 | (0xff & this.data[readPosition++]) << 8 | 0xff & this.data[readPosition++];
         }

         return param;
      };

      /**
       * Reads a string from current position. Reads the length from the string and
       * then the actual string.
       *
       * @returns {String} The value read or null if data was not available.
       */
      this.readString = function () {
         var stringData = void 0,
             string = null;

         stringData = this.readBlob();
         if (!!stringData) {
            if (stringData.length > 0) {
               string = _stringUtils2.default.uint8ArrayToString(stringData);
            } else {
               string = '';
            }
         }

         return string;
      };

      /**
       * Read the encoded blob {Uint8array} from the current position. Reads the length
       * from the buffer and then the actual Blob.
       *
       * @returns {Uint8Array} The value read or null if data was not available.
       */
      this.readBlob = function () {
         var blob = null,
             len = this.readUint32();

         if (len && ensureRead(len)) {
            blob = this.data.subarray(readPosition, readPosition + len);
            readPosition += len;
            seekToNextBlock(false);
         }

         // Return an empty blob when the length read from the XDRBuffer is 0.
         if (len === 0) {
            return new Uint8Array(0);
         }

         return blob;
      };

      /**
       * Read the variant type and then the data from the current position. Reads the
       * type first and then data accordingly.
       *
       * @returns {Number|String|Blob} The value read or null if data was not available.
       */
      this.readVariant = function () {
         var param = null,
             type = this.readUint32();

         switch (type) {
            case VDPService.VARIANT_TYPE.STRING:
               param = this.readString();
               break;
            case VDPService.VARIANT_TYPE.SIGNED_INTEGER:
               param = this.readInt32();
               break;
            case VDPService.VARIANT_TYPE.UNSIGNED_INTEGER:
               param = this.readUint32();
               break;
            case VDPService.VARIANT_TYPE.UNSIGNED_INTEGER_8:
               param = this.readUint64();
               console.error("UNSIGNED_INTEGER_8", param);
               break;
            case VDPService.VARIANT_TYPE.BLOB:
               param = this.readBlob();
               break;
            case VDPService.VARIANT_TYPE.CHAR:
               param = this.readUint8();
               if (param !== null) {
                  param = String.fromCharCode(param);
               }
               break;
            default:
               _jscdkLogger2.default.error("Failed to read the variant due to invalid type: " + type);
         }

         return param;
      };

      /**
       * Skips the number of bytes. Note that all elements are initialized to
       * 0 by default.
       *
       * @param {Integer} pos - The number of bytes to skip.
       */
      this.skipWriteBytes = function (num) {
         ensureWrite(num);
         this.length += num;
      };

      /**
       * Seek the read position ensuring that it does not
       * go beyond the length.
       *
       * @param {Integer} pos - The position to seek to.
       * @returns {Boolean} True if successful.
       */
      this.seekReadPosition = function (pos) {
         if (pos >= 0 && pos < this.length) {
            readPosition = pos;
            return true;
         }

         return false;
      };

      /**
       * Ensure that the buffer is large enough to write the number of bytes.
       * The size is multiplied by 1.5 times.
       *
       * @param {Integer} size - Tbe number of bytes to ensure.
       */
      ensureWrite = function ensureWrite(size) {
         if (size > 0) {
            var buffer = void 0,
                reqLength = self.length + size,
                newLength = self.data.length;

            while (newLength < reqLength) {
               newLength = Math.floor(newLength * 1.5);
            }

            if (newLength > self.data.length) {
               buffer = new Uint8Array(newLength);
               buffer.set(self.data);
               self.data = buffer;
            }
         }
      };

      /**
       * Check if the number of bytes can be read from the current read
       * position.
       *
       * @param {Integer} length - Tbe number of bytes to be read.
       * @returns {Boolean} true if the buffer is large enough to read the length.
       */
      ensureRead = function ensureRead(length) {
         return !!self.data && readPosition + length <= self.data.length;
      };

      /**
       * Append a Uint8Array with padding of 4 bytes according to XDR.
       *
       * @private
       * @param {Uint8Array} value - The value to be set.
       */
      setUint8Array = function setUint8Array(value) {
         ensureWrite(value.length);
         if (value && value.length) {
            self.data.set(value, self.length);
         }

         self.length += value.length;
         seekToNextBlock(true);
      };

      /**
       * Helper function used to seek to the end of the 4-byte block.
       *
       * @private
       * @param {Boolean} seekWrite - true to seek write buffer,
       *                              false to seek read buffer.
       */
      seekToNextBlock = function seekToNextBlock(seekWrite) {
         if (seekWrite) {
            self.length = self.length + 3 & ~0x3;
         } else {
            readPosition = readPosition + 3 & ~0x3;
         }
      };
   },

   /**
    * A root VDPService.Service instance needs to be created to handle channel
    * connections.
    *
    * @constructor
    * @param {VVC} vvc - VVC instance.
    * @param {VVCSession} vvcSession - VVCSession instance.
    */

   Service: function Service(vvc, vvcSession) {
      var self = this,


      /**
       * The vvcListener object to listen to new channels
       * opened by the server.
       *
       * @type {VVCListener}
       * @private
       */
      vvcListener = null,


      /**
       * A list of VDPService channels indexed by VVC channel ID.
       *
       * @type {VDPService.Channel[]}
       * @private
       */
      vdpChannels = [],


      /**
       * Forward defining the functions for JSLint.
       * @private
       */
      onPeerChannelOpen = null,
          onChannelCloseError = null,


      /**
       * A list of callbacks to be called when a channel is opened
       * by a remote application.
       */
      onChannelCreatedListeners = [];

      /**
       * Initialize the VVC transport listening for channels opened
       * by the server beginning with "RP" as done with the vdpService
       * native client.
       */
      vvcListener = vvc.createListener(vvcSession, "RP*");
      vvcListener.onpeeropen = function (session, channel) {
         if (vvcSession !== session) {
            _jscdkLogger2.default.error("Unexpected session object.");
            return;
         }
         onPeerChannelOpen(channel);
      };

      /**
       * Add a listener to be called when a channel is opened by
       * the remote application.
       *
       * @param {Function} callback
       *    This listener is called when the server creates a new channel and no
       *    other listeners have yet to accept the channel.
       *    Parameters:
       *       channel   The VDPService.Channel object of the newly created channel.
       *                 The plugin must call VDPService.Service.connectChannel to
       *                 accept the channel, the channel will be automatically rejected
       *                 if no listeners accept it, or manually rejected via
       *                 VDPService.Service.rejectChannel
       */
      this.addChannelCreatedListener = function (callback) {
         onChannelCreatedListeners.push(callback);
      };

      /**
       * Connect and acknowledge the new channel opened by the server.
       *
       * vdpservice.js automatically acknowledges the first "channel object" that is
       * created by the server if the channel object name if not specified through this
       * method. If the "channel object" name is passed with this method, vdpservice.js
       * then only acknowledges a channel object from the server with the desired name.
        * @param {VDPService.Channel} channel - The VDPService.Channel object to
       *                                       connect to.
       * @param {[String[]]} desiredObjectNames - The list of object names to accept.
       * @returns {Boolean} true if the channel was successfully acknowledged.
       */
      this.connectChannel = function (channel, desiredObjectNames) {
         if (!(channel instanceof VDPService.Channel)) {
            _jscdkLogger2.default.error("Invalid argument.");
            return false;
         }

         /*
          * The channel cannot be found in our list of existing
          * VDPService.Channel references.
          */
         if (vdpChannels[channel.id] !== channel) {
            _jscdkLogger2.default.error("Channel with id " + channel.id + " cannot be found in the list of existing channels.");
            return false;
         }

         // The channel in the OPEN state to be connected.
         if (channel.state !== VDPService.CHANNEL_STATE.OPEN) {
            _jscdkLogger2.default.error("Invalid channel state: " + channel.state);
            return false;
         }

         // Accept the channel.
         if (!vvcSession.acceptChannel(vvcSession.getChannel(channel.id))) {
            _jscdkLogger2.default.error("vvcSession.acceptChannel failed for" + " channel with id: " + channel.id);
            delete vdpChannels[channel.id];
            return false;
         }

         /*
          * The channel has been accepted by the plugin and is now NOT_READY until
          * one "channel object" is created by the server and acknowledged
          * automatically by VDPService.Channel implementation.
          */
         channel.state = VDPService.CHANNEL_STATE.NOT_READY;
         channel.desiredObjects = desiredObjectNames || [];

         return true;
      };

      /**
       * Reject the newly opened channel by the server.
       *
       * @param {VDPService.Channel} channel - The VDPService.Channel object to reject.
       * @returns {boolean} true if the channel was rejected.
       */
      this.rejectChannel = function (channel) {
         if (!(channel instanceof VDPService.Channel)) {
            _jscdkLogger2.default.error("Invalid argument.");
            return false;
         }

         /*
          * The channel cannot be found in our list of existing
          * VDPService.Channels.
          */
         if (vdpChannels[channel.id] !== channel) {
            _jscdkLogger2.default.error("Channel with id " + channel.id + " cannot be found in the list of existing channels.");
            return false;
         }

         /*
          * The channel must be in the OPEN state.
          * A OPEN state denotes that the channel is neither accepted
          * or rejected by the plugin.
          */
         if (channel.state !== VDPService.CHANNEL_STATE.OPEN) {
            _jscdkLogger2.default.error("Invalid channel state: " + channel.state);
            return false;
         }

         // Reject the channel.
         if (!vvcSession.rejectChannel(vvcSession.getChannel(channel.id))) {
            _jscdkLogger2.default.error("vvcSession.rejectChannel failed for" + " channel with id: " + channel.id);
            return false;
         }

         channel.state = VDPService.CHANNEL_STATE.CLOSED;
         delete vdpChannels[channel.id];

         return true;
      };

      /**
       * Disconnect the channel.
       *
       * @param {VDPService.Channel} channel - The VDPService.Channel object to
       *                                       disconnect.
       * @returns {Boolean} Returns true if the channel close request was successfully
       *                    sent to VVC and the state is set to CLOSING.
       */
      this.disconnectChannel = function (channel) {
         if (!(channel instanceof VDPService.Channel)) {
            _jscdkLogger2.default.error("Invalid argument.");
            return false;
         }

         /*
          * The channel cannot be found in our list of existing
          * VDPService.Channels.
          */
         if (vdpChannels[channel.id] !== channel) {
            _jscdkLogger2.default.error("Channel with id " + channel.id + " cannot be found in the list of existing channels.");
            return false;
         }

         _jscdkLogger2.default.debug("Disconnecting channel with id:" + channel.id + " state:" + channel.state);

         // Call VVCChannel.close() if it has not been yet called.
         if (!(channel.state === VDPService.CHANNEL_STATE.CLOSING || channel.state === VDPService.CHANNEL_STATE.CLOSED)) {
            if (!vvcSession.getChannel(channel.id).close()) {
               _jscdkLogger2.default.error("vvcSession.disconnectChannel failed for channel with" + " id: " + channel.id);
               return false;
            }

            channel.state = VDPService.CHANNEL_STATE.CLOSING;
         }

         return true;
      };

      /**
       * Whether there is a VDPService.Channel object with the particular ID
       * in the list of vdpChannels.
       *
       * @param {Integer} channelID - The channel id.
       * @returns {Boolean} Whether the VDPSerice.Channel object with the particular
       *                    ID is present in the list of existing channels.
       */
      this.isChannelPresent = function (channelID) {
         return vdpChannels.hasOwnProperty(channelID);
      };

      /**
       * Called when the peer opens a channel.
       *
       * @param {VVCChannel} vvcChannel - The VVCChannel object.
       * @private
       */
      onPeerChannelOpen = function onPeerChannelOpen(channel) {
         var vdpChannel = void 0,
             i = void 0;

         console.error(channel);

         // An event listener to be called when the VVC channel closes.
         channel.onclose = function () {
            onChannelCloseError(channel);
         };

         // An event listener to called when there is a VVC channel error.
         channel.onerror = function () {
            onChannelCloseError(channel);
         };

         vdpChannel = new VDPService.Channel(channel);
         vdpChannels[channel.id] = vdpChannel;

         if (onChannelCreatedListeners.length) {
            // Find a listener to accept our newly created channel
            for (i = 0; i < onChannelCreatedListeners.length; ++i) {
               onChannelCreatedListeners[i](vdpChannel);

               if (vdpChannel.state !== VDPService.CHANNEL_STATE.OPEN) {
                  break;
               }
            }

            // If no one accepted or rejected the channel we need to reject it.
            if (vdpChannel.state === VDPService.CHANNEL_STATE.OPEN) {
               self.rejectChannel(vdpChannel);
            }
         } else {
            _jscdkLogger2.default.warning("No onChannelCreated listeners have been " + "set by the consumer.");
         }
      };

      /**
       * Channel has been closed or there is a channel error.
       *
       * @param {VVCChannel} vvcChannel - The VVCChannel object.
       * @private
       */
      onChannelCloseError = function onChannelCloseError(vvcChannel) {
         var vdpChannel = void 0;

         vdpChannel = vdpChannels[vvcChannel.id];

         if (!vdpChannel) {
            _jscdkLogger2.default.error("Channel with id " + vvcChannel.id + " cannot be found in the list of existing channels.");
            return;
         }

         /*
          * Invoke vdpChannel.onDisconnect if the channel is currently
          * in READY state.
          */
         if (vdpChannel.state === VDPService.CHANNEL_STATE.READY) {
            if (!!vdpChannel.onDisconnect) {
               vdpChannel.onDisconnect();
            } else {
               _jscdkLogger2.default.warning("onDisconnect listener has not been" + " set by the consumer.");
            }
         }

         vdpChannel.state = VDPService.CHANNEL_STATE.CLOSED;
         delete vdpChannels[vvcChannel.id];
      };
   },

   /**
    * VDPService.Channel is a RPC wrapper over VVCChannel. Its created when a channel is
    * opened by the server. A channel is a communication path between the remote
    * application and the local plugin. The consumers will use the VDPService.Channel
    * object to communicate with the server using RPCs.
    * @constructor
    *
    * @param (VVChannel) vvcChannel - The VVC channel object that will be using to send
    *                                   and receive data.
    *
    * Listeners:
    *    .onReady
    *       Called for each new channel object connected to the VDPService.Channel.
    *       The object is now ready to send and receive RPCs.
    *
    *   .onDisconnect
    *       Called for each channel object which is disconnected from the channel.
    *       The object is disconnected and can no longer send or receive RPCs.
    *
    *   .onInvoke
    *       Called when the server on the other end of the channel called Invoke(),
    *       that is, when there is a new RPC message received.
    *          @param rpc          This parameter holds the data given by the server.
    *                              This should be altered to hold the return values,
    *                              and the RPC will be returned to the server when this
    *                              method returns.
    *                              The following properties must be processed:
    *               .command       {Integer} or {String}. The command code represents the
    *                              remote method that the object is meant to represent.
    *               .type          Whether the RPC is a REQUEST or a POST RPC.
    *               .params[]      {Integer} or {String} or {Uint8Array} The data given
    *                              by the server.
    */
   Channel: function Channel(vvcChannel) {
      var self = this,


      /**
       * The next request ID for the RPC.
       *
       * @type {Integer}
       * @private
       */
      requestID = VDPService.START_REQUEST_ID,


      /**
       * List of requests which are waiting for a return context
       * from the server.
       *
       * @type {{onDone, onAbort}[]} Array of {onDone, onAbort} indexed by
       *                              requestIDs.
       * @private
       */
      pendingRequests = [],


      /**
       * List of functions forward defined for Jslint.
       */
      onVVCMessage = null,
          encode = null,
          decode = null,
          handleCreateObject = null,
          handleDestroyObject = null,
          handleOnInvoke = null,
          findOpenObjectByID = null,
          findOpenObjectByName = null;

      /**
       * The id of the channel.
       *
       * @type {Integer}
       */
      this.id = vvcChannel.id;

      /**
       * The name of the channel.
       *
       * @type {String}
       */
      this.name = vvcChannel.name;

      /**
       * The initial state of the channel is PENDING, that is,
       * the channel is open from the server side but it
       * needs to be accepted by a plugin.
       *
       * @type {VDPService.CHANNEL_STATE}
       */
      this.state = VDPService.CHANNEL_STATE.OPEN;

      /**
       * The list of all open objects on the channel.
       * @type {{id, name}[]}
       */
      this.openObjects = [];

      /**
       * The list of object names to accept from the server.
       * @type {String[]}
       */
      this.desiredObjects = [];

      /**
       * Returns whether the requestID is pending.
       *
       * @param {Integer} requestID - The RPC requestID.
       * @returns {Boolean} whether the request ID is pending
       */
      this.isRequestPending = function (requestID) {
         return pendingRequests.hasOwnProperty(requestID);
      };

      // An event listener to be called when a RPC is received from the server.
      vvcChannel.onmessage = function (event) {
         onVVCMessage(new Uint8Array(event.data));
      };

      /**
       * Callback invoked by VVC when a new message is received.
       *
       * @param data {Uint8Array} - The data received from VVC.
       * @private
       */
      onVVCMessage = function onVVCMessage(data) {
         /*
          * This channel data is received from the server. We decode the
          * buffer into a plain object using XDR decoder.
          */
         console.warn(data);
         var userRPC = decode(data),
             objID = void 0;
         console.info(userRPC);
         if (!userRPC) {
            _jscdkLogger2.default.error("Failed to decode the message received from the server.");
            return;
         }

         /*
          * The server channel object ID in the contexts array will be 0 when a
          * channel command is received. Handle the channel commands sent from the
          * server.
          * TODO: Implement the channel command EXCHANGE_SECRET required
          * for side channels.
          */
         objID = userRPC.contexts[0];

         if (objID === 0) {
            switch (userRPC.command) {
               case VDPService.CHANNEL_COMMANDS.CREATE_OBJECT:
                  handleCreateObject(userRPC);
                  break;
               case VDPService.CHANNEL_COMMANDS.DESTROY_OBJECT:
                  handleDestroyObject(userRPC);
                  break;
               // below are only used for CDR
               case VDPService.CHANNEL_COMMANDS.EXCHANGE_SECRET:
                  console.error("we don't support exchange secret, please config Agent and try again");
                  break;
               case VDPService.CHANNEL_COMMANDS.SEND_PCOIP_SIDECHANNAME:
                  console.error("we don't support pcoip channel, please config Agent and try again");
                  break;
               case VDPService.CHANNEL_COMMANDS.BEAT_REQUEST:
                  console.error("we don't support beat request, please config Agent and try again");
                  break;
               case VDPService.CHANNEL_COMMANDS.BEAT_REPLY:
                  console.error("we don't support beat reply, please config Agent and try again");
                  break;
               default:
                  _jscdkLogger2.default.error("Invalid channel command received " + "from the server: " + userRPC.command);
            }
         } else if (findOpenObjectByID(objID)) {
            handleOnInvoke(userRPC);
         } else {
            _jscdkLogger2.default.error("Invalid server object ID: " + objID);
         }
      };

      /*
       * Initiates a RPC between the plugin and the server object on the other end of
       * the channel.
       *
       * The object can be specified with any of userRPC.object, .objID or .objName.
       * If no object is specified the first open object will be used.
       *
       * @param userRPC       {Object} An object of the following format:
       *            .command  {Integer} or {String} The remote code that the rpc
       *                      represents.
       *            .type     {VDPService.RPC_TYPE}  Whether the RPC is a REQUEST or a
       *                      POST RPC. Default is REQUEST.
       *            .params[] {Integer} or {String} or {Uint8Array}[]  Data to be sent
       *                      to the server.
       *            .onDone   {Function} Called when the VDPService.Channel.invoke call
       *                      has returned from the server.
       *            .onAbort  {Function} Called when the Invoke call fails due to a
       *                      VDPService error.
       *            .object   {{id,name}?} Object that this RPC request is for.
       *            .objID    {Integer?} Object ID that this RPC request is for.
       *            .objName  {String?} Object Name that this RPC request is for.
       *
       * Description of the two callback functions.
       *
       *    onDone                 Called when the VDPService.Channel.invoke call has
       *                           returned
       *                           from the server. Takes parameter:
       *        rpc                This will hold all of the return codes and values
       *                           given by the peer.
       *                           The following are the properties of the rpc object
       *                           that may be processed:
       *            .command       {Integer} or {String}. The command code represents
       *                           the remote method that the context is meant to
       *                           represent.
       *            .returnCode    {Integer} The return code set by the server.
       *            .returnParams  {Integer} or {String} or {Uint8Array}[] The return
       *                           params appended by the server.
       *
       *    onAbort                Called when the Invoke call fails due to a VDPService
       *                           error. Takes parameter:
       *        rpc                The following are the properties may be processed:
       *           .userCancelled  {Boolean} 0.
       *           .abortCode      {Integer} The abort reason.
       *
       * @returns {Integer} A non-zero requestID if successful.
       */
      this.invoke = function (userRPC) {
         var sendBuffer = void 0,
             object = null,
             rpc = {},
             i = void 0;

         // Check whether userRPC is an object literal.
         if (!userRPC || userRPC.constructor !== Object) {
            _jscdkLogger2.default.error("Invalid argument.");
            return 0;
         }

         if (this.state !== VDPService.CHANNEL_STATE.READY) {
            _jscdkLogger2.default.error("The channel must be in READY(" + VDPService.CHANNEL_STATE.READY + ") state. Current " + "state of the channel: " + this.state);
            return 0;
         }

         /*
          * Check the validity of the command. VDPService accepts number or
          * string commands.
          */
         if (!(typeof userRPC.command === 'number' || typeof userRPC.command === 'string')) {
            _jscdkLogger2.default.error("Invalid command type: " + userRPC.command);
            return 0;
         }

         /*
          * We receive the RPC params[] from the user.
          * TODO: need to verify whether RPCs with no parameters are allowed.
          */
         if (!(userRPC.params instanceof Array)) {
            _jscdkLogger2.default.error("Invalid argument property rpc.params: " + userRPC.params);
            return 0;
         }

         /*
          * Check if userRPC contains the right data types. If not, return
          * failure.
          */
         for (i = 0; i < userRPC.params.length; i++) {
            if (!(typeof userRPC.params[i] === 'number' || typeof userRPC.params[i] === 'string' || userRPC.params[i] instanceof Uint8Array)) {
               _jscdkLogger2.default.error("Invalid param: " + userRPC.params[i] + " at index: " + i);
               return 0;
            }
         }

         // Set the command and the params to the internal RPC object.
         rpc.command = userRPC.command;
         rpc.params = userRPC.params;

         // The default RPC type is REQUEST.
         if (userRPC.type === VDPService.RPC_TYPE.POST) {
            rpc.action = VDPService.RPC_ACTION.POST;
         } else {
            rpc.action = VDPService.RPC_ACTION.REQUEST;
         }

         /*
          * Add tbe server channel object ID and the request ID to the list
          * of contexts to be sent.
          */
         if (!!userRPC.object) {
            // Ensure object exists by searching by id
            object = findOpenObjectByID(userRPC.object.id);
         } else if (!!userRPC.objID) {
            object = findOpenObjectByID(userRPC.objID);
         } else if (!!userRPC.objName) {
            object = findOpenObjectByName(userRPC.objName);
         } else if (self.openObjects.length > 0) {
            // Just default to first open object
            object = self.openObjects[0];
         }

         if (!object) {
            _jscdkLogger2.default.error("Could not find matching channel object to invoke on " + "id: " + userRPC.objID + ", name: " + userRPC.objName);
            return 0;
         }

         rpc.contexts = [object.id, requestID];

         // Encode the user RPC in XDR format.
         sendBuffer = encode(rpc);

         // Send the buffer over the virtual channel.
         if (!vvcChannel.send(sendBuffer)) {
            return 0;
         }

         // Save onDone and onAbort callbacks for REQUEST RPCs.
         if (rpc.action !== VDPService.RPC_ACTION.POST) {
            pendingRequests[requestID] = {
               onDone: userRPC.onDone,
               onAbort: userRPC.onAbort };
         }

         return requestID++;
      };

      /**
       * Used by VDPService Tests. Retrieves the private encode function
       * to simulate RPCs in the tests.
       */
      this.getEncodeFunction = function () {
         return encode;
      };

      /**
       * Used by VDPService Tests. Retrieves the private decode function
       * to simulate RPCs in the tests.
       */
      this.getDecodeFunction = function () {
         return decode;
      };

      /**
       * Encodes the rpc object in XDR format. Uses XDRBuffer to do its operations.
       *
       * @private
       * @param rpc                 {Object} The object holds all of the information
       *                            of a remote call for the server. It has the
       *                            following properties some of which are optional
       *                            depending on the RPC action.
       *            .command        {Integer} or {String} The remote code that the rpc
       *                            represents.
       *            .action         {VDPService.RPC_ACTION} The action to be performed on
       *                            the RPC.
       *            .contexts[]     {Number[]}The channel object ID and the request ID
       *                            of the RPC.
       *            .params[]       {Integer} or {String} or {Uint8Array}[] Array of
       *                            heterogeneous types. Contains data to be sent to
       *                            the peer.
       *            .returnCode     {Integer} The return code to be sent to the server.
       *            .returnParams[] {Integer} or {String} or {Uint8Array}[] Array of
       *                            heterogeneous types.
       *                            Contains data to be sent as return value of a RPC
       *                            to the peer.
       *            .abort          {Integer} Set to 1 if the RPC should be aborted.
       *                            The peer will get an onAbort callback.
       *            .userCancelled  {Integer} 0.
       *            .abortCode      {Integer} The abort code of the RPC failure sent
       *                            to the peer.
       *
       * @returns {Uint8Array} the encoded buffer.
       */
      encode = function encode(rpc) {
         var i = void 0,
             xdr = new VDPService.XDRBuffer();

         // Initialize the encoder.
         xdr.initEncoder();
         xdr.skipWriteBytes(VDPService.RPC_HEADER_SIZE);

         // Write the data format as DATA_FORMAT_RPC.
         xdr.writeUint32(VDPService.RPC_DATA_FORMAT);

         // Write the action required for the RPC by the peer.
         xdr.writeUint8(rpc.action);

         // Write the number of contexts of the RPC.
         xdr.writeUint8(rpc.contexts.length);

         /**
          * Write the contexts of the RPC.
          * contexts[0] - The server channel object ID where the RPC will be sent.
          * contexts[1] - The request ID.
          */
         for (i = 0; i < rpc.contexts.length; i++) {
            xdr.writeVariant(rpc.contexts[i]);
         }

         // Write the command of the RPC.
         xdr.writeVariant(rpc.command);

         // Write the number of params of the RPC.
         xdr.writeUint8(rpc.params.length);

         // Write the params of the RPC.
         for (i = 0; i < rpc.params.length; i++) {
            // This version does not support named params. Write an empty string.
            xdr.writeVariant("");

            // Write the param.
            xdr.writeVariant(rpc.params[i]);
         }

         /*
          * The following needs to encoded only when the RPC
          * is of type RESPONSE. RESPONSE RPCs send the
          * plugin data to the server.
          */
         if (rpc.action === VDPService.RPC_ACTION.RESPONSE) {
            // Write the return code.
            xdr.writeUint32(rpc.returnCode);

            // Write the number of return params of the RPC.
            xdr.writeUint8(rpc.returnParams.length);

            // Write the return params from the RPC.
            for (i = 0; i < rpc.returnParams.length; i++) {
               /**
                * This version does not support named return params. Write an empty
                * string.
                */
               xdr.writeVariant("");

               // Write the param.
               xdr.writeVariant(rpc.returnParams[i]);
            }

            // Write the abort value of the RPC.
            xdr.writeUint8(rpc.abort);

            // Set the userCancelled value of the RPC.
            xdr.writeUint8(rpc.userCancelled);

            // Set the abortCode value from the RPC.
            xdr.writeUint32(rpc.abortCode);
         } else {
            xdr.skipWriteBytes(VDPService.MINIMUM_RETURN_SECTION_LENGTH);
         }

         /*
          * Append the 24-byte wireheader at the beginning of the buffer:
          * | length | capability | unused | unused | unused | unused |
          */
         xdr.setInt32(0, xdr.getData().length);
         xdr.setInt32(4, VDPService.CAPABILITY);

         return xdr.getData();
      };

      /**
       * Converts the encoded data received from the server into an rpc object with
       * the below properties.
       *
       * @private
       * @param {Uint8Array} data - The encoded data buffer.
       *
       * @returns {Object}  The object holds all of the information of a remote call
       *                     for the plugin. It has the following properties:
       *            .command        {Integer} or {String} The remote code that the rpc
       *                            represents.
       *            .action         {VDPService.RPC_ACTION} The action to be performed on
       *                            the RPC.
       *            .contexts[]     {Number[]}The channel object ID and the request ID
       *                            of the RPC.
       *            .params[]       {Integer} or {String} or {Uint8Array}[] Array of
       *                            heterogeneous types. Contains data to be sent to the
       *                            peer.
       *            .returnCode     {Integer} The return code to be sent to the server.
       *            .returnParams[] {Integer} or {String} or {Uint8Array}[] Array of
       *                            heterogeneous types.
       *                            Contains data to be sent as return value of a RPC to
       *                            the peer.
       *            .abort          {Integer} Set to 1 if the RPC should be aborted.
       *                            The peer will get an onAbort callback.
       *            .userCancelled  {Integer} 0.
       *            .abortCode      {Integer} The abort code of the RPC failure sent to
       *                            the peer.
       */
      decode = function decode(data) {
         var rpc = {},
             numOfContexts = void 0,
             numOfParams = void 0,
             numOfReturnParams = void 0,
             i = void 0,
             param = void 0,
             xdr = new VDPService.XDRBuffer();

         if (!xdr.initDecoder(data)) {
            _jscdkLogger2.default.error("Initializing the decoder with the given data failed.");
            return null;
         }

         // Check whether the length matches the data length.
         if (xdr.readUint32() !== data.length) {
            _jscdkLogger2.default.error("The length of the buffer does not match the header.");
            return null;
         }

         // Move the position pointer ahead to the first data byte.
         if (!xdr.seekReadPosition(VDPService.RPC_HEADER_SIZE)) {
            _jscdkLogger2.default.error("Cannot set the read position to the first data byte.");
            return null;
         }

         // Check the data format matches DATA_FORMAT_RPC.
         if (xdr.readUint32() !== VDPService.RPC_DATA_FORMAT) {
            return null;
         }

         // Read the RPC action field to allow the RPC to be processed accordingly.
         rpc.action = xdr.readUint8();
         if (rpc.action === null) {
            _jscdkLogger2.default.error("Failed to read the action property of rpc.");
            return null;
         }

         // Populate the rpc.type based on the RPC_ACTION.
         if (rpc.action === VDPService.RPC_ACTION.POST) {
            rpc.type = VDPService.RPC_TYPE.POST;
         } else if (rpc.action === VDPService.RPC_ACTION.REQUEST) {
            rpc.type = VDPService.RPC_TYPE.REQUEST;
         } else if (rpc.action !== VDPService.RPC_ACTION.RESPONSE) {
            _jscdkLogger2.default.error("Invalid action property of rpc: " + rpc.action);
            return null;
         }

         // Read the number of contexts of the RPC.
         numOfContexts = xdr.readUint8();
         if (numOfContexts === null) {
            _jscdkLogger2.default.error("Failed to read the number of contexts field of rpc.");
            return null;
         }

         /**
          * Reads the contexts of the RPC.
          * contexts[0] - The server channel object ID.
          * contexts[1] - The request ID.
          */
         rpc.contexts = [];
         for (i = 0; i < numOfContexts; ++i) {
            param = xdr.readVariant();
            if (param === null) {
               _jscdkLogger2.default.error("Failed to read the context at index: " + i);
               return null;
            }
            rpc.contexts.push(param);
         }

         // Read the command.
         rpc.command = xdr.readVariant();
         if (!(typeof rpc.command === 'number' || typeof rpc.command === 'string')) {
            _jscdkLogger2.default.error("Invalid command type: " + rpc.command);
            return null;
         }

         // Read the number of parameters field.
         numOfParams = xdr.readUint8();
         if (numOfParams === null) {
            _jscdkLogger2.default.error("Failed to read the number of params field of rpc.");
            return null;
         }

         // Read the params field.
         rpc.params = [];
         for (i = 0; i < numOfParams; ++i) {
            if (xdr.readVariant() === null) {
               _jscdkLogger2.default.error("Failed to read the named param at index: " + i);
               return null;
            }

            param = xdr.readVariant();
            if (param === null) {
               _jscdkLogger2.default.error("Failed to read the param value at index: " + i);
               return null;
            }
            rpc.params.push(param);
         }

         // Read the return code.
         rpc.returnCode = xdr.readUint32();
         if (rpc.returnCode === null) {
            _jscdkLogger2.default.error("Failed to read the return code of rpc.");
            return null;
         }

         // Read the number of return parameters field.
         numOfReturnParams = xdr.readUint8();
         if (numOfReturnParams === null) {
            _jscdkLogger2.default.error("Failed to read the number of return params field" + " of rpc.");
            return null;
         }

         // Read the return params.
         rpc.returnParams = [];
         for (i = 0; i < numOfReturnParams; ++i) {
            if (xdr.readVariant() === null) {
               _jscdkLogger2.default.error("Failed to read the return named parameter" + " field at index: " + i);
               return null;
            }

            param = xdr.readVariant();
            if (param === null) {
               _jscdkLogger2.default.error("Failed to read the return value at index: " + i);
               return null;
            }
            rpc.returnParams.push(param);
         }

         // Read whether the RPC has been aborted.
         rpc.abort = xdr.readUint8();
         if (rpc.abort === null) {
            _jscdkLogger2.default.error("Failed to read the abort value");
            return null;
         }

         // Read the userCancelled field.
         rpc.userCancelled = xdr.readUint8();
         if (rpc.userCancelled === null) {
            _jscdkLogger2.default.error("Failed to read the userCancelled value.");
            return null;
         }

         // Read the abortReason value from the buffer.
         rpc.abortCode = xdr.readUint32();
         if (rpc.abortCode === null) {
            _jscdkLogger2.default.error("Failed to read abortCode value.");
            return null;
         }

         return rpc;
      };

      /**
       * Handles the RPC received from the server.
       *
       * @private
       * @param rpc {Object} - The rpc object described in VDPService.Channel.decode.
       */
      handleOnInvoke = function handleOnInvoke(rpc) {
         var buffer = void 0,
             reqID = void 0,
             request = void 0;

         switch (rpc.action) {
            case VDPService.RPC_ACTION.REQUEST:
               /*
                * Inform the plugin about a new incoming RPC from the server by calling
                * onInvoke. The plugin reads the RPC data from the object passed with
                * onInvoke and adds the return data to this same object which is sent
                * back to the server.
                */
               if (!!self.onInvoke) {
                  self.onInvoke(rpc);
               } else {
                  _jscdkLogger2.default.error("onInvoke Listener has not been set" + " by the plugin.");
               }

               /*
                * Send the return parameters appended to the rpc object to
                * the server.
                */
               rpc.action = VDPService.RPC_ACTION.RESPONSE;

               // Clear the server params in this RESPONSE message.
               rpc.params = [];

               buffer = encode(rpc);

               // Send the buffer over the virtual channel.
               if (!vvcChannel.send(buffer)) {
                  _jscdkLogger2.default.error("Unable to send the response buffer of the RPC with " + "request ID = " + rpc.contexts[1]);
               }

               break;

            case VDPService.RPC_ACTION.POST:
               /*
                * Inform the plugin about a new incoming RPC from the server. We do no
                * process any return parameters of the onInvoke call as no response needs
                * to be sent to the server.
                */
               if (!!self.onInvoke) {
                  self.onInvoke(rpc);
               } else {
                  _jscdkLogger2.default.error("Unable to hand over the RPC to the " + "consumer as VDPService.Channel.onInvoke listener " + "has not been set.");
               }

               break;

            case VDPService.RPC_ACTION.RESPONSE:
               // Map the request ID of the RPC with the existing pending requests.
               reqID = rpc.contexts[1];
               request = pendingRequests[reqID];

               if (!request) {
                  _jscdkLogger2.default.error("Unable to find the request ID of " + "this RESPONSE RPC in the list of pending requests.");
                  return;
               }

               // Invoke the return callbacks saved while sending the RPC.
               if (rpc.abort) {
                  if (!!request.onAbort) {
                     request.onAbort(rpc);
                  } else {
                     _jscdkLogger2.default.error("Unable to hand over the RPC to " + "the consumer as " + "onAbort listener has not been saved.");
                  }
               } else {
                  if (!!request.onDone) {
                     request.onDone(rpc);
                  } else {
                     _jscdkLogger2.default.error("Unable to hand over the RPC to the " + "consumer as onDone listener has not been saved.");
                  }
               }

               delete pendingRequests[reqID];
               break;
         }
      };

      /**
       * Handles the creation of a "channel object" by the server. A channel object is
       * required by the server for communicating with RPCs. This method simply
       * acknowledges the first "channel object" that is created by the server if the
       * channel object name if not specified using VDPService.Service.connectChannel().
       * If the "channel object" name is passed with connectChannel, vdpservice.js only
       * only acknowledges the channel object with the desired name.
       *
       * Note that javascript version of vdpService for simplification does not give the
       * ability to the plugins to create "channel objects".
       *
       * @private
       * @param rpc {Object} - The rpc object described in VDPService.Channel.decode.
       */
      handleCreateObject = function handleCreateObject(rpc) {
         var name = void 0,
             objID = void 0,
             sendBuffer = void 0,
             vdpRPC = void 0,
             object = void 0;

         /*
          * The channel objects will have two parameters, server's channel object name
          * and object ID.
          */
         if (rpc.params.length !== 2 || typeof rpc.params[0] !== "string" || typeof rpc.params[1] !== "number") {
            _jscdkLogger2.default.error("Invalid parameters: " + rpc.params);
            return;
         }

         name = rpc.params[0];
         objID = rpc.params[1];
         console.error(name, objID);

         /*
          * If desiredObjects has been specified, then we must ensure that this
          * new channel object's name is in the desired object list.
          */
         if (self.desiredObjects && self.desiredObjects.length) {
            if (self.desiredObjects.indexOf(name) === -1) {
               _jscdkLogger2.default.info("Ignoring channel object " + name + ", because" + " it doesn't match desired channel objects " + self.desiredObjects);
               return null;
            }
         }

         vdpRPC = { command: VDPService.CHANNEL_COMMANDS.CREATE_OBJECT,
            action: VDPService.RPC_ACTION.POST,
            params: [name, objID],
            contexts: [0, 0] };

         sendBuffer = encode(vdpRPC);

         // Send the buffer over the virtual channel.
         if (!vvcChannel.send(sendBuffer)) {
            _jscdkLogger2.default.error("Unable to send the CREATE_OBJECT acknowledgement.");
            return;
         }

         /*
          * VDPService.Channel goes into a READY state when a "Channel
          * Object" is created by the server. The channel is ready to send RPCs.
          * Fire the onReady callback.
          */
         self.state = VDPService.CHANNEL_STATE.READY;

         // Add the object to our open objects list
         object = { id: objID, name: name };
         self.openObjects.push(object);

         _jscdkLogger2.default.info("vdpService: Acknowledged object ID " + objID + ", name " + name + ", for channel " + self.name);

         // Fire the onReady callback to the listener.
         if (!!self.onReady) {
            self.onReady(object);
         } else {
            _jscdkLogger2.default.error("onReady Listener has not been set by the plugin.");
         }
      };

      /**
       * Handles the destruction of a "channel object".
       *
       * @private
       * @param rpc {Object} - The rpc object described in VDPService.Channel.decode.
       */
      handleDestroyObject = function handleDestroyObject(rpc) {
         var name = void 0,
             objID = void 0,
             sendBuffer = void 0,
             vdpRPC = void 0,
             index = void 0,
             object = void 0;

         /*
          * The channel objects will have two parameters,
          * channel object name and ID.
          */
         if (rpc.params.length !== 2 || typeof rpc.params[0] !== "string" || typeof rpc.params[1] !== "number") {
            _jscdkLogger2.default.error("Invalid params length:" + rpc.params.length);
            return;
         }

         name = rpc.params[0];
         objID = rpc.params[1];

         // Find and remove the object from the list of open objects
         index = self.openObjects.indexOf(findOpenObjectByID(objID));

         if (index === -1) {
            _jscdkLogger2.default.error("Could not find open object with id:" + objID);
            return null;
         }

         object = self.openObjects.splice(index, 1)[0];

         /*
         * If there is now no server channel object to communicate with, the
         * channel goes into NOT_READY state.
         */
         if (self.openObjects.length === 0) {
            self.state = VDPService.CHANNEL_STATE.NOT_READY;
         }

         /**
          * Send the VDPService.CHANNEL_COMMANDS.DESTROY_OBJECT channel command
          * to the server.
          */
         vdpRPC = { command: VDPService.CHANNEL_COMMANDS.DESTROY_OBJECT,
            action: VDPService.RPC_ACTION.POST,
            params: [name, objID],
            contexts: [0, 0] };

         sendBuffer = encode(vdpRPC);

         /**
          * Send the buffer over the virtual channel. We trigger the channel
          * state change even when we fail to send the DESTROY_OBJECT packet to
          * the server.
          */
         if (!vvcChannel.send(sendBuffer)) {
            _jscdkLogger2.default.error("Failed to send the DESTROY_OBJECT acknowledgement.");
         }

         // Fire the onDisconnect callback to the listener.
         if (!!self.onDisconnect) {
            self.onDisconnect(object);
         } else {
            _jscdkLogger2.default.warning("onDisconnect Listener has not been set " + "by the plugin.");
         }
      };

      /**
       * Find an open channel object by id
       *
       * @private
       * @param {Number} id
       *    The object id to search for
       * @return {{id, name}?}
       *    The open object, or null when no object is found with id
       */
      findOpenObjectByID = function findOpenObjectByID(id) {
         var i = void 0;

         for (i = 0; i < self.openObjects.length; ++i) {
            if (self.openObjects[i].id === id) {
               return self.openObjects[i];
            }
         }

         return null;
      };

      /**
       * Find an open channel object by name
       *
       * @private
       * @param {String} name
       *    The object name to search for
       * @return {{id, name}?}
       *    The open object, or null when no object is found with name
       */
      findOpenObjectByName = function findOpenObjectByName(name) {
         var i = void 0;

         for (i = 0; i < self.openObjects.length; ++i) {
            if (self.openObjects[i].name === name) {
               return self.openObjects[i];
            }
         }

         return null;
      };
   }
});

exports.default = VDPService;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = GetTunnelConnectionHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GetTunnelConnectionHandler() {
   var router = void 0;

   // member variables
   this.messageName = "get-tunnel-connection";
   this.messageText = "get-tunnel-connection";
   this.responseTag = "tunnel-connection";

   this.subHandlerList = [];

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, 'router');
   if (!!router) {
      this.registerHandler(router, 'receiver');
      this.registerHandler(router, 'doLogout');
      this.registerHandler(router, 'doCancelAuthentication');
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * getTunnelConnectionHandler.js --
 *
 *      Implementation of the message handler to get tunnel connection.
 */

GetTunnelConnectionHandler.prototype = new _messageHandler.MessageHandler();
GetTunnelConnectionHandler.constructor = GetTunnelConnectionHandler;

/**
 * Set the request XML for getTunnelConnection.
 *
 * @param bypassTunnel [in] bypass tunnel or not(true/false).
 */

GetTunnelConnectionHandler.prototype.setRequestXML = function (bypassTunnel) {
   if (bypassTunnel === false) {
      // HTML Access should always bypass tunnel
      throw 'HTML Access cannot use the tunnel connection!';
      // this.requestXML = "";
      // this.setSubHandler();
   } else {
      this.requestXML = _util2.default.createElement("bypass-tunnel", "true");
      if (_util2.default.brokerSupportApplication()) {
         this.requestXML += _util2.default.createElement("multi-connection-aware", "true");
      }
      this.clearSubHandlers();
   }
};
/**
 * parse tunnel information from the response XML
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */

GetTunnelConnectionHandler.prototype.parseResult = function (responseXML) {
   var brokerTag = void 0;
   var responses = void 0;
   var result = void 0;
   var tunnelConnectionResponse = {};
   var xmlDoc = void 0;

   xmlDoc = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   if (result === "ok" || result === "error") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases.
       */
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(tunnelConnectionResponse, nameText, (0, _jquery2.default)(this).text());
      });
   }

   return tunnelConnectionResponse;
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */

GetTunnelConnectionHandler.prototype.onUpdated = function () {
   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   // Push error to UI
   _router2.default.prototype.pushErrorToUser(this);
};

/**
 * Set its sub handler.
 * NOTE: this function is not used any more.
 */

// GetTunnelConnectionHandler.prototype.setSubHandler = function ()
// {
//    var setupTunnelConnObject = globalArray["setup-tunnel-connection"];
//    if (!setupTunnelConnObject) {
//       setupTunnelConnObject = new SetupTunnelConnectionHandler();
//       globalArray[setupTunnelConnObject.messageName] = setupTunnelConnObject;
//       globalArray[setupTunnelConnObject.responseTag] = setupTunnelConnObject;
//    } else {
//       setupTunnelConnObject.resetData();
//    }
//
//    this.appendSubHandler(setupTunnelConnObject);
// };

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = KillSessionHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function KillSessionHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "kill-session";
   this.messageText = "kill-session";
   this.responseTag = "kill-session";
   this.composedHandlerList = [];

   this.itemId = '';
   this.itemType = '';
   this.callbackFunction = null;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * killSessionHandler.js --
 *
 *      Implementation of the message handler to kill session.
 *      current used type is only of Desktop And All Application
 *      sessions, the "ApplicationSession"(not recommanded) or
 *      "Application" is the preserved API for later function
 */

KillSessionHandler.prototype = new _messageHandler.MessageHandler();
// constructor
KillSessionHandler.constructor = KillSessionHandler;

KillSessionHandler.prototype.setCallbackFunction = function (callbackFunction) {
   this.callbackFunction = callbackFunction;
};

/**
 * parse information from the response XML of kill-session
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
KillSessionHandler.prototype.parseResult = function (responseXML) {
   var killSessionResponse = {},
       xmlDoc = (0, _jquery2.default)(responseXML),
       brokerTag = void 0,
       responses = void 0,
       result = void 0;

   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of killSessionHandler error");
      return null;
   }

   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   if (result === "ok" || result === "error") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases.
       */
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(killSessionResponse, nameText, (0, _jquery2.default)(this).text());
      });
   }

   return killSessionResponse;
};

/**
 * Set the request XML for kill-session
 * @param sessionId[in] session id to kill-session
 *
 */
KillSessionHandler.prototype.setRequestXML = function (sessionId) {
   var sessionIdElem = void 0;
   sessionIdElem = _util2.default.createElement("session-id", sessionId);
   this.requestXML = sessionIdElem;
   this.sessionId = sessionId;
};

/**
 * callback when received notification from handlers in dependency list or
 * router
 *
 */
KillSessionHandler.prototype.onUpdated = function () {
   var killSessionAction = void 0,
       callbackFunction = this.callbackFunction,
       key = this.messageName;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (typeof callbackFunction !== 'function') {
      if (this.state === _messageHandler.StateEnum.DONE) {
         if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
            _jscdkLogger2.default.debug('kill-session succeeds.');

            // Kill session succeeds
            killSessionAction = {
               name: "KillSession",
               result: "ok"
            };
            (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(killSessionAction));
         }
      }

      // push error if it exists
      _router2.default.prototype.pushErrorToUser(this);
   } else {
      if (this.state === _messageHandler.StateEnum.DONE) {
         if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
            _jscdkLogger2.default.debug('kill-session succeeds.');

            // Kill session succeeds
            callbackFunction({
               result: "success"
            });
         }
      }
      if (!!this.content["error"]) {
         callbackFunction({
            result: "fail",
            error: this.content["error"][key],
            sessionId: this.sessionId
         });
      }
      callbackFunction = null;
   }
};

/**
 * Triggered by the parent handler
 *
 */
KillSessionHandler.prototype.triggerExecution = function () {
   var getItemsObject = void 0,
       desktops = void 0,
       applications = void 0,
       applicationSessions = void 0,
       targetDesktop = void 0,
       targetApplication = void 0,
       targetApplicationSession = void 0,
       sessionId = void 0,
       handlerList = void 0,
       itemId = this.itemInfo.id,
       launchItemTypeIsDesktop = this.itemInfo.isDesktop,
       router = _jscdkClient.globalArray['router'],
       errorMessage = void 0,
       errorObj = {};

   _messageHandler.MessageHandler.prototype.triggerExecution.apply(this);

   // Get session ID of the desktop whose id equals itemId.
   getItemsObject = this.parentHandler;
   if (!getItemsObject) {
      if (!_util2.default.brokerSupportApplication()) {
         getItemsObject = _jscdkClient.globalArray['get-desktops' + itemId];
      } else {
         getItemsObject = _jscdkClient.globalArray['get-launch-items' + itemId];
      }
   }
   if (!!getItemsObject && !!getItemsObject.content["parsedResult"]) {
      desktops = getItemsObject.content["parsedResult"]["desktops"];
      applications = getItemsObject.content["parsedResult"]["applications"];
      applicationSessions = getItemsObject.content["parsedResult"]["application-sessions"];
   }
   if (launchItemTypeIsDesktop && !!desktops) {
      // using this function, for URI launching might use desktop name or its id
      targetDesktop = getItemsObject.findDesktop(itemId, desktops);
      if (!!targetDesktop) {
         sessionId = targetDesktop["session-id"];
      }
   }
   if (!launchItemTypeIsDesktop && !!applications && !!applicationSessions) {
      targetApplication = _util2.default.findFirstItemWithPropertyInList('id', itemId, applications);
      if (!!targetApplication) {
         targetApplicationSession = _util2.default.findFirstItemWithPropertyInList('origin-id', targetApplication['origin-id'], applicationSessions);
         if (!!targetApplicationSession) {
            sessionId = targetApplicationSession.id;
         }
      }
   }

   // kill the session.
   if (!!sessionId && sessionId.trim() !== "") {
      this.setRequestXML(sessionId);
      handlerList = this.composeHandlerList();
      router.postMessage(handlerList);
   } else {
      errorObj.name = "JSCDK_ERROR_LOGOFF_POOL_FAILED";
      if (launchItemTypeIsDesktop) {
         errorMessage = _util2.default._("This desktop cannot be logged off. Please contact your system administrator.");
      } else {
         errorMessage = _util2.default._("This application cannot be reset. Please contact your system administrator.");
      }
      _router2.default.prototype.pushSelfDefinedError(errorObj, errorMessage);
   }
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.requestLastActiveTimeFromPortal = requestLastActiveTimeFromPortal;
exports.requestLastActiveTimeFromRemoteSession = requestLastActiveTimeFromRemoteSession;
exports.prepareForAlreadyAuthenticated = prepareForAlreadyAuthenticated;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _getTunnelConnectionHandler = __webpack_require__(23);

var _getTunnelConnectionHandler2 = _interopRequireDefault(_getTunnelConnectionHandler);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The method the jscdk can get last user active time from detecting layer
 *
 * The last active time will be returned using async method in
 * timerCtrlCommand
 *
 */
function requestLastActiveTime(ActionName) {
   var requestLastUserActiveTimeAction = {};

   if (!_util2.default.brokerSupportApplication()) {
      return;
   }
   _jscdkLogger2.default.debug("request last active time for:" + ActionName);
   requestLastUserActiveTimeAction.name = ActionName;
   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(requestLastUserActiveTimeAction));
}

/**
 * The method the jscdk can get last user active time from Portal page,
 * i.e. the page before enter desktop page or applications page for both
 * Client.
 */
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * timer-util.js --
 *
 *      common functions for idle timeout.
 *
 */

function requestLastActiveTimeFromPortal() {
   requestLastActiveTime("RequestLastUserActiveTime");
}

/**
 * The method the jscdk can get last user active time from desktop page
 * or
 * applications page for WebClient
 *
 * currently is identical to requestLastActiveTimeFromUI, 'Cause the
 * redirection
 */
function requestLastActiveTimeFromRemoteSession() {
   requestLastActiveTime("RequestLastUserActiveTime");
}

function prepareForAlreadyAuthenticated() {
   var getDesktopsObject = void 0,
       getLaunchItemsObject = void 0,
       getTunnelConnObject = void 0;

   if (!_jscdkClient.globalArray) {
      return;
   }
   /*
    * getDesktops or getLaunchItems depends on getTunnelConnection, but
    * getTunnelConnection's state will be set to StateEnum.DONE in the
    * successive code segment, thus getDesktops or getLaunchItems behaves
    * wrongly to update UI to turn to desktop/items select page. We need to
    * reset data for getDesktops or getLaunchItems to avoid such behavior.
    */
   _jscdkLogger2.default.debug("prepare for already authenticated");
   getDesktopsObject = _jscdkClient.globalArray["get-desktops"];
   if (!!getDesktopsObject) {
      getDesktopsObject.resetData();
   }

   getLaunchItemsObject = _jscdkClient.globalArray["get-launch-items"];
   if (!!getLaunchItemsObject) {
      getLaunchItemsObject.resetData();
   }

   // Get GetTunnelConnectionHandler
   getTunnelConnObject = _jscdkClient.globalArray["get-tunnel-connection"];
   if (!!getTunnelConnObject) {
      // Update the state of GetTunnelConnectionHandler to DONE to fake
      // sending success
      getTunnelConnObject.setState(_messageHandler.StateEnum.DONE);
   } else {
      // The existence of GetTunnelConnectionHandler
      // is required when already authenticated.
      getTunnelConnObject = new _getTunnelConnectionHandler2.default();
      _jscdkClient.globalArray[getTunnelConnObject.messageName] = getTunnelConnObject;
      _jscdkClient.globalArray[getTunnelConnObject.responseTag] = getTunnelConnObject;
      // Update the state of GetTunnelConnectionHandler to DONE to fake
      // sending success
      getTunnelConnObject.setState(_messageHandler.StateEnum.DONE);
   }
}

/***/ }),
/* 26 */
/***/ (function(module, exports) {

var path = 'common/commondialog/dialog_service_confirm.html';
var html = "<div class=\"dialog-title\">{{ngDialogData.title}}</div>\n<div class=\"dialog-content\">\n   <div class=\"session-ops-window-text\">{{ngDialogData.message}}</div>\n   <div id=\"session-ops-warning-no-ft\" class=\"session-ops-window-text warning\" ng-show=\"ngDialogData.showWarning && !ngDialogData.isTransferringFile && !ngDialogData.isTransferringPrintFile\">{{'UNSAVED_WORK_M' | i18n}}</div>\n   <div id=\"session-ops-warning-ft\" class=\"session-ops-window-text warning\" ng-show=\"ngDialogData.showWarning && ngDialogData.isTransferringFile && !ngDialogData.isTransferringPrintFile\">{{'UNSAVED_WORK_FT_M' | i18n}}</div>\n   <div id=\"session-ops-warning-print\" class=\"session-ops-window-text warning\" ng-show=\"ngDialogData.showWarning && !ngDialogData.isTransferringFile && ngDialogData.isTransferringPrintFile\">{{'UNSAVED_WORK_PRINT_M' | i18n}}</div>\n   <div id=\"session-ops-warning-print-ft\" class=\"session-ops-window-text warning\" ng-show=\"ngDialogData.showWarning && ngDialogData.isTransferringFile && ngDialogData.isTransferringPrintFile\">{{'UNSAVED_WORK_PRINT_FT_M' | i18n}}</div>\n</div>\n<div class=\"dialog-button-row\" dialog-tab-scope>\n   <button class=\"modal-button-base modal-button-right modal-button-blue ok-button\" ng-click=\"confirm() || closeThisDialog()\" id=\"okDialogBtn\" dialog-tabindex=\"1\" dialog-prevent-key-up>\n      {{(ngDialogData.buttonLabelConfirm) || ('OK' | i18n)}}\n   </button>\n   <button class=\"modal-button-base modal-button-right modal-button-grey\" ng-click=\"close() || closeThisDialog()\" id=\"cancelDialogBtn\" dialog-tabindex=\"2\" dialog-prevent-key-up>\n      {{(ngDialogData.buttonLabelCancel) || ('CANCEL' | i18n)}}\n   </button>\n</div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _ngDialog = __webpack_require__(9);

var _ngDialog2 = _interopRequireDefault(_ngDialog);

var _usernameUtil = __webpack_require__(105);

var _usernameUtil2 = _interopRequireDefault(_usernameUtil);

var _userglbpref = __webpack_require__(104);

var _userglbpref2 = _interopRequireDefault(_userglbpref);

var _localizeService = __webpack_require__(97);

var _timezone = __webpack_require__(107);

var _uriParamValidator = __webpack_require__(103);

var _uriParamValidator2 = _interopRequireDefault(_uriParamValidator);

var _toastService = __webpack_require__(102);

var _toastService2 = _interopRequireDefault(_toastService);

var _storageService = __webpack_require__(101);

var _storageService2 = _interopRequireDefault(_storageService);

var _safeStorageService = __webpack_require__(100);

var _safeStorageService2 = _interopRequireDefault(_safeStorageService);

var _prefdata = __webpack_require__(99);

var _prefdata2 = _interopRequireDefault(_prefdata);

var _multisiteService = __webpack_require__(98);

var _multisiteService2 = _interopRequireDefault(_multisiteService);

var _dpiService = __webpack_require__(96);

var _dpiService2 = _interopRequireDefault(_dpiService);

var _credentialcleanService = __webpack_require__(95);

var _credentialcleanService2 = _interopRequireDefault(_credentialcleanService);

var _brokerSessionStorageService = __webpack_require__(94);

var _brokerSessionStorageService2 = _interopRequireDefault(_brokerSessionStorageService);

var _baseViewService = __webpack_require__(93);

var _baseViewService2 = _interopRequireDefault(_baseViewService);

var _viewclientModel = __webpack_require__(92);

var _viewclientModel2 = _interopRequireDefault(_viewclientModel);

var _osModel = __webpack_require__(91);

var _osModel2 = _interopRequireDefault(_osModel);

var _connectionUriModel = __webpack_require__(90);

var _connectionUriModel2 = _interopRequireDefault(_connectionUriModel);

var _connectionServerModel = __webpack_require__(89);

var _connectionServerModel2 = _interopRequireDefault(_connectionServerModel);

var _clientidModel = __webpack_require__(88);

var _clientidModel2 = _interopRequireDefault(_clientidModel);

var _blastsessionsModel = __webpack_require__(87);

var _blastsessionsModel2 = _interopRequireDefault(_blastsessionsModel);

var _baseviewclientModel = __webpack_require__(86);

var _baseviewclientModel2 = _interopRequireDefault(_baseviewclientModel);

var _scrollableDialogFuzzyFree = __webpack_require__(84);

var _scrollableDialogFuzzyFree2 = _interopRequireDefault(_scrollableDialogFuzzyFree);

var _scrollableDialog = __webpack_require__(85);

var _scrollableDialog2 = _interopRequireDefault(_scrollableDialog);

var _ws1Service = __webpack_require__(106);

var _ws1Service2 = _interopRequireDefault(_ws1Service);

var _dialogAccessibility = __webpack_require__(83);

var _appConstant = __webpack_require__(82);

var _appConstant2 = _interopRequireDefault(_appConstant);

var _dialogService = __webpack_require__(81);

var _aboutDialogController = __webpack_require__(80);

var _aboutDialogController2 = _interopRequireDefault(_aboutDialogController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import jscdkUIAdapter from './service/jscdk-ui-adapter';
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * Common module which provides many useful services/models.
 */

exports.default = _angular2.default.module('com.vmware.vdi.htmlaccess.common', [_ngDialog2.default]).service('usernameUtil', _usernameUtil2.default).service('userGlobalPref', ['$log', '$rootScope', '$window', 'prefData', _userglbpref2.default]).factory('localize', ['$window', 'viewClientModel', '$rootScope', _localizeService.localize]).filter('i18n', ['localize', _localizeService.i18n]).factory('translate', ['localize', _localizeService.translate]).factory('timezone', ['$window', '$log', 'prefData', _timezone.timezone]).service('URIParamValidator', ['usernameUtil', _uriParamValidator2.default]).service('toastService', _toastService2.default).service('storageService', ['$window', _storageService2.default]).service('safeStorageService', ['$window', _safeStorageService2.default]).factory('prefData', _prefdata2.default).service('multiSiteService', ['$window', _multisiteService2.default])
// .service('jscdkUIAdapter', ['$rootScope', '$q', '$window',
// jscdkUIAdapter])
.factory('dpiService', ['$window', 'constants', 'userGlobalPref', _dpiService2.default]).service('credCleanService', ['$window', 'userGlobalPref', 'viewClientModel', _credentialcleanService2.default]).service('brokerSessionStorageService', ['$window', 'storageService', _brokerSessionStorageService2.default]).service('baseViewService', ['$location', '$timeout', '$window', 'viewClientModel', 'credCleanService', _baseViewService2.default]).factory('viewClientModel', ['$window', 'BaseViewClientModel', 'osModel', 'clientID', 'storageService', _viewclientModel2.default]).factory('osModel', _osModel2.default).service('connectionURIModel', ['storageService', 'usernameUtil', 'viewClientModel', _connectionUriModel2.default]).factory('connectionServerModel', ['$window', _connectionServerModel2.default]).factory('clientID', ['$window', _clientidModel2.default]).service('blastSessionsModel', ['brokerSessionStorageService', _blastsessionsModel2.default]).factory('BaseViewClientModel', ['$rootScope', '$timeout', 'brokerSessionStorageService', 'constants', _baseviewclientModel2.default]).directive('fuzzyFree', ['$rootScope', '$timeout', _scrollableDialogFuzzyFree2.default]).directive('scrollableDialog', ['$window', _scrollableDialog2.default]).directive('dialogTabindex', _dialogAccessibility.dialogTabindex).directive('dialogPreventKeyUp', ['$rootScope', _dialogAccessibility.dialogPreventKeyUp]).directive('dialogTabScope', ['$timeout', _dialogAccessibility.dialogTabScope]).directive('timezoneList', _timezone.timezoneListDirective).constant('constants', _appConstant2.default).config(['ngDialogProvider', _dialogService.ngDialogProvider]).service('dialogService', ['ngDialog', _dialogService.dialogService]).service('ws1Service', ['constants', 'brokerSessionStorageService', 'connectionURIModel', _ws1Service2.default]).controller('AboutDialogCtrl', ['$scope', 'viewClientModel', 'localize', _aboutDialogController2.default]).name;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _fullscreenService = __webpack_require__(34);

var _bitbuffer = __webpack_require__(33);

var _bitbuffer2 = _interopRequireDefault(_bitbuffer);

var _renderCacheService = __webpack_require__(36);

var _renderCacheService2 = _interopRequireDefault(_renderCacheService);

var _vncDecoder = __webpack_require__(37);

var _vncDecoder2 = _interopRequireDefault(_vncDecoder);

var _wmksBaseService = __webpack_require__(38);

var _wmksBaseService2 = _interopRequireDefault(_wmksBaseService);

var _normalizationService = __webpack_require__(35);

var _normalizationService2 = _interopRequireDefault(_normalizationService);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _angular2.default.module('com.vmware.vdi.htmlaccess.desktop.sharedUtil', []).service('fullscreenSubService', ['$window', _fullscreenService.fullscreenSubService]).service('bitBuffer', _bitbuffer2.default).service('renderCacheService', ['bitBuffer', _renderCacheService2.default]).service('normalizationService', _normalizationService2.default).service('fullscreenService', ['$window', '$timeout', 'fullscreenSubService', _fullscreenService.fullscreenService]).service('vncDecoder', ['normalizationService', 'renderCacheService', _vncDecoder2.default]).service('wmksBaseService', ['$window', 'normalizationService', _wmksBaseService2.default]).name; /*********************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            *********************************************************/

/***/ }),
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var StringUtils = function () {
   return {

      /**
       * uint8ArrayToString
       *
       * Helper function used to convert a Uint8Array containing UTF-8 data to a string.
       *
       * @param array   Array to convert.
       * @return        Converted string.
       */
      uint8ArrayToString: function uint8ArrayToString(array) {
         var str = '',
             CHUNK_SZ = 0x8000,
             c = [],
             i = void 0;
         try {
            /*
             * The "apply" method can only handle arrays up to a certain size, so we
             * split the array into large chunks and process them chunk by chunk.
             * The subarray method will safely return the remainder of the array if the
             * upper bound is higher than the array bound.
             */
            for (i = 0; i < array.length; i += CHUNK_SZ) {
               c.push(String.fromCharCode.apply(null, array.subarray(i, i + CHUNK_SZ)));
            }
            str = decodeURIComponent(escape(c.join("")));
         } catch (e) {
            _jscdkLogger2.default.info('uint8ArrayToString failed to parse array with length ' + array.length + ': ' + e);
         }
         return str;
      },

      /**
       * stringToUint8Array
       *
       * Helper function used to convert a string to a Uint8Array.  Note that it is not
       * explicitly null-terminated, so consumers who are using this function to create
       * data to send over the network may need to append '\x00' if the server side is
       * expecting null-terminated string.
       *
       * This will not work for unmatched surrogate halves, but it is good enough for
       * us to use for now.
       *
       * @param string        String to convert.
       * @param nullTerminate Whether to null-terminate the string (unspecified means false).
       * @return              Converted array in UTF-8 form.
       */
      stringToUint8Array: function stringToUint8Array(string, nullTerminate) {
         var i = 0,
             utf8String = void 0,
             array = void 0;

         // Convert from UTF-16 to UTF-8.
         try {
            utf8String = unescape(encodeURIComponent(string));
         } catch (e) {
            _jscdkLogger2.default.error('Failed to convert string to UTF-8 with error: ' + e);
            return new Uint8Array(0);
         }

         // Copy the UTF-8 data to the Uint8Array.
         array = new Uint8Array(utf8String.length + (nullTerminate ? 1 : 0));
         for (i = 0; i < utf8String.length; i++) {
            array[i] = utf8String.charCodeAt(i);
         }

         // null-terminate if necessary.
         if (nullTerminate) {
            array[array.length] = 0;
         }

         return array;
      },

      /**
       * uint8ArrayIndexOf
       *
       * Helper function that does the equivalent of Array indexOf(), but for Uint8Array.
       *
       * @param array         Array to search
       * @param element       Element to search for
       * @param start         Optional start index to search (default is 0).
       * @return              First index of element if found, -1 otherwise.
       */
      uint8ArrayIndexOf: function uint8ArrayIndexOf(array, element, start) {
         var i = void 0;

         if (!(array instanceof Uint8Array) || typeof element !== 'number' || element >= 256 || start === -1) {
            return -1;
         }

         if (start === undefined) {
            start = 0;
         }

         for (i = start; i < array.length; i++) {
            if (array[i] === element) {
               return i;
            }
         }

         return -1;
      },

      /**
       * uint8ArrayTokenize
       *
       * Helper function that retrieves the subarray of a Uint8Array that begins at the
       * specified starting index and ends at first occurrence of the specified array
       * element (exclusive of the index where the element occurs).  If the element isn't
       * found, the rest of the array is returned.
       *
       * @param array         Array to search
       * @param element       Element to search for
       * @param start         Optional start index to search (default is 0).
       * @return              Object containing:
       *                       .index: First index of element if found, -1 otherwise.
       *                       .result: Subarray as mentioned in function description.
       */
      uint8ArrayTokenize: function uint8ArrayTokenize(array, element, start) {
         var index = void 0,
             resultArray = void 0;

         start = start || 0;

         index = StringUtils.uint8ArrayIndexOf(array, element, start);
         resultArray = array.subarray(start, index);

         return { 'index': index, 'result': resultArray };
      }
   };
}(); /*********************************************************
      * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
      *********************************************************/

/**
 * string-utils.js
 *
 * Utility functions for converting between JavaScript strings and
 * uint8Arrray objects.
 **/

exports.default = StringUtils;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = bitBuffer;
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * bitbuffer.js -- bitBuffer
 *
 * Service to generate bitBuffer instance.
 */

function bitBuffer() {
   var BitBuffer = function BitBuffer(buffer, size) {
      this._buf = buffer;
      this._size = size;
      this._readCount = 0;
      this._overflow = false;
      this._thisByte = 0;
      this._thisByteBits = 0;
   };

   BitBuffer.prototype.readBits0 = function (val, nr) {
      var mask = void 0;

      if (this._bits < nr) {
         this._overflow = true;
         return -1;
      }

      mask = ~(0xff >> nr); /* ones in the lower 'nr' bits */
      val <<= nr; /* move output value up to make space */
      val |= (this._thisByte & mask) >> 8 - nr;
      this._thisByte <<= nr;
      this._thisByte &= 0xff;
      this._thisByteBits -= nr;

      return val;
   };

   BitBuffer.prototype.readBits = function (nr) {
      var origNr = nr;
      var val = 0;

      if (this._overflow) {
         return 0;
      }

      while (nr > this._thisByteBits) {
         nr -= this._thisByteBits;
         val = this.readBits0(val, this._thisByteBits);

         if (this._readCount < this._size) {
            this._thisByte = this._buf[this._readCount++];
            this._thisByteBits = 8;
         } else {
            this._thisByte = 0;
            this._thisByteBits = 0;
            if (nr > 0) {
               this._overflow = true;
               return 0;
            }
         }
      }

      val = this.readBits0(val, nr);
      return val;
   };

   BitBuffer.prototype.readEliasGamma = function () {
      var l = 0;
      var value = void 0;
      var bit = void 0;
      var origidx = this._readCount;
      var origbit = this._thisByteBits;

      while (!this._overflow && (bit = this.readBits(1)) === 0) {
         l++;
      }

      value = 1 << l;

      if (l) {
         value |= this.readBits(l);
      }

      return value;
   };
   return {
      newInstance: function newInstance(buffer, size) {
         return new BitBuffer(buffer, size);
      }
   };
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.fullscreenSubService = fullscreenSubService;
exports.fullscreenService = fullscreenService;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * fullscreen-service.js -- fullscreenService
 *
 * "sharedUtilModule" will shared among modules.
 * functions like this and logger should also be added in this place
 * to share among all modules like for launcher, appblast, mulitmon,
 * rtav, etc...
 *
 * Service to control the fullscreen related logic, only support one
 * listener for event, and extenable to the many version.
 */

function fullscreenSubService($window) {
   this.isFullscreen = function () {
      return !($window.document.fullScreenElement !== undefined && $window.document.fullScreenElement === null || $window.document.msFullscreenElement !== undefined && $window.document.msFullscreenElement === null || $window.document.mozFullScreen !== undefined && !$window.document.mozFullScreen || $window.document.webkitIsFullScreen !== undefined && !$window.document.webkitIsFullScreen);
   };

   /**
    * Will execute the callback when either waitTime reached or condition is
    *    satisfied
    * @param  {function} condition The condition function, which once return
    *    true, will trigger the execution of callback
    * @param  {function} callback The callback function will be processed
    *    sooner
    *    or later.
    * @param  {number} waitMaxTime The max wait time in ms
    */
   this.waitCondition = function (condition, callback, waitMaxTime) {
      var waitTime = waitMaxTime || 3000,
          //ms
      checkInterval = 100,
          //ms
      checkFunction = void 0,
          waitTimer = void 0;

      checkFunction = function checkFunction() {
         waitTime -= checkInterval;
         if (condition() || waitTime <= 0) {
            callback();
            clearInterval(waitTimer);
         }
      };

      if (condition()) {
         callback();
      } else {
         waitTimer = setInterval(checkFunction, checkInterval);
      }
   };
}

/**
 * Control the full screen related logic, since chrome will take time to update
 * the property value on some version, add waitTime as 500ms to avoid using
 * corrupted properties.
 */
function fullscreenService($window, $timeout, fullscreenSubService) {
   var fullscreenHandler = {},
       onFullscreenChanged = void 0,
       isFullscreen = fullscreenSubService.isFullscreen,
       waitCondition = fullscreenSubService.waitCondition,
       waitTime = 500;

   onFullscreenChanged = function onFullscreenChanged(event) {
      console.info("full screen changed");
      if (isFullscreen()) {
         console.info("enter full screen");
         if (!fullscreenHandler || typeof fullscreenHandler.onEnterFullscreen !== "function") {
            console.error("found no handler");
            return;
         }
         waitCondition(function () {
            /**
             * Use tolerent to avoid delay before entering fullscreen on some
             * machines since chrome has bug on some machines to support screenX
             * https://drafts.csswg.org/cssom-view/#dom-window-screenx
             */
            var tolerent = 10;
            return screenX <= screen.availLeft + tolerent && screenY <= screen.availTop + tolerent;
         }, function () {
            $timeout(fullscreenHandler.onEnterFullscreen, waitTime);
         });
      } else {
         console.info("exit full screen");
         if (!fullscreenHandler || typeof fullscreenHandler.onExitFullscreen !== "function") {
            console.error("found no handler");
            return;
         }
         /**
          * Specify the wait time here to avoid a chrome bug on "screen", which
          * in corner cases violates the spec:
          * https://developer.mozilla.org/en-US/docs/Web/API/Screen/availLeft
          */
         waitCondition(function () {
            return screenX >= screen.availLeft && screenY >= screen.availTop;
         }, fullscreenHandler.onExitFullscreen, waitTime);
      }
   };
   return {
      enterFullscreen: function enterFullscreen(elem) {
         if (isFullscreen()) {
            return;
         }
         if (elem.requestFullScreen) {
            elem.requestFullScreen();
         } else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
         } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen(elem.ALLOW_KEYBOARD_INPUT);
         } else if (elem.webkitRequestFullScreen) {
            elem.webkitRequestFullScreen(elem.ALLOW_KEYBOARD_INPUT);
         } else if (elem.msRequestFullscreen) {
            elem.msRequestFullscreen();
         } else {
            console.error("fail to max the screen");
         }
      },
      exitFullscreen: function exitFullscreen() {
         if (isFullscreen()) {
            if ($window.document.exitFullscreen) {
               $window.document.exitFullscreen();
            } else if ($window.document.msExitFullscreen) {
               $window.document.msExitFullscreen();
            } else if ($window.document.mozCancelFullScreen) {
               $window.document.mozCancelFullScreen();
            } else if ($window.document.webkitExitFullscreen) {
               $window.document.webkitExitFullscreen();
            } else {
               console.error("fail to cancel maximizing the screen");
            }
         }
      },
      onEnterFullscreen: function onEnterFullscreen(callback) {
         fullscreenHandler.onEnterFullscreen = callback;
      },
      onExitFullscreen: function onExitFullscreen(callback) {
         fullscreenHandler.onExitFullscreen = callback;
      },
      bindFullScreen: function bindFullScreen() {
         $(document).on('webkitfullscreenchange mozfullscreenchange ' + 'fullscreenchange MSFullscreenChange', onFullscreenChanged);
      },
      unbindFullScreen: function unbindFullScreen() {
         $(document).off('webkitfullscreenchange mozfullscreenchange ' + 'fullscreenchange MSFullscreenChange', onFullscreenChanged);
      }
   };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = normalizationService;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * normalization-service.js -- normalizationService
 *
 * 3+ monitor support is not added in the 17Q2
 * And only support same DPI for now, checkpoint tracking has not been adapted yet.
 */

function normalizationService() {
   this._perMonitorMode = false;

   this.clear = function () {
      this._rawSetting = {};
      this._normalizationModel = null;
      this._normalizedSettings = {};
      this._defaultModel = {};
      this._agentDPI = 1.0;
      this._DPIEnabled = true;
   };
   this.clear();

   this.setAgentDPI = function (dpi) {
      this._agentDPI = dpi;
   };

   /**
    * To fully enable this, the segment mouse map is needed, which is simple but
    * will not be done in 17q2 since we adapt the per system to reduce the
    * chance of meeting bug 1847196 when using multimon.
    */
   this.setPerMonitor = function (usePerMonitor) {
      this._perMonitorMode = !!usePerMonitor;
   };

   this.isPerMonitorMode = function () {
      return this._perMonitorMode;
   };

   /**
    * Returns the scale factor, which is depending the defination of "High
    * Resolution" option
    * Now using agent DPI scale, since the final design is so, and logic for
    * single monitor also get changed accordingly.
    */
   this.getFactor = function (id) {
      var baseDPI = this._rawSetting['0'].devicePixelRatio,
          monitorDPI = this._rawSetting[id].devicePixelRatio,
          compensateFactor = this._perMonitorMode ? 1 : monitorDPI / baseDPI,
          clientFactor = this._DPIEnabled ? compensateFactor : monitorDPI;

      return clientFactor * this._agentDPI;
   };

   /**
    * To indicate whether the DPI Sync is enabled or not, and DPI sync here is
    * defined as "using client DPI scale if enabled, use native pixel if not".
    * @param {boolean} enabled
    */
   this.setDPISync = function (enabled) {
      this._DPIEnabled = enabled;
   };

   /**
    * Returns the param to normalize target to refer
    * @param  {object} target
    * @param  {object} refer
    * @param  {object} k
    * @return {object}
    */
   this._getNormalizationParam = function (target, refer, k) {
      var param = {
         k: k,
         tx: refer.x - k * target.x,
         ty: refer.y - k * target.y
      };
      return param;
   };

   /**
    * After 17Q2, if want to support different DPI, the segment model should be
    * used.
    * @param  {object} point The source point
    * @param  {object} model The model
    * @return {object} This returns the point in the model
    */
   this.normalize = function (point, model) {
      if (!this._defaultModel) {
         return point;
      }
      if (!model) {
         model = this._defaultModel;
      }
      return {
         x: Math.round(point.x * model.k + model.tx),
         y: Math.round(point.y * model.k + model.ty)
      };
   };

   /**
    * revert the point back to normal using the identical model
    * @param  {object} point
    * @param  {object} model
    * @return {object}
    */
   this.revert = function (point, model) {
      if (!this._defaultModel) {
         return point;
      }
      if (!model) {
         model = this._defaultModel;
      }
      return {
         x: Math.round((point.x - model.tx) / model.k),
         y: Math.round((point.y - model.ty) / model.k)
      };
   };

   /**
    * Since we only support 2 monitors this function need no param, and will
    * return the stable point compare with rawSetting[0]
    *
    * Using this way, we will have bug 1834512, but we will not fix it for 17Q2,
    * Using the dragging detection before entering multimon can fix it, but need
    *    new UI and workflow.
    *
    * Written in the readable way instead of with the simpliest logic.
    *
    * @return {object} The top or left point in the line segment of the sharing
    *    Edge.
    */
   this._getStablePoint = function (id) {
      var baseId = '0',
          isLeft = this._rawSetting[id].x + this._rawSetting[id].width <= this._rawSetting[baseId].x,
          isRight = this._rawSetting[id].x >= this._rawSetting[baseId].x + this._rawSetting[baseId].width,
          isTop = this._rawSetting[id].y + this._rawSetting[id].height <= this._rawSetting[baseId].y,
          isDown = this._rawSetting[id].y >= this._rawSetting[baseId].y + this._rawSetting[baseId].height;

      if (isLeft) {
         return {
            x: this._rawSetting[baseId].x,
            y: Math.max(this._rawSetting[baseId].y, this._rawSetting[id].y)
         };
      } else if (isTop) {
         return {
            x: Math.max(this._rawSetting[baseId].x, this._rawSetting[id].x),
            y: this._rawSetting[baseId].y
         };
      } else if (isRight) {
         return {
            x: this._rawSetting[id].x,
            y: Math.max(this._rawSetting[baseId].y, this._rawSetting[id].y)
         };
      } else {
         return {
            x: Math.max(this._rawSetting[baseId].x, this._rawSetting[id].x),
            y: this._rawSetting[id].y
         };
      }
   };

   /**
    * Generate the model
    * In 17Q2 only enable 2 monitors, or a tree grow shall be used.
    */
   this._generateModel = function () {
      var key = void 0;
      this._normalizationModel = {};
      this._normalizationModel['0'] = this._getNormalizationParam({
         x: this._rawSetting['0'].x,
         y: this._rawSetting['0'].y
      }, {
         x: 0,
         y: 0
      }, this.getFactor(0));

      for (key in this._rawSetting) {
         if (this._rawSetting.hasOwnProperty(key) && key !== "0") {
            var stablePoint = this._getStablePoint(key);
            this._normalizationModel[key] = this._getNormalizationParam(stablePoint, this.normalize(stablePoint, this._normalizationModel['0']), this.getFactor(Number(key)));
         }
      }
   };

   this._calculateNormalizedSetting = function () {
      var key = void 0,
          startPoint = void 0;

      this._normalizedSettings = {};
      for (key in this._rawSetting) {
         if (this._rawSetting.hasOwnProperty(key) && this._normalizationModel.hasOwnProperty(key)) {
            startPoint = this.normalize(this._rawSetting[key], this._normalizationModel[key]);
            this._normalizedSettings[key] = {
               x: startPoint.x,
               y: startPoint.y,
               width: Math.round(this._rawSetting[key].width * this.getFactor(key)),
               height: Math.round(this._rawSetting[key].height * this.getFactor(key)),
               isModified: this.getFactor(key) !== 1
            };
         }
      }
   };

   /**
    * Avoid bug 1860710, since width need to be even for RDSH.
    */
   this._clipSettings = function () {
      var key = void 0;
      for (key in this._normalizedSettings) {
         if (this._normalizedSettings.hasOwnProperty(key)) {
            if (this._normalizedSettings[key].x % 2 !== 0) {
               this._normalizedSettings[key].x--;
               if (this._normalizedSettings[key].width % 2 !== 0) {
                  this._normalizedSettings[key].width++;
               }
            } else {
               if (this._normalizedSettings[key].width % 2 !== 0) {
                  this._normalizedSettings[key].width--;
               }
            }
         }
      }
   };

   this.setScreenModel = function (model) {
      this._defaultModel = model;
   };

   /**
    * Set the raw setting gathered from browser, currently only enable for chrome
    * @param {number} id
    * @param {object} setting
    */
   this.setRawSetting = function (id, setting) {
      this._rawSetting[id] = setting;
   };

   /**
    * Set the raw setting gathered from browser, currently only enable for chrome
    * @param {number} id
    * @param {object} setting
    */
   this.removeRawSetting = function (id) {
      delete this._rawSetting[id];
   };

   /**
    * Using the previous input data to calculate and derive the model and setting
    */
   this.calculate = function () {
      this._generateModel();
      this._calculateNormalizedSetting();
      this._clipSettings();
   };

   /**
    * Get the derived model
    * @return {object}
    */
   this.getNormalizationModel = function () {
      return this._normalizationModel;
   };

   /**
    * Get the derived normalized settings
    * @return {object}
    */
   this.getNormalizedSettings = function () {
      return this._normalizedSettings;
   };

   this.getSizeFactor = function (id) {
      return this._normalizationModel[id].k;
   };

   this.isScaleMismatched = function () {
      if (!this._rawSetting['0'] || this._rawSetting['0'].devicePixelRatio === undefined) {
         return false;
      }

      for (var key in this._rawSetting) {
         if (key !== '0' && this._rawSetting.hasOwnProperty(key) && this._rawSetting['0'].devicePixelRatio !== this._rawSetting[key].devicePixelRatio) {
            return true;
         }
      }
      return false;
   };
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = renderCacheService;
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * render-cache-service.js -- renderCacheService
 *
 * Service to handle cache for rendering.
 */

function renderCacheService(bitBuffer) {
   this.decodeToCacheEntry = -1;
   this.updateCache = [];
   this.updateCacheEntries = 0;
   this.cacheOperationType = {
      updateCacheOpInit: 0,
      updateCacheOpBegin: 1,
      updateCacheOpEnd: 2,
      updateCacheOpReplay: 3
   };

   this.fail = function (message) {
      console.error(message);
      return false;
   };

   this.releaseImage = function (rect) {
      if (!!rect.image) {
         if (typeof rect.image.close === "function") {
            rect.image.close();
         }
         delete rect.image;
      }
      if (!!rect.data) {
         delete rect.data;
      }
   };
   /*
    *------------------------------------------------------------------------------
    *
    * _evictUpdateCacheEntry
    *
    *    Evict one entry from the update cache.  This is done in response
    *    to the payload of the Begin opcode as well as the destination
    *    slot of the Begin opcode.
    *
    * Results:
    *    None.
    *
    *------------------------------------------------------------------------------
    */

   this._evictUpdateCacheEntry = function (slot) {

      this.releaseImage(this.updateCache[slot]);

      this.updateCache[slot] = {};
      this.updateCache[slot].image = null;
   };

   /*
    *----------------------------------------------------------------------------
    *
    * _executeUpdateCacheInit --
    *
    *      Handle the UPDATE_CACHE_OP_INIT subcommand.  This resets the
    *      cache, evicting all entries and resets the cache sizes and
    *      flags.  The sizes and flags must be a subset of those which
    *      the client advertised in the capability packet.
    *
    * Results:
    *      None.
    *
    * Side effects:
    *      Resets update cache.
    *
    *----------------------------------------------------------------------------
    */

   this._executeUpdateCacheInit = function (rect) {
      var i = void 0;

      for (i = 0; i < this.updateCacheEntries; i++) {
         this._evictUpdateCacheEntry(i);
      }

      this.updateCache = [];
      this.updateCacheEntries = rect.updateCacheEntries;

      for (i = 0; i < this.updateCacheEntries; i++) {
         this.updateCache[i] = {};
         this.updateCache[i].image = null;
      }
   };

   /*
    *----------------------------------------------------------------------------
    *
    * _updateCacheInsideBeginEnd --
    *
    *      Returns true if the decoder has received in the current
    *      framebuffer update message a VNC_UPDATECACHE_OP_BEGIN message
    *      but not yet received the corresponding OP_END.
    *
    * Side effects:
    *      None.
    *
    *----------------------------------------------------------------------------
    */

   this._updateCacheInsideBeginEnd = function () {
      return this.decodeToCacheEntry !== -1;
   };

   /*
    *----------------------------------------------------------------------------
    *
    * _updateCacheInitialized --
    *
    *      Returns true if the decoder has been configured to have an
    *      active UpdateCache and the cache size negotiation has
    *      completed..
    *
    * Side effects:
    *      None.
    *
    *----------------------------------------------------------------------------
    */

   this._updateCacheInitialized = function () {
      return this.updateCacheEntries !== 0;
   };

   /*
    *----------------------------------------------------------------------------
    *
    * _executeUpdateCacheBegin --
    *
    *      Handle the UPDATE_CACHE_OP_BEGIN subcommand.  Process the
    *      message payload, which is a mask of cache entries to evict.
    *      Evict any existing entry at the destination slot, and create a
    *      new entry there.
    *
    * Results:
    *      None.
    *
    * Side effects:
    *      Evicts elements of the update cache.
    *      Creates a new cache entry.
    *
    *----------------------------------------------------------------------------
    */

   this._executeUpdateCacheBegin = function (rect) {
      var maskBitBuf = void 0,
          maskState = void 0,
          maskCount = void 0,
          i = void 0,
          j = void 0;

      if (!this._updateCacheInitialized()) {
         return false;
      }

      if (this._updateCacheInsideBeginEnd() || rect.slot >= this.updateCacheEntries) {
         return this.fail("error: cache status wrong for cache begin");
      }

      maskBitBuf = bitBuffer.newInstance(rect.data, rect.dataLength);
      maskState = !maskBitBuf.readBits(1);
      maskCount = 0;
      j = 0;

      do {
         maskCount = maskBitBuf.readEliasGamma();
         maskState = !maskState;

         if (maskState) {
            for (i = 0; i < maskCount && i < this.updateCacheEntries; i++) {
               this._evictUpdateCacheEntry(i + j);
            }
         }

         j += maskCount;
      } while (j < this.updateCacheEntries && !maskBitBuf.overflow);

      this.decodeToCacheEntry = rect.slot;
      this._evictUpdateCacheEntry(rect.slot);

      this.updateCache[this.decodeToCacheEntry].imageWidth = rect.width;
      this.updateCache[this.decodeToCacheEntry].imageHeight = rect.height;
      return true;
   };

   /*
    *----------------------------------------------------------------------------
    *
    * _executeUpdateCacheEnd --
    *
    *      Handle the UPDATE_CACHE_OP_END subcommand.  Process the
    *      message payload, which is a serialized bitmask of screen
    *      regions to scatter the update image to.
    *
    * Results:
    *      None.
    *
    * Side effects:
    *      Draws to the canvas.
    *
    *----------------------------------------------------------------------------
    */
   this._executeUpdateCacheEnd = function (rect, offset) {
      if (!this._updateCacheInitialized()) {
         return false;
      }
      if (!this._updateCacheInsideBeginEnd()) {
         return this.fail("error: cache status wrong for cache end");
      }
      var update = this.updateCache[this.decodeToCacheEntry],
          state = void 0,
          count = void 0,
          dstx = 0,
          dsty = 0,
          dstw = Math.ceil(rect.width / 16),
          dsth = Math.ceil(rect.height / 16),
          srcx = 0,
          srcy = 0,
          srcw = update.imageWidth / 16,
          srch = update.imageHeight / 16,
          availwidth = void 0,
          bitbuf = void 0,
          targetPoint = void 0;

      if (!this._updateCacheInitialized() || !this._updateCacheInsideBeginEnd() || rect.slot !== this.decodeToCacheEntry || rect.slot >= this.updateCacheEntries) {
         return this.fail("error: requested cache slot invalid");
      }

      update.encodedMaskRect = {
         x: rect.x,
         y: rect.y,
         width: rect.width,
         height: rect.height
      };
      update.mask = rect.data;
      update.maskLength = rect.dataLength;

      bitbuf = bitBuffer.newInstance(update.mask, update.maskLength);
      state = !bitbuf.readBits(1);
      count = 0;

      do {
         if (count === 0) {
            count = bitbuf.readEliasGamma();
            state = !state;
         }

         availwidth = Math.min(srcw - srcx, dstw - dstx);
         availwidth = Math.min(availwidth, count);

         if (state) {
            targetPoint = this.vncDecoder._normalize({
               x: rect.x + dstx * 16,
               y: rect.y + dsty * 16
            }, offset);
            // Don't worry if we don't have a full 16-wide mcu at the
            // screen edge.  The canvas will trim the drawImage
            // coordinates for us.
            //
            this.vncDecoder._context.drawImage(update.image, srcx * 16, srcy * 16, availwidth * 16, 16, targetPoint.x, targetPoint.y, availwidth * 16, 16);

            srcx += availwidth;
            if (srcx === srcw) {
               srcx = 0;
               srcy++;
            }
         }

         dstx += availwidth;
         if (dstx === dstw) {
            dstx = 0;
            dsty++;
         }

         count -= availwidth;
      } while (dsty < dsth && !bitbuf._overflow);

      this.decodeToCacheEntry = -1;
      return true;
   };

   /*
    *----------------------------------------------------------------------------
    *
    * _executeUpdateCacheReplay --
    *
    *      Handle the UPDATE_CACHE_OP_REPLAY subcommand.  Process the
    *      message payload, which is a serialized mask used to subset the
    *      bitmask provided at the time the cache entry being replayed
    *      was created.  Scatters the specified subset of the cached
    *      image to the canvas.
    *
    * Results:
    *      None.
    *
    * Side effects:
    *      Draws to the canvas.
    *
    *----------------------------------------------------------------------------
    */

   this._executeUpdateCacheReplay = function (rect, offset) {
      if (!this._updateCacheInitialized()) {
         return false;
      }

      if (rect.slot >= this.updateCacheEntries) {
         return this.fail("error: requested cache slot invalid");
      }

      if (!this.updateCache[rect.slot] || !this.updateCache[rect.slot].encodedMaskRect) {
         return this.fail("error: requested cache slot data invalid");
      }

      var update = this.updateCache[rect.slot],
          encodedMaskRect = this.updateCache[rect.slot].encodedMaskRect,
          dstx = 0,
          dsty = 0,
          dstw = Math.ceil(encodedMaskRect.width / 16),
          dsth = Math.ceil(encodedMaskRect.height / 16),
          availwidth = void 0,
          srcx = 0,
          srcy = 0,
          srcw = update.imageWidth / 16,
          srch = update.imageHeight / 16,
          targetPoint = void 0,
          maskBitBuf = bitBuffer.newInstance(rect.data, rect.dataLength),
          updateBitBuf = bitBuffer.newInstance(update.mask, update.maskLength),
          updateState = !updateBitBuf.readBits(1),
          updateCount = 0,
          maskState = !maskBitBuf.readBits(1),
          maskCount = 0;

      if (!this._updateCacheInitialized() || this._updateCacheInsideBeginEnd() || rect.slot >= this.updateCacheEntries) {
         return this.fail("");
      }

      do {
         if (updateCount === 0) {
            updateCount = updateBitBuf.readEliasGamma();
            updateState = !updateState;
         }
         if (maskCount === 0) {
            maskCount = maskBitBuf.readEliasGamma();
            maskState = !maskState;
         }

         availwidth = dstw - dstx;
         availwidth = Math.min(availwidth, updateCount);

         if (updateState) {
            availwidth = Math.min(availwidth, srcw - srcx);
            availwidth = Math.min(availwidth, maskCount);

            if (maskState) {
               targetPoint = this.vncDecoder._normalize({
                  x: encodedMaskRect.x + dstx * 16,
                  y: encodedMaskRect.y + dsty * 16
               }, offset);
               // Don't worry if the right/bottom blocks are not
               // 16-pixel, the canvas will trim the drawImage dimesions
               // for us.
               if (true) {
                  this.vncDecoder._context.drawImage(update.image, srcx * 16, srcy * 16, availwidth * 16, 16, targetPoint.x, targetPoint.y, availwidth * 16, 16);
               }

               if (false) {
                  this._lighten(targetPoint.x, targetPoint.y, availwidth * 16, 16, "red");
               }
            }

            srcx += availwidth;
            if (srcx === srcw) {
               srcx = 0;
               srcy++;
            }

            maskCount -= availwidth;
         }

         dstx += availwidth;
         if (dstx === dstw) {
            dstx = 0;
            dsty++;
         }

         updateCount -= availwidth;
      } while (dsty < dsth && !maskBitBuf._overflow && !updateBitBuf._overflow);
      return true;
   };

   this._lighten = function (x, y, w, h, color) {
      this.vncDecoder._context.globalCompositeOperation = "lighten";
      this.vncDecoder._context.fillStyle = color;
      this.vncDecoder._context.fillRect(x, y, w, h);
      this.vncDecoder._context.globalCompositeOperation = "source-over";
   };

   /*
    *------------------------------------------------------------------------------
    *
    * _executeUpdateCacheReplay
    *
    *    Dispatch the updateCache commands according to their opcode.
    *    data is in various length as maskLength
    *
    * Results:
    *    None.
    *
    * Side Effects:
    *    None.
    *
    *------------------------------------------------------------------------------
    */

   this.operateOnCache = function (rect, offset) {
      switch (rect.opcode) {
         case this.cacheOperationType.updateCacheOpInit:
            this._executeUpdateCacheInit(rect);
            break;
         case this.cacheOperationType.updateCacheOpBegin:
            this._executeUpdateCacheBegin(rect);
            break;
         case this.cacheOperationType.updateCacheOpEnd:
            this._executeUpdateCacheEnd(rect, offset);
            break;
         case this.cacheOperationType.updateCacheOpReplay:
            this._executeUpdateCacheReplay(rect, offset);
            break;
         default:
            return this.fail("error: requested cache opcode invalid");
      }
   };
   this.setImage = function (rect) {
      this.updateCache[this.decodeToCacheEntry].image = rect.image;
   };
   this.setVncDecoder = function (decoder) {
      this.vncDecoder = decoder;
   };
   this.decodingCache = function () {
      return this.decodeToCacheEntry !== -1;
   };
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = vncDecoder;
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * vnc-decoder.js -- vncDecoder
 *
 * Service to get a VNC decoder
 * This file is needed since we want to fix bug 1797231 and unblock the release
 * of multimon feature, so the changes that should be done in 17Q2 after
 * completing the split of the vnc decoder from the wmks is move in 17Q1, thus
 * this file is incompleted and reduandant with the one in the wmks.
 *
 * In another words, the one in wmks will work for single monitor as before,
 * while this one will work for multimon, and we plan to merger them later.
 *
 * And why this can fix the crash issue is for we pass the non-rendered VNC messages
 * around instead of the whole screen image, which save a lot of memory alloc
 * and free.
 */

function vncDecoder(normalizationService, renderCacheService) {
   this._canvas = null;
   this._context = null;
   this.encodingTypes = {
      encCopyRect: 0x01,
      encTightPNG: -260,
      encUpdateCache: 127 + 0x574d5600,
      //sub encodings
      subEncFill: 0x80
   };

   this._screenBase = {
      x: 0,
      y: 0
   };

   /**
    * Chrome on some windows machine has bug, e.g. the screenX, screenY on the
    * problem machine return 3844, 1924 after using fullscreen, while the true
    * value on the system setting is 3840 and 1920
    * use Math.min(screen.availLeft, screeX) to bypass come this bug according
    * to spec:
    * https://drafts.csswg.org/cssom-view/#dom-window-screenx
    */
   this.initScreen = function () {
      if (screen.availLeft !== undefined && screen.availTop !== undefined) {
         this._screenBase = normalizationService.normalize({
            x: Math.min(screenX, screen.availLeft),
            y: Math.min(screenY, screen.availTop)
         });
      } else {
         this._screenBase = normalizationService.normalize({
            x: screenX,
            y: screenY
         });
      }
   };

   this._normalize = function (p, offset) {
      return {
         x: p.x - offset.x - this._screenBase.x,
         y: p.y - offset.y - this._screenBase.y
      };
   };

   this._copyRectBlit = function (srcX, srcY, width, height, dstX, dstY) {
      this._backgroundContext.drawImage(this._canvas, srcX, srcY, width, height, srcX, srcY, width, height);
      this._context.drawImage(this._backgroundCanvas, srcX, srcY, width, height, dstX, dstY, width, height);
   };

   this._fillRectWithColor = function (x, y, width, height, color) {
      var newStyle = void 0,
          canvas2dCtx = this._context;
      newStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
      canvas2dCtx.fillStyle = newStyle;
      canvas2dCtx.fillRect(x, y, width, height);
   };

   this._renderImage = function (rect, offset) {
      var p = this._normalize({
         x: rect.x,
         y: rect.y
      }, offset);
      try {
         this._context.drawImage(rect.image, p.x, p.y);
      } catch (e) {
         console.error(e);
      }
   };

   this.setCanvas = function (canvas) {
      var size = {
         width: canvas.width,
         height: canvas.height
      };
      this._canvas = canvas;
      this._context = this._canvas.getContext('2d');
      if (!!this._backgroundCanvasObject) {
         this._backgroundCanvasObject.remove();
      }
      this._backgroundCanvasObject = $('<canvas/>').css({
         position: 'absolute'
      });
      this._backgroundCanvasObject.attr(size).css(size);
      this._backgroundCanvas = this._backgroundCanvasObject[0];
      this._backgroundContext = this._backgroundCanvas.getContext('2d');
      renderCacheService.setVncDecoder(this);
   };

   this.onDPIChanged = function (canvas) {
      var size = {
         width: canvas.width,
         height: canvas.height
      };
      this._backgroundCanvasObject.attr(size);
   };

   /**
    * The function to render a rect, which include a special one as End of Frame
    *    indicate the end of async rendering is done.
    * @param  {object} rect The object including data
    * @param  {object} offset The screen offset information
    * @param  {function} onRenderDone The callback for finish rendering, accept no param
    */
   this.render = function (rect, offset, onRenderDone) {
      var pSrc, p;
      switch (rect.encoding) {
         case this.encodingTypes.encCopyRect:
            pSrc = this._normalize({
               x: rect.srcX,
               y: rect.srcY
            }, offset);
            p = this._normalize({
               x: rect.x,
               y: rect.y
            }, offset);
            this._copyRectBlit(pSrc.x, pSrc.y, rect.width, rect.height, p.x, p.y);
            break;
         case this.encodingTypes.encTightPNG:
            if (rect.subEncoding === this.encodingTypes.subEncFill) {
               p = this._normalize({
                  x: rect.x,
                  y: rect.y
               }, offset);
               this._fillRectWithColor(p.x, p.y, rect.width, rect.height, rect.color);
            } else if (renderCacheService.decodingCache()) {
               renderCacheService.setImage(rect, offset);
            } else {
               this._renderImage(rect, offset);
               this.releaseRectData(rect);
            }
            break;
         case this.encodingTypes.encUpdateCache:
            renderCacheService.operateOnCache(rect, offset);
            break;
         default:
            /**
             * can't use Logger since the commen Logger service is still not
             * completed after page merging
             */
            console.error("unsupported encoding type found for multimon");
            break;
      }

      /**
       * similar timeout also exist in wmks to allow canvas to render, and
       * here it's mainly for GC
       */
      setTimeout(onRenderDone, 1);
   };

   this.releaseRectData = renderCacheService.releaseImage;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = wmksBaseService;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * wmks-base-service.js -- wmksBaseService
 *
 * This hold the getEventPosition function, which currently not support retina,
 * later would add more logic and function in.
 */

function wmksBaseService($window, normalizationService) {
   this.getEventPosition = function (event, offset) {
      var docX = void 0,
          docY = void 0,
          defaultPosition = {
         x: 0,
         y: 0
      },
          normalizedPosition = void 0;

      if (!offset || !event) {
         return defaultPosition;
      }
      if (event.pageX || event.pageY) {
         docX = event.pageX;
         docY = event.pageY;
      } else if (event.clientX || event.clientY) {
         docX = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
         docY = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
      } else {
         return defaultPosition;
      }
      normalizedPosition = normalizationService.normalize({
         x: docX + screenX,
         y: docY + screenY
      });
      return {
         x: normalizedPosition.x + offset.x,
         y: normalizedPosition.y + offset.y
      };
   };
   /**
    * Add this workaround check to avoid a bug happens by chance of
    * wrong screenX, where the offset is added with a extra number,
    * and the availLeft is correct when this bug happens without the
    * positive extra offset. so when screen.availLeft exist, use min
    * of both should fix it.
    *
    * On the spec, the screenX should never be smaller than the
    * screen.availLeft, please refer the definition in:
    * https://drafts.csswg.org/cssom-view/#dom-window-screenx
    * as "The screenX attribute must return the x-coordinate of the position
    * where the event occurred relative to the origin of the Web-exposed
    * screen area."
    * And after entering fullscreen, they should be equal to each other, if
    * the browser don't count the windows/Mac OS bar in.
    */
   this.getScreenSetting = function () {
      var offsetX = void 0,
          offsetY = void 0;

      if (!screen || screenX === undefined || screenY === undefined) {
         return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            devicePixelRatio: window.devicePixelRatio || 1
         };
      }
      if (screen.availLeft !== undefined) {
         offsetX = Math.min(screenX, screen.availLeft);
      } else {
         offsetX = screenX;
      }
      if (screen.availTop !== undefined) {
         offsetY = Math.min(screenY, screen.availTop);
      } else {
         offsetY = screenY;
      }

      return {
         x: offsetX,
         y: offsetY,
         width: screen.width,
         height: screen.height,
         devicePixelRatio: window.devicePixelRatio || 1
      };
   };

   /**
    * whether should prevent default
    * @param {object} event
    */
   this.shouldPreventDefault = function (event) {
      if (!event) {
         return false;
      }
      var specialKeys = ["meta", "ctrl", "alt", "shift"];
      var hasSpecialKey = false;
      specialKeys.forEach(function (keyName) {
         if (event[keyName + "Key"]) {
            hasSpecialKey = true;
         }
      });
      /**
       * 65 is A, 90 is Z, add this condition for avoiding bug 1821196
       */
      return !(!!event.key && event.key.length === 1 && event.key.charCodeAt(0) >= 65 && event.key.charCodeAt(0) <= 90) || hasSpecialKey;
   };
}

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DoLogoutHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * doLogoutHandler.js --
 *
 *      Implementation of the message handler to do logout.
 */

function DoLogoutHandler() {
   var router = void 0,

   // the handler has been initialized in getItemsControler
   setPrefHandler = _jscdkClient.globalArray["set-user-global-preferences"];

   // member variables below
   this.messageName = "do-logout";
   this.messageText = "do-logout";
   this.responseTag = "logout";
   this.needClearURIFlag = false;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
   }
   // the composedHandlerList needs to keep this order, which is to let set
   // preference before log out.  Otherwise, it pops the un-authenticated
   // error.
   this.composedHandlerList = [setPrefHandler, this];
}

// inherits MessageHandler prototype
DoLogoutHandler.prototype = new _messageHandler.MessageHandler();
// constructor
DoLogoutHandler.constructor = DoLogoutHandler;

DoLogoutHandler.prototype.setNeedClearURIFlag = function () {
   this.needClearURIFlag = true;
};
/**
 * parse configuration information from the response XML of GetConfiguration
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return Object. key-value pairs parsed from response, if error then return
 *    null
 */
DoLogoutHandler.prototype.parseResult = function (responseXML) {
   var logoutResponse = {},
       xmlDoc = (0, _jquery2.default)(responseXML),
       brokerTag = void 0,
       responses = void 0,
       result = void 0;

   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of doLogoutHandler error");
      return null;
   }

   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   _util2.default.addItemForJson(logoutResponse, "result", result);
   return logoutResponse;
};

DoLogoutHandler.prototype.onUpdated = function () {
   var logoutAction = {
      name: "Logout"
   },
       router = _util2.default.getObject(_jscdkClient.globalArray, "router"),
       urlHandler = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this);
   /**
    * For doLogout message, the possible error is NOT_AUTHENTICATED. But if
    * user wants to logout from the broker, the NOT_AUTHENTICATED error can
    * be treated as successful too. So set the state to DONE even there is an
    * error occurs for doLogout message.
    */
   this.setState(_messageHandler.StateEnum.DONE);
   if (this.needClearURIFlag) {
      //just for the first time after setting this flag.(user URI only take
      // affect for once)
      this.needClearURIFlag = false;
      // delete urlHandler referece from globalArray.
      urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");
      if (!!urlHandler) {
         _jscdkClient.globalArray["url-handler"] = null;
      }
   }
   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(logoutAction));
   if (router) {
      router.setDoLogout();
      _jscdkLogger2.default.info("Logout completed.");
   }
   if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
      _jscdkLogger2.default.debug("Logout result is OK.");
   } else {
      _jscdkLogger2.default.error("Logout failed.");
   }
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = GetAuthenticationStatusHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _timerUtil = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GetAuthenticationStatusHandler() {
   // member variables below
   this.messageName = "get-authentication-status";
   this.messageText = "get-authentication-status";
   this.responseTag = "authentication-status";

   // register dependencies here
   var router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
   this.needCallbackFlag = false;
   this.workForSilentModeFlag = false;
   this.requestXML = "";
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * getAuthenticationStatusHandler.js --
 *
 *      Implementation of the message handler to send getAuthenticationStatus.
 */

GetAuthenticationStatusHandler.prototype = new _messageHandler.MessageHandler();
GetAuthenticationStatusHandler.constructor = GetAuthenticationStatusHandler;

GetAuthenticationStatusHandler.prototype.setWorkForSilentModeFlag = function () {
   this.workForSilentModeFlag = true;
};

GetAuthenticationStatusHandler.prototype.setRequestXML = function (needCallback) {
   if (needCallback === true) {
      this.needCallbackFlag = true;
   } else if (needCallback === false) {
      this.needCallbackFlag = false;
   } else {
      _jscdkLogger2.default.debug("error: needCallback should be of bool type");
      this.needCallbackFlag = false;
      return;
   }
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
GetAuthenticationStatusHandler.prototype.onUpdated = function () {
   var response = this.content["parsedResult"],
       userActiveTimeSyncCtrl = void 0,
       router = _util2.default.getObject(_jscdkClient.globalArray, "router");

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      //deal with ok response according to callback type
      _jscdkLogger2.default.debug('get authentication status succeeds.');
      if (!this.needCallbackFlag && !this.workForSilentModeFlag) {
         _jscdkLogger2.default.log("deal with getAuthenticationStatus response with normal process");
         this.dealWithAuthenticationStatusXML(response);
      } else if (this.needCallbackFlag) {
         //use timer controller to deal with response
         userActiveTimeSyncCtrl = _util2.default.getObject(_jscdkClient.globalArray, "get-broker-sso-time-ctrl");
         if (!!userActiveTimeSyncCtrl) {
            userActiveTimeSyncCtrl.dealWithAuthenticationStatusXML(response);
         } else {
            _jscdkLogger2.default.error("find userActiveTimeSyncCtrl undefined when getAuthenticationStatus.needCallbackFlag is set");
         }
      } else {
         // this.workForSilentModeFlag === true
         this.workForSilentModeFlag = false;
         _jscdkLogger2.default.log("deal with getAuthenticationStatus response before act in desktop-select page");
         this.returnAuthenticationStatus(response);
      }
   }

   //push error to handle old version broker, and deal with not authed error
   // case
   router.pushErrorToUser(this);
};

GetAuthenticationStatusHandler.prototype.returnAuthenticationStatus = function (response) {
   var authStatusAction = void 0;

   if (response.sso === "unlocked") {
      authStatusAction = { name: "AuthenticationStatusUnlocked" };
   } else {
      // cann't reuse name: DoLock cause the dialog should not jump out in
      // silent mode.
      authStatusAction = { name: "AuthenticationStatusLocked" };
   }
   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(authStatusAction));
};

/* normal deal with AuthenticationStatusXML
 *
 * should only be used when init page
 */
GetAuthenticationStatusHandler.prototype.dealWithAuthenticationStatusXML = function (response) {
   var authStatusAction = void 0,
       idleTimeoutTimerController = _util2.default.getObject(_jscdkClient.globalArray, "idle-timeout-timer");

   if (response.sso === "unlocked") {
      //prepare for already authentication case
      (0, _timerUtil.prepareForAlreadyAuthenticated)();
      //already authenticated, send to UI to read timer info back from
      // cookie or session storage
      authStatusAction = { name: "SessionUnlocked" };
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(authStatusAction));
   } else {
      authStatusAction = { name: "LockedNewTab" };
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(authStatusAction));
   }
};
/**
 * parse locale information from the response XML of GetAuthenticationStatus
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
GetAuthenticationStatusHandler.prototype.parseResult = function (responseXML) {
   var responseBody = void 0,
       brokerTag = void 0,
       brokerElem = void 0,
       responses = void 0,
       resultText = void 0,
       authStatusResponse = {},
       ssoNode = void 0,
       ssoText = void 0,
       timeToSsoLockNode = void 0;

   if (!responseXML || responseXML === "") {
      return null;
   }
   responseBody = (0, _jquery2.default)(responseXML);
   //broker version in XML response is stored for later usage
   brokerElem = responseBody.find("broker"); //TOPolish: need to delete repeat
   // code with brokerTag
   _jscdkClient.globalArray["brokerVersion"] = brokerElem.attr("version");

   //parse data
   brokerTag = (0, _jquery2.default)(responseBody.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of getAuthenticationStatus error");
      return null;
   }
   responses = brokerTag.children(this.responseTag);
   resultText = responses.children("result").text();
   if (!!resultText && resultText.trim() !== "") {
      authStatusResponse["result"] = resultText;
   } else {
      _jscdkLogger2.default.error("response of getAuthenticationStatus error, no valid result tag");
      return null;
   }
   if (resultText === "ok") {
      ssoNode = responses.children("sso");
      if (!ssoNode) {
         _jscdkLogger2.default.error("response of getAuthenticationStatus error, no sso tag with result set ok");
         return null;
      }
      ssoText = (0, _jquery2.default)(ssoNode).text();
      _util2.default.addItemForJson(authStatusResponse, "sso", ssoText);

      if (ssoText === "unlocked") {
         timeToSsoLockNode = responses.children("time-to-sso-lock");
         if (!timeToSsoLockNode) {
            _jscdkLogger2.default.error("response of getAuthenticationStatus error, no time-to-sso-lock tag with sso set unlocked");
            return null;
         }
         _util2.default.addItemForJson(authStatusResponse, "time-to-sso-lock", (0, _jquery2.default)(timeToSsoLockNode).text());
      }
   } else if (resultText === "error") {
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(authStatusResponse, nameText, (0, _jquery2.default)(this).text());
      });
   }
   return authStatusResponse;
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ResetDesktopHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ResetDesktopHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "reset-desktop";
   this.messageText = "reset-desktop";
   this.responseTag = "reset-desktop";
   this.composedHandlerList = [];
   // requestId will increase when a new instance is created
   // use prototype requestId to share in all instances
   ResetDesktopHandler.prototype.requestId += 1;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * resetDesktopHandler.js --
 *
 *      Implementation of the message handler to reset desktop.
 */

ResetDesktopHandler.prototype = new _messageHandler.MessageHandler();
// constructor
ResetDesktopHandler.constructor = ResetDesktopHandler;

/**
 * parse information from the response XML of reset-desktop
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
ResetDesktopHandler.prototype.parseResult = function (responseXML) {
   var responseBody = responseXML;
   var brokerTag = void 0;
   var responses = void 0;
   var result = void 0;
   var tokenText = void 0;
   var resetDesktopResponse = {};
   var xmlDoc = void 0;

   xmlDoc = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   if (result === "ok" || result === "error") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases.
       */
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(resetDesktopResponse, nameText, (0, _jquery2.default)(this).text());
      });
   }
   return resetDesktopResponse;
};

/**
 * Set the request XML for reset-desktop
 * @param desktopId[in] desktop id to reset
 *
 */
ResetDesktopHandler.prototype.setRequestXML = function (desktopId) {
   var desktopIdElem = void 0;
   desktopIdElem = _util2.default.createElement("desktop-id", desktopId);
   this.requestXML = desktopIdElem;
};

/**
 * callback when received notification from handlers in dependency list or
 * router
 *
 */
ResetDesktopHandler.prototype.onUpdated = function () {
   var resetDesktopAction = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
         _jscdkLogger2.default.debug('Reset desktop succeeds.');

         // Kill session succeeds
         resetDesktopAction = { name: "ResetDesktop", result: "ok" };
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(resetDesktopAction));
      }
   }

   // push error if it exists
   _router2.default.prototype.pushErrorToUser(this);
};

/***/ }),
/* 42 */,
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function($) {/*** IMPORTS FROM imports-loader ***/
(function() {

(function() {

function stringFromArray (data) {
   var length = data.length,
      tmp = new Array(Math.ceil(length / 8)),
      i, j;

   for (i = 0, j = 0; i < length; i += 8, j++) {
      tmp[j] = String.fromCharCode(data[i],
                                     data[i + 1],
                                     data[i + 2],
                                     data[i + 3],
                                     data[i + 4],
                                     data[i + 5],
                                     data[i + 6],
                                     data[i + 7]);
   }

   return tmp.join('').substr(0, length);
};


function arrayFromString (str, useUint8Array) {
   var length = str.length,
      array = useUint8Array ? new Uint8Array(length) : new Array(length),
      i;

   for (i = 0; i+7 < length; i += 8) {
      array[i] = str.charCodeAt(i);
      array[i + 1] = str.charCodeAt(i + 1);
      array[i + 2] = str.charCodeAt(i + 2);
      array[i + 3] = str.charCodeAt(i + 3);
      array[i + 4] = str.charCodeAt(i + 4);
      array[i + 5] = str.charCodeAt(i + 5);
      array[i + 6] = str.charCodeAt(i + 6);
      array[i + 7] = str.charCodeAt(i + 7);
   }

   for (; i < length; i++) {
      array[i] = str.charCodeAt(i);
   }

   return array;
};


var Base64 = {
decodeToArray: function (data, useUint8Array) {
      return arrayFromString(window.atob(data), useUint8Array);
   },

decodeToString: function (data) {
      return window.atob(data);
   },

encodeFromArray: function (data) {
      return window.btoa(stringFromArray(data));
   },

encodeFromString: function (data) {
      return window.btoa(data);
   }
};

/*
 *------------------------------------------------------------------------------
 *
 * wmks\core.js
 *
 *    This file initializes the WMKS root namespace and some of the generic
 *    functionality is defined accordingly.
 *
 *    This contains the following:
 *    1. Global constants (WMKS.CONST)
 *       Specific constants go a level deeper. (Ex: WMKS.CONST.TOUCH, etc.)
 *    2. Generic utility / helper functions.
 *       a. WMKS.LOGGER:   Logging with different log levels.
 *       b. AB.BROWSER:    Detects various browser types and features.
 *       c. WMKS.UTIL:     Utility helper functions.
 *
 *    NOTE: Namespace should be upper case.
 *
 *------------------------------------------------------------------------------
 */

WMKS = {};

/**
 *------------------------------------------------------------------------------
 *
 * WMKS.LOGGER
 *
 *    The logging namespace that defines a log utility. It has:
 *    1. Five logging levels
 *    2. Generic log function that accepts a log level (defaults to LOG_LEVEL).
 *    3. Log level specific logging.
 *    4. Log only when requested log level is above or equal to LOG_LEVEL value.
 *    5. Dynamically set logging levels.
 *
 *------------------------------------------------------------------------------
 */

WMKS.LOGGER = new function() {
   'use strict';

   this.LEVEL = {
      TRACE: 0,
      DEBUG: 1,
      INFO:  2,
      WARN:  3,
      ERROR: 4
   };

   // The default log level is set to INFO.
   var _logLevel = this.LEVEL.INFO,
       _logLevelDesc = [' [Trace] ', ' [Debug] ', ' [Info ] ', ' [Warn ] ', ' [Error] '];

   // Logging functions for different log levels.
   this.trace = function(args) { this.log(args, this.LEVEL.TRACE); };
   this.debug = function(args) { this.log(args, this.LEVEL.DEBUG); };
   this.info =  function(args) { this.log(args, this.LEVEL.INFO);  };
   this.warn =  function(args) { this.log(args, this.LEVEL.WARN);  };
   this.error = function(args) { this.log(args, this.LEVEL.ERROR); };

   /*
    *---------------------------------------------------------------------------
    *
    * log
    *
    *    The common log function that uses the default logging level.
    *    Use this when you want to see this log at all logging levels.
    *
    *    IE does not like if (!console), so check for undefined explicitly.
    *    Bug: 917027
    *
    *---------------------------------------------------------------------------
    */

   this.log =
      (typeof console === 'undefined' || typeof console.log === 'undefined')?
         $.noop :
         function(logData, level) {
            level = (level === undefined)? this.LEVEL.INFO : level;
            if (level >= _logLevel && logData) {
               // ISO format has ms precision, but lacks IE9 support.
               // Hence use UTC format for IE9.
               console.log((WMKS.BROWSER.isIE()?
                              new Date().toUTCString() : new Date().toISOString())
                           + _logLevelDesc[level] + logData);
            }
         };

   /*
    *---------------------------------------------------------------------------
    *
    * setLogLevel
    *
    *    This public function is used to set the logging level. If the input is
    *    invalid, then the default logging level is used.
    *
    *---------------------------------------------------------------------------
    */

   this.setLogLevel = function(newLevel) {
      if (typeof newLevel === 'number' && newLevel >= 0 && newLevel < _logLevelDesc.length) {
         _logLevel = newLevel;
      } else {
         this.log('Invalid input logLevel: ' + newLevel);
      }
   };
};


/**
 *------------------------------------------------------------------------------
 *
 * WMKS.BROWSER
 *
 *    This namespace object contains helper function to identify browser
 *    specific details such as isTouchDevice, isIOS, isAndroid, etc.
 *
 *    Browser version detection is available through the object "version" like
 *    so:
  *    * WMKS.BROWSER.version.full (String)
 *      - Full version string of the browser.
 *        e.g For Chrome 35.6.1234 this would be "35.6.1234"
 *    * WMKS.BROWSER.version.major (Integer)
 *      - Major version of the browser.
 *        e.g For Chrome 35.6.1234 this would be 35
 *    * WMKS.BROWSER.version.minor (Integer)
 *      - Minor version of the browser.
 *        e.g For Chrome 35.6.1234 this would be 6
 *    * WMKS.BROWSER.version.float (Float)
 *      - Major and minor version of the browser as a float.
 *        e.g For Chrome 35.6.1234 this would be 35.6
 *------------------------------------------------------------------------------
 */

WMKS.BROWSER = new function() {
   var ua = navigator.userAgent.toLowerCase(),
       vs = navigator.appVersion.toString(),
       trueFunc = function() { return true; },
       falseFunc = function() { return false; };

   // In the wake of $.browser being deprecated, use the following:
   this.isIE = (ua.indexOf('msie') !== -1 || ua.indexOf('trident') !== -1 || ua.indexOf('edge') !== -1)?
                  trueFunc : falseFunc;

   // Since Opera 30, Opera's UA is changed to "OPR".
   this.isOpera = (ua.indexOf('opera/') !== -1 || ua.indexOf('opr/') !== -1)? trueFunc : falseFunc;
   this.isWebkit = this.isChrome = this.isSafari = this.isBB = falseFunc;

   // Check for webkit engine.
   if (!this.isIE() && !this.isOpera() && ua.indexOf('applewebkit') !== -1) {
      this.isWebkit = trueFunc;
      // Webkit engine is used by chrome, safari and blackberry browsers.
      if (ua.indexOf('chrome') !== -1) {
         this.isChrome = trueFunc;
      } else if (ua.indexOf('bb') !== -1) {
         // Detect if its a BlackBerry browser or higher on OS BB10+
         this.isBB = trueFunc;
      } else if (ua.indexOf('safari') !== -1) {
         this.isSafari = trueFunc;
      }
   }

   // See: https://developer.mozilla.org/en/Gecko_user_agent_string_reference
   // Also, Webkit/IE11 say they're 'like Gecko', so we get a false positive here.
   this.isGecko = (!this.isWebkit() && !this.isIE() && ua.indexOf('gecko') !== -1)
      ? trueFunc : falseFunc;

   this.isFirefox = (ua.indexOf('firefox') !== -1 || ua.indexOf('iceweasel') !== -1)?
                     trueFunc : falseFunc;

   // Flag indicating low bandwidth, not screen size.
   this.isLowBandwidth = (ua.indexOf('mobile') !== -1)? trueFunc : falseFunc;

   // Detect specific mobile devices. These are *not* guaranteed to also set
   // isLowBandwidth. Some however do when presenting over WiFi, etc.
   this.isIOS = ((ua.indexOf('iphone') !== -1) || (ua.indexOf('ipod') !== -1) ||
                 (ua.indexOf('ipad') !== -1))? trueFunc : falseFunc;

   /* typically also sets isLinux */
   this.isAndroid = (ua.indexOf('android') !== -1)? trueFunc : falseFunc;

   // Detect IE mobile versions.
   this.isIEMobile = (ua.indexOf('IEMobile') !== -1)? trueFunc : falseFunc;

   // Flag indicating that touch feature exists. (Ex: includes Win8 touch laptops)
   this.hasTouchInput = ('ontouchstart' in window
                        || navigator.maxTouchPoints
                        || navigator.msMaxTouchPoints)? trueFunc : falseFunc;

   // TODO: Include windows/BB phone as touchDevice.
   this.isTouchDevice = (this.isIOS() || this.isAndroid() || this.isBB())?
                        trueFunc : falseFunc;

   // PC OS detection.
   this.isChromeOS = (ua.indexOf('cros') !== -1)? trueFunc : falseFunc;
   this.isWindows = (ua.indexOf('windows') !== -1)? trueFunc : falseFunc;
   this.isLinux = (ua.indexOf('linux') !== -1)? trueFunc : falseFunc;
   this.isMacOS = (ua.indexOf('macos') !== -1 || ua.indexOf('macintosh') > -1)?
                  trueFunc : falseFunc;

   var getValue = function(regex, index) {
      var match = ua.match(regex);
      return (match && match.length > index && match[index]) || '';
   };
   this.version = { full : "" };
   if(this.isSafari()){
      this.version.full = getValue(/Version[ \/]([0-9\.]+)/i, 1);
   } else if(this.isChrome()){
      this.version.full = getValue(/Chrome\/([0-9\.]+)/i, 1);
   } else if(this.isFirefox()){
      this.version.full = getValue(/(?:Firefox|Iceweasel)[ \/]([0-9\.]+)/i, 1);
   } else if(this.isOpera()){
      this.version.full = getValue(/Version[ \/]([0-9\.]+)/i, 1) || getValue(/(?:opera|opr)[\s\/]([0-9\.]+)/i, 1);
   } else if(this.isIE()){
      this.version.full = getValue(/(?:\b(MS)?IE\s+|\bTrident\/7\.0;.*\s+rv:|\bEdge\/)([0-9\.]+)/i, 2);
   }
   var versionParts = this.version.full.split('.');

   this.version.major = parseInt(versionParts.length > 0 ? versionParts[0] : 0, 10);
   this.version.minor = parseInt(versionParts.length > 1 ? versionParts[1] : 0, 10);
   this.version.float = parseFloat(this.version.full);

   /*
    *---------------------------------------------------------------------------
    *
    * isCanvasSupported
    *
    *    Tests if the browser supports the use of <canvas> elements properly
    *    with the ability to retrieve its draw context.
    *
    *---------------------------------------------------------------------------
    */

   this.isCanvasSupported = function() {
      try {
         var canvas = document.createElement('canvas');
         var result = !!canvas.getContext; // convert to Boolean, invert again.
         canvas = null; // was never added to DOM, don't need to remove
         return result;
      } catch(e) {
         return false;
      }
   };

};


/**
 *------------------------------------------------------------------------------
 *
 * WMKS.CONST
 *
 *    Constant values under CONST namespace that's used across WMKS.
 *
 *------------------------------------------------------------------------------
 */

WMKS.CONST = {
   // Touch events can use the following keycodes to mimic mouse events.
   CLICK: {
      left:       0x1,
      middle:     0x2,
      right:      0x4
   },

   FORCE_RAW_KEY_CODE: {
      8:          true,    // backspace
      9:          true,    // tab
      13:         true     // newline
   }
};


/**
 *------------------------------------------------------------------------------
 *
 * WMKS.UTIL
 *
 *    This namespace object contains common helper function.
 *
 *------------------------------------------------------------------------------
 */

WMKS.UTIL = {
   /*
    *---------------------------------------------------------------------------
    *
    * createCanvas
    *
    *    This function creates a canvas element and adds the absolute
    *    position css to it if the input flag is set.
    *
    *---------------------------------------------------------------------------
    */

   createCanvas: function(addAbsolutePosition) {
      var css = {};
      if (addAbsolutePosition) {
         css.position = 'absolute';
      }
      return $('<canvas/>').css(css);
   },

   /*
    *---------------------------------------------------------------------------
    *
    * createVideo
    *
    *    This function creates a video element and adds the absolute
    *    position css to it if the input flag is set.
    *
    *---------------------------------------------------------------------------
    */

   createVideo: function(addAbsolutePosition) {
      var css = {};
      if (addAbsolutePosition) {
         css.position = 'absolute';
      }
      return $('<video/>').css(css);
   },

   /*
    *---------------------------------------------------------------------------
    *
    * getLineLength
    *
    *    Gets the length of the line that starts at (0, 0) and ends at
    *    (dx, dy) and returns the floating point number.
    *
    *---------------------------------------------------------------------------
    */

   getLineLength: function(dx, dy) {
      return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
   },

   /*
    *---------------------------------------------------------------------------
    *
    * isHighResolutionSupported
    *
    *    Indicates if high-resolution mode is available for this browser. Checks
    *    for a higher devicePixelRatio on the browser.
    *
    *---------------------------------------------------------------------------
    */

   isHighResolutionSupported: function() {
      return window.devicePixelRatio && window.devicePixelRatio > 1;
   },

   /*
    *---------------------------------------------------------------------------
    *
    * isFullscreenNow
    *
    *    Utility function to inform if the browser is in full-screen mode.
    *
    *---------------------------------------------------------------------------
    */

   isFullscreenNow: function() {
      return document.fullscreenElement ||
             document.mozFullScreenElement ||
             document.msFullscreenElement ||
             document.webkitFullscreenElement
             ? true : false;
   },

   /*
    *---------------------------------------------------------------------------
    *
    * isFullscreenEnabled
    *
    *    Utility function that indicates if fullscreen feature is enabled on
    *    this browser.
    *
    *    Fullscreen mode is disabled on Safari as it does not support keyboard
    *    input in fullscreen for "security reasons". See bug 1296505.
    *
    *---------------------------------------------------------------------------
    */

   isFullscreenEnabled: function() {
      return !WMKS.BROWSER.isSafari() &&
             (document.fullscreenEnabled ||
             document.mozFullScreenEnabled ||
             document.msFullscreenEnabled ||
             document.webkitFullscreenEnabled)
             ? true : false;
   },

   /*
    *---------------------------------------------------------------------------
    *
    * toggleFullScreen
    *
    *    This function toggles the fullscreen mode for this browser if it is
    *    supported. If not, it just ignores the request.
    *
    *---------------------------------------------------------------------------
    */

   toggleFullScreen: function(showFullscreen, element) {
      var currentState = WMKS.UTIL.isFullscreenNow(),
          ele = element || document.documentElement;

      if (!WMKS.UTIL.isFullscreenEnabled()) {
         WMKS.LOGGER.warn('This browser does not support fullScreen mode.');
         return;
      }
      if (currentState === showFullscreen) {
         // already in the desired state.
         return;
      }

      // If currently in Fullscreen mode, turn it off.
      if (currentState) {
         if (document.exitFullscreen) {
            document.exitFullscreen();
         } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
         } else if (document.webkitCancelFullScreen) {
            document.webkitCancelFullScreen();
         } else if(document.msExitFullscreen) {
            document.msExitFullscreen();
         }
      } else {
         // Flip to full-screen now.
         if (ele.requestFullscreen) {
            ele.requestFullscreen();
         } else if (ele.mozRequestFullScreen) {
            ele.mozRequestFullScreen();
         } else if (ele.webkitRequestFullscreen) {
            ele.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
         } else if (ele.msRequestFullscreen) {
            ele.msRequestFullscreen();
         }
      }
   }

};

/*
 *-----------------------------------------------------------------------------
 * wmks/bitbuf.js
 *
 *    This class implements decoding of variable-length-encoded
 *    integers from an array of bytes.
 *
 *-----------------------------------------------------------------------------
 */


/*
 *----------------------------------------------------------------------------
 *
 * BitBuf --
 *
 *      Given a buffer of bytes and its size, initialize a BitBuf
 *      object for reading from or writing to that buffer.
 *
 * Results:
 *      The initialized bit buffer.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------------
 */

WMKS.BitBuf = function(buffer, size) {
   "use strict";
   this._buf = buffer;
   this._size = size;
   this._readCount = 0;
   this._overflow = false;
   this._thisByte = 0;
   this._thisByteBits = 0;

   return this;
};


/*
 *----------------------------------------------------------------------------
 *
 * BitBuf.readBits0 --
 *
 *      Helper for readBits() which reads a number of bits from the
 *      current active byte and returns them to the caller.
 *
 * Results:
 *      The bits requested.
 *
 * Side effects:
 *      Advances the buffer read offset by the specified number of bits.
 *
 *----------------------------------------------------------------------------
 */

WMKS.BitBuf.prototype.readBits0 = function (val, nr) {
   "use strict";
   var mask;

   if (this._bits < nr) {
      this._overflow = true;
      return -1;
   }

   mask = ~(0xff >> nr);        /* ones in the lower 'nr' bits */
   val <<= nr;                  /* move output value up to make space */
   val |= (this._thisByte & mask) >> (8-nr);
   this._thisByte <<= nr;
   this._thisByte &= 0xff;
   this._thisByteBits -= nr;

   return val;
};


/*
 *----------------------------------------------------------------------------
 *
 * BitBuf.readBits --
 *
 *      Read and return the specified number of bits from the BitBuf.
 *
 * Results:
 *      The value from the buffer.
 *
 * Side effects:
 *      Advances the buffer read offset by the specified number of bits.
 *
 *----------------------------------------------------------------------------
 */

WMKS.BitBuf.prototype.readBits = function (nr) {
   "use strict";
   var origNr = nr;
   var val = 0;

   if (this._overflow) {
      return 0;
   }

   while (nr > this._thisByteBits) {
      nr -= this._thisByteBits;
      val = this.readBits0(val, this._thisByteBits);

      if (this._readCount < this._size) {
         this._thisByte = this._buf[this._readCount++];
         this._thisByteBits = 8;
      } else {
         this._thisByte = 0;
         this._thisByteBits = 0;
         if (nr > 0) {
            this._overflow = true;
            return 0;
         }
      }
   }

   val = this.readBits0(val, nr);
   return val;
};


/*
 *----------------------------------------------------------------------------
 *
 * BitBuf.readEliasGamma --
 *
 *      Read an elias-gamma-encoded integer from the buffer.  The
 *      result will be greater than or equal to one, and is
 *      constrained to fit in a 32-bit integer.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Advances the buffer read offset by the necessary number of bits.
 *
 *----------------------------------------------------------------------------
 */

WMKS.BitBuf.prototype.readEliasGamma = function() {
   "use strict";
   var l = 0;
   var value;
   var bit;
   var origidx = this._readCount;
   var origbit = this._thisByteBits;

   while (!this._overflow &&
          (bit = this.readBits(1)) == 0) {
      l++;
   }

   value = 1 << l;

   if (l) {
      value |= this.readBits(l);
   }

   return value;
}

/*
 * wmks/websocketInit.js
 *
 *   Contains a helper function to instantiate WebSocket object.
 *
 */




/*
 *------------------------------------------------------------------------------
 *
 * WMKSWebSocket
 *
 *    Create an alternate class that consumes WebSocket and provides a
 *    non-native code constructor we can use to stub out in Jasmine (a
 *    testing framework).
 *
 * Results:
 *    Newly constructed WebSocket.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.WebSocket = function(url, protocol) {
   return new window.WebSocket(url, protocol);
};

/*
 * wmks/arrayPush.js
 *
 *   Convenience functions for building an array of bytes
 *   (for sending messages to servers or handling image formats).
 *
 */


Array.prototype.push8 = function (aByte) {
   this.push(aByte & 0xFF);
};


Array.prototype.push16 = function (aWord) {
   this.push((aWord >> 8) & 0xFF,
             (aWord     ) & 0xFF);
};


Array.prototype.push32 = function (aLongWord) {
   this.push((aLongWord >> 24) & 0xFF,
             (aLongWord >> 16) & 0xFF,
             (aLongWord >>  8) & 0xFF,
             (aLongWord      ) & 0xFF);
};


Array.prototype.push16le = function(aWord) {
   this.push((aWord     ) & 0xff,
             (aWord >> 8) & 0xff);
};


Array.prototype.push32le = function(aLongWord) {
   this.push((aLongWord     ) & 0xff,
             (aLongWord >> 8) & 0xff,
             (aLongWord >> 16) & 0xff,
             (aLongWord >> 24) & 0xff);
};

/*
 *------------------------------------------------------------------------------
 * wmks/ImageManagerWMKS.js
 *
 *    This class abstracts Image caching solution in an optimal way. It takes
 *    care of returning the image in a clean, and memory leak proof manner.
 *    It exposes 2 functions  to get and release images. The get function
 *    returns an Image object either from an unused cache or by creating a new one.
 *    The return function, depending on the max allowed cache size decides to
 *    either add the image to the cache or get rid of it completely.
 *
 *------------------------------------------------------------------------------
 */

function ImageManagerWMKS(imageCacheSize) {
  'use strict';
   var _cacheSize = imageCacheSize;  // Max number of images cached.
   var _cacheArray = [];             // Cache to hold images.

   /*
    *---------------------------------------------------------------------------
    *
    * _getImage
    *
    *    Pushes the current image to the cache if it is not full,
    *    and then deletes the image.
    *
    *---------------------------------------------------------------------------
    */

   var _getImageFromCache = function() {
      if (_cacheArray.length > 0) {
         return _cacheArray.shift();
      } else {
         return new Image();
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _deleteImage
    *
    *    This private function takes an array containing a single image and
    *    deletes the image. The reason for using an array containing the image
    *    instead of 'delete image' call is to comply with javascript strict mode.
    *
    *---------------------------------------------------------------------------
    */

   var _deleteImage = function(imgArray) {
      delete imgArray[0];
      imgArray[0] = null;
      imgArray = null;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _cacheImageOrDelete
    *
    *    Private function that resets event handlers if any. Sets src to an
    *    empty image. Pushes the current image to the cache if it is not full,
    *    else deletes the image.
    *
    *---------------------------------------------------------------------------
    */

   var _cacheImageOrDelete = function(image) {
      // Reset onload and onerror event handlers if any.
      image.onload = image.onerror = null;

      /*
       * Issues with webkit image caching:
       * 1. Setting image.src to null is insufficient to turn off image caching
       *    in chrome (webkit).
       * 2. An empty string alone is not sufficient since browsers may treat
       *    that as meaning the src is the current page (HTML!) which will
       *    lead to a warning on the browsers javascript console.
       * 3. If we set it to an actual string with an empty data URL, this helps
       *    the first time, however when we try to decode the same image again
       *    and again later on, the onload will not be called and we have a
       *    problem.
       * 4. If we set it to a data:image with invalid data some browsers
       *    (such as IE11 or Edge) will spam the log with error messages.
       * 5. So finally, we use the smallest valid 1x1 black gif and append a
       *    timestamp to the data URL so that the browser treats it as a new
       *    image every time. This keeps image cache consistent.
       */
      var tinyGif = [ 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x01, 0x00,
                      0x01, 0x00, 0x00, 0xFF, 0x00, 0x2C, 0x00, 0x00,
                      0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x02,
                      0x00, 0x3B ];
      tinyGif.push32($.now());
      image.src = "data:image/gif;base64," + Base64.encodeFromArray(tinyGif);

      if (_cacheArray.length <= _cacheSize) {
         _cacheArray.push(image);
      } else {
         // Image deleting in strict mode causes error. Hence the roundabout way.
         _deleteImage([image]);
      }
   };

   /*
    *---------------------------------------------------------------------------
    *
    * getImage
    *
    *    Public function that invokes a private function _getImageFromCache()
    *    to get an image.
    *
    *---------------------------------------------------------------------------
    */
   this.getImage = function() {
      return _getImageFromCache();
   };

   /*
    *---------------------------------------------------------------------------
    *
    * releaseImage
    *
    *    Public function that invokes a private function _cacheImageOrDelete()
    *    to add the image to a cache when the cache is not full or delete the
    *    image.
    *
    *---------------------------------------------------------------------------
    */
   this.releaseImage = function(image) {
      if (!image) {
         return;
      }
      _cacheImageOrDelete(image);
   };
};
/*********************************************************
 * Copyright (C) 2015 VMware, Inc. All rights reserved.
 *********************************************************/

/*
 * wmks/mp4Decoder.js
 *
 *   WebMKS MP4 decoder prototype.
 *
 */

function MP4Decoder() {
   this._mediaSource = null;
   this._sourceBuffer = null;
   this._tempQueue = [];
   this._mediaPlayer = null;
   this._isError = false;
   this._isErrorDoneCalled = false;
   this._sendRequest= 0;
   this._doneRequest= 0;
   this._decodeDoneCb = null;
   this._decodeErrorCb = null;
   MP4Decoder.instanceNumber++;
   this._name = "MP4Decoder" + MP4Decoder.instanceNumber;
};

MP4Decoder.instanceNumber = 0;
MP4Decoder.byteStreamFormat = 'video/mp4; codecs="avc1.640030"';

MP4Decoder.prototype.toString = function() {
   return this._name;
};


/*
 *------------------------------------------------------------------------------
 *
 * _init
 *
 *    Generate a Media Source object and associate it with video DOM element.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

MP4Decoder.prototype.init = function(mediaPlayer, urlObject, mediaSourceObject,
                                     decodeDoneCb, decodeErrorCb) {
   var self = this,
       URL = urlObject || window.URL || window.webkitURL,
       MediaSource = mediaSourceObject || window.MediaSource || window.WebKitMediaSource;

   this.reset();

   this._decodeDoneCb = decodeDoneCb;
   this._decodeErrorCb = decodeErrorCb;
   this._mediaPlayer = mediaPlayer;
   this._mediaSource = new MediaSource();
   // Attach a media source object to HTMLMediaElement.
   this._mediaPlayer.src = URL.createObjectURL(this._mediaSource);
   this._mediaSource.addEventListener('sourceopen',
   function(e) {
      return self._onMediaSourceOpen(e);
   }, false);
   this._mediaSource.addEventListener('webkitsourceopen',
   function(e) {
      return self._onMediaSourceOpen(e);
   }, false);
};


/*
 *------------------------------------------------------------------------------
 *
 * _onMediaSourceOpen
 *
 *       After media source is open, create a source buffer with MP4 decoder and
 *    attach it to media source object. If there is any MP4 data in the buffer,
 *    add it to source buffer so that media source can play it.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

MP4Decoder.prototype._onMediaSourceOpen = function (e) {
   var self = this;

   WMKS.LOGGER.log(this + " media source status is changed to open.");

   if (this._mediaSource.readyState !== "open") {
      WMKS.LOGGER.log(this + " media source is not open yet.");
      return;
   }

   this._sourceBuffer = this._mediaSource.addSourceBuffer(
      MP4Decoder.byteStreamFormat);

   /*
    * Listen to update event. It will fire after current buffer data is
    * handled by media source object.
    */
   this._sourceBuffer.addEventListener('updateend', function () {
      if (self._tempQueue.length === 0) {
         return;
      }

      if (self._tempQueue[0].method === "add" && self._decodeDoneCb) {
         self._doneRequest++;
         WMKS.LOGGER.debug(self + " request track: send " + self._sendRequest +
                           " done " + self._doneRequest);
         self._decodeDoneCb();
      }

      self._tempQueue.shift();
      self._flushPayloads();
   });

   this._sourceBuffer.addEventListener('error', function(e) {
      WMKS.LOGGER.error(self + " error code is " + e);
   });
   // If we receive any MP4 during MediaSource initialization process, decode it now.
   this._flushPayloads();
   return;
};


/*
 *------------------------------------------------------------------------------
 *
 * _flushPayloads
 *
 *    Append all the data in our temp buffer to sourceBuffer object.
 *
 * Side Effects:
 *    Display MP4 video.
 *
 *------------------------------------------------------------------------------
 */

MP4Decoder.prototype._flushPayloads = function () {
   var bufferStart = 0,
       bufferEnd = 0,
       removeEnd = 0;
   if (!this._sourceBuffer) {
      WMKS.LOGGER.log(this + "source buffer is not ready yet.");
      return;
   }

   if (this._tempQueue.length === 0) {
      return;
   }

   if (this._mediaSource.readyState === "open" &&
       !this._sourceBuffer.updating) {
      try {
         if (this._tempQueue[0].method === "add") {
            this._sourceBuffer.appendBuffer(this._tempQueue[0].payload);
         } else if (this._tempQueue[0].method === "remove") {
            bufferStart = this._sourceBuffer.buffered.start(0);
            bufferEnd = this._sourceBuffer.buffered.end(0);
            removeEnd = this._mediaPlayer.currentTime - 0.5;
            WMKS.LOGGER.log(this + " status:  start " + bufferStart +
                            " end " + bufferEnd + " with current time " +
                            this._mediaPlayer.currentTime);
            if (removeEnd > bufferStart) {
               WMKS.LOGGER.log(this + " start to remove from " +
                               bufferStart + " to " + removeEnd);
               this._sourceBuffer.remove(bufferStart, removeEnd);
            } else {
               WMKS.LOGGER.log(this + " it is too close to clear buffer.");
               this._tempQueue.shift();
               throw "close buffer";
            }
         }
      } catch (e) {
         if (e.name === "QuotaExceededError") {
            var self = this;
            WMKS.LOGGER.log(this + " browser is full.");
            setTimeout(function(){
               self._tempQueue.unshift({method: "remove"});
               self._flushPayloads();
            }, 0);
         } else {
            WMKS.LOGGER.error(this + " encounters a unrecoverable error. " + e);
            this._isError = true;

            if (this._decodeDoneCb) {
               this._decodeDoneCb();
            }

            if (this._decodeErrorCb && !this._isErrorDoneCalled) {
               this._isErrorDoneCalled = true;
               this._decodeErrorCb();
            }
         }
      }
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * reset
 *
 *    Reset all the resources used by MP4 Decoder object.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

MP4Decoder.prototype.reset = function() {
   WMKS.LOGGER.log(this + " is reset.");
   if (this._mediaSource) {
      if (this._sourceBuffer) {
         this._mediaSource.removeSourceBuffer(this._sourceBuffer);
         this._sourceBuffer = null;
      }

      /*
       * Only end the stream if media source is open. Otherwise
       * Chrome browser will throw exception.
       */
      if (this._mediaSource.readyState === "open") {
         this._mediaSource.endOfStream();
      }
      this._mediaSource = null;
   }

   if (this._mediaPlayer) {
      this._mediaPlayer.src = "";
      this._mediaPlayer = null;
   }

   this._sendRequest= 0;
   this._doneRequest= 0;
   this._decodeDoneCb = null;
   this._decodeErrorCb = null;
   this._isError = false;
   this._isErrorDoneCalled = false;
   this._tempQueue = [];
};


/*
 *------------------------------------------------------------------------------
 *
 * appendData
 *
 *    Append MP4 data to media source object. If media source is not ready, put
 *    it into temporary buffer.
 *
 * Side Effects:
 *    Display MP4 video.
 *
 *------------------------------------------------------------------------------
 */

MP4Decoder.prototype.appendData = function(payload) {
   if (this._isError) {
      WMKS.LOGGER.log(this + " is in error state.");
      if (this._decodeDoneCb) {
         this._decodeDoneCb();
      }
      return;
   }

   this._sendRequest++;

   this._tempQueue.push({method: "add", payload: payload});
   this._flushPayloads();

   if (this._mediaPlayer && this._mediaPlayer.paused) {
      this._mediaPlayer.play();
   }
};/*
 * Some code adapted from:
 * https://github.com/brandonaaron/jquery-mousewheel
 */

/* ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2013, Brandon Aaron (http://brandon.aaron.sh)
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * ***** END LICENSE BLOCK ***** */

 /*
 * wmks/mousewheel.js
 *
 *    Event registration for mouse wheel support.
 *
 * jQuery doesn't provide events for mouse wheel movement. This script
 * registers some events we can hook into to detect mouse wheel events
 * in a somewhat cross-browser way.
 *
 * The only information we really need in WebMKS is the direction it scrolled,
 * and not the deltas. This is good, because there is no standard at all
 * for mouse wheel events across browsers when it comes to variables and
 * values, and it's nearly impossible to normalize.
 */

(function() {


var WHEEL_EVENTS = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                   ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];

if ( $.event.fixHooks ) {
   for ( var i = toFix.length; i; ) {
      $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
   }
}

/*
 *------------------------------------------------------------------------------
 *
 * onMouseWheelEvent
 *
 *    Handles a mouse wheel event. The resulting event will have wheelDeltaX
 *    and wheelDeltaY values.
 *
 * Results:
 *    The returned value from the handler(s).
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

function onMouseWheelEvent(event) {
   var deltaX   = 0,
       deltaY   = 0,
       dispatch = $.event.dispatch || $.event.handle;

   // Old school scrollwheel delta
   if ( 'detail'      in event ) { deltaY = event.detail * -1;      }
   if ( 'wheelDelta'  in event ) { deltaY = event.wheelDelta;       }
   if ( 'wheelDeltaY' in event ) { deltaY = event.wheelDeltaY;      }
   if ( 'wheelDeltaX' in event ) { deltaX = event.wheelDeltaX * -1; }

   // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
   if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
      deltaX = deltaY * -1;
      deltaY = 0;
   }

   // New school wheel delta (wheel event)
   if ( 'deltaY' in event ) { deltaY = event.deltaY * -1; }
   if ( 'deltaX' in event ) { deltaX = event.deltaX;      }

   // No change actually happened, no reason to go any further
   if ( deltaY === 0 && deltaX === 0 ) { return; }

   event = $.event.fix(event);
   event.type = 'mousewheel';
   delete event.wheelDelta;
   event.wheelDeltaX = deltaX;
   event.wheelDeltaY = deltaY;

   return dispatch.call(this, event);
}


/*
 *------------------------------------------------------------------------------
 *
 * $.event.special.mousewheel
 *
 *    Provides a "mousewheel" event in jQuery that can be binded to a callback.
 *    This handles the different browser events for wheel movements.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

$.event.special.mousewheel = {
   setup: function() {
      if (this.addEventListener) {
         var i;

         for (i = 0; i < WHEEL_EVENTS.length; i++) {
            this.addEventListener(WHEEL_EVENTS[i], onMouseWheelEvent, false);
         }
      } else {
         this.onmousewheel = onMouseWheelEvent;
      }
   },

   tearDown: function() {
      if (this.removeEventListener) {
         var i;

         for (i = 0; i < WHEEL_EVENTS.length; i++) {
            this.removeEventListener(WHEEL_EVENTS[i], onMouseWheelEvent, false);
         }
      } else {
         this.onmousewheel = onMouseWheelEvent;
      }
   }
};


})();
/*
 * wmks/vncProtocol.js
 *
 *   WebMKS VNC decoder prototype.
 *
 */

WMKS.VNCDecoder = function(opts) {
   var i;
   this.options = $.extend({}, this.options, opts);

   $.extend(this, {
      useVMWRequestResolution: false,
      useVMWRequestStreamState: false,
      useVMWRequestMultiMon: false,
      useVMWKeyEvent: false,                 // VMware VScanCode key inputs are handled.
      allowVMWKeyEvent2UnicodeAndRaw: false, // unicode + JS keyCodes are handled by server.
      useVMWAck: false,
      useVMWAudioAck: false,
      useVMWSessionClose: false,             // Session close msg are sent and handled by server.
      serverSupportsMKSVChanClipboard: false,
      vvc: null,
      vvcSession: null,
      _websocket: null,
      _encrypted: false,
      _receivedFirstUpdate: false,
      _serverInitialized: false,
      _canvas: [],
      _currentCursorURI: 'default',
      _cursorVisible: true,
      _imageCache: [],

      _copyRectBlit: null,
      _copyRectOffscreenBlit: null,

      _state: this.DISCONNECTED,

      _FBWidth: 0,
      _FBHeight: 0,
      _FBName: '',
      _FBBytesPerPixel: 0,
      _FBDepth: 3,

      /*
       * Mouse state.
       * The current button state(s) are sent with each pointer event.
       */
      _mouseButtonMask: 0,
      _mouseX: 0,
      _mouseY: 0,
      onDecodeComplete: {},

      /*
       * Frame buffer update state.
       */
      rects: 0,
      rectsRead: 0,
      rectsDecoded: 0,

      /*
       * Width/height requested through self.onRequestResolution()
       */
      requestedWidth: 0,
      requestedHeight: 0,

      decodeToCacheEntry: -1,
      updateCache: [],
      updateCacheEntries: 0,
      cacheFlags: 0,

      /*
       * Rate-limit resolution requests to the server.  These are slow
       * & we get a better experience if we don't send too many of
       * them.
       */
      resolutionTimeout: {},
      resolutionTimer: null,
      resolutionRequestActive: false,

      /*
       * We maintain an incrementing ID for each update request.
       * This assists in tracking updates/acks with the host.
       */
      updateReqId: 0,

      /*
       * Typematic details for faking keyboard auto-repeat in
       * the client.
       */
      typematicState: 1,             // on
      typematicPeriod: 33333,        // microseconds
      typematicDelay: 500000,        // microseconds

      /*
       * Bitmask of Remote keyboard LED state
       *
       * Bit 0 - Scroll Lock
       * Bit 1 - Num Lock
       * Bit 2 - Caps Lock
       */
      _keyboardLEDs: 0,

      /*
       * Bitmask of currently requested stream state.
       *
       * Bit 0 - Disable Audio (value 1 = disabled, 0 = enabled).
       * Bit 1 - Disable Video (value 1 = disabled, 0 = enabled).
       */
      _streamState: 0,

      /*
       * Timestamp frame's timestamp value --
       * This is stored as the low and high 32 bits as
       * Javascript integers can only give 53 bits of precision.
       */
      _frameTimestampLo: 0,
      _frameTimestampHi: 0,

      rect: [],
      _msgTimer: null,
      _mouseTimer: null,
      _mouseActive: false,
      msgTimeout: {},
      mouseTimeout: {},

      _retryConnectionTimer: null,

      _url: "",
      _receiveQueue: [],
      _receiveQueueIndex: 0,
      _receiveQueueLength: 0,

      /*
       * API to pass VNC data to UI layer for displaying in the multimon mode,
       *    passed in when enable multimon, should be null if not in the the
       *    multimon mode.
       * @type {object}
       */
      _multimonRenderer: null,
      _isInMultimonMode: false
   });

   this.setRenderCanvas(this.options.canvas);

   /*
    * Did we get a backbuffer canvas?
    */
   if (this.options.backCanvas) {
      this._canvas = this._canvas.concat([this.options.backCanvas]);
      this._canvas[1].ctx = this.options.backCanvas.getContext('2d');
   }

   if (this.options.blitTempCanvas) {
      this._canvas = this._canvas.concat([this.options.blitTempCanvas]);
      this._canvas[2].ctx = this.options.blitTempCanvas.getContext('2d');
   }

   if (this.options.mediaPlayer) {
      this._mp4Decoder = new MP4Decoder();
   }

   /*
    * multimonRenderer will be activited when using the multiple monitor mode,
    * and the properties used to render in the single monitor mode like _canvas,
    * _mediaPlayer and _mp4Decoder will be disabled during that time.
    */
   if (this.options.multimonRenderer) {
      this._multimonRenderer = this.options.multimonRenderer;
   }

   /*
    * If the browser supports createImageBitmap we should use that and we will
    * not need our image manager.
    */
   if (typeof createImageBitmap !== 'undefined') {
      this._useImageBitmaps = true;
      this._imageManager = null;
   } else {
      this._imageManager = new ImageManagerWMKS(256);
   }

   /*
    *---------------------------------------------------------------------------
    *
    * _releaseImage
    *
    *    Pushes the current image to the cache if it is not full.
    *
    *---------------------------------------------------------------------------
    */

   this._releaseImage = function (image) {
      if (this._imageManager) {
         this._imageManager.releaseImage(image);
      } else if(typeof image.close === 'function') {
         /**
          * to fix bug 1820682
          * Add this close to trigger memory releasing, the spec can be found at
          * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap/close
          * Note that "This is an experimental technology" in the spec
          */
         image.close();
      }
   };

   return this;
};


$.extend(WMKS.VNCDecoder.prototype, {
   options: {
      canvas: null,
      backCanvas: null,
      blitTempCanvas: null,
      VCDProxyHandshakeVmxPath: null,
      useUnicodeKeyboardInput: false,
      enableVorbisAudioClips: false,
      enableOpusAudioClips: false,
      enableAacAudioClips: false,
      enableVVC: true,
      enableUint8Utf8: false,
      enableVMWSessionClose: false,
      enableSubRectangleCache: true,
      retryConnectionInterval: -1,
      sendRelativeMouseEvent: false,
      onConnecting: function() {},
      onConnected: function() {},
      onBeforeDisconnected: function() {},
      onDisconnected: function() {},
      onAuthenticationFailed: function() {},
      onError: function(err) {},
      onProtocolError: function() {},
      onNewDesktopSize: function(width, height) {},
      onKeyboardLEDsChanged: function(leds) {},
      onCursorStateChanged: function(visibility) {},
      onHeartbeat: function(interval) {},
      onUpdateCopyPasteUI: function(disableCopy, disablePaste) {},
      onMultimonCapacityUpdated: function(enabled) {},
      onCopy: function(txt) {},
      onSetReconnectToken: function(token) {},
      onAudio: function(audioInfo) {},
      onAudioMixer: function(audioMixerInfo) {},
      onEncodingChanged: function(currentEncoding) {},
      cacheSizeKB: 102400,
      cacheSizeEntries: 1024
   },

   DISCONNECTED: 0,
   VNC_ACTIVE_STATE: 1,
   FBU_DECODING_STATE: 2,
   FBU_RESTING_STATE: 3,

   /*
    * Server->Client message IDs.
    */
   msgFramebufferUpdate: 0,
   msgSetColorMapEntries: 1,
   msgRingBell: 2,
   msgServerCutText: 3,
   msgVMWSrvMessage: 127,

   /*
    * VMWSrvMessage sub-IDs we handle.
    */
   msgVMWSrvMessage_ServerCaps: 0,
   msgVMWSrvMessage_Audio: 3,
   msgVMWSrvMessage_Heartbeat: 4,
   msgVMWSrvMessage_SetReconnectToken: 6,
   msgVMWSrvMessage_SessionClose: 7,
   msgVMWSrvMessage_AudioMixer: 8,

   /*
    * Client->Server message IDs: VNCClientMessageID
    */
   msgClientEncodings: 2,
   msgFBUpdateRequest: 3,
   msgKeyEvent: 4,
   msgPointerEvent: 5,
   msgVMWClientMessage: 127,

   /*
    * VMware Client extension sub-IDs: VNCVMWClientMessageID
    */
   msgVMWKeyEvent: 0,
   msgVMWPointerEvent2: 2,
   msgVMWKeyEvent2: 6,
   msgVMWAudioAck: 7,
   msgVMWSessionClose: 12,
   msgVMWRequestStreamState: 15,

   /*
    * Encodings for rectangles within FBUpdates.
    */
   encRaw:               0x00,
   encCopyRect:          0x01,
   encTightPNG:          -260,
   encDesktopSize:       -223,
   encH264RectEnc:        20 + 0x574d5600,
   encTightDiffComp:      22 + 0x574d5600,
   encH264MP4:            24 + 0x574d5600,
   encVMWDefineCursor:   100 + 0x574d5600,
   encVMWCursorState:    101 + 0x574d5600,
   encVMWCursorPosition: 102 + 0x574d5600,
   encVMWTypematicInfo:  103 + 0x574d5600,
   encVMWLEDState:       104 + 0x574d5600,
   encVMWServerPush2:    123 + 0x574d5600,
   encVMWServerCaps:     122 + 0x574d5600,
   encVMWFrameStamp:     124 + 0x574d5600,
   encOffscreenCopyRect: 126 + 0x574d5600,
   encUpdateCache:       127 + 0x574d5600,
   encTopologyChangeEnc: 128 + 0x574d5600,
   encH264MultimonEnc:   129 + 0x574d5600,
   encTightJpegQuality10: -23,

   diffCompCopyFromPrev: 0x1,
   diffCompAppend: 0x2,
   diffCompAppendRemaining:  0x3,

   updateCacheOpInit:        0,
   updateCacheOpBegin:       1,
   updateCacheOpEnd:         2,
   updateCacheOpReplay:      3,

   updateCacheCapDisableOffscreenSurface: 0x2,
   updateCacheCapReplay: 0x4,
   /**
    * @const
    * Signifies that the decoder will use the rectangle header as the region to
    * apply the scatter mask, rather than the entire virtual framebuffer. This
    * is required for the encoder to do per-head multimon encoding where each
    * head may have an origin not on a 16-pixel boundary in the virtual
    * framebuffer.
    * Clients advertising this cap are compatible with older servers as those
    * servers always used the VBB bounds as the rectangle header, so only the
    * server needs to check and handle both cases.
    */
   updateCacheCapSubRectangle: 0x100,

   /*
    * Capability bits from VMWServerCaps which we can make use of.
    */
   serverCapKeyEvent:             0x002,
   serverCapClientCaps:           0x008,
   serverCapUpdateAck:            0x020,
   serverCapRequestResolution:    0x080,
   serverCapKeyEvent2Unicode:     0x100,
   serverCapKeyEvent2JSKeyCode:   0x200,
   serverCapAudioAck:             0x400,
   serverCapMultiMon:             0x1000,
   serverCapUpdateCacheInfo:      0x2000,
   serverCapDisablingCopyUI:      0x4000,
   serverCapDisablingPasteUI:     0x8000,
   serverCapSessionClose:         0x20000,
   serverCapHasMKSVChanClipboard: 0x40000,
   serverCapRequestStreamState:   0x400000,

   /*
    * Capability bits from VMClientCaps which we make use of.
    */
   clientCapHeartbeat:            0x100,
   clientCapVorbisAudioClips:     0x200,
   clientCapAacAudioClips:        0x800,
   clientCapAudioAck:             0x1000,
   clientCapSetReconnectToken:    0x4000,
   clientCapSessionClose:         0x8000,
   clientCapUseMKSVChanClipboard: 0x10000,
   clientCapUseAudioMixer:        0x20000,
   clientCapOpusAudioClips:       0x100000,

   /*
    * Flags in the requestStreamState packet
    */
   streamStateDisableAudio: 0x1,
   streamStateDisableVideo: 0x2,

   /*
    * Flags in the VNCAudioData packet
    */
   audioflagRequestAck:       0x1,
   audioflagFmtMask:          0x3f << 24,
   audioflagFmtShift:         24,
   audioFlagFmtClipsVorbis:   4,
   audioFlagFmtClipsOpus:     5,
   audioFlagFmtClipsAac:      6,

   /*
    * Sub-encodings for the tightPNG encoding.
    */
   subEncFill: 0x80,
   subEncJPEG: 0x90,
   subEncPNG:  0xA0,
   subEncDiffJpeg:  0xB0,
   subEncMask: 0xF0,

   mouseTimeResolution: 16,  // milliseconds
   resolutionDelay: 300     // milliseconds
});





/** @private */

/*
 *------------------------------------------------------------------------------
 *
 * fail
 *
 *    Prints an error message and disconnects from the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Prints an error message and disconnects from the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.fail = function (msg) {
   WMKS.LOGGER.log(msg);
   this.disconnect();
   return null;
};



/*
 *------------------------------------------------------------------------------
 *
 * _assumeServerIsVMware
 *
 *    Enables features available only on VMware servers.
 *
 *    This is called when we have reason to believe that we are connecting
 *    to a VMware server. Old servers do not advertise their extensions,
 *    so we have to rely on fingerprinting for those.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Enables VMware-only features, which may crash connections
 *    to non-VMware servers.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._assumeServerIsVMware = function () {
   /*
    * Only when we skip VNC authentication we also assume that the server
    * is a VMware one. This is an additional protection in case someone
    * implements a server that emits CursorState updates.
    */
   if (!this.usedVNCHandshake) {
      return;
   }

   /*
    * The server seems to be a VMware server. Enable proprietary extensions.
    */
   this.useVMWKeyEvent = true;
};






/*
 *
 * RX/TX queue management
 *
 */


/*
 *------------------------------------------------------------------------------
 *
 * _receiveQueueBytesUnread
 *
 *    Calculates the number of bytes received but not yet parsed.
 *
 * Results:
 *    The number of bytes locally available to parse.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._receiveQueueBytesUnread = function () {
   "use strict";

   return this._receiveQueueLength - this._receiveQueueIndex;
};


/*
 *------------------------------------------------------------------------------
 *
 * _receiveQueueConsumeBytes
 *
 *    Advances the read pointer the specified number of bytes into the
 *    current websocket message.  Note that a complete VNC message may
 *    be split into more than one websocket message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._receiveQueueConsumeBytes = function (nr) {
   this._receiveQueueIndex += nr;

   while (this._receiveQueueIndex > 0 &&
          this._receiveQueue[0].data.byteLength <= this._receiveQueueIndex) {
      this._receiveQueueLength -= this._receiveQueue[0].data.byteLength;
      this._receiveQueueIndex -= this._receiveQueue[0].data.byteLength;
      this._receiveQueue.shift();
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _receiveQueueReset
 *
 *    Resets the receive queue, eg after websocket disconnect.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._receiveQueueReset = function () {
   this._receiveQueue = [];
   this._receiveQueueLength = 0;
   this._receiveQueueIndex = 0;
};


/*
 *------------------------------------------------------------------------------
 *
 * _readBytes
 *
 *    Pops the first 'length' bytes from the front of the receive buffer.
 *
 * Results:
 *    Array of 'length' bytes.
 *
 * Side Effects:
 *    Advances receive buffer.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readBytes = function (length) {
   "use strict";

   if (this._receiveQueueIndex + length <=
       this._receiveQueue[0].data.byteLength) {

      var result = new Uint8Array(this._receiveQueue[0].data,
                                  this._receiveQueueIndex,
                                  length);

      this._receiveQueueConsumeBytes(length);

      return result;
   } else {
      var result = new Uint8Array(length);
      var offset = 0;

      while (length > 0) {
         var thisAmt = Math.min(length,
                                this._receiveQueue[0].data.byteLength -
                                this._receiveQueueIndex);

         var tmp = new Uint8Array(this._receiveQueue[0].data,
                                  this._receiveQueueIndex,
                                  thisAmt);
         result.set(tmp, offset);
         offset += thisAmt;
         length -= thisAmt;
         this._receiveQueueConsumeBytes(thisAmt);
      }

      return result;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _readByte
 *
 *    Pops the first byte from the front of the receive buffer.
 *
 * Results:
 *    First byte of the receive buffer.
 *
 * Side Effects:
 *    Advances receive buffer.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readByte = function () {
   "use strict";

   var bytes = this._readBytes(1);
   return bytes[0];
};


/*
 *------------------------------------------------------------------------------
 *
 * _skipBytes
 *
 *    Drops 'nr' bytes from the front of the receive buffer.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Advances receive buffer.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._skipBytes = function (nr) {
   "use strict";
   this._receiveQueueConsumeBytes(nr);
};


/*
 *------------------------------------------------------------------------------
 *
 * _readString
 *
 *    Pops the first 'stringLength' bytes from the front of the read buffer.
 *
 * Results:
 *    An array of 'stringLength' bytes.
 *
 * Side Effects:
 *    Advances receive buffer.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readString = function (stringLength) {
   "use strict";

   var bytes = this._readBytes(stringLength);

   return stringFromArray(bytes);
};




/*
 *------------------------------------------------------------------------------
 *
 * _readStringUTF8
 *
 *    Pops the first 'stringLength' bytes from the front of the read buffer
 *    and parses the string for unicode. If it finds unicode, it converts them
 *    to unicode and returns the unicode string.
 *
 * Results:
 *    A unicode string thats as long as 'stringLength' in case of non-unicodes
 *    or shorter.
 *
 * Side Effects:
 *    Advances receive buffer.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readStringUTF8 = function (stringLength) {
   "use strict";

   var c, c1, c2, c3, valArray = [], i = 0;
   var bytes = this._readBytes(stringLength);

   while (i < stringLength) {
      c = bytes[i];
      if (c < 128) {
          // Handle non-unicode string here.
          valArray.push(c);
          i++;
      } else if (c < 224) {
         c1 = bytes[i+1] & 63;
         valArray.push(((c & 31) << 6) | c1);
         i += 2;
      } else if (c < 240) {
         c1 = bytes[i+1] & 63;
         c2 = bytes[i+2] & 63;
         valArray.push(((c & 15) << 12) | (c1 << 6) | c2);
         i += 3;
      } else {
         c1 = bytes[i+1] & 63;
         c2 = bytes[i+2] & 63;
         c3 = bytes[i+3] & 63;
         valArray.push(((c & 7) << 18) | (c1 << 12) | (c2 << 6) | c3);
         i += 4;
      }
   }

   // Apply all at once is faster:
   // http://jsperf.com/string-fromcharcode-apply-vs-for-loop
   //
   return String.fromCharCode.apply(String, valArray);
};




/*
 *------------------------------------------------------------------------------
 *
 * _readInt16
 *
 *    Pops the first two bytes from the front of the receive buffer.
 *
 * Results:
 *    First two bytes of the receive buffer.
 *
 * Side Effects:
 *    Advances receive buffer.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readInt16 = function () {
   "use strict";

   var bytes = this._readBytes(2);

   return ((bytes[0] << 8) +
           (bytes[1]));
};


/*
 *------------------------------------------------------------------------------
 *
 * _readInt32
 *
 *    Pops the first four bytes from the front of the receive buffer.
 *
 * Results:
 *    First four bytes of the receive buffer.
 *
 * Side Effects:
 *    Advances receive buffer.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readInt32 = function () {
   "use strict";

   var bytes = this._readBytes(4);

   return ((bytes[0] << 24) +
           (bytes[1] << 16) +
           (bytes[2] <<  8) +
           (bytes[3]));
};




/*
 *------------------------------------------------------------------------------
 *
 * _sendString
 *
 *    Sends a string to the server, using the appropriate encoding.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendString = function (stringValue) {
   "use strict";
   this._sendBytes(arrayFromString(stringValue));
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendBytes
 *
 *    Sends the array 'bytes' of data bytes to the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendBytes = function (bytes) {
   "use strict";
   if (!this._websocket) {
      return;
   }

   var msg = new ArrayBuffer(bytes.length);
   var uint8View = new Uint8Array(msg);
   var i;
   for (i = 0; i < bytes.length; i++) {
      uint8View[i] = bytes[i];
   }
   this._websocket.send(msg);
};





/*
 *
 * Parser / queue bridge helpers
 *
 */

WMKS.VNCDecoder.prototype._setReadCB = function(bytes, nextFn, nextArg) {
   this.nextBytes = bytes;
   this.nextFn = nextFn;
   this.nextArg = nextArg;
};


/*
 *
 * Client message sending
 *
 */


/*
 *------------------------------------------------------------------------------
 *
 * _sendMouseEvent
 *
 *    Sends the current absolute mouse state to the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 * When isAbsolute is TRUE, the x and y fields represent the current
 * mouse location in server pixels (ie, in the virtual bounding box,
 * translated so that the upper left corner is (0,0) ).  The x and y
 * values increase as you move right and down.
 *
 * When isAbsolute is FALSE, the x and y fields represent unaccelerated
 * relative mouse moves (in client pixels).  The x and y values increase
 * as you move right and down.
 *
 * uint8 isAbsolute;
 * int32 x;
 * int32 y;

 *
 * Button order goes from least to most significant bit as
 * HID_MOUSE_BUTTONX.  The button is currently pressed iff the bit is set.
 *
 * 0x01 HID_MOUSE_BUTTON_LEFT
 * 0x02 HID_MOUSE_BUTTON_RIGHT
 * 0x04 HID_MOUSE_BUTTON_MIDDLE
 * 0x08 HID_MOUSE_BUTTON4
 * 0x10 HID_MOUSE_BUTTON5 etc.
 *
 uint32 buttons;

 * HID_MOUSE_WHEEL: (vertical scroll)
 * -1: Scroll down
 *  0: Do not scroll
 *
 int8 wheel;

 * HID_MOUSE_HSCROLL: (horizontal scroll)
 * -1: Scroll left
 *  0: Do not scroll
 *  1: Scroll right
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendMouseEvent = function () {
   if (this.options.sendRelativeMouseEvent) {
      //send relative mouse event
      var arr = [];
      arr.push8(this.msgVMWClientMessage);
      arr.push8(this.msgVMWPointerEvent2);   // Pointer event 2 message sub-type
      arr.push16(19);  // Length
      arr.push8(0);    // isAbsolute
      arr.push32(this._mouseX); //dx
      arr.push32(this._mouseY); //dy
      arr.push32(this._mouseButtonMask); //buttons
      arr.push8(0);  //wheel
      arr.push8(0); //hscroll
      this._sendBytes(arr);
      this._mouseActive = false;
   } else {
      //send absolute mouse event
      var arr = [];
      arr.push8(this.msgPointerEvent);
      arr.push8(this._mouseButtonMask);
      arr.push16(this._mouseX);
      arr.push16(this._mouseY);
      this._sendBytes(arr);
      this._mouseActive = false;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendResolutionRequest
 *
 *    Sends the most recently requested resolution to the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendResolutionRequest = function () {
   var arr = [];
   arr.push8(this.msgVMWClientMessage);
   arr.push8(5);       // Resolution request 2 message sub-type
   arr.push16(8);      // Length
   arr.push16(this.requestedWidth);
   arr.push16(this.requestedHeight);
   this._sendBytes(arr);
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendTopologyRequest
 *
 *    Sends the requested topology to the server.
 *    This is mainly a javascript version of VNCDecode_SendResolutionRequest()
 *    at bora/lib/vnc/vncDecodeBackend.c
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendTopologyRequest = function (multiMonRects) {
   var arr = [],
       i = 0;
   arr.push8(this.msgVMWClientMessage);
   // VNCVMWClientMessageID::VNCVMWRequestMultimonID @ bora/public/vnc.h
   arr.push8(10);
   /*
    * 6 bytes : 2 of push8s, 2 of push16s.
    * 20 bytes: size of each monitor rectangle.
    */
   arr.push16(6 + 20 * multiMonRects.length);
   arr.push16(multiMonRects.length);
   for (i = 0; i < multiMonRects.length; i++) {
      // Each rectangle is 20 bytes in size, 5 items of 4 bytes each.
      arr.push32(multiMonRects[i].left);
      arr.push32(multiMonRects[i].top);
      arr.push32(multiMonRects[i].requestedWidth);
      arr.push32(multiMonRects[i].requestedHeight);
      arr.push32(0);
   }
   this._sendBytes(arr);
};


/*
 *------------------------------------------------------------------------------
 *
 * _customRendererEnabled
 *
 *    Return whether should redirect control and data into the  customized
 *    multimonRenderer than use them locally, which should only be true
 *    after entering the multimon with a valid multimonRenderer existing.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._customRendererEnabled = function () {
   return this._isInMultimonMode && !!this._multimonRenderer;
};

/*
 *------------------------------------------------------------------------------
 *
 * _sendClientEncodingsMsg
 *
 *    Sends the server a list of supported image encodings.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendClientEncodingsMsg = function () {
   var i;
   var encodings = [this.encTightDiffComp,
                    this.encTightPNG,
                    this.encDesktopSize,
                    this.encVMWDefineCursor,
                    this.encVMWCursorState,
                    this.encVMWCursorPosition,
                    this.encVMWTypematicInfo,
                    this.encVMWLEDState,
                    this.encVMWServerPush2,
                    this.encVMWServerCaps,
                    this.encTightJpegQuality10,
                    this.encVMWFrameStamp,
                    this.encUpdateCache];

   if (this.options.mediaPlayer) {
      encodings.unshift(this.encH264MP4);
   }
   if (this.options.enableRawH264) {
      encodings.unshift(this.encH264RectEnc);
   }
   if (this.options.enableTopologyChange) {
      encodings.unshift(this.encToppologyChangeEnc);
   }
   if (this.options.enableH264Multimon) {
      encodings.unshift(this.encH264MultimonEnc);
   }

   if (this._canvas[1]) {
      encodings = [this.encOffscreenCopyRect].concat(encodings);
   }

   /*
    * Blits seem to work well on most browsers now.
    */
   encodings = [this.encCopyRect].concat(encodings);

   var message = [];
   message.push8(this.msgClientEncodings);
   message.push8(0);
   message.push16(encodings.length);
   for (i = 0; i < encodings.length; i += 1) {
      message.push32(encodings[i]);
   }
   this._sendBytes(message);
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendFBUpdateRequestMsg
 *
 *    Sends the server a request for a new image, and whether
 *    the update is to be incremental.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendFBUpdateRequestMsg = function (incremental) {
   var message = [];
   message.push8(this.msgFBUpdateRequest);
   message.push8(incremental);
   message.push16(0);
   message.push16(0);
   message.push16(this._FBWidth);
   message.push16(this._FBHeight);
   this._sendBytes(message);
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendAck
 *
 *    Sends the server an acknowledgement of rendering the frame.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendAck = function(renderMilliseconds, updateReqId) {
   var msg;
   if (this.useVMWAck) {
      /*
       * Add one millisecond to account for the enforced sleep
       * between frames, and another as a bit of a swag.
       */
      var time = (renderMilliseconds + 2) * 10;
      var arr = [];
      arr.push8(this.msgVMWClientMessage);
      arr.push8(4);           // ACK message sub-type
      arr.push16(8);          // Length
      arr.push8(updateReqId); // update id
      arr.push8(0);           // padding
      arr.push16(time);       // render time in tenths of millis
      this._sendBytes(arr);
   } else {
      this._sendFBUpdateRequestMsg(updateReqId);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendAudioAck
 *
 *    Sends the server an acknowledgement of an audio packet.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendAudioAck = function(timestampLo, timestampHi) {
   var arr = [];
   arr.push8(this.msgVMWClientMessage);
   arr.push8(this.msgVMWAudioAck);
   arr.push16(12); // length
   arr.push32(timestampLo);
   arr.push32(timestampHi);
   this._sendBytes(arr);
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendRequestStreamState
 *
 *    Sends the server a requestStreamState packet.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *    Can lead to the server disabling / enabling sending of video and audio.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendRequestStreamState = function(state) {
   if (this._serverInitialized && this.useVMWRequestStreamState) {
      var arr = [];
      arr.push8(this.msgVMWClientMessage);
      arr.push8(this.msgVMWRequestStreamState);
      arr.push16(8); // Length
      arr.push32(state);
      this._sendBytes(arr);
   }
};


/*
 *
 * Cursor updates
 *
 */


/*
 *------------------------------------------------------------------------------
 *
 * _changeCursor
 *
 *    Generates an array containing a Windows .cur file and loads it
 *    as the browser cursor to be used when hovering above the canvas.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Changes the cursor in the browser.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._changeCursor = function(pixels, mask, hotx, hoty, w, h) {
   var cursorData = [];

   var RGBImageDataSize = w * h * 4;   // 32 bits per pixel image data
   var maskSize = Math.ceil((w * h) / 8.0);  // 1 bit per pixel of mask data.

   var cursorDataSize = (RGBImageDataSize + 40 + /* Bitmap Info Header Size */
                         maskSize * 2);          /* 2 masks XOR & AND */

   var x, y;
   /*
    * We need to build an array of bytes that looks like a Windows .cur:
    *   -> http://en.wikipedia.org/wiki/ICO_(file_format)
    *   -> http://en.wikipedia.org/wiki/BMP_file_format
    */
   cursorData.push16le(0);
   cursorData.push16le(2);     // .cur type
   cursorData.push16le(1);     // One image

   cursorData.push8(w);
   cursorData.push8(h);
   cursorData.push8(0);        // True Color cursor
   cursorData.push8(0);
   cursorData.push16le(hotx);  // Hotspot X location
   cursorData.push16le(hoty);  // Hostpot Y location

   // Total size of all image data including their headers (but
   // excluding this header).
   cursorData.push32le(cursorDataSize);

   // Offset (immediately past this header) to the BMP data
   cursorData.push32le(cursorData.length+4);

   // Bitmap Info Header
   cursorData.push32le(40);    // Bitmap Info Header size
   cursorData.push32le(w);
   cursorData.push32le(h*2);
   cursorData.push16le(1);
   cursorData.push16le(32);
   cursorData.push32le(0);     // Uncompressed Pixel Data
   cursorData.push32le(RGBImageDataSize  + (2 * maskSize));
   cursorData.push32le(0);
   cursorData.push32le(0);
   cursorData.push32le(0);
   cursorData.push32le(0);

   /*
    * Store the image data.
    * Note that the data is specified UPSIDE DOWN, like in a .bmp file.
    */
   for (y = h-1; y >= 0; y -= 1) {
      for (x = 0; x < w; x += 1) {
         /*
          * The mask is an array where each bit position indicates whether or
          * not the pixel is transparent. We need to convert that to an alpha
          * value for the pixel (clear or solid).
          */
         var arrayPos = y * Math.ceil(w/8) + Math.floor(x/8);
         var alpha = 0;
         if (mask.length > 0) {
            alpha = (mask[arrayPos] << (x % 8)) & 0x80 ? 0xff : 0;
         }

         arrayPos = ((w * y) + x) * 4;
         cursorData.push8(pixels[arrayPos]);
         cursorData.push8(pixels[arrayPos+1]);
         cursorData.push8(pixels[arrayPos+2]);
         if (mask.length > 0) {
            cursorData.push8(alpha);
         } else {
            cursorData.push8(pixels[arrayPos+3]);
         }
      }
   }

   /*
    * The XOR and AND masks need to be specified - but the data is unused
    * since the alpha channel of the cursor image is sufficient. So just
    * fill in a blank area for each.
    */
   for (y = 0; y < h; y += 1) {
      // The masks are single bit per pixel too
      for (x = 0; x < Math.ceil(w/8); x +=1) {
         cursorData.push8(0);
      }
   }

   for (y = 0; y < h; y += 1) {
      // The masks are single bit per pixel too
      for (x = 0; x < Math.ceil(w/8); x +=1) {
         cursorData.push8(0);
      }
   }

   var url = 'data:image/x-icon;base64,' + Base64.encodeFromArray(cursorData),
      self = this;

   function updateCursor(url, hx, hy) {
      if (!!hx) {
         hotx = hx
      }
      if (!!hy) {
         hoty = hy
      }
      self._currentCursorURI =
         'url(' + url + ') ' + hotx + ' ' + hoty + ', default';
      self._updateCanvasCursor();
   }

   /**
    * Cursor handler is added for bug 1792047
    * When DPI is more than 100%, client needs to scale cursor to draw it right
    */
   if (!!this.options.cursorHandler) {
      this.options.cursorHandler(url, w, h, updateCursor, hotx, hoty);
   } else {
      updateCursor(url);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _readOffscreenCopyRect
 *
 *    Parses payload of an offscreen copy rectangle packet.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readOffscreenCopyRect = function (rect) {
   rect.srcBuffer = this._readByte();
   rect.dstBuffer = this._readByte();
   rect.srcX = this._readInt16();
   rect.srcY = this._readInt16();
   this._nextRect();
};


/*
 *-----------------------------------------------------------------------------
 *
 * _readUpdateCacheData
 *
 *    Parses payload of an updateCache rectangle packet.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *-----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readUpdateCacheData = function (rect) {
   "use strict";

   rect.data = this._readBytes(rect.dataLength);
   this._nextRect();
};

WMKS.VNCDecoder.prototype._readUpdateCacheInitData = function (rect) {
   "use strict";

   this._skipBytes(4);                         // VNCVMWMessageHeader
   rect.flags = this._readInt32();
   rect.updateCacheEntries = this._readInt16();
   this._skipBytes(4);                         // size in kb, not really used
   this._nextRect();
};


/*
 *-----------------------------------------------------------------------------
 *
 * _readUpdateCacheRect
 *
 *    Reads the cached update opcode and dispatches to the correct handler.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *-----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readUpdateCacheRect = function (rect) {
   "use strict";

   rect.opcode = this._readByte();
   rect.slot = this._readInt16();
   rect.dataLength = this._readInt16();

   if (rect.opcode != this.updateCacheOpInit) {
      this._setReadCB(rect.dataLength, this._readUpdateCacheData, rect);
   } else {
      this._setReadCB(rect.dataLength, this._readUpdateCacheInitData, rect);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _readVMWDefineCursorData
 *
 *    Parses a VMware cursor definition payload.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Changes the cursor in the browser.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readVMWDefineCursorData = function (rect) {
   var y, x,
       andData = [], pixels = [], mask = [],
       hexMask, pixelIdx, maskIdx, channels;

   // If this is a color cursor
   if (rect.cursorType === 0) {
       if (rect.masklength > 0) {
          andData = this._readBytes(rect.masklength);
       }

       if (rect.pixelslength > 0) {
          pixels = this._readBytes(rect.pixelslength);
       }

      for (y = 0; y < rect.height; y++) {
         for (x = 0; x < rect.width; x++) {
            pixelIdx = x + y * rect.width;
            maskIdx = y * Math.ceil(rect.width / 8) + Math.floor(x / 8);
            // The mask is actually ordered 'backwards'
            hexMask = 1 << (7 - x % 8);

            // If the and mask is fully transparent
            if ((andData[pixelIdx * 4] === 255) &&
                (andData[pixelIdx * 4 + 1] === 255) &&
                (andData[pixelIdx * 4 + 2] === 255) &&
                (andData[pixelIdx * 4 + 3] === 255)) {
                // If the pixels at this point should be inverted then
                // make the image actually a simple black color.
                for (var channel = 0; channel < 4; channel++) {
                   if (pixels[pixelIdx * 4 + channel] !== 0) {
                     pixels[pixelIdx * 4 + channel] = 0;
                     mask[maskIdx] |= hexMask;
                   }
                }
                // Otherwise leave the mask alone
            } else {
                mask[maskIdx] |= hexMask;
            }
         }
      }
   } else if (rect.cursorType === 1) {      // An Alpha Cursor
       if (rect.pixelslength > 0) {
          pixels = this._readBytes(rect.pixelslength);

          // Recognise and correct a special case cursor - 1x1 fully
          // transparent cursor, which the server sends when the
          // cursor is invisible.  Some browsers render fully
          // transparent cursors as fully opaque, so add a tiny bit of
          // alpha.  This cursor should never be seen as the
          // cursorVisible state should kick in to hide it, but add
          // this as an additional guard against the "extra black dot"
          // cursor of various bug reports.
          //
          if (rect.pixelslength == 4 && pixels[3] == 0) {
             pixels[3] = 1;
          }
       }
   }

   this._changeCursor(pixels, mask,
                      rect.x,
                      rect.y,
                      rect.width,
                      rect.height);
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readVMWDefineCursor
 *
 *    Parses a VMware cursor definition header.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readVMWDefineCursor = function (rect) {
   /*
    * Start with 2 bytes of type (and padding).
    */
   rect.cursorType = this._readByte();
   this._skipBytes(1);

   rect.pixelslength = 4 * rect.width * rect.height;

   if (rect.cursorType === 0) {
      rect.masklength = rect.pixelslength;
   } else {
      rect.masklength = 0;
   }

   this._setReadCB(rect.pixelslength + rect.masklength,
                   this._readVMWDefineCursorData, rect);
};


/*
 *------------------------------------------------------------------------------
 *
 * _updateCanvasCursor
 *
 *    Look at all cursor and browser state and decide what the canvas
 *    cursor style should be.
 *
 *    Note the following caveats:
 *       - MSIE does not support data-uri based cursors, only default or none.
 *       - Firefox on OSX must use "none, !important", not "none", with a
 *            bad bug otherwise (...)
 *       - Chrome and Safari should use "none", and get an extra black dot
 *            for "none, !important"
 *
 *    Apply the new style only if something has changed.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Changes the cursor in the browser.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._updateCanvasCursor = function() {
   var str;
   var currentElement;
   if (this._cursorVisible) {
      if (WMKS.BROWSER.isIE()) {
         // IE is not compatible with dataURI cursors
         str = "default";
      } else {
         str = this._currentCursorURI;
      }
   } else {
      if (WMKS.BROWSER.isFirefox() && WMKS.BROWSER.isMacOS()) {
         str = "none, !important";
      } else {
         // IE is not compatible with "none, !important"
         // Firefox on linux ignores "none, !important"
         str = "none";
      }
   }

   currentElement = this._mediaPlayer || this._canvas[0];
   // At times, we get the same cursor image that's already used, ignore it.
   if (currentElement.style.cursor !== str) {
      currentElement.style.cursor = str;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _readVMWCursorState
 *
 *    Parses a VMware cursor state update (cursor visibility, etc.).
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Changes the cursor in the browser.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readVMWCursorState = function(rect) {
   var cursorState = this._readInt16();
   this._cursorVisible = !!(cursorState & 0x01);
   this._updateCanvasCursor();
   this.options.onCursorStateChanged(this._cursorVisible);
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readVMWCursorPosition
 *
 *    Parses a VMware cursor position update.
 *    Ignores the payload as the client cursor cannot be moved in a browser.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readVMWCursorPosition = function (rect) {
   /*
    * We cannot warp or move the host/browser cursor
    */
   WMKS.VNCDecoder.cursorPosition = rect;
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readTypematicInfo
 *
 *    Parses a typematic info update.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readTypematicInfo = function(rect) {
   this.typematicState = this._readInt16(),
   this.typematicPeriod = this._readInt32(),
   this.typematicDelay = this._readInt32();
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readLEDState
 *
 *    Parses an LED State update.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readLEDState = function(rect) {
   this._keyboardLEDs = this._readInt32();

   this.options.onKeyboardLEDsChanged(this._keyboardLEDs);

   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readFrameStamp
 *
 *    Parses a timestamp frame update.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readFrameStamp = function(rect) {
   this._frameTimestampLo = this._readInt32();
   this._frameTimestampHi = this._readInt32();
   this._nextRect();
};


/*
 *
 * Framebuffer updates
 *
 */


/*
 *------------------------------------------------------------------------------
 *
 * _fillRectWithColor
 *
 *    Fills a rectangular area in the canvas with a solid colour.
  *
 * Results:
 *    None.
 *
 * Side Effects:
 *    A coloured canvas.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._fillRectWithColor = function(canvas2dCtx, x, y,
                                                        width, height, color) {
   var newStyle;
   newStyle = "rgb(" + color[0] + "," + color[1] + "," + color[2] + ")";
   canvas2dCtx.fillStyle = newStyle;
   canvas2dCtx.fillRect(x, y, width, height);
};


/*
 *------------------------------------------------------------------------------
 *
 * _blitImageString
 *
 *    Blits a serialised image (as a string) onto the canvas.
 *    Ignores the Alpha channel information and blits it opaquely.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    A coloured canvas.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._blitImageString = function(canvas2dCtx, x, y,
                                                      width, height, str) {
   var img, i, data;
   img = canvas2dCtx.createImageData(width, height);
   data = img.data;
   for (i=0; i < (width * height * 4); i=i+4) {
      data[i    ] = str.charCodeAt(i + 2);
      data[i + 1] = str.charCodeAt(i + 1);
      data[i + 2] = str.charCodeAt(i + 0);
      data[i + 3] = 255; // Set Alpha
   }
   canvas2dCtx.putImageData(img, x, y);
};


/*
 *------------------------------------------------------------------------------
 *
 * _copyRectGetPut
 * _copyRectDrawImage
 * _copyRectDrawImageTemp
 *
 *    Copy a rectangle from one canvas/context to another.  The
 *    canvas/contexts are indicated by an index into this._canvas[]
 *    array.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._copyRectGetPut = function (srcIndex,
                                                      srcX, srcY,
                                                      width, height,
                                                      dstIndex,
                                                      dstX, dstY) {
   var img;
   img = this._canvas[srcIndex].ctx.getImageData(srcX, srcY,
                                                 width, height);

   this._canvas[dstIndex].ctx.putImageData(img, dstX, dstY);
   delete img;
};


WMKS.VNCDecoder.prototype._copyRectDrawImage = function (srcIndex,
                                                         srcX, srcY,
                                                         width, height,
                                                         dstIndex,
                                                         dstX, dstY) {
   this._canvas[dstIndex].ctx.drawImage(this._canvas[srcIndex],
                                        srcX, srcY,
                                        width, height,
                                        dstX, dstY,
                                        width, height);
};


WMKS.VNCDecoder.prototype._copyRectDrawImageTemp = function (srcIndex,
                                                             srcX, srcY,
                                                             width, height,
                                                             dstIndex,
                                                             dstX, dstY) {
   this._copyRectDrawImage(srcIndex,
                           srcX, srcY,
                           width, height,
                           2,
                           srcX, srcY);

   this._copyRectDrawImage(2,
                           srcX, srcY,
                           width, height,
                           dstIndex,
                           dstX, dstY);
};


/*
 *------------------------------------------------------------------------------
 *
 * _lighten
 *
 *    Blend a coloured rectangle onto the frontbuffer canvas.  Useful
 *    for tracking how different parts of the screen are drawn and
 *    debugging protocol operations.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._lighten = function(x, y, w, h, color) {
   "use strict";

   this._canvas[0].ctx.globalCompositeOperation = "lighten";
   this._canvas[0].ctx.fillStyle = color;
   this._canvas[0].ctx.fillRect(x, y, w, h);
   this._canvas[0].ctx.globalCompositeOperation = "source-over";
};


/*
 *------------------------------------------------------------------------------
 *
 * _decodeDiffComp
 *
 *    Decodes a diff-compressed jpeg string from the encoder.  This
 *    permits us to reuse portions of the previous jpeg image - in
 *    particular to copy the quantization and huffman tables which are
 *    frequently identical between successive images.
 *
 *    For more information about diff-compressed jpeg, see the
 *    description of this extension in bora/public/vnc.h.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._decodeDiffComp = function (data, oldData) {
   "use strict";

   var l = 0;
   var i = 0;
   var out = new Uint8Array(1024);
   var data2;

   // Construct a full jpeg rectangle from the first 1024 bytes of the
   // previous rectangle, plus the diff-compressed incoming data.
   //
   while (i < data.length && l <= out.length) {
      switch (data[i++]) {
      case this.diffCompCopyFromPrev:
         // Copy up to 255 bytes from the previous decompressed
         // rectangle.
         var nr = data[i++];
         out.set(oldData.subarray(l, l+nr), l);
         l += nr;
         break;
      case this.diffCompAppend:
         // Append up to 255 bytes from the incoming (compressed)
         // rectangle.
         var nr = data[i++];
         out.set(data.subarray(i, i+nr), l);
         i += nr;
         l += nr;
         break;
      case this.diffCompAppendRemaining:
         // Append the remainder of the incoming rectangle.  This is
         // the final opcode.
         data2 = new Uint8Array(l + data.length - i);
         data2.set(out.subarray(0, l), 0);

         // It is possible that i == data.length at this point, IE10 does not
         // like doing .subarray at the end of an array, so we must avoid it.
         if (i < data.length) {
            data2.set(data.subarray(i), l);
         }

         return data2;
      }
   }

   // This exit point can occur only for small rectangles less than
   // 1024 bytes in length which happen not to finish with an
   // AppendRemaining opcode.  This is legal but rare.
   //
   return out.subarray(0, l);
};


/*
 *------------------------------------------------------------------------------
 *
 * _readTightData
 *
 *    Parses a compressed FB update payload.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readTightData = function (rect) {
   /*
    * Skip the preamble and read the actual JPEG data.
    */
   var data = this._readBytes(this.nextBytes),
       URL  = window.URL || window.webkitURL,
       self = this,
       type;

   if (rect.subEncoding === this.subEncDiffJpeg) {
      data = this._decodeDiffComp(data, this._lastJpegData);
   }

   if (rect.subEncoding !== this.subEncPNG) {
      this._lastJpegData = data;
      type = 'image/jpeg';
   } else {
      type = 'image/png';
   }

   if (this._useImageBitmaps) {
      /*
       * Unfortunately we cannot move the callback function(){} here out to
       * be static because createImageBitmap returns a future with imageBitmap
       * as the argument, and we need to associate that imageBitmap with the
       * correct rect, and this can only done by creating a new clousure.
       */
      createImageBitmap(new Blob([data], {type: type}))
         .then(function (imageBitmap) {
            rect.image = imageBitmap;
            self.onDecodeComplete();
         });
   } else {
      /*
       * Construct an Image and keep a reference to it in the
       * rectangle object. Since Images are loaded asynchronously
       * we can't draw it until the image has finished loading so
       * we don't call onDecodeComplete() until this has happened.
       */
      rect.image = this._imageManager.getImage();
      rect.image.width = rect.width;
      rect.image.height = rect.height;

      if (URL) {
         rect.image.onload = this.onDecodeObjectURLComplete;
         rect.image.src = URL.createObjectURL(new Blob([data], {type: type}));
      } else {
         // Ensure data is in base64 string format
         data = Base64.encodeFromArray(data);
         rect.image.onload = this.onDecodeComplete;
         rect.image.src = 'data:' + type + ';base64,' + data;
      }
   }

   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readTightPNG
 *
 *    Parses the head of a compressed FB update payload.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readTightPNG = function (rect) {

   rect.subEncoding = this._readByte();
   rect.subEncoding &= this.subEncMask;

   /*
    * if _mediaPlayer is set, widgetProto is prepared to use a MP4 encoding and we
    * need to notify it to activate canvas element.
    * But we shall only active canvas element while not in the multimon mode,
    * since that the working canvases in the multimon mode is controlled by the
    * UI layer.
    */
   if (this._mediaPlayer && !this._customRendererEnabled()) {
      this.options.onEncodingChanged("TightPNG");
   }

   if (rect.subEncoding === this.subEncFill) {
      rect.color = [];
      rect.color[0] = this._readByte();
      rect.color[1] = this._readByte();
      rect.color[2] = this._readByte();
      rect.color[3] = 0xff;
      this.rectsDecoded++;
      this._nextRect();
   } else {
      var lengthSize = 1;
      var dataSize = this._readByte();
      if (dataSize & 0x80) {
         lengthSize = 2;
         dataSize &= ~0x80;
         dataSize += this._readByte() << 7;
         if (dataSize & 0x4000) {
            lengthSize = 3;
            dataSize &= ~0x4000;
            dataSize += this._readByte() << 14;
         }
      }

      this._setReadCB(dataSize, this._readTightData, rect);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _readH264MP4Rect
 *
 *    Parses the head of a MP4 FB update payload. If this is the first frame of
 *    MP4 stream, we will reset the media source object.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readH264MP4Rect = function(rect) {
   var opcode = this._readInt16();
   var streamId = this._readInt16();
   var dataSize = this._readInt32();

   if (this._customRendererEnabled()) {
      // Stream is reset on the server. We need to reset media source object.
      if (opcode === 1) {
         WMKS.LOGGER.log("MP4 encoding is selected and stream is reset in the" +
            " multimon mode with id " + streamId);
         this._multimonRenderer.onInit("mp4", {streamId: streamId},
            this.onDecodeComplete, this.onDecodeMP4Error);
      }

      this._setReadCB(dataSize, this._readMultimonH264MP4Data, streamId);
   } else {
      // Stream is reset on the server. We need to reset media source object.
      if (opcode === 1) {
         WMKS.LOGGER.log("MP4 encoding is selected and stream is reset.");
         this.options.onEncodingChanged("MP4");
         this._mp4Decoder.init(this._mediaPlayer, undefined, undefined,
            this.onDecodeComplete, this.onDecodeMP4Error);
      }

      this._setReadCB(dataSize, this._readH264MP4Data, rect);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _readH264MP4Data
 *
 *    Parses a MP4 FB update payload and play the video if Media source object
 *    is ready. Otherwise, put the data to the cache.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readH264MP4Data = function(rect) {
   this._mp4Decoder.appendData(this._readBytes(this.nextBytes));
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readMultimonH264MP4Data
 *
 *    Pass the mp4 data into the multimon renderer for displaying, which is also
 *    able to cache the package if not able to display right away.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readMultimonH264MP4Data = function(streamId) {
   this._multimonRenderer.onData("mp4", {
         streamId: streamId,
         data: this._readBytes(this.nextBytes)
      },
      this.onDecodeComplete, this.onDecodeMP4Error
   );
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readH264Rect
 *
 *    Parses the head of a raw H.264 FB update payload. If this is the first
 *    frame of raw stream, we will reset the media source object.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readH264Rect = function(rect) {
   var opcode = this._readInt16();
   var streamId = this._readInt16();
   var dataSize = this._readInt32();

   // Stream is reset on the sever. We need to reset media source object.
   if (opcode === 1) {
      /*
       * Raw H264 is not handled by browser natively. So, do nothing when we
       * receive this data.
       */
      WMKS.LOGGER.log("Raw H264 encoding is selected and stream is reset.");
      if (!this._customRendererEnabled()) {
         /*
          * Skip the onEncodingChanged call in multimon mode, since it will be
          * handled in the UI layer for each monitors.
          * p.s. actually, we haven't support this mode yet.
          */
         this.options.onEncodingChanged("RawH264");
      }
   }

   this._setReadCB(dataSize, this._readH264Data, rect);
};


/*
 *------------------------------------------------------------------------------
 *
 * _readH264Data
 *
 *       Parses a RAW FB update payload and do nothing (drop it).
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readH264Data = function(rect) {
   // do nothing
   this._readBytes(this.nextBytes);
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readCopyRect
 *
 *    Parses a CopyRect (blit) FB update.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readCopyRect = function (rect) {
   rect.srcX = this._readInt16();
   rect.srcY = this._readInt16();
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readRaw
 *
 *    Reads a raw rectangle payload.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readRaw = function (rect) {
   rect.imageString = this._readString(this.nextBytes);
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readDesktopSize
 *
 *    Parses a screen size update.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Calls the outer widget's onNewDesktopSize callback.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readDesktopSize = function (rect) {
   this._FBWidth = rect.width;
   this._FBHeight = rect.height;

   /*
    * Resize the canvas to the new framebuffer dimensions.
    */
   this.options.onNewDesktopSize(this._FBWidth, this._FBHeight);
   this._nextRect();
};


/*
 *------------------------------------------------------------------------------
 *
 * _readRect
 *
 *    Parses an FB update rectangle.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._readRect = function() {
   var i = this.rectsRead;

   this.rect[i] = {};
   this.rect[i].x        = this._readInt16();
   this.rect[i].y        = this._readInt16();
   this.rect[i].width    = this._readInt16();
   this.rect[i].height   = this._readInt16();
   this.rect[i].encoding = this._readInt32();

   if (this.rect[i].encoding !== this.encTightPNG &&
       this.rect[i].encoding !== this.encH264MP4) {
      this.rectsDecoded++;
   }

   switch (this.rect[i].encoding) {
   case this.encRaw:
      this._setReadCB(this.rect[i].width *
                      this.rect[i].height *
                      this._FBBytesPerPixel,
                      this._readRaw, this.rect[i]);
      break;
   case this.encCopyRect:
      this._setReadCB(4, this._readCopyRect, this.rect[i]);
      break;
   case this.encOffscreenCopyRect:
      this._setReadCB(6, this._readOffscreenCopyRect, this.rect[i]);
      break;
   case this.encUpdateCache:
      this._setReadCB(5, this._readUpdateCacheRect, this.rect[i]);
      break;
   case this.encH264RectEnc:
      // VNCDecodeReadUpdateRectangle @ bora/lib/vnc/vncDecode.c
      this._setReadCB(8, this._readH264Rect, this.rect[i]);
      break;
   case this.encTightPNG:
      this._setReadCB(4, this._readTightPNG, this.rect[i]);
      break;
   case this.encH264MP4:
      this._setReadCB(8, this._readH264MP4Rect);
      break;
   case this.encDesktopSize:
      this._readDesktopSize(this.rect[i]);
      break;
   case this.encVMWDefineCursor:
      this._setReadCB(2, this._readVMWDefineCursor, this.rect[i]);
      break;
   case this.encVMWCursorState:
      this._assumeServerIsVMware();
      this._setReadCB(2, this._readVMWCursorState, this.rect[i]);
      break;
   case this.encVMWCursorPosition:
      this._readVMWCursorPosition(this.rect[i]);
      break;
   case this.encVMWTypematicInfo:
      this._setReadCB(10, this._readTypematicInfo, this.rect[i]);
      break;
   case this.encVMWLEDState:
      this._setReadCB(4, this._readLEDState, this.rect[i]);
      break;
   case this.encVMWFrameStamp:
      this._setReadCB(8, this._readFrameStamp, this.rect[i]);
      break;
   default:
      return this.fail("Disconnected: unsupported encoding " +
                       this.rect[i].encoding);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _evictUpdateCacheEntry
 *
 *    Evict one entry from the update cache.  This is done in response
 *    to the payload of the Begin opcode as well as the destination
 *    slot of the Begin opcode.
 *
 * Results:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._evictUpdateCacheEntry = function(slot) {
   "use strict";

   if (this.updateCache[slot].image !== null) {
      this._releaseImage(this.updateCache[slot].image);
   }

   this.updateCache[slot] = {};
   this.updateCache[slot].image = null;
};


/*
 *----------------------------------------------------------------------------
 *
 * _executeUpdateCacheInit --
 *
 *      Handle the UPDATE_CACHE_OP_INIT subcommand.  This resets the
 *      cache, evicting all entries and resets the cache sizes and
 *      flags.  The sizes and flags must be a subset of those which
 *      the client advertised in the capability packet.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Resets update cache.
 *
 *----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._executeUpdateCacheInit = function(rect) {
   "use strict";

   var i;

   for (i = 0; i < this.updateCacheEntries; i++) {
      this._evictUpdateCacheEntry(i);
   }

   this.updateCache = [];
   this.updateCacheEntries = rect.updateCacheEntries;
   this.cacheFlags = rect.flags;

   if (this.updateCacheEntries > this.options.cacheSizeEntries) {
      return this.fail("Disconnected: requested cache too large");
   }

   for (i = 0; i < this.updateCacheEntries; i++) {
      this.updateCache[i] = {};
      this.updateCache[i].image = null;
   }
};


/*
 *----------------------------------------------------------------------------
 *
 * _updateCacheInsideBeginEnd --
 *
 *      Returns true if the decoder has received in the current
 *      framebuffer update message a VNC_UPDATECACHE_OP_BEGIN message
 *      but not yet received the corresponding OP_END.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._updateCacheInsideBeginEnd = function () {
   return this.decodeToCacheEntry !== -1;
};


/*
 *----------------------------------------------------------------------------
 *
 * _updateCacheInitialized --
 *
 *      Returns true if the decoder has been configured to have an
 *      active UpdateCache and the cache size negotiation has
 *      completed.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._updateCacheInitialized = function () {
   return this.updateCacheEntries !== 0;
};


/*
 *----------------------------------------------------------------------------
 *
 * _subRectangleCacheEnabled --
 *
 *      Although backward compatible of updateCacheCapSubRectangle should exist
 *      on the Server side, here still adding the extra check in case webmks is
 *      used to connect between the server and client both without this capacity.
 *
 *      Returns true if the decoder has been configured to have an
 *      active UpdateCache and the subrectangle cache type is used after the
 *      negotiation.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._subRectangleCacheEnabled = function () {
   return this.options.enableSubRectangleCache &&
      this._updateCacheInitialized() &&
      (this.cacheFlags & this.updateCacheCapSubRectangle);
};


/*
 *----------------------------------------------------------------------------
 *
 * _executeUpdateCacheBegin --
 *
 *      Handle the UPDATE_CACHE_OP_BEGIN subcommand.  Process the
 *      message payload, which is a mask of cache entries to evict.
 *      Evict any existing entry at the destination slot, and create a
 *      new entry there.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Evicts elements of the update cache.
 *      Creates a new cache entry.
 *
 *----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._executeUpdateCacheBegin = function(rect) {
   "use strict";

   var maskBitBuf;
   var maskState, maskCount;
   var i, j;

   if (!this._updateCacheInitialized() ||
       this._updateCacheInsideBeginEnd() ||
       rect.slot >= this.updateCacheEntries) {
      return this.fail("Disconnected: requested cache slot too large");
   }

   maskBitBuf = new WMKS.BitBuf(rect.data, rect.dataLength);
   maskState = !maskBitBuf.readBits(1);
   maskCount = 0;
   j = 0;

   do {
      maskCount = maskBitBuf.readEliasGamma();
      maskState = !maskState;

      if (maskState) {
         for (i = 0; i < maskCount && i < this.updateCacheEntries; i++) {
            this._evictUpdateCacheEntry(i + j);
         }
      }

      j += maskCount;
   } while (j < this.updateCacheEntries && !maskBitBuf.overflow);


   this.decodeToCacheEntry = rect.slot;
   this._evictUpdateCacheEntry(rect.slot);

   this.updateCache[this.decodeToCacheEntry].imageWidth = rect.width;
   this.updateCache[this.decodeToCacheEntry].imageHeight = rect.height;
};


/*
 *----------------------------------------------------------------------------
 *
 * _executeUpdateCacheEnd --
 *
 *      Handle the UPDATE_CACHE_OP_END subcommand.  Process the
 *      message payload, which is a serialized bitmask of screen
 *      regions to scatter the update image to.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Draws to the canvas.
 *
 *----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._executeUpdateCacheEnd = function(rect) {
   "use strict";
   var encodedMaskRect = null;
   var update = this.updateCache[this.decodeToCacheEntry];
   var state, count;
   var dstx = 0;
   var dsty = 0;
   var dstw;
   var dsth;
   var srcx = 0;
   var srcy = 0;
   var srcw = update.imageWidth / 16;
   var srch = update.imageHeight / 16;
   var availwidth;
   var bitbuf;

   if (!this._updateCacheInitialized() ||
       !this._updateCacheInsideBeginEnd() ||
       rect.slot != this.decodeToCacheEntry ||
       rect.slot >= this.updateCacheEntries) {
      return this.fail("Disconnected: requested cache slot invalid");
   }

   if (this._subRectangleCacheEnabled()) {
      encodedMaskRect = {
         x: rect.x,
         y: rect.y,
         width: rect.width,
         height: rect.height
      };
   } else {
      encodedMaskRect = {
         x: 0,
         y: 0,
         width: this._FBWidth,
         height: this._FBHeight
      };
   }

   dstw = Math.ceil(encodedMaskRect.width / 16);
   dsth = Math.ceil(encodedMaskRect.height / 16);

   update.encodedMaskRect = encodedMaskRect;
   update.mask = rect.data;
   update.maskLength = rect.dataLength;

   bitbuf = new WMKS.BitBuf(update.mask, update.maskLength);
   state = !bitbuf.readBits(1);
   count = 0;

   do {
      if (count == 0) {
         count = bitbuf.readEliasGamma();
         state = !state;
      }

      availwidth = Math.min(srcw - srcx, dstw - dstx);
      availwidth = Math.min(availwidth, count);

      if (state) {
         // Don't worry if we don't have a full 16-wide mcu at the
         // screen edge.  The canvas will trim the drawImage
         // coordinates for us.
         //
         this._canvas[0].ctx.drawImage(update.image,
                                       srcx * 16,
                                       srcy * 16,
                                       availwidth * 16, 16,
                                       encodedMaskRect.x + dstx * 16,
                                       encodedMaskRect.y + dsty * 16,
                                       availwidth * 16, 16);

         srcx += availwidth;
         if (srcx == srcw) {
            srcx = 0;
            srcy++;
         }
      }

      dstx += availwidth;
      if (dstx == dstw) {
         dstx = 0;
         dsty++;
      }

      count -= availwidth;

   } while (dsty < dsth && !bitbuf._overflow);

   this.decodeToCacheEntry = -1;
};


/*
 *----------------------------------------------------------------------------
 *
 * _executeUpdateCacheReplay --
 *
 *      Handle the UPDATE_CACHE_OP_REPLAY subcommand.  Process the
 *      message payload, which is a serialized mask used to subset the
 *      bitmask provided at the time the cache entry being replayed
 *      was created.  Scatters the specified subset of the cached
 *      image to the canvas.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      Draws to the canvas.
 *
 *----------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._executeUpdateCacheReplay = function(rect) {
   "use strict";

   if (rect.slot >= this.updateCacheEntries) {
      return this.fail("Disconnected: requested cache slot invalid");
   }

   /*
    * Ignore the cache relay when mask is missing, in case the rect message for
    * the multimon is buffered on network right after switched to single monitor
    * mode.
    */
   if (!this.updateCache[rect.slot].encodedMaskRect) {
      return;
   }

   var update = this.updateCache[rect.slot];
   var encodedMaskRect = update.encodedMaskRect;
   var dstx = 0;
   var dsty = 0;
   var dstw = Math.ceil(encodedMaskRect.width / 16);
   var dsth = Math.ceil(encodedMaskRect.height / 16);
   var availwidth;
   var srcx = 0;
   var srcy = 0;
   var srcw = update.imageWidth / 16;
   var srch = update.imageHeight / 16;

   var maskBitBuf = new WMKS.BitBuf(rect.data, rect.dataLength);
   var updateBitBuf = new WMKS.BitBuf(update.mask, update.maskLength);

   var updateState = !updateBitBuf.readBits(1);
   var updateCount = 0;

   var maskState = !maskBitBuf.readBits(1);
   var maskCount = 0;

   if (!this._updateCacheInitialized() ||
       this._updateCacheInsideBeginEnd() ||
       rect.slot >= this.updateCacheEntries) {
      return this.fail("");
   }

   do {
      if (updateCount == 0) {
         updateCount = updateBitBuf.readEliasGamma();
         updateState = !updateState;
      }
      if (maskCount == 0) {
         maskCount = maskBitBuf.readEliasGamma();
         maskState = !maskState;
      }

      availwidth = dstw - dstx;
      availwidth = Math.min(availwidth, updateCount);

      if (updateState) {
         availwidth = Math.min(availwidth, srcw - srcx);
         availwidth = Math.min(availwidth, maskCount);

         if (maskState) {
            // Don't worry if the right/bottom blocks are not
            // 16-pixel, the canvas will trim the drawImage dimesions
            // for us.
            this._canvas[0].ctx.drawImage(update.image,
                                         srcx * 16,
                                         srcy * 16,
                                         availwidth * 16, 16,
                                         encodedMaskRect.x + dstx * 16,
                                         encodedMaskRect.y + dsty * 16,
                                         availwidth * 16, 16);

            if (false) {
               this._lighten(encodedMaskRect.x + dstx * 16,
                             encodedMaskRect.y + dsty * 16,
                             availwidth * 16, 16,
                             "red");
            }
         }

         srcx += availwidth;
         if (srcx == srcw) {
            srcx = 0;
            srcy++;
         }

         maskCount -= availwidth;
      }

      dstx += availwidth;
      if (dstx == dstw) {
         dstx = 0;
         dsty++;
      }

      updateCount -= availwidth;

   } while (dsty < dsth &&
            !maskBitBuf._overflow &&
            !updateBitBuf._overflow);
};


/*
 *------------------------------------------------------------------------------
 *
+ * _handleRequestConnectVmxMsg
+ *
+ *    Callback to handle console proxy VMX info request message.
+ *
+ * Results:
+ *    None.
+ *
+ * Side Effects:
+ *    Sends the VMX string passed to the initial connect call.
+ *    Sets next parser callback.
+ *
+ *------------------------------------------------------------------------------
+ */
WMKS.VNCDecoder.prototype._handleVCDProxyVmxPathMessage = function () {
   var requestString = this._readString(17);
   if (requestString !== "connect info vmx\n") {
      return this.fail("Invalid connection vmx request: " + requestString);
   }

   this._sendString(this.options.VCDProxyHandshakeVmxPath);
   this._setReadCB(12, this._peekFirstMessage);
};

/*
 *------------------------------------------------------------------------------
 *
 * _executeUpdateCacheReplay
 *
 *    Dispatch the updateCache commands according to their opcode.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._executeUpdateCache = function(rect) {
   "use strict";

   switch (rect.opcode) {
   case this.updateCacheOpInit:
      this._executeUpdateCacheInit(rect);
      break;
   case this.updateCacheOpBegin:
      this._executeUpdateCacheBegin(rect);
      break;
   case this.updateCacheOpEnd:
      this._executeUpdateCacheEnd(rect);
      break;
   case this.updateCacheOpReplay:
      this._executeUpdateCacheReplay(rect);
      break;
   default:
      return this.fail("Disconnected: requested cache opcode invalid");
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _executeRectSingleForMultimon
 *
 *    Execute the update command specified in a single rect for multimon mode.
 *    The ack will not be sent before the real rendering among monitors, and we
 *    will improve the preformence after 17Q1 to sending the undecoded binary
 *    instead of the decoded image, and for 17Q1, the cache is disabled from
 *    agent side, and encRaw and encOffscreenCopyRect are tested as not used, so
 *    disable them all to reduce the change size.
 *
 *    Currently only support encCopyRect, encUpdateCache, encTightPNG.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._executeRectSingleForMultimon = function (rect,
                                                                    frameId,
                                                                    onDone,
                                                                    onError) {
   switch (rect.encoding) {
      case this.encCopyRect:
      case this.encTightPNG:
         this._multimonRenderer.onData("rect", {
            data: rect,
            frameId: frameId
         }, onDone, onError);
         break;
      case this.encUpdateCache:
         if (this.options.enableSubRectangleCache) {
            this._multimonRenderer.onData("rect", {
               data: rect,
               frameId: frameId
            }, onDone, onError);
         } else {
            onDone();
         }
         break;
      case this.encRaw:
         WMKS.LOGGER.warn("unsupported encoding for multimon: encRaw");
         rect.imageString = "";
         onDone();
         break;
      case this.encDesktopSize:
      case this.encVMWDefineCursor:
      case this.encVMWCursorState:
      case this.encVMWCursorPosition:
      case this.encH264MP4:
         onDone();
         break;
      default:
         onError();
         break;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _executeRectSingle
 *
 *    Execute the update command specified in a single rect.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Updates the canvas contents.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._executeRectSingle = function (rect) {
   var ctx = this._canvas[0].ctx;

   switch (rect.encoding) {
      case this.encRaw:
         this._blitImageString(ctx,
                               rect.x,
                               rect.y,
                               rect.width,
                               rect.height,
                               rect.imageString);
         rect.imageString = "";
         break;
      case this.encCopyRect:
         this._copyRectBlit(0,      // source index
                            rect.srcX,
                            rect.srcY,
                            rect.width,
                            rect.height,
                            0,      // dest index
                            rect.x,
                            rect.y);
         break;
      case this.encOffscreenCopyRect:
         this._copyRectOffscreenBlit(rect.srcBuffer,
                                     rect.srcX,
                                     rect.srcY,
                                     rect.width,
                                     rect.height,
                                     rect.dstBuffer,
                                     rect.x,
                                     rect.y);
         break;
      case this.encTightPNG:
         if (rect.subEncoding === this.subEncFill) {
            this._fillRectWithColor(ctx,
                                    rect.x,
                                    rect.y,
                                    rect.width,
                                    rect.height,
                                    rect.color);
         } else if (this.decodeToCacheEntry === -1) {
            ctx.drawImage(rect.image,
                          rect.x,
                          rect.y);

            this._releaseImage(rect.image);
            rect.image = null;
         } else {
            this.updateCache[this.decodeToCacheEntry].image = rect.image;
            rect.image = null;
         }
         break;
      case this.encDesktopSize:
      case this.encVMWDefineCursor:
      case this.encVMWCursorState:
      case this.encVMWCursorPosition:
      case this.encH264MP4:
         break;
      case this.encUpdateCache:
         this._executeUpdateCache(rect);
         break;
      default:
         break;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * sendACK
 *
 *    send ACK for rendering.
 *    The the decodeStart and updateReqId will uses the this.decodeStart, and
 *    this.updateReqId respectively for single monitor mode, while use the param
 *    maintained by the multimon renderer for multimon mode.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.sendACK = function (decodeStart, updateReqId) {
    var now = (new Date()).getTime(),
       decodeStartTime = decodeStart || this.decodeStart,
       updateRequestId = (updateReqId !== undefined) ? updateReqId : this.updateReqId;
    this._sendAck(now - decodeStartTime, updateRequestId);
};


/*
 *------------------------------------------------------------------------------
 *
 * _executeRects
 *
 *    When this is called, all data for all rectangles is available
 *    and all JPEG images have been loaded. We can noe perform all
 *    drawing in a single step, in the correct order.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Updates the canvas contents.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._executeRects = function () {
   /*
    * When this is called, all data for all rectangles is
    * available and all JPEG images have been loaded.  We can
    * now perform all drawing in a single step, in the correct order.
    */
   var i,
      decodeStart,
      updateReqId,
      rectLength,
      processedRectNum,
      onError,
      onDone,
      frameId;

   if (this._state !== this.FBU_DECODING_STATE) {
      return this.fail("wrong state: " + this._state);
   }

   if (this.rectsDecoded !== this.rects ||
      this.rectsRead !== this.rects) {
      return this.fail("messed up state");
   }

   if (this._customRendererEnabled()) {
      // cache properties by local variables since the call could be async
      decodeStart = this.decodeStart;
      updateReqId = this.updateReqId;
      rectLength = this.rects;
      processedRectNum = 0;
      onDone = onError = function() {
         processedRectNum++;
         if (processedRectNum === rectLength) {
            this.sendACK(decodeStart, updateReqId);
         }
      }.bind(this);
      /*
       * frameId is used to ensure rect updates are renderred by frame which
       * can avoid diplaying out renderring result when only part of rect
       * updating in a frame are done.
       *
       * Use time since if 2 frames are handled within 1ms, displaying the final
       * result is reasonable.
       * @type {number}
       */
      frameId = Date.now();
      for (i = 0; i < this.rects; i++) {
         this._executeRectSingleForMultimon(this.rect[i], frameId, onDone,
            onError);
         delete this.rect[i];
      }
   } else {
      for (i = 0; i < this.rects; i++) {
         this._executeRectSingle(this.rect[i]);
         delete this.rect[i];
      }
      this.sendACK();
   }

   this.rects = 0;
   this.rectsRead = 0;
   this.rectsDecoded = 0;
   this.updateReqId = 0;

   if (this._receivedFirstUpdate === false) {
    this.options.onConnected();
    this._receivedFirstUpdate = true;
   }


   var self = this;
   this._state = this.FBU_RESTING_STATE;
   this._getNextServerMessage();


   /*
    * Resting like this is a slight drain on performance,
    * especially at higher framerates.
    *
    * If the client could just hit 50fps without resting (20
    * ms/frame), it will now manage only 47.6fps (21 ms/frame).
    *
    * At lower framerates the difference is proportionately
    * less, eg 20fps->19.6fps.
    *
    * It is however necessary to do something like this to
    * trigger the screen update, as the canvas double buffering
    * seems to use idleness as a trigger for swapbuffers.
    */

   this._msgTimer = setTimeout(this.msgTimeout, 1 /* milliseconds */);
};


/*
 *------------------------------------------------------------------------------
 *
 * _nextRect
 *
 *    Configures parser to process next FB update rectangle,
 *    or progresses to rendering.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._nextRect = function() {
   this.rectsRead++;
   if (this.rectsRead < this.rects) {
      this._setReadCB(12, this._readRect);
   } else {
      this._state = this.FBU_DECODING_STATE;
      if (this.rectsDecoded === this.rects) {
         this._executeRects();
      }
   }
};





/*
 *
 * Server message handling
 *
 */


/*
 *------------------------------------------------------------------------------
 *
 * _gobble
 *
 *    Throws away a sequence of bytes and calls next().
 *    Like _skipBytes(), but usable with _setReadCB().
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Skips a message chunk.
 *    Calls a dynamic callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._gobble = function (next) {
   this._skipBytes(this.nextBytes);
   next();
};


/*
 *------------------------------------------------------------------------------
 *
 * _getNextServerMessage
 *
 *    Sets up parser to expect the head of a new message from the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._getNextServerMessage = function () {
   this._setReadCB(1, this._handleServerMsg);
};



/*
 *------------------------------------------------------------------------------
 *
 * _framebufferUpdate
 *
 *    Parses header of new image being received.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Resets FB update parser.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._framebufferUpdate = function () {
   this.updateReqId = this._readByte();
   this.rects = this._readInt16();
   this.rectsRead = 0;
   this.rectsDecoded = 0;
   this.decodeStart = (new Date()).getTime();
   this._setReadCB(12, this._readRect);
};



/*
 *------------------------------------------------------------------------------
 *
 * _handleServerInitializedMsg
 *
 *    Callback to handle VNC server init'd message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets various instance-wide config vars that describe the connection.
 *    Processes the message.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleServerInitializedMsg = function () {
   var self = this;

   /*
    * Screen size
    */
   this._FBWidth  = this._readInt16();
   this._FBHeight = this._readInt16();

   /*
    * PIXEL_FORMAT
    * We really only need the depth/bpp and endian flag.
    */
   var bpp           = this._readByte();
   var depth         = this._readByte();
   var bigEndian     = this._readByte();
   var trueColor     = this._readByte();

   WMKS.LOGGER.log('Screen: ' + this._FBWidth + ' x ' + this._FBHeight +
                   ', bits-per-pixel: ' + bpp + ', depth: ' + depth +
                   ', big-endian-flag: ' + bigEndian +
                   ', true-color-flag: ' + trueColor);

   /*
    * Skip the 'color'-max values.
    */
   this._skipBytes(6);

   var redShift = this._readByte();
   var greenShift = this._readByte();
   var blueShift = this._readByte();

   WMKS.LOGGER.debug('red shift: ' + redShift +
                     ', green shift: ' + greenShift +
                     ', blue shift: ' + blueShift);

   /*
    * Skip the 3 bytes of padding
    */
   this._skipBytes(3);

   /*
    * Read the connection name.
    */
   var nameLength   = this._readInt32();

   this.options.onNewDesktopSize(this._FBWidth, this._FBHeight);

   /*
    * After measuring on many browsers, these appear to be universal
    * best choices for blits and offscreen blits respectively.
    */
   this._copyRectBlit = this._copyRectDrawImageTemp;
   this._copyRectOffscreenBlit = this._copyRectDrawImage;

   // keyboard.grab();

   if (trueColor) {
      this._FBBytesPerPixel = 4;
      this._FBDepth        = 3;
   } else {
      return this.fail('no colormap support');
   }

   var getFBName = function () {
      self._FBName = self._readString(nameLength);

      self._sendClientEncodingsMsg();
      self._sendFBUpdateRequestMsg(0);

      WMKS.LOGGER.log('Connected ' +
                      (self._encrypted? '(encrypted)' : '(unencrypted)') +
                      ' to: ' + self._FBName);

      self._serverInitialized = true;
      self._getNextServerMessage();
   };

   this._setReadCB(nameLength, getFBName);
};


/*
 *------------------------------------------------------------------------------
 *
 * _peekFirstMessage
 *
 *    We have built and deployed two sorts of VNC servers, those that
 *    expect an RFB 003.008 and VNC authentication handshake, and
 *    those which jump straight into the VNC protocol at the
 *    serverInitialized message.  Previously we had to switch the
 *    client between these two modes, but it is possible to build a
 *    single client which can talk to both types of server simply by
 *    examining the size of the first message we receive.
 *
 *    Note that this is a very robust detection method - the server is
 *    required in each case to send a message of a specific size on
 *    connection establishment.  We are lucky that the two messages
 *    are of different sizes.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._peekFirstMessage = function () {
   this.usedVNCHandshake = (this._receiveQueue[0].data.byteLength == 12);
   if (this.usedVNCHandshake) {
      this._setReadCB(12, this._handleProtocolVersionMsg);
   } else {
      this._setReadCB(24, this._handleServerInitializedMsg);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleSecurityResultMsg
 *
 *    Callback to handle VNC security result message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Processes the message.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleSecurityResultMsg = function () {
   var self = this;
   var reasonLength;
   var handleReason = function() {
      var reason = self._readString(reasonLength);
      self.options.onAuthenticationFailed();
      return self.fail(reason);
   };

   var handleReasonLength = function() {
      reasonLength = self._readInt32();
      self._setReadCB(reasonLength, handleReason);
   };


   switch (this._readInt32()) {
      case 0:  // OK
         /*
          * Send '1' to indicate the the host should try to
          * share the desktop with others.  This is currently
          * ignored by our server.
          */
         this._sendBytes([1]);
         this._setReadCB(24, this._handleServerInitializedMsg);
         return;
      case 1:  // failed
         this._setReadCB(4, handleReasonLength);
         return;
      case 2:  // too-many
         this.options.onAuthenticationFailed();
         return this.fail("Too many auth attempts");
      default:
         return this.fail("Bogus security result");
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleSecurityMsg
 *
 *    Callback to handle VNC security message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Processes the message.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleSecurityMsg = function () {
   var authenticationScheme = 0;
   var numTypes;
   var reasonLength;
   var self = this;

   var handleReason = function() {
      var reason = this._readString(reasonLength);
      self.options.onAuthenticationFailed();
      return self.fail(reason);
   };

   var handleReasonLength = function() {
      reasonLength = self._readInt32();
      self._setReadCB(reasonLength, handleReason);
   };

   var handleSecurityTypes = function() {
      var securityTypes = self._readBytes(numTypes);
      WMKS.LOGGER.log("Server security types: " + securityTypes);
      for (var i=0; i < securityTypes.length; i+=1) {
         if (securityTypes && (securityTypes[i] < 3)) {
            authenticationScheme = securityTypes[i];
         }
      }
      if (authenticationScheme === 0) {
         return self.fail("Unsupported security types: " + securityTypes);
      }
      self._sendBytes([authenticationScheme]);
      WMKS.LOGGER.log('Using authentication scheme: ' + authenticationScheme);
      if (authenticationScheme === 1) {
         // No authentication required - just handle the result state.
         self._setReadCB(4, self._handleSecurityResultMsg);
      } else {
         return self.fail("vnc authentication not implemented");
      }
   };

   numTypes = this._readByte();
   if (numTypes === 0) {
      this._setReadCB(4, handleReasonLength);
   } else {
      this._setReadCB(numTypes, handleSecurityTypes);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleProtocolVersionMsg
 *
 *    Callback to handle VNC handshake message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends own ID string back.
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleProtocolVersionMsg = function () {
   var serverVersionPacket = this._readString(12);
   if (serverVersionPacket !== "RFB 003.008\n") {
      return this.fail("Invalid Version packet: " + serverVersionPacket);
   }
   this._sendString("RFB 003.008\n");
   this._setReadCB(1, this._handleSecurityMsg);
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendClientCaps
 *
 *    Send our VNCVMW client caps to the server.
 *    Right now the only one we send is VNCVMW_CLIENTCAP_HEARTBEAT (0x100).
 *
 * Results:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendClientCaps = function() {
   if (this._serverInitialized) {
      var arr = [];
      var caps = (this.clientCapHeartbeat |
                  this.clientCapAudioAck |
                  this.clientCapSetReconnectToken);
      if (this.options.enableVorbisAudioClips) {
        caps |= this.clientCapVorbisAudioClips;
      }

      if (this.options.enableOpusAudioClips) {
        caps |= this.clientCapOpusAudioClips;
      }

      if (this.options.enableAacAudioClips) {
        caps |= this.clientCapAacAudioClips;
      }

      if (this.options.enableVMWSessionClose) {
        caps |= this.clientCapSessionClose;
      }

      if (this.options.enableVMWAudioMixer) {
         caps |= this.clientCapUseAudioMixer;
      }

      if (this.serverSupportsMKSVChanClipboard && this.vvcSession) {
        caps |= this.clientCapUseMKSVChanClipboard;
      }
      arr.push8(this.msgVMWClientMessage);
      arr.push8(3);                        // Client caps message sub-type
      arr.push16(8);                       // Length
      arr.push32(caps);                    // Capability mask
      this._sendBytes(arr);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendSessionClose
 *
 *    Send our VNCVMW session close request to the server.
 *
 * Results:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendSessionClose = function(closeReason) {
   if (this._serverInitialized &&
       this.useVMWSessionClose &&
       this.options.enableVMWSessionClose) {
      WMKS.LOGGER.log("Send session close to server.");
      var arr = [];
      arr.push8(this.msgVMWClientMessage);
      arr.push8(this.msgVMWSessionClose);
      arr.push16(8);
      arr.push32(closeReason);
      this._sendBytes(arr);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _sendUpdateCacheInfo
 *
 *    Send our VMWUpdateCache cache sizes and capabilities to the server.
 *
 * Results:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._sendUpdateCacheInfo = function() {
   "use strict";

   var arr = [];
   var flags = (this.updateCacheCapReplay |
                this.updateCacheCapDisableOffscreenSurface);
   if (this.options.enableSubRectangleCache) {
       flags |= this.updateCacheCapSubRectangle;
   }
   var cacheSizeEntries = this.options.cacheSizeEntries;
   var cacheSizeKB = this.options.cacheSizeKB;
   WMKS.LOGGER.trace('sendUpdateCacheInfo');
   arr.push8(this.msgVMWClientMessage);
   arr.push8(11);                        // VNCVMWUpdateCacheInfoID
   arr.push16(14);                       // Length
   arr.push32(flags);
   arr.push16(cacheSizeEntries);
   arr.push32(cacheSizeKB);
   this._sendBytes(arr);
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleServerCapsMsg
 *
 *    Parses a VNC VMW server caps message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Might request a change to the client resolution.
 *    Will trigger the sending of our client capabilities.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleServerCapsMsg = function () {
   var caps = this._readInt32();
   this.useVMWKeyEvent = !!(caps & this.serverCapKeyEvent);
   /*
    * serverCapKeyEvent2Unicode, serverCapKeyEvent2JSKeyCode indicates that
    * unicode and raw JS keyCode inputs are handled by the server and
    * options.useUnicodeKeyboardInput indicates that the client
    * should use unicode if possible. The flag allowVMWKeyEventUnicode is set
    * when the above 3 value are true.
    */
   this.allowVMWKeyEvent2UnicodeAndRaw =
      this.options.useUnicodeKeyboardInput &&
      !!(caps & this.serverCapKeyEvent2Unicode) &&
      !!(caps & this.serverCapKeyEvent2JSKeyCode);

   this.useVMWAck      = !!(caps & this.serverCapUpdateAck);
   this.useVMWRequestResolution = !!(caps & this.serverCapRequestResolution);
   this.useVMWRequestStreamState = !!(caps & this.serverCapRequestStreamState);
   this.useVMWRequestMultiMon = !!(caps & this.serverCapMultiMon);
   this.useVMWAudioAck = !!(caps & this.serverCapAudioAck);
   this.useVMWSessionClose = !!(caps & this.serverCapSessionClose);
   this.serverSupportsMKSVChanClipboard = !!(caps & this.serverCapHasMKSVChanClipboard);

   /*
    * If we have already been asked to send a resolution request
    * to the server, this is the point at which it becomes legal
    * to do so.
    */
   if (this.useVMWRequestResolution &&
      this.requestedWidth > 0 &&
      this.requestedHeight > 0) {
      this.onRequestResolution(this.requestedWidth,
                               this.requestedHeight);
   }

   this.options.onMultimonCapacityUpdated(this.useVMWRequestMultiMon);

   if (caps & this.serverCapClientCaps) {
      this._sendClientCaps();
   }

   if (caps & this.serverCapUpdateCacheInfo) {
      this._sendUpdateCacheInfo();
   }

   if ((caps & this.serverCapDisablingCopyUI) ||
       (caps & this.serverCapDisablingPasteUI)) {
      var noCopyUI = 0;
      var noPasteUI = 0;
      if (caps & this.serverCapDisablingCopyUI) {
         noCopyUI = 1;
      }
      if (caps & this.serverCapDisablingPasteUI) {
         noPasteUI = 1;
      }
      this.options.onUpdateCopyPasteUI(noCopyUI, noPasteUI);
   }

   this._getNextServerMessage();
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleServerHeartbeatMsg
 *
 *    Parses a VNC VMW server heartbeat message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Calls the user-provided callback for heartbeat events.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleServerHeartbeatMsg = function () {
   var interval = this._readInt16();
   this.options.onHeartbeat(interval);
   this._getNextServerMessage();
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleSessionCloseMsg
 *
 *    Parses a VNC VMW server session close message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Calls the user-provided callback for session close events.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleSessionCloseMsg = function () {
   var closeReason = this._readInt32();
   this.options.onBeforeDisconnected(closeReason);
   this._getNextServerMessage();
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleAudioMixer
 *
 *    Parses a VNC VMW server audio mixer message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Calls the user-provided callback for audio mixer events.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleAudioMixer = function () {
   var channelId = this._readInt32();
   var msgType = this._readInt32();
   var data = this._readInt32();
   var flags = this._readInt32();

   /*
    * We don't support more than 2 channels at this time. i.e. stereo or mono.
    * msgType 0: volume mute 1: volume change
    */
   if (channelId < 2 && (msgType === 0 || msgType === 1)) {
      this.options.onAudioMixer({channelId: channelId,
                                   msgType: msgType,
                                      data: data,
                                     flags: flags});
   } else {
      WMKS.LOGGER.warn("Ignoring audio mixer message for an unsupported " +
                       " channelId = " + channelId +
                       " msgType = " + msgType +
                       " data = " + data +
                       " flags = " + flags);
   }

   this._getNextServerMessage();
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleServerSetReconnectToken
 *
 *    Parses a VNC VMW server setReconnectToken message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Calls the user-provided callback for setReconnectToken events.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleServerSetReconnectTokenMsg = function (len) {
   var token = this._readString(len);
   this.options.onSetReconnectToken(token);
   console.error("token: " + token);
   this._getNextServerMessage();
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleServerAudioMsg
 *
 *    Parses a VNC VMW server audio message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Reads the audio data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleServerAudioMsg = function () {
   var length = this._readInt32();
   var sampleRate = this._readInt32();
   var numChannels = this._readInt32();
   var sampleSize = this._readInt32();
   var containerSize = this._readInt32();
   var timestampL = this._readInt32();
   var timestampH = this._readInt32();
   var flags = this._readInt32();

   var audioInfo = {sampleRate: sampleRate,
                    numChannels: numChannels,
                    containerSize: containerSize,
                    sampleSize: sampleSize,
                    length: length,
                    audioTimestampLo: timestampL,
                    audioTimestampHi: timestampH,
                    frameTimestampLo: this._frameTimestampLo,
                    frameTimestampHi: this._frameTimestampHi,
                    flags: flags,
                    data: null};

   this._setReadCB(length, this._handleServerAudioMsgData, audioInfo);
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleServerAudioMsgData
 *
 *    Reads VNC VMW audio data.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Calls the user-provided callback for audio events.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleServerAudioMsgData = function (audioInfo) {
   if (audioInfo.length > 0) {
      audioInfo.data = this._readBytes(audioInfo.length);
      /*
       * Web client and native client should have the same behavior on
       * audio ack (native client: VNCDecodeReadAudio). Old servers and
       * new servers behave differently though because new servers check
       * the client audioack capability flag. Here is the detail:
       *
       * Old servers:
       *
       * ServerCap (useVMWAudioAck) can be true of false. The audioInfo.flags
       * is always set to zero. Hence audioflagRequestAck flag is neglected for
       * old servers. We send audio acks purely depending on whether the server
       * supports audioack or not.
       *
       * New servers:
       *
       * ServerCap (useVMWAudioAck) is always set to true. The audioInfo.flags
       * contains the audiotype in the most significant 8 bits. So this flag
       * is supposed to be non-zero. If the audioflagRequestAck bit is set,
       * we send audio ack. Otherwise we don't send audio ack.
       *
       * A special case for new server is client does not specify audiotype, In
       * this rare case, we always send audio ack.
       */
      if (this.useVMWAudioAck &&
          (audioInfo.flags == 0 ||
          (audioInfo.flags & this.audioflagRequestAck))) {
         this._sendAudioAck(audioInfo.audioTimestampLo,
                            audioInfo.audioTimestampHi);
      }
      this.options.onAudio(audioInfo);
   } else {
      WMKS.LOGGER.info("Audio data length is 0.");
   }
   this._getNextServerMessage();
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleServerCutText
 *
 *    Parses a server cut text message.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Calls the user-provided callback for cut text (copy) events.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleServerCutText = function (length) {
   var txt = this._readStringUTF8(length);
   this.options.onCopy(txt);
   this._getNextServerMessage();
};


/*
 *------------------------------------------------------------------------------
 *
 * _handleServerMsg
 *
 *    Parses a VNC message header and dispatches it to the correct callback.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Parses first byte of a message (type ID).
 *    Sets next parser callback.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._handleServerMsg = function () {
   var length, c, red, green, blue;
   var self = this;
   var msgType = this._readByte();

   switch (msgType) {
   case this.msgFramebufferUpdate:
      this._setReadCB(3, this._framebufferUpdate);
      break;
   case this.msgSetColorMapEntries:
      var getNumColors = function () {
         self._skipBytes(3);
         var numColors = self._readInt16();
         // XXX: just ignoring incoming colors
         self._setReadCB(6 * numColors, self._gobble, self._getNextServerMessage);
      };
      this._setReadCB(5, getNumColors);
      break;
   case this.msgRingBell:
      this._getNextServerMessage();
      break;
   case this.msgServerCutText:
      var getServerCutTextHead = function () {
         self._readBytes(3);  // Padding
         length = self._readInt32();
         if (length > 0) {
            self._setReadCB(length, self._handleServerCutText, length);
         } else {
            self._getNextServerMessage();
         }
      };

      this._setReadCB(8, getServerCutTextHead);
      break;
   case this.msgVMWSrvMessage:
      var getVMWSrvMsgHead = function () {
         var id = self._readByte();
         var len = self._readInt16();

         // VMWServerCaps
         if (id === this.msgVMWSrvMessage_ServerCaps) {
            if (len !== 8) {
               self.options.onProtocolError();
               return self.fail('invalid length message for id: ' + id + ', len: ' + len);
            }
            self._setReadCB(len - 4, self._handleServerCapsMsg);

         // VMWHeartbeat
         } else if (id === this.msgVMWSrvMessage_Heartbeat) {
            if (len !== 6) {
               self.options.onProtocolError();
               return self.fail('invalid length message for id: ' + id + ', len: ' + len);
            }
            self._setReadCB(len - 4, self._handleServerHeartbeatMsg);

         // VMWSetReconnectToken
         } else if (id === this.msgVMWSrvMessage_SetReconnectToken) {
            console.error("get setReconnectToken message");
            self._setReadCB(len - 4, self._handleServerSetReconnectTokenMsg,
                            len - 4);

         // VMWAudio
         } else if (id === this.msgVMWSrvMessage_Audio) {
            if (len !== 36) {
               self.options.onProtocolError();
               return self.fail('invalid length message for id: ' + id + ', len: ' + len);
            }
            self._setReadCB(len - 4, self._handleServerAudioMsg);

         // VMWSessionClose
         } else if (id === this.msgVMWSrvMessage_SessionClose) {
            if (len !== 8) {
               self.options.onProtocolError();
               return self.fail('invalid length message for id: ' + id + ', len: ' + len);
            }
            self._setReadCB(len - 4, self._handleSessionCloseMsg);

            // VMWAudioMixer
         } else if (id === this.msgVMWSrvMessage_AudioMixer) {
            if (len !== 20) {
               self.options.onProtocolError();
               return self.fail('invalid length message for id: ' + id + ', len: ' + len);
            }
            self._setReadCB(len - 4, self._handleAudioMixer);

         // Unhandled message type -- just gobble it and move on.
         } else {
            var bytesLeft = len - 4;
            if (bytesLeft === 0) {
               self._getNextServerMessage();
            } else {
               self._setReadCB(bytesLeft, self._gobble, self._getNextServerMessage);
            }
         }
      };

      this._setReadCB(3, getVMWSrvMsgHead);
      break;

   default:
      this.options.onProtocolError();
      return this.fail('Disconnected: illegal server message type ' + msgType);
   }

};



/*
 *------------------------------------------------------------------------------
 *
 * _processMessages
 *
 *    VNC message loop.
 *    Dispatches data to the specified callback(s) until nothing is left.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Calls dynamically specified callbacks.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype._processMessages = function () {
   while (this._state === this.VNC_ACTIVE_STATE &&
         this._receiveQueueBytesUnread() >= this.nextBytes) {
      var nrBytes = this.nextBytes;
      var before = this._receiveQueueBytesUnread();
      this.nextFn(this.nextArg);
      var after = this._receiveQueueBytesUnread();
      if (nrBytes < before - after) {
         return this.fail("decode overrun " + nrBytes + " vs " +
                          (before - after));
      }
   }
};





/** @public */

/*
 *
 * Event handlers called from the UI
 *
 */


/*
 *------------------------------------------------------------------------------
 *
 * onMouseMove
 *
 *    Updates absolute mouse state internally and on the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.onMouseMove = function (x, y) {
   this._mouseX = x;
   this._mouseY = y;

   if (this._serverInitialized) {
      this._mouseActive = true;
      if (this._mouseTimer === null) {
         this._sendMouseEvent();
         this._mouseTimer = setTimeout(this.mouseTimeout,
                                       this.mouseTimeResolution);
      }
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * onMouseButton
 *
 *    Updates absolute mouse state internally and on the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.onMouseButton = function (x, y, down, bmask) {
   this._mouseX = x;
   this._mouseY = y;
   if (down) {
      this._mouseButtonMask |= bmask;
   } else {
      this._mouseButtonMask &= ~bmask;
   }
   if (this._serverInitialized) {
      this._mouseActive = true;
      this._sendMouseEvent();
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * onKeyVScan
 *
 *    Sends a VMware VScancode key event to the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.onKeyVScan = function (keysym, down) {
   if (this._serverInitialized) {
      var arr = [];
      arr.push8(this.msgVMWClientMessage);
      arr.push8(this.msgVMWKeyEvent);   // Key message sub-type
      arr.push16(8);  // Length
      arr.push16(keysym);
      arr.push8(down);
      arr.push8(0);   /// padding
      this._sendBytes(arr);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * onVMWKeyUnicode
 *
 *    Sends the keycode to the server as is from the browser.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.onVMWKeyUnicode = function (key, down, raw) {
   if (this._serverInitialized) {
      var arr = [];
      arr.push8(this.msgVMWClientMessage);
      arr.push8(this.msgVMWKeyEvent2);    // VMW unicode key message sub-type
      arr.push16(10);   // length
      arr.push32(key);
      arr.push8(down);
      arr.push8(raw);
      this._sendBytes(arr);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * onMouseWheel
 *
 *    Sends a VMware mouse wheel event to the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.onMouseWheel = function(x, y, dx, dy) {
   if (this._serverInitialized) {
      var arr = [];
      arr.push8(this.msgVMWClientMessage);
      arr.push8(this.msgVMWPointerEvent2);    // Pointer event 2 message sub-type
      arr.push16(19);  // Length
      arr.push8(1);    // isAbsolute
      arr.push32(x);
      arr.push32(y);
      arr.push32(0);
      arr.push8(dy);
      arr.push8(dx);
      this._sendBytes(arr);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * onRequestResolution
 *
 *    Schedules a rate-limited VMware resolution request from client
 *    to server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.onRequestResolution = function(width, height) {
   if (this._serverInitialized &&
       this.useVMWRequestResolution &&
       (width !== this.requestedWidth || height !== this.requestedHeight)) {

      this.resolutionRequestActive = true;

      /*
       * Cancel any previous timeout and start the clock ticking
       * again.  This means that opaque window resizes will not
       * generate intermediate client->server messages, rather we will
       * wait until the user has stopped twiddling for half a second
       * or so & send a message then.
       */
      clearTimeout(this.resolutionTimer);
      this.resolutionTimer = setTimeout(this.resolutionTimeout,
                                        this.resolutionDelay);
      this.requestedWidth = width;
      this.requestedHeight = height;
      this._isInMultimonMode = false;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * onRequestTopology
 *
 *    Send topology request from client
 *    to server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.onRequestTopology = function(multiMonRects) {
   // reset status since switch to multimon
   this.requestedWidth = 0;
   this.requestedHeight = 0;

   if (this._serverInitialized && this.useVMWRequestMultiMon) {
      WMKS.LOGGER.log("Calling _sendTopologyRequest with arg:" +
         JSON.stringify(multiMonRects));
      this._sendTopologyRequest(multiMonRects);
      this._isInMultimonMode = true;
   }
};


/*
 *
 * Connection handling
 *
 */


/*
 *------------------------------------------------------------------------------
 *
 * disconnect
 *
 *    Tears down the WebSocket and discards internal state.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    See above.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.disconnect = function () {
   "use strict";

   if (this._state !== this.DISCONNECTED) {
      this._state = this.DISCONNECTED;
      if (this._mp4Decoder) {
         this._mp4Decoder.reset();
         this._mp4Decoder = null;
      }
      if (this._isInMultimonMode) {
         if (this._customRendererEnabled()) {
            this._multimonRenderer.reset();
         }
         this._isInMultimonMode = false;
      }
      this._multimonRenderer = null;
      this._receiveQueueReset();
      this.rects = 0;
      this._receivedFirstUpdate = false;

      if (this._websocket) {
         // User initialized closed.
         this._sendSessionClose(23);
         this._websocket.onopen    = null;
         this._websocket.onclose   = null;
         this._websocket.onmessage = null;
         this._websocket.onerror   = null;
         this._websocket.close();
         delete this._websocket;
      }
      this._serverInitialized = false;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * connect
 *
 *    Initialises the client and connects to the server.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Resets state and connects to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.connect = function (destinationUrl) {
   var self = this;

   this.setRenderCanvas(this.options.canvas);
   this._mediaPlayer = this.options.mediaPlayer;

   /*
    * This closure is run whenever the handler indicates it's
    * completed its decoding pass. We use it to indicate to the
    * server that we've decoded this request if this is the last
    * rect in the update.
    */
   this.onDecodeComplete = function () {
      self.rectsDecoded++;
      if (self.rectsDecoded === self.rects && self.rectsRead === self.rects) {
         self._state = self.FBU_DECODING_STATE;
         self._executeRects();
      }
   };

   this.onDecodeObjectURLComplete = function() {
      URL.revokeObjectURL(this.src);
      self.onDecodeComplete();
   };

   this.onDecodeMP4Error = function() {
      /*
       * If server receives the client encoding request, it is going to
       * invalidate current encoding region and client will receive a full
       * frame update.
       */
      var mediaPlayer = self.options.mediaPlayer;
      WMKS.LOGGER.log("Resetting stream request is sent.");

      // Disable H.264 cap.
      self.options.mediaPlayer = null;
      self._sendClientEncodingsMsg();
      // Enable H.264 cap.
      self.options.mediaPlayer = mediaPlayer;
      self._sendClientEncodingsMsg();
   };

   this.msgTimeout = function() {
      self._state = self.VNC_ACTIVE_STATE;
      self._processMessages();
   };

   this.mouseTimeout = function() {
      self._mouseTimer = null;
      if (self._mouseActive) {
         self._sendMouseEvent();
         self._mouseTimer = setTimeout(self.mouseTimeout, self.mouseTimeResolution);
      }
   };

   /*
    * Timer callback to limit the rate we send resolution-request
    * packets to the server.  No more than once a second is plenty.
    */
   this.resolutionTimeout = function() {
      if (self.resolutionRequestActive) {
         self._sendResolutionRequest();
         self.resolutionRequestActive = false;
      }
   };

   if (this.options.VCDProxyHandshakeVmxPath) {
      this._setReadCB(17, this._handleVCDProxyVmxPathMessage);
   } else {
      this._setReadCB(12, this._peekFirstMessage);
   }

   this._url = destinationUrl;
   this._receiveQueueReset();

   this.wsOpen = function (evt) {
      self._state = self.VNC_ACTIVE_STATE;
      if (this.protocol !== "binary" &&
          this.protocol !== "vmware-vvc") {
         return this.fail("no agreement on protocol");
      }

      if (this.protocol === "vmware-vvc") {
         self._setupVVC();
         WMKS.LOGGER.log('WebSocket is using VMware Virtual Channels');
         this.protocol = "binary";
      }

      if (this.protocol === "binary") {
         this.binaryType = "arraybuffer";
         WMKS.LOGGER.log('WebSocket HAS binary support');
      }

      // Note: this is after _setupVVC() in case the UI wants to add vvc listeners.
      self.options.onConnecting(self.vvc, self.vvcSession);

      WMKS.LOGGER.log('WebSocket created protocol: ' + this.protocol);
   };

   this.wsClose = function (evt) {
      self.options.onDisconnected(evt.reason, evt.code);
   };

   this.wsMessage = function (evt) {
      if (typeof evt.data !== "string") {
         // This should always be the case, as the protocol is now
         // always binary.
         self._receiveQueue.push(evt);
         self._receiveQueueLength += evt.data.byteLength;
      } else {
         return self.fail("non-binary message");
      }
      self._processMessages();
   };

   this.wsError = function (evt) {
      self.options.onError(evt);
   };

   this.protocolList = ["binary"];

   if (this.options.enableVVC) {
      this.protocolList.push("vmware-vvc");
   }

   this._setupConnection = function () {
      self._websocket = WMKS.WebSocket(self._url, self.protocolList);
      self._websocket.onopen = self.wsOpen;
      self._websocket.onclose = self.wsClose;
      self._websocket.onmessage = self.wsMessage;
      self._websocket.onerror = self.wsError;
   };

   this._setupVVC = function() {
      self.vvc = new VVC();
      self.vvcSession = self.vvc.openSession(self._websocket);

      self.vvcSession.onerror = function(status) {
         self.vvcSession.close();
      };

      self.vvcSession.ontransportclose = function(evt) {
         self.wsClose(evt);
      };

      self.vvcSession.ontransporterror = function(evt) {
         self.wsError(evt);
      };

      var listener = self.vvc.createListener(self.vvcSession, "blast-*");

      listener.onpeeropen = function(session, channel) {
         if (channel.name === "blast-mks") {
            channel.onclose = function(evt) {
               session.close();
               self._websocket = null;
               self.disconnect();
            };

            channel.onerror = function(evt) {
               session.close();
               self._websocket = null;
               self.disconnect();
            };

            self._websocket   = channel;
            channel.onmessage = self.wsMessage;
            session.acceptChannel(channel);
         } else if (channel.name === "blast-audio") {
            channel.onclose = function(evt) {
               session.close();
            };

            channel.onerror = function(evt) {
               session.close();
            };

            channel.onmessage = self.wsMessage;
            session.acceptChannel(channel);
         }
      };
   }

   this._retryConnectionTimeout = function() {
      if (self._state === self.DISCONNECTED) {
         WMKS.LOGGER.log("Connection timeout. Retrying now.");
         if (self._websocket) {
            self._websocket.onclose = function() {};
            self._websocket.close();
            self._websocket = null;
         }
         self._setupConnection();
      }
      self._retryConnectionTimer = null;
   };

   if (this.options.enableUint8Utf8) {
      addUint8Utf8(this);
   }

   this._setupConnection();

   if (this.options.retryConnectionInterval > 0) {
      // only retry once here.
      WMKS.LOGGER.log("Check connection status after " +
                       this.options.retryConnectionInterval + "ms.");
      this._retryConnectionTimer =
         setTimeout(this._retryConnectionTimeout,
                    this.options.retryConnectionInterval);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * setRenderCanvas
 *
 *    Set the canvas that is used to render the image data. Used by the
 *    analyzer to redirect pixel data to a backbuffer.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    This canvas is also used as the source for blits, so it should be set
 *    early on and not modified externally afterwards.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.setRenderCanvas = function (rc) {
   this._canvas[0] = rc;
   this._canvas[0].ctx = rc.getContext('2d');

   if (!this._canvas[0].ctx.createImageData) {
      throw("no canvas imagedata support");
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * setAudioStreamEnabled
 *
 *    Send a message to the server to enable or disable sending of audio data.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *    Can affect whether we receive audio data from the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.setAudioStreamEnabled = function(enable) {
   if (enable) {
      this._streamState &= ~this.streamStateDisableAudio;
   } else {
      this._streamState |= this.streamStateDisableAudio;
   }

   this._sendRequestStreamState(this._streamState);
};


/*
 *------------------------------------------------------------------------------
 *
 * setVideoStreamEnabled
 *
 *    Send a message to the server to enable or disable sending of video data.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *    Can affect whether we receive video data from the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.VNCDecoder.prototype.setVideoStreamEnabled = function(enable) {
   if (enable) {
      this._streamState &= ~this.streamStateDisableVideo;
   } else {
      this._streamState |= this.streamStateDisableVideo;
   }

   this._sendRequestStreamState(this._streamState);
};
// Use the following for js-lint.
/*global WMKS:false, Base64:false, stringFromArray:false, arrayFromString:false*/
/*jshint bitwise:false*/

/*
 * wmks/vncProtocolUint8Utf8.js
 *
 *   Calling addUint8Utf8 with an WMKS.VNCDecoder instance will restore
 *   the legacy uint8utf8 support.
 *
 *   Most functions are only monkey patched if the protocol is uint8utf8,
 *   leaving the normal functionality unchanged. This is a temporary fix
 *   until uint8utf8 support can be updated to convert to ArrayBuffers
 *   instead of the older string based receiveQueue.
 */
function addUint8Utf8(vncDecoder) {
   'use strict';

   WMKS.LOGGER.debug('adding uint8utf8 support');
   var self = vncDecoder;

   if (!self.hasOwnProperty('_legacyReceiveQueue')) {
      self._legacyReceiveQueue = '';
      self._legacyReceiveQueueIndex = '';
   }

   self.useLegacy = false;


   var legacyFunctions = {};

   /*
    *
    * RX/TX queue management
    *
    */
   legacyFunctions._receiveQueueBytesUnread = function () {
      return this._legacyReceiveQueue.length - this._legacyReceiveQueueIndex;
   };

   legacyFunctions._receiveQueueConsumeBytes = function (nr) {
      this._legacyReceiveQueueIndex += nr;
   };

   legacyFunctions._receiveQueueReset = function () {
      this._legacyReceiveQueue = '';
      this._legacyReceiveQueueIndex = 0;
   };

   legacyFunctions._readString = function (stringLength) {
      var string = this._legacyReceiveQueue.slice(this._legacyReceiveQueueIndex,
                                                  this._legacyReceiveQueueIndex + stringLength);
      this._legacyReceiveQueueIndex += stringLength;
      return string;
   };




   /*
    *------------------------------------------------------------------------------
    *
    * _readStringUTF8
    *
    *    Pops the first 'stringLength' bytes from the front of the read buffer
    *    and parses the string for unicode. If it finds unicode, it converts them
    *    to unicode and returns the unicode string.
    *
    * Results:
    *    A unicode string thats as long as 'stringLength' in case of non-unicodes
    *    or shorter.
    *
    * Side Effects:
    *    Advances receive buffer.
    *
    *------------------------------------------------------------------------------
    */

   legacyFunctions._readStringUTF8 = function (stringLength) {
      var c, c1, c2, c3, valArray = [],
          i = this._legacyReceiveQueueIndex;
      while (i < this._legacyReceiveQueueIndex + stringLength) {
         c = this._legacyReceiveQueue.charCodeAt(i);
         if (c < 128) {
            // Handle non-unicode string here.
            valArray.push(c);
            i++;
         } else if (c < 224) {
            c1 = this._legacyReceiveQueue.charCodeAt(i+1) & 63;
            valArray.push(((c & 31) << 6) | c1);
            i += 2;
         } else if (c < 240) {
            c1 = this._legacyReceiveQueue.charCodeAt(i+1) & 63;
            c2 = this._legacyReceiveQueue.charCodeAt(i+2) & 63;
            valArray.push(((c & 15) << 12) | (c1 << 6) | c2);
            i += 3;
         } else {
            c1 = this._legacyReceiveQueue.charCodeAt(i+1) & 63;
            c2 = this._legacyReceiveQueue.charCodeAt(i+2) & 63;
            c3 = this._legacyReceiveQueue.charCodeAt(i+3) & 63;
            valArray.push(((c & 7) << 18) | (c1 << 12) | (c2 << 6) | c3);
            i += 4;
         }
      }

      this._legacyReceiveQueueIndex += stringLength;
      // WMKS.LOGGER.warn(valArray + ' :arr, str: ' + String.fromCharCode.apply(String, valArray));
      // Apply all at once is faster: http://jsperf.com/string-fromcharcode-apply-vs-for-loop
      return String.fromCharCode.apply(String, valArray);
   };


   /*
    *------------------------------------------------------------------------------
    *
    * _readByte
    *
    *    Pops the first byte from the front of the receive buffer.
    *
    * Results:
    *    First byte of the receive buffer.
    *
    * Side Effects:
    *    Advances receive buffer.
    *
    *------------------------------------------------------------------------------
    */

   legacyFunctions._readByte = function () {
      var aByte = this._legacyReceiveQueue.charCodeAt(this._legacyReceiveQueueIndex);
      this._legacyReceiveQueueIndex += 1;
      return aByte;
   };


   /*
    *------------------------------------------------------------------------------
    *
    * _readBytes
    *
    *    Pops the first 'length' bytes from the front of the receive buffer.
    *
    * Results:
    *    Array of 'length' bytes.
    *
    * Side Effects:
    *    Advances receive buffer.
    *
    *------------------------------------------------------------------------------
    */

   legacyFunctions._readBytes = function (length) {
      var result, i;

      result = new Array(length);

      for (i = 0; i < length; i++) {
         result[i] = this._legacyReceiveQueue.charCodeAt(i + this._legacyReceiveQueueIndex);
      }

      this._legacyReceiveQueueIndex += length;
      return result;
   };


   /*
    *------------------------------------------------------------------------------
    *
    * _sendString
    *
    *    Sends a string to the server, using the appropriate encoding.
    *
    * Results:
    *    None.
    *
    * Side Effects:
    *    Sends data.
    *
    *------------------------------------------------------------------------------
    */

   legacyFunctions._sendString = function (stringValue) {
      if (!this._websocket) {
         return;
      }

      this._websocket.send(stringValue);
   };


   /*
    *------------------------------------------------------------------------------
    *
    * _sendBytes
    *
    *    Sends the array 'bytes' of data bytes to the server.
    *
    * Results:
    *    None.
    *
    * Side Effects:
    *    Sends data.
    *
    *------------------------------------------------------------------------------
    */

   legacyFunctions._sendBytes = function (bytes) {
      this._sendString(stringFromArray(bytes));
   };




   /*
    *
    * Client message sending
    *
    */



   /*
    *------------------------------------------------------------------------------
    *
    * _sendClientEncodingsMsg
    *
    *    Sends the server a list of supported image encodings.
    *    This is a temporary override to disabled encTightDiffComp
    *    until it can be better tested and potentially updated.
    *
    * Results:
    *    None.
    *
    * Side Effects:
    *    Sends data.
    *
    *------------------------------------------------------------------------------
    */

   legacyFunctions._sendClientEncodingsMsg = function () {
      var i;
      var encodings = [/* this.encTightDiffComp, */
         this.encTightPNG,
         this.encDesktopSize,
         this.encVMWDefineCursor,
         this.encVMWCursorState,
         this.encVMWCursorPosition,
         this.encVMWTypematicInfo,
         this.encVMWLEDState,
         this.encVMWServerPush2,
         this.encVMWServerCaps,
         this.encTightJpegQuality10,
         this.encVMWFrameStamp,
         this.encUpdateCache];


      if (this.options.mediaPlayer) {
         encodings.unshift(this.encH264MP4);
      }

      if (this._canvas[1]) {
         encodings = [this.encOffscreenCopyRect].concat(encodings);
      }

      /*
       * Blits seem to work well on most browsers now.
       */
      encodings = [this.encCopyRect].concat(encodings);

      var message = [];
      message.push8(this.msgClientEncodings);
      message.push8(0);
      message.push16(encodings.length);
      for (i = 0; i < encodings.length; i += 1) {
         message.push32(encodings[i]);
      }
      this._sendBytes(message);
   };

   /*
    *
    * Framebuffer updates
    *
    */


   /*
    *------------------------------------------------------------------------------
    *
    * _readTightData
    *
    *    Parses a compressed FB update payload.
    *
    * Results:
    *    None.
    *
    * Side Effects:
    *    Sets next parser callback.
    *
    *------------------------------------------------------------------------------
    */

   legacyFunctions._readTightData = function (rect) {
      /*
       * Skip the preamble and read the actual JPEG data.
       */
      var type = (rect.subEncoding === this.subEncPNG) ? 'image/png' : 'image/jpeg',
          data = this._readString(this.nextBytes),
          URL  = window.URL || window.webkitURL,
          self = this;

      if (this._useImageBitmaps) {
         data = arrayFromString(data, true);
         createImageBitmap(new Blob([data], {type: type}))
            .then(function (imageBitmap) {
               rect.image = imageBitmap;
               self.onDecodeComplete();
            });
      } else {
         /*
          * Construct an Image and keep a reference to it in the
          * rectangle object. Since Images are loaded asynchronously
          * we can't draw it until the image has finished loading so
          * we don't call onDecodeComplete() until this has happened.
          */
         rect.image = this._imageManager.getImage();
         rect.image.width = rect.width;
         rect.image.height = rect.height;
         rect.image.destX = rect.x;
         rect.image.destY = rect.y;

         if (URL) {
            data = arrayFromString(data, true);
            rect.image.onload = this.onDecodeObjectURLComplete;
            rect.image.src = URL.createObjectURL(new Blob([data], {type: type}));
         } else {
            data = Base64.encodeFromString(data);
            rect.image.onload = this.onDecodeComplete;
            rect.image.src = 'data:' + type + ';base64,' + data;
         }
      }

      this._nextRect();
   };


   /*
    *------------------------------------------------------------------------------
    *
    * _peekFirstMessage
    *
    *    We have built and deployed two sorts of VNC servers, those that
    *    expect an RFB 003.008 and VNC authentication handshake, and
    *    those which jump straight into the VNC protocol at the
    *    serverInitialized message.  Previously we had to switch the
    *    client between these two modes, but it is possible to build a
    *    single client which can talk to both types of server simply by
    *    examining the size of the first message we receive.
    *
    *    Note that this is a very robust detection method - the server is
    *    required in each case to send a message of a specific size on
    *    connection establishment.  We are lucky that the two messages
    *    are of different sizes.
    *
    * Results:
    *    None.
    *
    * Side Effects:
    *    Sets next parser callback.
    *
    *------------------------------------------------------------------------------
    */

   legacyFunctions._peekFirstMessage = function () {
      this.usedVNCHandshake = (this._receiveQueueBytesUnread() == 12);
      if (this.usedVNCHandshake) {
         this._setReadCB(12, this._handleProtocolVersionMsg);
      } else {
         this._setReadCB(24, this._handleServerInitializedMsg);
      }
   };



   function replaceFunctions(vncDecoder) {
      WMKS.LOGGER.trace('uint8utf8: replacing functions');
      vncDecoder._originalFunctions = vncDecoder._originalFunctions || {};

      for (var functionName in legacyFunctions) {
         if(legacyFunctions.hasOwnProperty(functionName)){
            if (!vncDecoder._originalFunctions[functionName]) {
               //Save reference to original
               vncDecoder._originalFunctions[functionName] = vncDecoder[functionName];
            }
            vncDecoder[functionName] = legacyFunctions[functionName];
         }
      }
   }

   function restoreFunctions(vncDecoder) {
      WMKS.LOGGER.trace('restoreFunctions');
      if (!vncDecoder._originalFunctions) {
         return;
      }  //never replaced

      for (var functionName in vncDecoder._originalFunctions) {
         if(vncDecoder._originalFunctions.hasOwnProperty(functionName)){
            vncDecoder[functionName] = vncDecoder._originalFunctions[functionName];
         }
      }
   }

   self.wsOpen = function (evt) {

      self._state = self.VNC_ACTIVE_STATE;
      if (this.protocol !== 'uint8utf8' &&
          this.protocol !== 'binary' &&
          this.protocol !== 'vmware-vvc') {
         return self.fail('no agreement on protocol');
      }

      if (this.protocol === 'vmware-vvc') {
         self._setupVVC();
         WMKS.LOGGER.log('WebSocket is using VMware Virtual Channels');
         this.protocol = 'binary';
      }

      if (this.protocol === 'binary') {
         this.binaryType = 'arraybuffer';
         WMKS.LOGGER.log('WebSocket HAS binary support');
      }

      self.useLegacy = (this.protocol === 'uint8utf8');

      if (self.useLegacy) {
         replaceFunctions(self);
      } else{
         restoreFunctions(self);
      }

      // Note: this is after _setupVVC() in case the UI wants to add vvc listeners.
      self.options.onConnecting(self.vvc, self.vvcSession);

      WMKS.LOGGER.log('WebSocket created protocol: ' + this.protocol);
   };


   var wsMessageOriginal = self.wsMessage;
   self.wsMessage = function (evt) {
      if (!self.useLegacy) { return wsMessageOriginal.apply(this, arguments); }

      if (self._legacyReceiveQueueIndex > self._legacyReceiveQueue.length) {
         return self.fail('overflow receiveQueue');
      } else if (self._legacyReceiveQueueIndex === self._legacyReceiveQueue.length) {
         self._legacyReceiveQueue = '';
         self._legacyReceiveQueueIndex = 0;
      }

      if (typeof evt.data !== 'string') {
         var data = new Uint8Array(evt.data);
         self._legacyReceiveQueue = self._legacyReceiveQueue.concat(stringFromArray(data));
      } else {
         self._legacyReceiveQueue = self._legacyReceiveQueue.concat(evt.data);
      }
      self._processMessages();
   };


   if (self.protocolList.indexOf('uint8utf8') === -1) {
      self.protocolList.push('uint8utf8');
   }
   legacyFunctions._receiveQueueReset.call(self);
}
// Use the following for js-lint.
/*global WMKS:false, $:false */

/*
 *------------------------------------------------------------------------------
 *
 * wmks/keyboardManager.js
 *
 *   WebMKS related keyboard management is handled here.
 *   There are 2 types of inputs that can be sent.
 *
 *   1. VMware VScanCodes that are handled by the hypervisor.
 *   2. KeyCodes + unicode based messages for Blast+NGP.
 *
 *   The message type to be sent is determined by flags in vncDecoder:
 *      useVMWKeyEvent            // VMware VScanCode key inputs are handled.
 *      useVMWKeyEventUnicode     // unicode key inputs are handled.
 *
 *   Input handling is quite different for desktop browsers with physical
 *   keyboard vs soft keyboards on touch devices. To deal with these we use
 *   separate event handlers for keyboard inputs.
 *
 *------------------------------------------------------------------------------
 */

/*
 * List of keyboard constants.
 */
WMKS.CONST.KB = {

   ControlKeys: [
   /*
    * backspace, tab, enter, shift, ctrl, alt, pause, caps lock, escape,
    * pgup, pgdown, end, home, left, up, right, down, insert, delete,
    * win-left(or meta on mac), win-right, menu-select(or meta-right), f1 - f12,
    * num-lock, scroll-lock
    */
      8, 9, 13, 16, 17, 18, 19, 20, 27,
      33, 34, 35, 36, 37, 38, 39, 40, 45, 46,
      91, 92, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123,
      144, 145, 240
   ],

   /*
    * If you change this, change 'vals' in syncModifiers.
    * shift, ctrl, alt, win-left, win-right, cmd-left/cmd-right on Firefox
    */
   Modifiers:        [16, 17, 18, 91, 92],

   WestEuroLanguage: ['de-DE','it-IT','es-ES','pt-BR', 'pt-PT', 'fr-FR', 'fr-CH', 'de-CH'],
   /*
    * List of characters to discard on an onKeyDown on Windows with Firefox
    * 192 = VK_OEM_3
    */
   Diacritics:       [192],

   KEY_CODE: {
      Shift:         16,
      Ctrl:          17,
      Alt:           18,
      Meta:          91,               // Mac left CMD key.
      Enter:         13,
      CapsLock:      20
   },

   SoftKBRawKeyCodes:      [8, 9, 13], // backspace, tab, newline
   keyInputDefaultValue:   ' ',        // Default value for the input textbox.


   ANSIShiftSymbols:    "~!@#$%^&*()_+{}|:\"<>?",  // ANSI US layout keys that require shift
   ANSINoShiftSymbols:  "`-=[]\\;',./1234567890",  // ANSI US layout keys that do not require shift

   WindowsKeys: {
      left:  91,  // win-left(or meta on Mac, search on ChromeOS)
      right: 92   // win-right
   },

   VScanMap: {}
};

// on windows system 224 is a normal key value

if (WMKS.BROWSER.isMacOS()) {
   WMKS.CONST.KB.Modifiers = [16, 17, 18, 91, 92, 224];
}

// Map of all ANSI special symbols
WMKS.CONST.KB.ANSISpecialSymbols = WMKS.CONST.KB.ANSIShiftSymbols + WMKS.CONST.KB.ANSINoShiftSymbols;

WMKS.KeyboardManager = function(options) {
   'use strict';
   if (!options || !options.vncDecoder) {
      return null;
   }

   this._vncDecoder = options.vncDecoder;
   // Any raw key that needs to be ignored.
   this.ignoredRawKeyCodes = options.ignoredRawKeyCodes;
   this.fixANSIEquivalentKeys = options.fixANSIEquivalentKeys;
   this.mapMetaToCtrlForKeys = options.mapMetaToCtrlForKeys;

   this.keyDownKeyTimer = null;
   this.keyDownIdentifier = null;
   this.pendingKey = null;
   this.addCtrlKey = false;
   this.activeModifiers = [];
   this.keyToUnicodeMap = {};
   this.keyToRawMap = {};
   this.keyboardLayoutId = options.keyboardLayoutId;
   // Use different map with mappings for all unicode --> vScanCode.
   this.UnicodeToVScanMap = WMKS.CONST.KB.VScanMap[this.keyboardLayoutId];

   this._windowsKeyManager = {
      // Windows key simulation is enabled or not.
      enabled: options.enableWindowsKey,
      // Windows key is simulated when Ctrl + Windows are pressed.
      windowsOn: false,
      // left Windows key is down or not.
      leftWindowsDown: false,
      // right Windows key is down or not.
      rightWindowsDown: false,
      // modified keyCode map.
      modifiedKeyMap: {
         Pause : 19 // The keyCode of Pause key should be 19
      },
      modifiedKey: null,

      /*
       * reset
       *
       * It's important to do reset when the browser loses focus.
       * Otherwise, some key release events are not captured when
       * the browser loses focuse. In consequence, the states are incorrect.
       */
      reset: function() {
        this.windowsOn = false;
        this.leftWindowsDown = false;
        this.rightWindowsDown = false;
        this.modifiedKey = null;
      },

      /*
       * keyboardHandler
       *
       * Handles Windows keydown and keyup event.
       */
      keyboardHandler: function(e) {
         /*
          * Fix bug 1492888 - Ctrl-Command doesn't work on Firefox
          * On Firefox at Mac OS, left Command key and right Command key
          * have the same value: 224. It differs from Webkit browsers.
          * On Webkit browsers at Mac OS, left Command key is of value 91,
          * while right Command key is of value 93. Since we can't differentiate
          * left Command key from right Command key on Firefox of Mac OS,
          * we generally assume a left Windows key is down.
          */
         if (e.keyCode === WMKS.CONST.KB.WindowsKeys.left || e.keyCode === 224) {
            // Left Windows key is down or up.
            this.leftWindowsDown = e.type === 'keydown';
            if (!this.leftWindowsDown) {
               // Left Windows key is released.
               this.windowsOn = false;
            }
         } else if (e.keyCode === WMKS.CONST.KB.WindowsKeys.right) {
            // Right Windows key is down or up.
            this.rightWindowsDown = e.type === 'keydown';
            if (!this.rightWindowsDown) {
               // Right Windows key is released.
               this.windowsOn = false;
            }
         }
      },

      /*
       * modifyKey
       *
       * Invoked by _extractKeyCodeFromEvent. Modify some keyCode value
       * when Windows key is held.
       */
      modifyKey: function(keyCode) {
         /*
          * Fix bug 1436247 - Windows+Pause doesn't work
          * The keyCode of Pause key should be 19. However, when Ctrl key is pressed,
          * Pause's keyCode is modified to 3. To fix this issue, at detecting keyCode
          * 3 while Ctrl and Windows are pressed, convert it to 19 directly.
          */
         if (keyCode === 3) {
            // Pause key with Ctrl emits 3.
            if (this.windowsOn) {
               // When Windows key is pressed, restore Pause key to 19.
               keyCode = this.modifiedKeyMap['Pause'];
               this.modifiedKey = 3;
            } else if (this.modifiedKey === 3) {
               // Pause key is released.
               keyCode = this.modifiedKeyMap['Pause'];
               this.modifiedKey = null;
            }
         }

         return keyCode;
      }
   };

   /*
    *---------------------------------------------------------------------------
    *
    * _extractKeyCodeFromEvent
    *
    *    Attempts to extract the keycode from a given key{down,up} event.  The
    *    value extracted may be a unicode value instead of a normal vk keycode.
    *    If this is the case then the 'isUnicode' property will be set to true.
    *    Additionally, in the unicode case, the caller should not expect a
    *    corresponding keyPress event.
    *
    * Results:
    *    If extraction succeeds, returns an object with 'keyCode' and
    *    'isUnicode' properties, null otherwise.
    *
    *---------------------------------------------------------------------------
    */

   this._extractKeyCodeFromEvent = function(e) {
      var keyCode = 0, isUnicode = false;

      if (e.keyCode) {
         keyCode = e.keyCode;
         /*
          * For pt-pt, when press ´ key on windows chrome, keycode is the same with
          *  º keypress keycode. Remap it.
          */
         if (this.keyboardLayoutId == "pt-PT" && WMKS.BROWSER.isChrome() &&
            (e.keyCode === 186 || e.keyCode === 191) && WMKS.BROWSER.isWindows()) {
            if(e.keyCode === 186) {
               keyCode = 180;
            } else {
               keyCode = 126;
            }
         }
         // After Firefox's update, the dead key has a keycode value on firefox.
         if (this.keyboardLayoutId == "de-DE" &&e.keyCode == 192 && WMKS.BROWSER.isFirefox()) {
            //keycodes are different on Chrome and Firefox on Mac
            keyCode = 187;
         }
         if ((this.keyboardLayoutId === "fr-CH" || this.keyboardLayoutId === "de-CH")
            && WMKS.BROWSER.isWindows() ) {
            if (e.keyCode === 221 ) {
               keyCode = 94;
            }
         }
      } else if (e.which) {
         keyCode = e.which;
      } else if (e.keyIdentifier && e.keyIdentifier.substring(0, 2) === 'U+') {
         /*
          * Safari doesn't give us a keycode nor a which value for some
          * keypresses. The only useful piece of a data is a Unicode codepoint
          * string (something of the form U+0000) found in the keyIdentifier
          * property. So fall back to parsing this string and sending the
          * converted integer to the agent as a unicode value.
          * See bugs 959274 and 959279.
          */
         keyCode = parseInt('0x' + e.keyIdentifier.slice(2), 16);
         if (keyCode) {
            isUnicode = true;
         } else {
            WMKS.LOGGER.log('assert: Unicode identifier=' + e.keyIdentifier
                          + ' int conversion failed, keyCode=' + keyCode);
            return null;
         }
      } else if (e.keyCode === 0 && WMKS.BROWSER.isFirefox() && e.key &&
         this._vncDecoder.allowVMWKeyEvent2UnicodeAndRaw) {
         /*
          * On Firefox, for some special key such as ü ö ä, the keyCode of
          * onKeyUp and keyDown is 0, but there is a value in key property.
          * See bug 1166133.
           */
         keyCode = 0;
      } else {
         if (!this._vncDecoder.allowVMWKeyEvent2UnicodeAndRaw) {
            keyCode = this.handleInternationalKeyboard(e,keyCode);
         }
         if (this.keyboardLayoutId == "ja-JP_106/109" && !WMKS.BROWSER.isFirefox() &&
            e.keyCode === 0) {
            /*
             * On browser except firefox in Japanese, for the special key
             * left to 1 key, the keyCode of onKeyUp and keyDown
             * is 0, and there is no value in key property.
             */
            keyCode = 165;
         }
         if (!keyCode) {
            WMKS.LOGGER.trace('assert: could not read keycode from event, '
                       + 'keyIdentifier=' + e.keyIdentifier);
            return null;
         }
      }

      if (!isUnicode && this._windowsKeyManager.enabled) {
         keyCode = this._windowsKeyManager.modifyKey(keyCode);
      }

      return {
         keyCode: keyCode,
         isUnicode: isUnicode
      };
   };


   /*
    *---------------------------------------------------------------------------
    *
    * onKeyDown
    *
    *    The first step in our input strategy. Capture a raw key. If it is a
    *    control key, send a keydown command immediately. If it is not, memorize
    *    it and return without doing anything. We pick it up in onKeyPress
    *    instead and bind the raw keycode to the Unicode result. Then, in
    *    onKeyUp, resolve the binding and send the keyup for the Unicode key
    *    when the scancode is received.
    *
    * Results:
    *    true if the key is non-raw (let the event through, to allow keypress
    *    to be dispatched.) false otherwise.
    *
    *---------------------------------------------------------------------------
    */

   this.onKeyDown = function(e) {
      var keyCodeRes,
          keyCode = 0,
          isUnicode = false,
          self = this;

      keyCodeRes = this._extractKeyCodeFromEvent(e);

      if (!keyCodeRes) {
         WMKS.LOGGER.log('Extraction of keyCode from keyUp event failed.');
         return false; // don't send a malformed command.
      }
      keyCode = keyCodeRes.keyCode;
      isUnicode = keyCodeRes.isUnicode;

      //WMKS.LOGGER.log("onKeyDown: keyCode=" + keyCode);

      // Sync modifiers because we don't always get correct events.
      this._syncModifiers(e);

      if (keyCode === 0) {
         WMKS.LOGGER.log("onKeyDown: Do not send 0 to server.");
         return true;
      }

      /*
       * Most control characters are 'dangerous' if forwarded to the underlying
       * input mechanism, so send the keys immediately without waiting for
       * keypress.
       */
      if ($.inArray(keyCode, WMKS.CONST.KB.Modifiers) !== -1) {
         // Handled above via syncModifiers
         e.returnValue = false;
         return false;
      }

      if (WMKS.CONST.KB.ControlKeys.indexOf(keyCode) !== -1) {
         e.returnValue = false;
         return this._handleControlKeys(keyCode);
      }


      /*
       * Send the keydown event right now if we were given a unicode codepoint
       * in the keyIdentifier field of the event.  There won't be a
       * corresponding key press event so we can confidently send it right now.
       */
      if (isUnicode) {
         WMKS.LOGGER.log('Send unicode down from keyIdentifier: ' + keyCode);
         self.sendKey(keyCode, false, true);
         e.returnValue = false;
         return false;
      }

      /*
       * Expect a keypress before control is returned to the main JavaScript.
       * The setTimeout(..., 0) is a failsafe that will activate only if the
       * main JavaScript loop is reached. When the failsafe activates, send
       * the raw key and hope it works.
       */
      if (this.keyDownKeyTimer !== null) {
         WMKS.LOGGER.log('assert: nuking an existing keyDownKeyTimer');
         clearTimeout(this.keyDownKeyTimer);
      }

      /*
       * Sometimes, on Mac Firefox, sending vscancode, control +alt +key, will
       * cause the timer start to work, and in press event, the timer will be null.
       * It causes sending twice keydown event. So set the time to 1 will reduce
       * this bugs' happen.
       */
      var time = 0;
      if (WMKS.BROWSER.isFirefox() && WMKS.BROWSER.isMacOS() && e.altKey === true &&
         e.ctrlKey === true && !this.allowVMWKeyEvent2UnicodeAndRaw) {
         time = 1;
      } else {
         time = 0;
      }

      this.keyDownKeyTimer = setTimeout(function() {
         // WMKS.LOGGER.log('timeout, sending raw keyCode=' + keyCode);
         self.sendKey(keyCode, false, false);
         self.keyDownKeyTimer = null;
         self.pendingKey = null;
      }, time);
      this.pendingKey = keyCode;

      // Safari has the keyIdentifier on the keydown calls (chrome is on keypress)
      // Save for reference in onKeyPress
      if (e.originalEvent && e.originalEvent.keyIdentifier) {
         this.keyDownIdentifier = e.originalEvent.keyIdentifier;
      }

      /*
       * If Alt or Ctrl or Win (by themselves) are held, inhibit the keypress by
       * returning false.
       * This prevents the browser from handling the keyboard shortcut
       */
      e.returnValue = !(this.activeModifiers.length === 1 &&
         (this.activeModifiers[0] === WMKS.CONST.KB.KEY_CODE.Alt ||
         this.activeModifiers[0] === WMKS.CONST.KB.KEY_CODE.Ctrl ||
         this.activeModifiers[0] === WMKS.CONST.KB.WindowsKeys.left ||
         this.activeModifiers[0] === WMKS.CONST.KB.WindowsKeys.right));
      return e.returnValue;
   };

   /*
    *---------------------------------------------------------------------------
    *
    * _handleControlKeys
    *
    *    This function takes care of the control keys and handling these.
    *
    *---------------------------------------------------------------------------
    */

   this._handleControlKeys = function(keyCode) {
      // var isCapsOn = this._vncDecoder._keyboardLEDs & 4;
      // WMKS.LOGGER.log('Led: ' + led + ', Caps: ' + isCapsOn);

      /*
       * Caps lock is an unusual key and generates a 'down' when the
       * caps lock light is going from off -> on, and then an 'up'
       * when the caps lock light is going from on -> off. The problem
       * is compounded by a lack of information between the guest & VMX
       * as to the state of caps lock light. So the best we can do right
       * now is to always send a 'down' for the Caps Lock key to try and
       * toggle the caps lock state in the guest.
       */
      if (this.isAddCapsLockEvent(keyCode)) {
         // TODO: Confirm if this works.
         this.sendKey(keyCode, false, false);
         this.sendKey(keyCode, true, false);
         return;
      }
      this.sendKey(keyCode, false, false);
      return false;
   };

   this.isAddCapsLockEvent = function(keyCode) {
      // On Windows 8.1 Caps lock's keycode is 240. No character's keycode is 240 now.
      return (keyCode === WMKS.CONST.KB.KEY_CODE.CapsLock && WMKS.BROWSER.isMacOS())
         || (keyCode === 240 && WMKS.BROWSER.isWindows());
   };

   this._handleCapsLockKey = function(keyCode) {
      /*
       * When press caps lock, there's only a up event. Add a down one, so it will work.
       * Add this in vscancode, unicode need to be Confirm if this works.
       * More introduction please check _handleControlKeys.
       */
      if (this.isAddCapsLockEvent(keyCode) && !this._vncDecoder.allowVMWKeyEvent2UnicodeAndRaw) {
         this.sendKey(keyCode, false, false);
         this.sendKey(keyCode, true, false);
         return false;
      }
   };

   /*
    *---------------------------------------------------------------------------
    *
    * _syncModifiers
    *
    *    Parse the altKey, shiftKey, metaKey and ctrlKey attributes of an event
    *     to synthesize event keystrokes. The keydown and keyup events are not
    *    reliably sent by all browsers but these attributes are always set,
    *    so key off of these to send keydown and keyup events for those keys.
    *
    *---------------------------------------------------------------------------
    */

   this._syncModifiers = function(e) {
      var thisMod, thisVal, i, idx;
      // This must be in the order of WMKS.CONST.KB.Modifiers
      var vals = [e.shiftKey, e.ctrlKey, e.altKey, e.metaKey, false, false];
      // var names = ['shift', 'ctrl', 'alt', 'meta']; // used with logging.

      // Do check for AltGr and set ctrl and alt if set
      if (e.altGraphKey === true) {
         vals[1] = vals[2] = true;
      }

      /*
       * on windows firefox, altgr keys,e.ctrlKey and e.altKey are false.
       * Reset them to true. Or it will cause multi control + alt events.
       */
      vals = this.resetEventValue(e,vals);
      /*
       * On OSX if the meta key (aka CMD) key is pressed along with one of
       * either A, C, V, or X we map the CMD key to CTRL, allowing
       * the Mac user to use CMD-V for CTRL-V etc.
       */
      if (e.metaKey === true && this.mapMetaToCtrlForKeys.indexOf(e.keyCode) !== -1) {
         vals[1] = true;  // turn on CTRL
         vals[3] = false; // turn off CMD
      }

      /*
       * When Windows key simulation is enabled, pressing Ctrl+Win
       * on Windows or Ctrl+CMD on OSX simulates a Windows key.
       */
      if (this._windowsKeyManager.enabled) {
         this._windowsKeyManager.keyboardHandler(e);

         if (e.ctrlKey === true) {
            // Ctrl key is down.
            if (this._windowsKeyManager.leftWindowsDown  ||
               this.activeModifiers.indexOf(WMKS.CONST.KB.WindowsKeys.left) !== -1) {
               // Left Windows key is down.
               vals[1] = false;  // turn off Ctrl
               vals[3] = true;   // turn on left Windows
               // Ctrl + Windows are pressed.
               this._windowsKeyManager.windowsOn = true;
            } else if (this._windowsKeyManager.rightWindowsDown ||
               this.activeModifiers.indexOf(WMKS.CONST.KB.WindowsKeys.right) !== -1) {
               // Right Windows key is down.
               vals[1] = false;  // turn off Ctrl
               vals[4] = true;   // turn on right Windows
               // Ctrl + Windows are pressed.
               this._windowsKeyManager.windowsOn = true;
            }
         }
      }

      for (i = 0; i < WMKS.CONST.KB.Modifiers.length; i++) {
         thisMod = WMKS.CONST.KB.Modifiers[i];
         thisVal = vals[i];

         idx = this.activeModifiers.indexOf(thisMod);
         if (thisVal && idx === -1) {
            // WMKS.LOGGER.log(names[i] + ' down');
            this.activeModifiers.push(thisMod);
            this.sendKey(thisMod, false, false);
         } else if (!thisVal && idx !== -1) {
            // WMKS.LOGGER.log(names[i] + ' up');
            this.activeModifiers.splice(idx, 1);
            this.sendKey(thisMod, true, false);
         }
      }
   };

   /*
    * On Windows Firefox, altgr keys,e.ctrlKey and e.altKey are false.
    * Reset them to true.
    */
   this.resetEventValue = function(e,vals) {
      var keyCode = e.charCode || e.which;
      var table = WMKS.keyboardUtils._WindowsFirefoxAltGr[this.keyboardLayoutId];
      if (!!table && table.indexOf(keyCode)!== -1 && WMKS.BROWSER.isWindows() &&
         WMKS.BROWSER.isFirefox()) {
         vals[1] = vals[2] = true;
      }
      return vals;
   };

   /*
    *---------------------------------------------------------------------------
    *
    * cancelModifiers
    *
    *    Clear all modifiers currently in a 'keydown' state. Used as a cleanup
    *    for onBlur or to clear the modifier state upon close of the
    *    extendedKeypad widget.
    *
    *    applyToSoftKB - When set and is a touch device, perform this action.
    *
    *---------------------------------------------------------------------------
    */

   this.cancelModifiers = function(applyToSoftKB) {
      var i;
      /*
       * On blur events invoke cancelModifiers for desktop browsers. This is not
       * desired in case of softKB (touch devices, as we constantly change focus
       * from canvas to the hidden textbox (inputProxy) - PR 1084858.
       */
      if (WMKS.BROWSER.isTouchDevice() && !applyToSoftKB) {
         return;
      }
      for (i = 0; i < this.activeModifiers.length; i++) {
         this.sendKey(this.activeModifiers[i], true, false);
      }
      this.activeModifiers.length = 0;

      if (this._windowsKeyManager.enabled) {
         // Reset Windows key status.
         this._windowsKeyManager.reset();
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * updateModifiers
    *
    *    This function update the state of the modifiers based on the input.
    *    If the modifier key is down, we add it to the modifier list else remove
    *    it from the list and send the appropriate key info to the protocol.
    *
    *    NOTE: Currently used by extendedKeypad widget.
    *
    *---------------------------------------------------------------------------
    */

   this.updateModifiers = function(modKey, isUp) {
      this.sendKey(modKey, isUp, false);
      if (isUp) {
         this.activeModifiers.splice(this.activeModifiers.indexOf(modKey), 1);
      } else {
         this.activeModifiers.push(modKey);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * onKeyPress
    *
    *    Desktop style onKeyPress handler. See onKeyDown for how our keyboard
    *    input mechanism works.
    *
    *---------------------------------------------------------------------------
    */

   this.onKeyPress = function(e) {
      var keyCode,
          isRaw = false,
          shiftMismatch = false,
          noShiftMismatch = false,
          keyCodeMismatch = false,
          isSpecialSymbol = false,
          key = "", // String version of the key pressed
          isWestEuroLanguage =  WMKS.CONST.KB.WestEuroLanguage.indexOf(this.keyboardLayoutId) !== -1;

      /*
       * If on a Mac, and ONLY Alt is held, prefer the raw key code.
       * This is because Alt-* on a US Mac keyboard produces many international
       * characters, which I would prefer to ignore for the sake of letting
       * keyboard shortcuts work naturally.
       */
      if (WMKS.BROWSER.isMacOS() && this.activeModifiers.length === 1 &&
          this.activeModifiers[0] === WMKS.CONST.KB.KEY_CODE.Alt) {
         WMKS.LOGGER.log('Preferring raw keycode with Alt held (Mac)');
         return false;
      } else if (e.charCode && e.charCode >= 0x20) {
         /*
          * Low order characters are control codes, which we need to send raw.
          * 0x20 is SPACE, which is the first printable character in Unicode.
          */
         keyCode = e.charCode;
         isRaw = false;
      } else if (e.keyCode) {
         keyCode = e.keyCode;
         keyCode = this.remapUncontrolKey(e, keyCode, isRaw).keyCode;
         isRaw = this.remapUncontrolKey(e, keyCode, isRaw).isRaw;
      } else {
         WMKS.LOGGER.log('assert: could not read keypress event');
         return false;
      }

      if (this.keyDownKeyTimer !== null) {
         clearTimeout(this.keyDownKeyTimer);
         this.keyDownKeyTimer = null;
      }
      //WMKS.LOGGER.log("onKeyPress: keyCode=" + keyCode);

      if (isRaw && WMKS.CONST.KB.ControlKeys.indexOf(keyCode) !== -1) {
         // keypress for a keydown that was sent as a control key. Ignore.
         return false;
      }

      if (this.handleUnusefulKeys(e)) {
         return false;
      }
      /* Top left key on windows firefox, the key value is the same with altgr+4,5,
       * it will cause the key won's display. So remap it to the different key value.
       */
      e = this.fixDeFrChSpecialKeys(e,this.pendingKey,keyCode);
      /*
       * Update the modifier state before we send a character which may conflict
       * with a stale modifier state
       */
      this._syncModifiers(e);

      if (this.pendingKey !== null) {
         if (isRaw) {
            this.keyToRawMap[this.pendingKey] = keyCode;
         } else {
            this.keyToUnicodeMap[this.pendingKey] = keyCode;
         }
      }

      if (this.fixANSIEquivalentKeys && e.originalEvent) {
         if (e.originalEvent.key) {
            key = e.originalEvent.key;
         } else if (!WMKS.BROWSER.isWindows() || !WMKS.BROWSER.isChrome()) {
            if (e.originalEvent.keyIdentifier === "" && this.keyDownIdentifier) {
               // Parse Unicode as hex
               key = String.fromCharCode(parseInt(this.keyDownIdentifier.replace("U+", ""), 16));
            } else if(e.originalEvent.keyIdentifier) {
               // Parse Unicode as hex
               key = String.fromCharCode(parseInt(e.originalEvent.keyIdentifier.replace("U+", ""), 16));
            }
         }
         if (key) {
            keyCodeMismatch = (key.charCodeAt(0) !== keyCode);
            shiftMismatch = (WMKS.CONST.KB.ANSIShiftSymbols.indexOf(key) !== -1 &&
               this.activeModifiers.indexOf(WMKS.CONST.KB.KEY_CODE.Shift) === -1);
            noShiftMismatch = (WMKS.CONST.KB.ANSINoShiftSymbols.indexOf(key) !== -1 &&
               this.activeModifiers.indexOf(WMKS.CONST.KB.KEY_CODE.Shift) !== -1);
            isSpecialSymbol = (WMKS.CONST.KB.ANSISpecialSymbols.indexOf(key) !== -1);
         }
      }

      this.keyDownIdentifier = null;


      if (this.fixANSIEquivalentKeys && key && isSpecialSymbol &&
          (keyCodeMismatch || shiftMismatch || noShiftMismatch)) {
         if (noShiftMismatch) {
            // Should not have shift depressed for this key code, turn it off
            this.sendKey(WMKS.CONST.KB.KEY_CODE.Shift, true, false);
         }
         this.handleSoftKb(key.charCodeAt(0), true);
         if (noShiftMismatch) {
            // Turn shift back on after sending keycode.
            this.sendKey(WMKS.CONST.KB.KEY_CODE.Shift, false, false);
         }
      } else {
         if (!this._vncDecoder.allowVMWKeyEvent2UnicodeAndRaw) {
            keyCode = this.handleInternationalKeyboard(e,keyCode,this.pendingKey);
         }
         if (this.pendingKey !== null) {
            if (isRaw) {
               this.keyToRawMap[this.pendingKey] = keyCode;
            } else {
               this.keyToUnicodeMap[this.pendingKey] = keyCode;
            }
         }
         this.sendAndfixWrongKeys(e, keyCode, isRaw, this.pendingKey);
      }

      /*
       * Keycodes 50 and 55 are deadkeys when AltGr is pressed. Pressing them a
       * second time produces two keys (either ~ or `). Send an additional up
       * keystroke so that the second keypress has both a down and up event.
       * PR 969092
       */
      if (((this.pendingKey === 50 && keyCode === 126) ||
           (this.pendingKey === 55 && keyCode === 96)) &&
          !isRaw) {
         WMKS.LOGGER.debug("Sending extra up for Unicode " + keyCode
            + " so one isn't missed.");
         this.sendKey(keyCode, true, !isRaw);
      }

      this.pendingKey = null;
      return false;
   };

   /* Top left key on windows firefox, the key value is the same with altgr+4,5,
    * it will cause the key won's display. So remap it to the different key value.
    */
   this.fixDeFrChSpecialKeys = function(e,pendingKey,keyCode) {
      if ((this.keyboardLayoutId ==='de-CH' || this.keyboardLayoutId ==='fr-CH') &&
            WMKS.BROWSER.isWindows() && WMKS.BROWSER.isFirefox()) {
         if(e.charCode === 176 && pendingKey === 176 ){
            e.keyCode =  1176;
            e.charCode = 1176;
         } else if (e.charCode === 167 && pendingKey === 167 ) {
            e.keyCode =  1167;
            e.charCode = 1167;
         }
      }
      return e;
   };

   /*
    * In some languages the keys on Mac keyboard can't be found directly
    * on Windows keyboard. Some characters can't be displayed.
    * eg.: "§" on Mac Fr keyboard, need to be transformed to press "!" + shift .
    *      "@" on Mac Fr keyboard, need to be transformed to press "0" + altgr .
    *      "_" + shift on Mac Fr keyboard, need to be transformed to press "0" ,
    *      release a shift key.
    */
   this.sendAndfixWrongKeys = function (e, keyCode, isRaw, pendingKey) {
      var isSmallKeyboardKey = this.isSmallKeyboardKey(e, keyCode, pendingKey),
          isAddShiftKey  = this.isAddShiftKey(e, keyCode),
          isAddAltGr = this.isAddAltGr(e, keyCode),
          isDeleteShiftKey = this.isDeleteShiftKey(e, keyCode);

      if (!this._vncDecoder.allowVMWKeyEvent2UnicodeAndRaw &&
          (isSmallKeyboardKey || isAddShiftKey || isDeleteShiftKey || isAddAltGr) ){
         if (isSmallKeyboardKey || isAddShiftKey) {
            this.sendKey(16, false, false);
            this.sendKey(keyCode, false, !isRaw);
            this.sendKey(16, true, false);
         }
         if (isDeleteShiftKey) {
            this.sendKey(16, true, false);
            this.sendKey(keyCode, false, !isRaw);
            this.sendKey(16, false, false);
         }
         if (isAddAltGr) {
            this.sendKey(17, false, false);
            this.sendKey(18, false, false);
            this.sendKey(keyCode, false, !isRaw);
            this.sendKey(17, true, false);
            this.sendKey(18, true, false);
         }
      } else {
         this.sendKey(keyCode, false, !isRaw);
      }
   };

   /*
    * in some languages right number keyboard, some characters can't be handle.
    * when meet this situation, also send a shift key =/*
    */
   this.isSmallKeyboardKey = function (e, keyCode, pendingKey) {
      var isSmallKeyboardKey = false,
          table = WMKS.keyboardUtils._SmallKeyboardKey[this.keyboardLayoutId];
      if (e.shiftKey === false && e.altKey === false && e.ctrlKey === false &&
         this.isFitSmallKeyboardPendingKey(keyCode,pendingKey)) {
         if (!!table && table.indexOf(keyCode)!== -1) {
            isSmallKeyboardKey = true;
         }
      }

      return isSmallKeyboardKey;
   };

   /*
    * On Windows, for number keys, can't add a shift. It's not on small keyboard.
    * Need to detect the pending value.
    */
   this.isFitSmallKeyboardPendingKey = function(keyCode, pendingKey) {
      var isFitSmallKeyboardPendingKey = true,
          table = WMKS.keyboardUtils._smallKeyboardPendingKey[this.keyboardLayoutId];
      if (table && table[keyCode]  && WMKS.BROWSER.isWindows()) {
         if ( table[keyCode] === pendingKey || typeof table[keyCode] === 'object' &&
            table[keyCode].indexOf(pendingKey) !== -1 ) {
            isFitSmallKeyboardPendingKey = false;
         }
      }
      return isFitSmallKeyboardPendingKey;
   };

   this.isMacChromeVscancodeFr = function () {
      return WMKS.BROWSER.isMacOS() && !this._vncDecoder.allowVMWKeyEvent2UnicodeAndRaw
         && this.keyboardLayoutId == 'fr-FR';
   };

   /*
    * In some languages mac keyboard key are not in windows keyboard, some
    * characters can't be handle. Add a shift key.
    */
   this.isAddShiftKey = function (e,keyCode) {
      var code = e.keyCode || e.charCode;

      return code == 167 && this.isMacChromeVscancodeFr();
   };

   /*
    * In some languages mac keyboard key are not in windows keyboard,
    * some characters can't be handle.
    * if delete a shift key could solve this issue, send it.
    */
   this.isDeleteShiftKey = function (e,keyCode) {
      var code = e.keyCode || e.charCode;

      return (code == 95 || code == 42 || code == 35) && this.isMacChromeVscancodeFr() && e.shiftKey;
   };

   /*
    * In some languages mac keyboard key are not in windows keyboard,
    * some characters can't be handle.
    * if send another altgr key could solve this issue, send it.
    */
   this.isAddAltGr = function (e,keyCode) {
      var code = e.keyCode || e.charCode;

      return (code == 64 || code == 35) && this.isMacChromeVscancodeFr();
   };

   /*
    * On Windows IE browser, when press ^ and another key, it will
    * call keypress twice, one is ^ key , one
    * is the other key event. There will one more ^ key. PR 1580113
    */
   this.handleUnusefulKeys = function (e) {
      var isUnusefulKey  = false,
          table;
      // only fix IE 11 now.
      if (WMKS.BROWSER.isIE() && WMKS.BROWSER.version.major > 10) {
         table = WMKS.keyboardUtils._keypressUnusefulKeys[this.keyboardLayoutId];
         if (!!table && table.indexOf(e.keyCode)!== -1) {
            isUnusefulKey = true;
         }
      }
      return isUnusefulKey;
   };

   /*
    * Some keys with alt gr on Chrome, the key code is the same with
    * control keys. Remap them to the right keycode.
    */
   this.remapUncontrolKey = function (e, keyCode, isRaw) {
      var altgrOnChrome =  WMKS.BROWSER.isChrome() && e.altKey && e.ctrlKey,
         isRaw = true,
         newCode,
         remap = WMKS.keyboardUtils._remapUncontrolKeys[this.keyboardLayoutId];

      if (altgrOnChrome) {
         if (remap !== undefined) {
            newCode = remap[e.keyCode];
         }
         if (newCode !== undefined) {
            isRaw = false;
            keyCode = newCode;
         }
      }
      return {
         keyCode: keyCode,
         isRaw: isRaw
      };
   };

   this.handleInternationalKeyboard = function (e, keyCode, pendingKey) {
      var altgrOnChrome =  WMKS.BROWSER.isChrome() && e.altKey && e.ctrlKey,
          altgrOnFirefox = WMKS.BROWSER.isFirefox() && e.altKey && e.ctrlKey,
          specialKeyOnFirefox = (e.keyCode === 0 )&& WMKS.BROWSER.isFirefox() &&
            e.key && (e.charCode === 0),
          isWestEuroLanguage =  WMKS.CONST.KB.WestEuroLanguage.indexOf(this.keyboardLayoutId) !== -1;

      if (!isWestEuroLanguage && e.keyCode === 0 && WMKS.BROWSER.isFirefox() &&
         e.key && !keyCode) {
         /*
          * On Firefox, for some special key such as ü ö ä, the keyCode of
          * onKeyUp and keyDown is 0, but there is a value in key property.
          * See bug 1166133.
           */
         keyCode = 0;
      }
      switch (this.keyboardLayoutId) {
         case 'ja-JP_106/109':
            keyCode = this.getRemapPendingKey(keyCode, pendingKey);
            break;
         case 'de-DE':
            if ((keyCode == 123 || keyCode == 124 || keyCode == 125 ) &&
               (altgrOnChrome || WMKS.BROWSER.isFirefox) && WMKS.BROWSER.isWindows()) {
               /*
                * Keycodes are different on Mac and Windows in Chrome,
                * remap the altgr keys to the same one.
                */
               if (keyCode == 123) {
                  keyCode = 124;
               } else if(keyCode == 124 ) {
                  keyCode = 8804;
               } else if(keyCode == 125) {
                  keyCode = 8800;
               }
            }
            if (keyCode == 192 && WMKS.BROWSER.isFirefox() && WMKS.BROWSER.isMacOS()) {
               //keycodes are different on Chrome and Firefox on Mac
               keyCode = 187;
            }
            keyCode = this.getRemapPendingKey(keyCode, pendingKey);
            break;
         case 'it-IT':
            if ( e.keyCode === 37 && altgrOnChrome) {
               keyCode = e.keyCode + 1000;
            }
            // There's no data when press # key
            if ( specialKeyOnFirefox && e.key=='#' && WMKS.BROWSER.isWindows()) {
               keyCode = 35;
            }
            break;
         case "es-ES":
            // There's no data when press ´ key
            if ( e.keyCode === 0 && WMKS.BROWSER.isFirefox() && (e.key ==' ' ||
               e.key == 'Dead') && e.charCode ==0 && e.which == 0) {
               keyCode = 222;
            }
            if ( specialKeyOnFirefox && e.key=='\\' && WMKS.BROWSER.isWindows()) {
               keyCode = 186;
            }
            if ( (e.keyCode === 48 || e.keyCode === 34) && altgrOnChrome) {
               keyCode = e.keyCode + 1000;
            }
            keyCode = this.getRemapPendingKey(keyCode, pendingKey);
            break;
         case 'pt-PT':
            if ((keyCode == 123 || keyCode == 167 ) && (altgrOnChrome ||
               WMKS.BROWSER.isFirefox) && WMKS.BROWSER.isWindows()) {
               //keycodes are different on Mac and Windows in Chrome, remap the altgr keys to the same one.
               if (keyCode == 123) {
                  keyCode = 55; //7
               } else if(keyCode == 167 ) {
                  keyCode = 52; //4
               }
            }
            if (WMKS.BROWSER.isFirefox && WMKS.BROWSER.isWindows()) {
               //keycodes are different on Mac and Windows in Chrome, remap the altgr keys to the same one.
               if(e.key == '«'){
                  keyCode = 187;
               }
               if(e.key == 'À' ) {
                  keyCode = 333;
               }
            }
            if (e.keyCode == 192 &&  WMKS.BROWSER.isChrome && WMKS.BROWSER.isWindows()) {
               //keycodes are different on Mac and Windows in Chrome, remap the altgr keys to the same one.
               keyCode = 333;
            }
            break;
         case "fr-FR":
            // There's no data when press 6 key
            if ( e.keyCode === 29 && WMKS.BROWSER.isChrome() && e.key !="€" &&
               WMKS.BROWSER.isMacOS()) {
               keyCode = 124;
            }
            keyCode = this.getRemapPendingKey(keyCode, pendingKey);
            break;
         case "fr-CH":
         case "de-CH":
            if ( e.ctrlKey === true && e.altKey === true ) {
               var code = e.keyCode || e.which;
               if ( WMKS.BROWSER.isMacOS()) {
                  if (code === 61) {
                     //~
                     keyCode = 187;
                  }
                  if (e.keyCode === 34 && WMKS.BROWSER.isChrome()) {
                     //{ on chrome is map to @
                     keyCode = 224
                  }
               }
            }
            if ( (e.keyCode || e.which) === 96 && (WMKS.BROWSER.isChrome() ||
               WMKS.BROWSER.isFirefox() ) && WMKS.BROWSER.isWindows() &&
               e.key === '`') {
               keyCode = 94
            }
            if (specialKeyOnFirefox || (WMKS.BROWSER.isMacOS() && altgrOnFirefox)) {
               keyCode = this.getKeyCodeFromKey(e,keyCode) || keyCode;
            }
            if (WMKS.BROWSER.isWindows() && altgrOnFirefox) {
               keyCode = this.getRemapFrChAltgrKey(keyCode);
            }
            if (e.key === "§" && altgrOnFirefox && WMKS.BROWSER.isMacOS()) {
                keyCode = 232;  //should not show character when click altgr and è
            }
            if (e.key === "À" && (e.keyCode || e.which) === 192 &&
               this.keyboardLayoutId === 'de-CH' && pendingKey !== 65) {
               if ( WMKS.BROWSER.isMacOS() || (WMKS.BROWSER.isFirefox() &&
                  WMKS.BROWSER.isWindows()) ) {
                  keyCode = 1224;
               }
            }
            keyCode = this.getRemapPendingKey(keyCode, pendingKey);
            break;
      };
      if (isWestEuroLanguage && (specialKeyOnFirefox || altgrOnFirefox) &&
         this.keyboardLayoutId !== 'fr-CH' && this.keyboardLayoutId !== 'de-CH') {
         if (e.charCode === 176 && WMKS.BROWSER.isMacOS() && altgrOnFirefox) {
            keyCode = 0;
            //should not show character when click altgr and ù
         } else {
            keyCode = this.getKeyCodeFromKey(e,keyCode) || keyCode;
         }
      }
      /*
       * in some languages right number keyboard, some characters can't be handle.
       * when meet this situation, also send a shift key
       */
      return keyCode;
   };

   /*
    *  windows ff these six keys' charcode and key value are different,
    *  it will cause a bug.Remap them.
    */
   this.getRemapFrChAltgrKey = function(keyCode) {
      var table = WMKS.keyboardUtils._remapFrChAltgrKey;
      if (table && table[keyCode]) {
         keyCode = table[keyCode];
      }
      return keyCode;
   };

   /*
    * On Windows, press accent key + a or e, will create a 224 key press event,
    * this is the same with key à directly, so it will display `à,
    * When meet this situation, map 224 to a normal a 65.
    */
   this.getRemapPendingKey = function(keyCode, pendingKey) {
      var table = WMKS.keyboardUtils._remapPending[this.keyboardLayoutId];
      if (table && table[keyCode] && table[keyCode] === pendingKey &&
         WMKS.BROWSER.isWindows()) {
         keyCode = pendingKey;
      }
      return keyCode;
   };

   /*
    * On Firefox, for some special key such as ü ö ä, the keyCode of
    * onKeyUp and keyDown is 0, but there is a value in key property.
    */
   this.getKeyCodeFromKey = function(e,keyCode) {
      var table = WMKS.keyboardUtils._charToKeycode[this.keyboardLayoutId];
      if (table) {
         keyCode = table[e.key];
      }
      return keyCode;
   };

   /*
    *---------------------------------------------------------------------------
    *
    * onKeyUp
    *
    *    Called to handle the keyboard "key up" event and send the appropriate
    *    key stroke to the server.
    *
    *---------------------------------------------------------------------------
    */

   this.onKeyUp = function(e) {
      var keyCode, keyCodeRes, unicode, raw, isUnicode = false;

      if (e.preventDefault) {
         e.preventDefault();
      } else {
         e.returnValue = false;
      }

      this.keyDownIdentifier = null;

      keyCodeRes = this._extractKeyCodeFromEvent(e);
      if (!keyCodeRes) {
         WMKS.LOGGER.debug('Extraction of keyCode from keyUp event failed.');
         return false; // don't send a malformed command.
      }
      keyCode = keyCodeRes.keyCode;
      isUnicode = keyCodeRes.isUnicode;

      //WMKS.LOGGER.log("onKeyUp: keyCode=" + keyCode);

      /*
       * Sync modifiers for we don't always get correct event.
       */
      this._syncModifiers(e);

      if (keyCode === 0) {
         WMKS.LOGGER.log("onKeyUp: Do not send 0 to server.");
         return true;
      }

      if ($.inArray(keyCode, WMKS.CONST.KB.Modifiers) !== -1) {
         // Handled above via syncModifiers
         return false;
      }

      this._handleCapsLockKey(keyCode);

      /*
       * Only process keyup operations at once for certain keys.
       * Inhibit default because these will never result in a keypress event.
       */
      if (isUnicode) {
         WMKS.LOGGER.log('Sending unicode key up from keyIdentifier: ' + keyCode);
         this.sendKey(keyCode, true, true);
      } else if (this.keyToUnicodeMap.hasOwnProperty(keyCode)) {
         unicode = this.keyToUnicodeMap[keyCode];
         this.sendKey(unicode, true, true);
         // the user may change keymaps next time, don't persist this mapping
         delete this.keyToUnicodeMap[keyCode];
      } else if (this.keyToRawMap.hasOwnProperty(keyCode)) {
         raw = this.keyToRawMap[keyCode];
         this.sendKey(raw, true, false);
         delete this.keyToRawMap[keyCode];
      } else {
         this.sendKey(keyCode, true, false);
      }

      return false;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * onKeyUpSoftKb
    *
    *    Event handler for soft keyboards. We do not have much going on here.
    *
    *---------------------------------------------------------------------------
    */

   this.onKeyUpSoftKb = function(e) {
      // for all browsers on soft keyboard.
      e.stopPropagation();
      e.preventDefault();
      return false;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * onKeyDownSoftKb
    *
    *    Special IOS onkeydown handler which only pays attention to certain keys
    *    and sends them directly. Returns false to prevent the default action,
    *    true otherwise.
    *
    *---------------------------------------------------------------------------
    */
   this.onKeyDownSoftKb = function(e) {
      var keyCode = e.keyCode || e.which;

      if (keyCode && WMKS.CONST.KB.SoftKBRawKeyCodes.indexOf(keyCode) !== -1) {
         // Non-Unicode but apply modifiers.
         this.handleSoftKb(keyCode, false);
         return false;
      }

      /*
       * Return value is true due to the following:
       * 1. For single-use-caps / Caps-Lock to work, we need to return true
       *    for all keys.
       * 2. Certain unicode characters are visible with keypress event
       *    alone. (keyCode value is 0)
       */
      return true;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * onKeyPressSoftKb
    *
    *    Returns latin1 & Unicode keycodes.
    *    Works for all basic input that you can do with a soft keyboard.
    *
    *    NOTE: Chrome on Android behaves differently. Hence we rely on
    *    onInputTextSoftKb() to handle the input event.
    *
    *---------------------------------------------------------------------------
    */

   this.onKeyPressSoftKb = function(e) {
      var keyCode = e.keyCode || e.which;
      if (WMKS.BROWSER.isAndroid() && WMKS.BROWSER.isChrome()) {
         // Android on Chrome, special case, ignore it.
         return true;
      }
      // Reset the text field first.
      $(e.target).val(WMKS.CONST.KB.keyInputDefaultValue);

      // Send both keydown and key up events.
      this.handleSoftKb(keyCode, true);

      /* If we use preventDefault() or return false, the single-use-caps does
       * not toggle back to its original state. Hence rely on the fact that
       * text-2-speech contains more than 1 character input */
      return true;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * onInputTextSoftKb
    *
    *    Event handler for input event on the input-proxy. This intercepts
    *    microphone text input as well as keyPress events. We have to make sure
    *    only the microphone inputs are processed.
    *
    *    The following logic is used to differentiate.
    *    1. If input value is the same as defaultValue, no input, ignore it.
    *    2. If input value has only a single char, then its mostly preceded by
    *       onKeyPressSoftKb(), so ignore it.
    *    3. There is more than 1 character, must be from speech-2-text. Process
    *       this one further.
    *
    * NOTE: Android chrome does not emit useful keyCodes, hence we use the value
    *       that's entered into the textbox and decode it to send as a message.
    *       http://code.google.com/p/chromium/issues/detail?id=118639
    *
    *---------------------------------------------------------------------------
    */

   this.onInputTextSoftKb = function(e) {
      // We have received speech-to-text input or something.
      var input = $(e.target),
          val = input.val(),
          defaultInputSize = WMKS.CONST.KB.keyInputDefaultValue.length;

      /*
       * TODO: It causes speech-to-text doesn't work on iOS.
       * Ignore input event due to bug 1080567. Keypress triggers
       * both keypress event as well as input event. It sends
       * duplicate texts to the remote desktop.
       */
      if (WMKS.BROWSER.isIOS()) {
         // In any case, clean-up this data, so we do not repeat it.
         input.val(WMKS.CONST.KB.keyInputDefaultValue);
         return false;
      }

      // Remove the default value from the input string.
      if (defaultInputSize > 0) {
         val = val.substring(defaultInputSize);
      }
      // WMKS.LOGGER.debug('input val: ' + val);

      /*
       * 1. We have to verify if speech-to-text exists, we allow that.
       * 2. In case of Android, keyPress does not provide valid data, hence
       *    all input is handled here.
       * 3. For all other cases, do not process, its handled in onKeyPress.
       */
      if (val.length > 1) {
         /*
          * There are 2+ chars, hence speech-to-text or special symbols on
          * android keyboard, let it in as is. If its speech-to-text, first
          * char is generally uppercase, hence flip that.
          */
         val = val.charAt(0).toLowerCase() + val.slice(1);
         this.processInputString(val);
      } else if (WMKS.BROWSER.isAndroid() && WMKS.BROWSER.isChrome()) {
         // We could get uppercase and lower-case values, use them as is.
         this.processInputString(val);
      }

      // In any case, clean-up this data, so we do not repeat it.
      input.val(WMKS.CONST.KB.keyInputDefaultValue);
      return true;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * processInputString
    *
    *    This function accepts a string of input characters and processes them.
    *    It decodes each character to its keyCode, and then sends each one of
    *    that in the order it was passed.
    *
    *    Returns the last key that was decoded from the input value.
    *
    *---------------------------------------------------------------------------
    */

   this.processInputString = function(str, processNewline) {
      var i, key = false;
      for (i = 0; i < str.length; i++) {
         if (processNewline && str.charAt(i) === '\n') {
            // Found a newline, handle this differently by sending the enter key.
            this.sendKey(WMKS.CONST.KB.KEY_CODE.Enter, false, false);
            this.sendKey(WMKS.CONST.KB.KEY_CODE.Enter, true, false);
            continue;
         }
         key = str.charCodeAt(i);
         if (!isNaN(key)) {
            // Send each key in if its a valid keycode.
            this.handleSoftKb(key, true);
         }
      }
      // Return the last keyCode from this input. When a single character is
      // passed, the last is essentially the keycode for that input character.
      return key;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * handleSoftKb
    *
    *    Process keyCode inputs from Soft keyboards. In case of unicode input
    *    we need to to check if the key provided needs to send an additional
    *    shift as well. VScanCodes assume Shift is sent.
    *
    *    Ex: keyCode 65, 97 are both mapped to 0x1e and hence for soft
    *        keyboards, we need to compute the extra shift key.
    *
    *    activeModifiers are used differently by Soft Keyboard compared to the
    *    desktop browser keyboards. The state of the activeModifiers are not
    *    managed by sending the keystrokes, but are explicitly turned on / off
    *    from the touch inputs.
    *
    *    The needsShift is specifically used for sending VScanCodes. This one
    *    sends an extra Shift key. However, if the activeModifier is already
    *    has the shiftKey down, we need to flip it, to revert this. Hence the
    *    needShift and activeModifiers shift work hand in hand.
    *
    *---------------------------------------------------------------------------
    */

   this.handleSoftKb = function(key, isUnicode) {
      var implicitShift, shiftSentAlready;

      /*
       * In case of unicode, determine if the shift key is implicit.
       * Ex: keyCode 97(char 'A') = 65(char 'a') + Shift (implicit)
       * We need this for sending VScanCode, as VScanCodes do not handle unicode
       * and we have to wrap the input key with a shift.
       */
      implicitShift = (isUnicode && WMKS.CONST.KB.UnicodeWithShift[key]);

      if (implicitShift) {
         // Determine if shift was already sent via extendedKeypad.
         shiftSentAlready =
            ($.inArray(WMKS.CONST.KB.KEY_CODE.Shift, this.activeModifiers) !== -1);

         if (!shiftSentAlready && !this._isUnicodeInputSupported()) {
            // Send shift down before sending the keys.
            this.sendKey(WMKS.CONST.KB.KEY_CODE.Shift, false, false);
         }
         // Send the key-down and up.
         this.sendKey(key, false, isUnicode);
         this.sendKey(key, true, isUnicode);

         // Determine if we need to send a shift down / up.
         if (!shiftSentAlready && !this._isUnicodeInputSupported()) {
            this.sendKey(WMKS.CONST.KB.KEY_CODE.Shift, true, false);
         } else if (shiftSentAlready && this._isUnicodeInputSupported()) {
            // WMKS.LOGGER.debug('Send extra shift down to keep the modifier state');
            this.sendKey(WMKS.CONST.KB.KEY_CODE.Shift, false, false);
         }
      } else {
         // Send the key-down and up.
         this.sendKey(key, false, isUnicode);
         this.sendKey(key, true, isUnicode);
      }
   };


   /**
    *---------------------------------------------------------------------------
    *
    * isBrowserCapsLockOn
    *
    * Utility function used to detect if CAPs lock is on. Based on the
    * Javascript inputs we attempt to detect if the browser CapsLock is on.
    * We can only detect this on desktop browsers that sends shift key
    * separately. We can for sure say if its CapsLock enabled. But we cannot
    * say if the capsLock is not enabled, as non-unicode does not pass that
    * info.
    *
    *---------------------------------------------------------------------------
    */

   this.isBrowserCapsLockOn = function(keyCode, isUnicode, shiftKeyDown) {
      return !WMKS.BROWSER.isTouchDevice()
         && isUnicode
         && ((WMKS.CONST.KB.UnicodeOnly[keyCode] && shiftKeyDown)
         || (WMKS.CONST.KB.UnicodeWithShift[keyCode] && !shiftKeyDown));
   };


   /*
    *---------------------------------------------------------------------------
    *
    * sendKey
    *
    *    Single point of action for sending keystrokes to the protocol.
    *    Needs to know whether it's a down or up operation, and whether
    *    keyCode is a Unicode character index (keypress) or a raw one (keydown).
    *
    *    Depending on what type key message is sent, the appropriate lookups are
    *    made and sent.
    *
    *    This function is also the final frontier for limiting processing of
    *    key inputs.
    *
    *---------------------------------------------------------------------------
    */

   this.sendKey = function(key, isUp, isUnicode) {
      // Check if VMW key event can be used to send key inputs.
      if (!this._vncDecoder.useVMWKeyEvent) {
         return;
      }

      // Final frontier for banning keystrokes.
      if (!isUnicode && this.ignoredRawKeyCodes.indexOf(key) !== -1) {
         return;
      }

      // WMKS.LOGGER.log((isUnicode? '+U' : '') + key + (isUp? '-up' : '-d'));
      if (this._vncDecoder.allowVMWKeyEvent2UnicodeAndRaw) {
         // Blast uses the unicode mode where we send unicode / raw keyCode.
         this._vncDecoder.onVMWKeyUnicode(key, !isUp, !isUnicode);
      } else {
         // Send VMware VScanCodes.
         this._sendVScanCode(key, isUp, isUnicode);
      }
   };

   /**
    *---------------------------------------------------------------------------
    *
    * _sendVScanCode
    *
    *    This function handles the complexity of sending VScanCodes to the
    *    server. This function looks up 2 different tables to convert unicode
    *    to VScanCodes.
    *       1. Unicode to VScanCode
    *       2. Raw JS KeyCodes to VScanCodes.
    *
    *    TODO: Cleanup keyboardMapper and keyboardUtils once key repeats
    *          and CAPs lock are handled as expected.
    *
    *---------------------------------------------------------------------------
    */

   this._sendVScanCode = function(key, isUp, isUnicode) {
      var vScanCode = null;
      if (isUnicode || key === 13) {
         vScanCode = this.UnicodeToVScanMap[key];
      }
      if (!vScanCode) {
         var table = WMKS.keyboardUtils._jsToVScanTables[this.keyboardLayoutId];
         if (!!table) {
            vScanCode = table[key];
         }
         if (!vScanCode) {
            // Since vScanCode is not valid, reset the flag.
            vScanCode = WMKS.keyboardUtils._jsToVScanTable[key];
         }
         /**
          * Support Ctrl+C/V in WSX and vSphere NGC.
          * Both in WSX and vSphere NGC, send vScanCode to the server.
          * However, _jsToVScanTable lacks mapping for the characters
          * a-z, hence, when pressing Ctrl+C, c is not mapped and sent.
          * In this scenario, map c using the UnicodeToVScanMap and
          * send the code to the server.
          */
         if (!vScanCode) {
            // Mapping to VScanCode using the unicode mapping table.
            vScanCode = this.UnicodeToVScanMap[key];
         }
      }
      if (!!vScanCode) {
         // WMKS.LOGGER.debug('key: ' + key + ' onKeyVScan: ' + vScanCode
         //   + (isUp? '-up' : '-d'));
         // performMapping keyCode to VMware VScanCode and send it.
         this._vncDecoder.onKeyVScan(vScanCode, !isUp);
      } else {
         WMKS.LOGGER.debug('unknown key: ' + key + (isUp? '-up' : '-d'));
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * clearState
    *
    *    Single point of action for sending keystrokes to the protocol. Nice for
    *    debugging. Needs to know whether it's a down or up operation, and
    *    whether the keyCode is a unicode character index (keypress) or a
    *    raw one (keydown).
    *
    *---------------------------------------------------------------------------
    */

   this.clearState = function() {
      // Clear any keyboard specific state that's held.

      // Clear modifiers.
      this.activeModifiers.length = 0;

      // clear all modifier keys on start
      this.sendKey(WMKS.CONST.KB.KEY_CODE.Alt, true, false);
      this.sendKey(WMKS.CONST.KB.KEY_CODE.Ctrl, true, false);
      this.sendKey(WMKS.CONST.KB.KEY_CODE.Shift, true, false);
      // Send meta only if its Mac OS.
      if (WMKS.BROWSER.isMacOS()) {
         this.sendKey(WMKS.CONST.KB.KEY_CODE.Meta, true, false);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * enableWindowsKey
    *
    *    Enable/disable the simulation of Windows key.
    *    Press Ctrl+Win on Windows or Ctrl+CMD on Mac to simulate Windows key.
    *
    *---------------------------------------------------------------------------
    */

   this.enableWindowsKey = function(value) {
      this._windowsKeyManager.enabled = value;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * setIgnoredRawKeyCodes
    *
    *    Set ignore raw keyCodes set.
    *
    *---------------------------------------------------------------------------
    */

   this.setIgnoredRawKeyCodes = function(value) {
      this.ignoredRawKeyCodes = value;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _isUnicodeInputSupported
    *
    *    This is a wrapper function that determines if the unicode input is
    *    handled by the server.
    *
    *    NOTE: true for Blast, false for WSX, NGC, etc.
    *
    *---------------------------------------------------------------------------
    */

   this._isUnicodeInputSupported = function() {
      return this._vncDecoder.allowVMWKeyEvent2UnicodeAndRaw;
   };
};


/**
 * WMKS.CONST.KB.UnicodeOnly
 * WMKS.CONST.KB.UnicodeWithShift
 * WMKS.CONST.KB.UnicodeToVScanMap
 *
 * The following are 2 sets of mapping that contain a key-value pair of unicode
 * to VScanCode map. Its split the mapping into two maps to enable detection
 * of whether the unicode is just a VScanCode or a combo of VScanCode with the
 * shift key down. This distinction is necessary in case of soft keyboards.
 *
 * These 2 maps are then merged into 1 final map UnicodeToVScanMap, that will
 * be used in the lookup code to send vScanCodes.
 */
WMKS.CONST.KB.UnicodeOnly = {

   // Space, enter, backspace
   32 : 0x39,
   13 : 0x1c,
   //8 : 0x0e,

   // Keys a-z
   97  : 0x1e,
   98  : 0x30,
   99  : 0x2e,
   100 : 0x20,
   101 : 0x12,
   102 : 0x21,
   103 : 0x22,
   104 : 0x23,
   105 : 0x17,
   106 : 0x24,
   107 : 0x25,
   108 : 0x26,
   109 : 0x32,
   110 : 0x31,
   111 : 0x18,
   112 : 0x19,
   113 : 0x10,
   114 : 0x13,
   115 : 0x1f,
   116 : 0x14,
   117 : 0x16,
   118 : 0x2f,
   119 : 0x11,
   120 : 0x2d,
   121 : 0x15,
   122 : 0x2c,

   // keyboard number keys (across the top) 1,2,3... -> 0
   49 : 0x02,
   50 : 0x03,
   51 : 0x04,
   52 : 0x05,
   53 : 0x06,
   54 : 0x07,
   55 : 0x08,
   56 : 0x09,
   57 : 0x0a,
   48 : 0x0b,

   // Symbol keys ; = , - . / ` [ \ ] '
   59 : 0x27, // ;
   61 : 0x0d, // =
   44 : 0x33, // ,
   45 : 0x0c, // -
   46 : 0x34, // .
   47 : 0x35, // /
   96 : 0x29, // `
   91 : 0x1a, // [
   92 : 0x2b, // \
   93 : 0x1b, // ]
   39 : 0x28  // '

};

WMKS.CONST.KB.UnicodeWithShift = {
   // Keys A-Z
   65 : 0x001e,
   66 : 0x0030,
   67 : 0x002e,
   68 : 0x0020,
   69 : 0x0012,
   70 : 0x0021,
   71 : 0x0022,
   72 : 0x0023,
   73 : 0x0017,
   74 : 0x0024,
   75 : 0x0025,
   76 : 0x0026,
   77 : 0x0032,
   78 : 0x0031,
   79 : 0x0018,
   80 : 0x0019,
   81 : 0x0010,
   82 : 0x0013,
   83 : 0x001f,
   84 : 0x0014,
   85 : 0x0016,
   86 : 0x002f,
   87 : 0x0011,
   88 : 0x002d,
   89 : 0x0015,
   90 : 0x002c,

   // Represents number 1, 2, ... 0 with Shift.
   33 : 0x0002, // !
   64 : 0x0003, // @
   35 : 0x0004, // #
   36 : 0x0005, // $
   37 : 0x0006, // %
   94 : 0x0007, // ^
   38 : 0x0008, // &
   42 : 0x0009, // *
   40 : 0x000a, // (
   41 : 0x000b, // )

   // Symbol keys with shift ----->  ; = , - . / ` [ \ ] '
   58  : 0x0027, // :
   43  : 0x000d, // +
   60  : 0x0033, // <
   95  : 0x000c, // _
   62  : 0x0034, // >
   63  : 0x0035, // ?
   126 : 0x0029, // ~
   123 : 0x001a, // {
   124 : 0x002b, // |
   125 : 0x001b, // }
   34  : 0x0028  // "
};

WMKS.CONST.KB.VScanMap['en-US'] = $.extend({},
                                           WMKS.CONST.KB.UnicodeOnly,
                                           WMKS.CONST.KB.UnicodeWithShift);

/*
 * wmks/keyboardUtils.js
 *
 *   WebMKS keyboard event decoder and key remapper.
 *
 */

WMKS.keyboardUtils = {};



WMKS.keyboardUtils._keyInfoTemplate = {
   jsScanCode: 0,
   vScanCode: 0,
};



/*
 *------------------------------------------------------------------------------
 *
 * keyDownUpInfo
 *
 *    Parses a keydown/keyup event.
 *
 * Results:
 *    { jsScanCode,  The JavaScript-reposted scancode, if any. Arbitrary.
 *      vScanCode }  The VMX VScancode for the key on a US keyboard, if any.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.keyboardUtils.keyDownUpInfo = function(event) {
   var evt = event || window.event;
   var ki = this._keyInfoTemplate;

   if (evt.type === 'keydown' || evt.type === 'keyup') {
      /*
       * Convert JS scancode to VMware VScancode
       */
      ki.jsScanCode = evt.keyCode;
      ki.vScanCode = this._jsToVScanTable[ki.jsScanCode];

      /*
       * Workaround ie9/ie10 enter key behaviour.  We receive
       * keydown/keyup events but no keypress events for the enter
       * key.  On the other hand Firefox and Chrome give us
       * keydown/keyup *plus* keypress events for this key.  Short of
       * using a timer, don't see a way to catch both cases without
       * introducing a browser dependency here.
       */
      if (WMKS.BROWSER.isIE() && WMKS.BROWSER.version.major <= 10 && ki.jsScanCode == 13) {
         ki.vScanCode = 28;
      }
   }

   return ki;
};


/*
 *------------------------------------------------------------------------------
 *
 * keyPressInfo
 *
 *    Parses a keypress event.
 *
 * Results:
 *    The Unicode character generated during the event, or 0 if none.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.keyboardUtils.keyPressInfo = function(event) {
   var evt = event || window.event;
   var uChar = 0;

   if (evt.type === 'keypress') {
      uChar = evt.which;

      /*
       * Handle Backspace, Tab, ESC via keyDown instead.
       */
      if (uChar == 8 || uChar == 9 || uChar == 27) {
         uChar = 0;
      }
   }

   return uChar;
};





/*
 * JS scancode to VMware VScancode conversion table
 */
WMKS.keyboardUtils._jsToVScanTable = {
   // Space, enter, tab, escape, backspace
   //32 : 0x039,
   //13 : 0x01c,
   9 : 0x00f,
   27 : 0x001,
   8 : 0x00e,

   // shift, control, alt, Caps Lock, Num Lock
   16 : 0x02a,     // left shift
   17 : 0x01d,     // left control
   18 : 0x038,     // left alt
   20 : 0x03a,
   240 : 0x03a,    // windows 8.1 caps lock
   144 : 0x045,

   // Arrow keys (left, up, right, down)
   37 : 0x14b,
   38 : 0x148,
   39 : 0x14d,
   40 : 0x150,

   // Special keys (Insert, delete, home, end, page up, page down, F1 - F12)
   45 : 0x152,
   46 : 0x153,
   36 : 0x147,
   35 : 0x14f,
   33 : 0x149,
   34 : 0x151,
   112 : 0x03b,
   113 : 0x03c,
   114 : 0x03d,
   115 : 0x03e,
   116 : 0x03f,
   117 : 0x040,
   118 : 0x041,
   119 : 0x042,
   120 : 0x043,
   121 : 0x044,
   122 : 0x057,
   123 : 0x058,

   // Special Keys (Left Apple/Command, Right Apple/Command, Left Windows, Right Windows, Menu)
   224 : 0x038,
   // ? : 0x138,
   91 : 0x15b,
   92 : 0x15c,
   93 : 0, //?

   42 : 0x054,  // PrintScreen / SysRq
   19 : 0x100  // Pause / Break

   /*
    * Commented out since these are locking modifiers that easily get
    * out of sync between server and client and thus cause unexpected
    * behaviour.
    */
   //144 : 0x045,  // NumLock
   //20 : 0x03a,  // CapsLock
   //145 : 0x046,  // Scroll Lock

};
WMKS.keyboardUtils._jsToVScanTables = {
   'de-DE' : {
      //German dead keys
      220: 0x029, //^
      221: 0x00d,  //´
      192: 13,
      192: 41, // ^ mac chrome
      187: 13, // ´ mac chrome
      96: 13 // ´ windows firefox
   },
   'es-ES' : {
      //Spanish dead keys
      94: 26,  //^
      96: 26, //`
      180: 40, //´
      168: 40, //
      192: 26,
      219: 26,
      222: 40,
      186: 26,
      242: 26
   },
   'it-IT' : {
      5: 18, //€
      30: 26,
      29: 27,
      64: 39, //ò
      35: 40, //à  bug 1710907
      91: 26, //è bug
      93: 27, //+ bug
      171: 27,
      109: 39,
      186: 39,
      123: 26, //é bug
      125: 27, //*
      8364: 18, //E
   }
};
WMKS.keyboardUtils._charToKeycode = {
   'de-DE' : {
      'ü': 252,
      'Ü': 252,
      'ö': 246,
      'Ö': 246,
      'ä': 228,
      'Ä': 228
   },
   'es-ES' : {
      '[': 192,
      ']': 43,
      '{': 222,
      '}': 231,
      '0': 186,
      '"': 1034,
      'º': 186,
      'ª': 186,
      'ç': 231,
      'Ç': 231,
      'Ñ': 209,
      'ñ': 209,
      '¡': 261,
      '¿': 161
   },
   'it-IT' : {
      '[': 30,
      '{': 30,
      ']': 29,
      '}': 29,
      '@': 1109,
      '%': 1037,
      'à': 1224,
      '°': 1224,
      'è': 232,
      'é': 232,
      'ì': 94,
      '^': 94,
      'ò': 242,
      'ç': 242,
      'ù': 249,
      '§': 249
   },
   'pt-BR' : {
      'ç': 231,
      'Ç': 231
      // '§': 167,
      // 'º': 186,
      // 'ª': 186
   },
   'pt-PT' : {
      'ç': 231,
      'Ç': 231,
      'º': 186,
      'ª': 186,
      '°': 43,
      '«': 187,
      '»': 187,
      'À': 333
   },
   'fr-FR' : {
      '²': 178
   },
   'fr-CH' : {
      '§': 167,
      '°': 176,
      'è': 232,
      'ü': 252,
      'é': 233,
      'ö': 246,
      'à': 1224,
      'ä': 228,
      '[': 232,
      '{': 224,
      '"': 1224
   },
   'de-CH' : {
      '§': 167,
      '°': 176,
      'è': 232,
      'ü': 252,
      'é': 233,
      'ö': 246,
      'à': 1224,
      'ä': 228,
      '[': 232,
      '{': 224,
      '"': 1224,
      'Ä': 228,
      'Ö': 246,
      'Ü': 252,
      'À': 1224,
      'È': 232,
      'É': 233
   }
};
WMKS.keyboardUtils._remapUncontrolKeys = {
   'de-DE' : {
      17: 81,
      13: 77
   },
   'es-ES' : {
      27: 219
   },
   'it-IT' : {
      13: 186
   },
   'pt-PT' : {
      27: 168
   },
   'fr-FR' : {
      27: 93
   },
   'fr-CH' : {
      27: 232
   },
  'de-CH' : {
      27: 232
   }

};
WMKS.keyboardUtils._keypressUnusefulKeys = {
   'de-DE' : [180,94,96],
   'es-ES' : [180,96]
};

WMKS.keyboardUtils._SmallKeyboardKey = {
   'de-DE' : [47,42,61],
   'it-IT' : [47,42,61],
   'es-ES' : [47,42,61],
   'ja-JP_106/109': [42,43],
   'en-US': [42,43],
   'pt-BR': [42],
   'pt-PT': [42,47],
   'fr-FR': [43,46,47,48,49,50,51,52,53,54,55,56,57],
   'fr-CH': [42,43,47],
   'de-CH': [42,43,47]
};
WMKS.keyboardUtils._smallKeyboardPendingKey = {
   'de-DE' : {
      47: 55,
      61: 48
   },
   'fr-FR': {
      43: [187, 61], // windows chrome, win ff +
      46: [190, 59], // windows chrome .
      47: [191, 58], // windows chrome /
      48: 48,
      49: 49,
      50: 50,
      51: 51,
      52: 52,
      53: 53,
      54: 54,
      55: 55,
      56: 56,
      57: 57
   }
};

/*
 * it-IT :# @ [ ] { } €
 * fr-fr :# @ [ \ ] ^ ` { | } ~ ¤ €
 * fr-CH :    #   @   [   \   ]   {   |     }    ~    ¢    ¦   ¬     `    €
 */

WMKS.keyboardUtils._WindowsFirefoxAltGr = {
   'pt-PT': [64, 91, 93, 123, 125, 163, 167, 168, 178, 8364],
   'de-DE': [64, 91, 92, 93, 123, 124, 125, 126, 172, 178, 179, 181, 8364],
   'it-IT': [35, 64, 91, 93, 123, 125, 8364],
   'es-ES': [35, 64, 91, 92, 93, 123, 124, 125, 126, 172, 178, 179, 181, 8364],
   'fr-FR': [35, 64, 91, 92, 93, 94, 96, 123, 124, 125, 126, 164, 8364],
   'fr-CH': [35, 64, 91, 92, 93, 123, 124, 125, 126, 162, 166, 172, 167, 176, 219, 8364],
   'de-CH': [35, 64, 91, 92, 93, 123, 124, 125, 126, 162, 166, 172, 167, 176, 8364]
};

WMKS.keyboardUtils._remapPending = {
   'fr-CH' : {
      224: 65, // â
      232: 69, // è
      233: 69, // é
      228: 65, // ä
      246: 79, // ö
      252: 85, // ü
      192: 65, // À
      219: 85, // û
      241: 78, // N
      209: 78, // n
      176: 52, // °
      167: 53 // §
   },
   'fr-FR' : {
      224: 65, // à
      232: 69, // è
      236: 73, // ì
      242: 79, // ò
      249: 85, // ù
      241: 78 // ~n
   },
   'de-CH' : {
      //German dead keys
      224: 65, // â
      232: 69, // è
      233: 69, // é
      228: 65, // ä
      246: 79, // ö
      252: 85, // ü
      192: 65, // À
      241: 78, // N
      209: 78, // n
      176: 52, // °
      167: 53, // §
      196: 65, // Ä
      214: 79, // Ö
      220: 85, // Ü
      200: 69, // È
      192: 65, // À
      201: 69, // é
      219: 85  // û
   },
   'de-DE' : {
      193: 65, // Á
      201: 69, // É
      205: 73, // Í
      211: 79, // Ó
      218: 85, // Ú
      194: 65, // Â
      202: 69, // Ê
      206: 73, // Î
      212: 79, // Ô
      219: 85  // Û
   },
   'ja-JP_106/109' : {
      92: 226 // \ windows firefox \ and top right key value are the same
   },
   'es-ES' : {
      193: 65, // Á
      201: 69, // É
      205: 73, // Í
      211: 79, // Ó
      218: 85, // Ú
      192: 65, // À
      200: 69, // È
      204: 73, // Ì
      210: 79, // Ò
      217: 85, // Ù
      241: 78 // ~n
   }
};
WMKS.keyboardUtils._remapFrChAltgrKey = {
   91:180, //up accent
   93:94, //~
   59:91, // [
   94:93,  //]
   92:123, //{
   0:125 //}
};/*globals WMKS */

WMKS.keyboardMapper = function(options) {
   if (!options.vncDecoder) {
      return null;
   }

   this._vncDecoder = options.vncDecoder;

   this._keysDownVScan = [];
   this._keysDownUnicode = [];

   this.VSCAN_CAPS_LOCK_KEY = 58;
   this.VSCAN_CMD_KEY = 347;

   // The current repeating typematic key
   this._typematicKeyVScan = 0;
   this._typematicDelayTimer = null;

   return this;
};


WMKS.keyboardMapper.prototype.doKeyVScan = function(vscan, down) {
   if (!this._vncDecoder.useVMWKeyEvent) {
      return;
   }

   /*
    * Caps lock is an unusual key and generates a 'down' when the
    * caps lock light is going from off -> on, and then an 'up'
    * when the caps lock light is going from on -> off. The problem
    * is compounded by a lack of information between the guest & VMX
    * as to the state of caps lock light. So the best we can do right
    * now is to always send a 'down' for the Caps Lock key to try and
    * toggle the caps lock state in the guest.
    */
   if (vscan === this.VSCAN_CAPS_LOCK_KEY && (navigator.platform.indexOf('Mac') !== -1)) {
       this._vncDecoder.onKeyVScan(vscan, 1);
       this._vncDecoder.onKeyVScan(vscan, 0);
       return;
   }

   /*
    * Manage an array of VScancodes currently held down.
    */
   if (down) {
      if (this._keysDownVScan.indexOf(vscan) <= -1) {
         this._keysDownVScan.push(vscan);
      }
      this.beginTypematic(vscan);
   } else {
      this.cancelTypematic(vscan);
      /*
       * If the key is in the array of keys currently down, remove it.
       */
      var index = this._keysDownVScan.indexOf(vscan);
      if (index >= 0) {
         this._keysDownVScan.splice(index, 1);
      }
   }

   /*
    * Send the event.
    */
   this._vncDecoder.onKeyVScan(vscan, down);
};


WMKS.keyboardMapper.prototype.doKeyUnicode = function(uChar, down) {
   if (!this._vncDecoder.useVMWKeyEvent) {
      return;
   }

   /*
    * Manage an array of Unicode chars currently "held down".
    */
   if (down) {
      this._keysDownUnicode.push(uChar);
   } else {
      /*
       * If the key is in the array of keys currently down, remove it.
       */
      var index = this._keysDownUnicode.indexOf(uChar);
      if (index >= 0) {
         this._keysDownUnicode.splice(index, 1);
      }
   }


   var modvscan = this._tableUnicodeToVScan[uChar];

   /*
    * Press the final key itself.
    */
   if (modvscan) {
      if (down) {
         this.beginTypematic(modvscan & 0x1ff);
      } else {
         this.cancelTypematic(modvscan & 0x1ff);
      }
      this._vncDecoder.onKeyVScan(modvscan & 0x1ff, down);
   }
};


WMKS.keyboardMapper.prototype.doReleaseAll = function() {
   var i;

   for (i = 0; i < this._keysDownUnicode.length; i++) {
      this.doKeyUnicode(this._keysDownUnicode[i], 0);
   }
   if (this._keysDownUnicode.length > 0) {
      console.log("Warning: Could not release all Unicode keys.");
   }

   for (i = 0; i < this._keysDownVScan.length; i++) {
      this.cancelTypematic(this._keysDownVScan[i]);
      this._vncDecoder.onKeyVScan(this._keysDownVScan[i], 0);
   }
   this._keysDownVScan = [];
};


/*
 *------------------------------------------------------------------------------
 *
 * beginTypematic
 *
 *    Begin the typematic process for a new key going down. Cancel any pending
 *    timers, record the new key going down and start a delay timer.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.keyboardMapper.prototype.beginTypematic = function (vscan) {
   /*
    * Don't begin typematic if the cmd key is down, we don't get
    * a key up for the alpha key if it was down whilst the cmd key
    * was also down. So there's no cancel of typematic.
    */
   if (this._keysDownVScan.indexOf(this.VSCAN_CMD_KEY) >= 0) {
      return;
   }

   // Cancel any typematic delay timer that may have been previously started
   this.cancelTypematicDelay();
   // And cancel any typematic periodic timer that may have been started
   this.cancelTypematicPeriod();
   if (this._vncDecoder.typematicState === 1) {
      // Begin the delay timer, when this fires we'll
      // start auto-generating down events for this key.
      this.startTypematicDelay(vscan);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * cancelTypematic
 *
 *    Cancel the typematic process for a key going up. If the key going up is our
 *    current typematic key then cancel both delay and periodic timers (if they exist).
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.keyboardMapper.prototype.cancelTypematic = function (vscan) {
    if (this._typematicKeyVScan === vscan) {
       this.cancelTypematicDelay();
       this.cancelTypematicPeriod();
    }
};


/*
 *------------------------------------------------------------------------------
 *
 * cancelTypematicDelay
 *
 *    Cancel a typematic delay (before auto-repeat) .
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.keyboardMapper.prototype.cancelTypematicDelay = function() {
   if (this._typematicDelayTimer !== null) {
      clearTimeout(this._typematicDelayTimer);
   }
   this._typematicDelayTimer = null;
};


/*
 *------------------------------------------------------------------------------
 *
 * cancelTypematicPeriod
 *
 *    Cancel a typematic periodic timer (the auto-repeat timer) .
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.keyboardMapper.prototype.cancelTypematicPeriod = function() {
    if (this._typematicPeriodTimer !== null) {
        clearInterval(this._typematicPeriodTimer);
    }
    this._typematicPeriodTimer = null;
};


/*
 *------------------------------------------------------------------------------
 *
 * startTypematicDelay
 *
 *    Start the typematic delay timer, when this timer fires, the specified
 *    auto-repeat will begin and send the recorded typematic key vscan code.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.keyboardMapper.prototype.startTypematicDelay = function(vscan) {
   var self = this;
   this._typematicKeyVScan = vscan;
   this._typematicDelayTimer = setTimeout(function () {
     self._typematicPeriodTimer = setInterval(function() {
        self._vncDecoder.onKeyVScan(self._typematicKeyVScan, 1);
     }, self._vncDecoder.typematicPeriod / 1000);
   }, this._vncDecoder.typematicDelay / 1000);
};


/*
 * Unicode to VMware VScancode conversion tables
 */

//WMKS.keyboardMapper.prototype._modShift = 0x1000;
//WMKS.keyboardMapper.prototype._modCtrl  = 0x2000;
//WMKS.keyboardMapper.prototype._modAlt   = 0x4000;
//WMKS.keyboardMapper.prototype._modWin   = 0x8000;

WMKS.keyboardMapper.prototype._tableUnicodeToVScan = {
   // Space, enter, backspace
   32 : 0x39,
   13 : 0x1c,
   //8 : 0x0e,

   // Keys a-z
   97  : 0x1e,
   98  : 0x30,
   99  : 0x2e,
   100 : 0x20,
   101 : 0x12,
   102 : 0x21,
   103 : 0x22,
   104 : 0x23,
   105 : 0x17,
   106 : 0x24,
   107 : 0x25,
   108 : 0x26,
   109 : 0x32,
   110 : 0x31,
   111 : 0x18,
   112 : 0x19,
   113 : 0x10,
   114 : 0x13,
   115 : 0x1f,
   116 : 0x14,
   117 : 0x16,
   118 : 0x2f,
   119 : 0x11,
   120 : 0x2d,
   121 : 0x15,
   122 : 0x2c,

   // keyboard number keys (across the top) 1,2,3... -> 0
   49 : 0x02,
   50 : 0x03,
   51 : 0x04,
   52 : 0x05,
   53 : 0x06,
   54 : 0x07,
   55 : 0x08,
   56 : 0x09,
   57 : 0x0a,
   48 : 0x0b,

   // Symbol keys ; = , - . / ` [ \ ] '
   59 : 0x27, // ;
   61 : 0x0d, // =
   44 : 0x33, // ,
   45 : 0x0c, // -
   46 : 0x34, // .
   47 : 0x35, // /
   96 : 0x29, // `
   91 : 0x1a, // [
   92 : 0x2b, // \
   93 : 0x1b, // ]
   39 : 0x28,  // '


   // Keys A-Z
   65 : 0x001e,
   66 : 0x0030,
   67 : 0x002e,
   68 : 0x0020,
   69 : 0x0012,
   70 : 0x0021,
   71 : 0x0022,
   72 : 0x0023,
   73 : 0x0017,
   74 : 0x0024,
   75 : 0x0025,
   76 : 0x0026,
   77 : 0x0032,
   78 : 0x0031,
   79 : 0x0018,
   80 : 0x0019,
   81 : 0x0010,
   82 : 0x0013,
   83 : 0x001f,
   84 : 0x0014,
   85 : 0x0016,
   86 : 0x002f,
   87 : 0x0011,
   88 : 0x002d,
   89 : 0x0015,
   90 : 0x002c,

   33 : 0x0002, // !
   64 : 0x0003, // @
   35 : 0x0004, // #
   36 : 0x0005, // $
   37 : 0x0006, // %
   94 : 0x0007, // ^
   38 : 0x0008, // &
   42 : 0x0009, // *
   40 : 0x000a, // (
   41 : 0x000b, // )

   58  : 0x0027, // :
   43  : 0x000d, // +
   60  : 0x0033, // <
   95  : 0x000c, // _
   62  : 0x0034, // >
   63  : 0x0035, // ?
   126 : 0x0029, // ~
   123 : 0x001a, // {
   124 : 0x002b, // |
   125 : 0x001b, // }
   34  : 0x0028, // "
};
/* global $:false, WMKS:false */

/*
 *------------------------------------------------------------------------------
 * wmks/touchHandler.js
 *
 *    This class abstracts touch input management and decouples this
 *    functionality from the widgetProto.
 *
 *    All variables are defined as private variables. Functions that do not
 *    need to be exposed should be private too.
 *
 *------------------------------------------------------------------------------
 */

/*
 *------------------------------------------------------------------------------
 *
 * WMKS.CONST.TOUCH
 *
 *    Enums and constants for touchHandlers. These comprise of constants for
 *    various gestures and types of gestures, etc.
 *
 *------------------------------------------------------------------------------
 */

WMKS.CONST.TOUCH = {
   FEATURE: {                             // List of optional touch features.
      SoftKeyboard:     0,
      ExtendedKeypad:   1,
      Trackpad:         2
   },
   // Tolerances for touch control
   tapMoveCorrectionDistancePx: 10,
   additionalTouchIgnoreGapMs: 1200,
   touchMoveSampleMinCount:   2,
   minKeyboardToggleTime:     50,         // Minimum time between keyboard toggles.
   leftDragDelayMs:           300,
   OP: {                                  // Touch event/gesture types.
      none:                   'none',
      scroll:                 'scroll',
      drag:                   'drag',
      move:                   'move',
      tap_twice:              'double-click',
      tap_1finger:            'click',
      tap_3finger:            'tap-3f'
   },
   SCROLL: {
      minDeltaDistancePx:     20          // Min distance to scroll before sending a scroll message.
   },
   DOUBLE_TAP: {                          // Constants for tolerance between double taps.
      tapGapInTime:           250,        // Allowed ms delay b/w the 2 taps.
      tapGapBonusTime:        200,        // Allowed extra ms delay based on tapGapBonus4TimeRatio value wrt tap proximity.
      tapGapBonus4TimeRatio:  0.4,        // Allowed ratio of tap proximity b/w taps vs tapGapInTime to activate tapGapBonusTime.
      tapGapInDistance:       40          // Allowed px distance b/w the 2 taps.
   }
};


WMKS.TouchHandler = function(options) {
   'use strict';
   if (!options || !options.canvas ||
       !options.widgetProto || !options.keyboardManager) {
      WMKS.LOGGER.warn('Invalid params set for TouchHandler.');
      return null;
   }

   var _widget = options.widgetProto,
       _keyboardManager = options.keyboardManager,
       _KEYBOARD = {
         visible: false,             // Internal flag to identify keyboard state.
         lastToggleTime: 0           // Last keyboard toggle timestamp used to detect spurious requests.
       },
       _repositionElements = [],     // Elements needing reposition upon rotation.
       _canvas = options.canvas,     // Canvas where all the action happens.
       _onToggle = options.onToggle; // Toggle callback function.

   // Timers
   var _dragTimer = null,
       _TAP_STATE = {               // Touch state machine.
         currentTouchFingers: -1,   // Indicates number of touch fingers
         firstTouch: null,
         currentTouch: null,
         touchArray: [],
         tapStartTime: null,        // Used to detect double tap
         touchMoveCount: 0,
         skipScrollCount: 0,
         scrollCount: 0,
         zoomCount: 0,
         opType: WMKS.CONST.TOUCH.OP.none
       };

      // List of jQuery objects that are used frequently.
   var _ELEMENTS = {
         inputProxy        : null,
         cursorIcon        : null,
         clickFeedback     : null,
         dragFeedback      : null,
         pulseFeedback     : null,
         scrollFeedback    : null,
         keypad            : null,
         trackpad          : null
       };


   /*
    *---------------------------------------------------------------------------
    *
    * _verifyQuickTouches
    *
    *    We noticed that the touch events get fired extremely quickly when there
    *    is touchstart, touchstart, touchmove, and the browser itself does not
    *    detect the second touchstart before the touchmove, instead it shows 1
    *    touchstartand the first touchmove indicates 1 finger with a move of
    *    over 50px. We decode the touchmoved location to the second touchstart
    *    location.
    *
    *    Ex: Following log indicates this scenario:
    *    3:41:54.566Z [Debug] touchstart#: 1 (e.targetTouches.length)
    *    3:41:54.568Z [Debug] touchstart#: 1 (e.targetTouches.length)
    *    3:41:54.584Z [Debug] single tap drag dist: 147.8715658942, scale: 0.90927...
    *    3:41:54.586Z [Info ] touchmove count: 1 touch#: 1 (e.targetTouches.length)
    *    3:41:54.600Z [Debug] onGestureEnd: 0.9092.. <-- gestureEnd happens only
    *                         if there were 2 touchstarts in the first place.
    *
    *---------------------------------------------------------------------------
    */

   this._verifyQuickTouches = function(e, dist, touchMoveCount) {
      // Only make use of this state if the opType is not defined, there
      // is a change in scale, this is the first touchmove and the distance b/w
      // firsttouch and the touchmove's event location is really huge.
      if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.none
            && dist > 50 && touchMoveCount === 1) {
         WMKS.LOGGER.debug('Special case - touchmove#: ' + touchMoveCount
            + ', targetTouches#: ' + e.targetTouches.length
            + ', dist: ' + dist + ', scale: ' + e.scale);
         return true;
      }
      return false;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _initDragEventAndSendFeedback
    *
    *    This is the initialization event that happens when we detect a gesture
    *    as a drag. It does the following:
    *    1. Sends a mouse down where the touch initially happened.
    *    2. Shows drag ready feedback.
    *
    *---------------------------------------------------------------------------
    */

   this._initDragEventAndSendFeedback = function(firstTouch) {
      if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.drag) {
         // Send the left mousedown at the touch location & send drag feedback
         var pos = this._applyZoomCorrectionToTouchXY(firstTouch);
         _widget.sendMouseButtonMessage(pos, true, WMKS.CONST.CLICK.left);
         // Show drag icon above implying the drag is ready to use.
         this._showFeedback(_ELEMENTS.dragFeedback, firstTouch);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _initTwoFingerTouch
    *
    *    This is the initialization event that happens when we detect a gesture
    *    as a drag. It does the following:
    *    1. Sends a mouse down where the touch initially happened.
    *    2. Shows drag ready feedback.
    *
    *---------------------------------------------------------------------------
    */

   this._initTwoFingerTouch = function(firstTouch, secondTouch) {
      /* WMKS.LOGGER.debug('Touch1: ' + firstTouch.screenX + ','
         + firstTouch.screenY + ' touch 2: ' + secondTouch.screenX + ','
         + secondTouch.screenY + ' opType: ' + _TAP_STATE.opType); */
      if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.none) {
         _TAP_STATE.currentTouchFingers = 2;
         /*
          * Now, 2 finger tap just happened. This could be one of the following:
          *    1. Scroll - (To detect use angle b/w lines upon touchmove).
          *    2. Zoom/pinch - Handled by the default handler (detect as above).
          *    3. right-click (When its neither of the above).
          *
          * Store the original 2 finger location and the leftmost location.
          * NB: Use location of the leftmost finger to position right click.
          * TODO: lefty mode
          */
         _TAP_STATE.touchArray.push(firstTouch);
         _TAP_STATE.touchArray.push(secondTouch);
         _TAP_STATE.firstTouch = WMKS.UTIL.TOUCH.copyTouch(
            WMKS.UTIL.TOUCH.leftmostOf(firstTouch, secondTouch));
         _TAP_STATE.currentTouch = WMKS.UTIL.TOUCH.copyTouch(_TAP_STATE.firstTouch);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _sendScrollEventMessage
    *
    *    This function handles the computation of the vertical scroll distance.
    *    If the distance is more than the threshold, then sends the appropriate
    *    message to the server.
    *
    *---------------------------------------------------------------------------
    */

   this._sendScrollEventMessage = function(touch) {
      var dx = 0, dy = 0, deltaX, deltaY, wheelDeltas, firstPos;
      if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.scroll) {
         deltaX = touch.clientX - _TAP_STATE.currentTouch.clientX;
         deltaY = touch.clientY - _TAP_STATE.currentTouch.clientY;

         wheelDeltas = this._calculateMouseWheelDeltas(deltaX, deltaY);
         dx = wheelDeltas.wheelDeltaX;
         dy = wheelDeltas.wheelDeltaY;

         // Only send if at least one of the deltas has a value.
         if (dx !== 0 || dy !== 0) {
            firstPos = this._applyZoomCorrectionToTouchXY(_TAP_STATE.touchArray[0]);
            _widget.sendScrollMessage(firstPos, dx, dy);

            // Update clientX, clientY values as we only need them.
            if (dx !== 0) {
               _TAP_STATE.currentTouch.clientX = touch.clientX;
            }

            if (dy !== 0) {
               _TAP_STATE.currentTouch.clientY = touch.clientY;
            }
         }
      }
      // TODO: Improve scroll by using residual scroll data when delta < minDeltaDistancePx.
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _calculateMouseWheelDeltas
    *
    *    This function calculates the wheelDeltaX and wheelDeltaY values
    *    according to the scroll delta distance.
    *
    *---------------------------------------------------------------------------
    */

   this._calculateMouseWheelDeltas = function(deltaX, deltaY) {
      var dx = 0,
          dy = 0,
          absDeltaX = Math.abs(deltaX),
          absDeltaY = Math.abs(deltaY),
          scrollX = absDeltaX > WMKS.CONST.TOUCH.SCROLL.minDeltaDistancePx,
          scrollY = absDeltaY > WMKS.CONST.TOUCH.SCROLL.minDeltaDistancePx,
          angle;

      /*
       * We don't want to send movements for every pixel we move.
       * So instead, we pick a threshold, and only scroll that amount.
       * This won't be perfect for all applications.
       */
      if (scrollX && scrollY) {
         /*
          * If the scroll angle is smaller than 45 degree,
          * do horizontal scroll; otherwise, do vertical scroll.
          */
         if (absDeltaY < absDeltaX) {
            // Horizontal scroll only.
            scrollY = false;
         } else {
            // Vertical scroll only.
            scrollX = false;
         }
      }

      if (scrollX) {
         dx = deltaX > 0 ? 1 : -1;
      }

      if (scrollY) {
         dy = deltaY > 0 ? -1 : 1;
      }

      if (_widget.options.reverseScrollY) {
         dy = dy * -1;
      }

      return {wheelDeltaX : dx, wheelDeltaY : dy};
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _updatePreScrollState
    *
    *    This function verifies if there was a residual scroll event, and if so.
    *    sends that after computing the directing of the scroll.
    *
    *---------------------------------------------------------------------------
    */

   this._updatePreScrollState = function(touch) {
      var deltaY = touch.clientY - _TAP_STATE.currentTouch.clientY;
      _TAP_STATE.scrollCount++;
      if (deltaY < 0) {
         _TAP_STATE.skipScrollCount--;
      } else {
         _TAP_STATE.skipScrollCount++;
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _sendResidualScrollEventMessage
    *
    *    This function verifies if there was a residual scroll event, and if so.
    *    sends that after computing the directing of the scroll.
    *
    *---------------------------------------------------------------------------
    */

   this._sendResidualScrollEventMessage = function() {
      // Detech if there is a leftover scroll event to be sent.
      if (_TAP_STATE.skipScrollCount !== 0 && _TAP_STATE.currentTouch) {
         var pos, sendScroll;

         // Server pays attention only to the sign of the scroll direction.
         sendScroll = (_TAP_STATE.skipScrollCount < 0) ? -1 : 1;

         WMKS.LOGGER.debug('Sending a residual scroll message.');
         WMKS.LOGGER.debug('Cur touch: ' + _TAP_STATE.currentTouch.pageX
            + ' , ' + _TAP_STATE.currentTouch.pageY);

         _TAP_STATE.skipScrollCount = 0;
         pos = this._applyZoomCorrectionToTouchXY(_TAP_STATE.currentTouch);
         // TODO KEERTHI: Fix this for horizontal scrolling as well.
         // dx for horizontal, dy for vertical.
         _widget.sendScrollMessage(pos, sendScroll, 0);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _isDoubleTap
    *
    *    Function to check if the tap is part of a double tap. The logic to
    *    determine is:
    *    1. There is always another tap earlier to this one.
    *    2. The time and proximity b/w 2 taps happen within the threshold values
    *    set in the constants: C.DOUBLE_TAP
    *    3. Based on heuristics we found that some double taps took longer than
    *    the threshold value but more accurate. Hence extend the time b/w double
    *    taps if the proximity of these 2 taps are under the
    *    tapGapBonus4TimeRatio(0.4) of the acceptable limit (tapGapInDistance).
    *    4. Make sure the double tap is always different from the two finger
    *    tap and the thresholds are within acceptable limits.
    *---------------------------------------------------------------------------
    */

   this._isDoubleTap = function(event, now) {
      var dist, duration;
      // Check if this is the second tap and there is a time delay from the first.
      if (_TAP_STATE.currentTouch === null || _TAP_STATE.tapStartTime === null
         || _TAP_STATE.opType !== WMKS.CONST.TOUCH.OP.none) {
         return false;
      }
      // Compute time difference and click position distance b/w taps.
      dist = WMKS.UTIL.TOUCH.touchDistance(_TAP_STATE.currentTouch, event.targetTouches[0]);
      duration = (now - _TAP_STATE.tapStartTime);
      // WMKS.LOGGER.debug('is tap_two (ms): ' + duration + ' & offset (px): ' + dist);

      // Check if the second tap occurred within the same vicinity as the first.
      if (dist < WMKS.CONST.TOUCH.DOUBLE_TAP.tapGapInDistance) {
         // If duration b/w taps is within acceptable limit
         if (duration < WMKS.CONST.TOUCH.DOUBLE_TAP.tapGapInTime) {
            // WMKS.LOGGER.debug('double tap correction activated.');
            return true;
         }
         // If the taps were extremely accurate < 40% tap gap, add the extra bonus tap gap time
         if ((dist / WMKS.CONST.TOUCH.DOUBLE_TAP.tapGapInDistance) < WMKS.CONST.TOUCH.DOUBLE_TAP.tapGapBonus4TimeRatio
                 && duration < (WMKS.CONST.TOUCH.DOUBLE_TAP.tapGapInTime + WMKS.CONST.TOUCH.DOUBLE_TAP.tapGapBonusTime)) {
            // WMKS.LOGGER.trace('Duration eligible for bonus with tapGapBonus4TimeRatio: '
            //      + (dist / WMKS.CONST.TOUCH.DOUBLE_TAP.tapGapInDistance));
            // WMKS.LOGGER.debug('double tap bonus correction activated.');
            return true;
         }
      }
      return false;
   };

   /*
    *---------------------------------------------------------------------------
    *
    * _onTouchStart
    *
    *    Called when a touch operation begins.
    *    A state machine is initiated which knows the number of fingers used for
    *    this touch operation in the case where it uses one finger.
    *
    *    For every touchstart, we perform the following logic:
    *    1. If the touch fingers = 1:
    *       a) Check if this touchstart is part of a double-click. If so, set
    *       the state machine info accordingly.
    *       b) If not, then update the state machine accordingly.
    *       c) for both case above, initialize a drag timer function with a
    *           delay threshold and upon triggering, initialize and set
    *           operation as a drag.
    *    2. If touch fingers = 2:
    *       a) Detect if we had earlier detected a 1 finger touchstart. In this
    *          case if the second touch happens quite late (After a set
    *          threshold) then we just ignore it. If not, then transform into
    *          a 2 finger touchstart.
    *          NOTE: This clears out the old 1 finger touchstart state.
    *       b) Initialize the 2 finger touch start as this could be a zoom /
    *          scroll/ right-click.
    *    3. The 3 finger touch start is detected, and if no operation is
    *       previously detected, then flag that state and toggle the keyboard.
    *
    *---------------------------------------------------------------------------
    */

   this._onTouchStart = function(e) {
      var pos, timeGap, self = this, now = $.now();

      // WMKS.LOGGER.debug('Start#: ' + e.targetTouches.length);
      // Unless two fingers are involved (native scrolling) prevent default
      if (e.targetTouches.length === 1) {
         /*
          * If it involves one finger, it may be:
          * - left click (touchstart and touchend without changing position)
          * - left drag (touchstart, activation timeout, touchmove, touchend)
          * - right click with staggered fingers (touchstart, touchstart, touchend)
          * - pan and scan (default behavior)
          * Allow the default behavior, but record the touch just in case it
          * becomes a click or drag.
          *
          * Also, check for a double click. See isDoubleTap() for details.
          */

         if (this._isDoubleTap(e, now)) {
            _TAP_STATE.firstTouch =
               WMKS.UTIL.TOUCH.copyTouch(_TAP_STATE.currentTouch);
            _TAP_STATE.opType = WMKS.CONST.TOUCH.OP.tap_twice;
         } else {
            _TAP_STATE.firstTouch =
               WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[0]);
            _TAP_STATE.currentTouch =
               WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[0]);
         }

         _TAP_STATE.currentTouchFingers = 1;
         _TAP_STATE.tapStartTime = now;

         // ontouchmove destroys this timer. The finger must stay put.
         if (_dragTimer !== null) {
            clearTimeout(_dragTimer);
         }

         _dragTimer = setTimeout(function() {
            _dragTimer = null;

            // Update opType and init the drag event.
            _TAP_STATE.opType = WMKS.CONST.TOUCH.OP.drag;
            self._initDragEventAndSendFeedback(_TAP_STATE.firstTouch);
         }, WMKS.CONST.TOUCH.leftDragDelayMs);

         // Must return true, else pinch to zoom and pan and scan will not work
         return true;
      } else if (e.targetTouches.length === 2) {
         // If touchstart happen a while after one another, wrap up the original op.
         if (_TAP_STATE.currentTouchFingers === 1) {
            // Now the second tap happens after a while. Check if its valid
            timeGap = now - _TAP_STATE.tapStartTime;
            if (timeGap > WMKS.CONST.TOUCH.additionalTouchIgnoreGapMs) {
               if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.drag) {
                  // Drag was in progress and we see a new touch.
                  // Hence end this and start a new one.
                  pos = this._applyZoomCorrectionToTouchXY(e.targetTouches[0]);
                  _widget.sendMouseButtonMessage(pos, true, WMKS.CONST.CLICK.left);
                  this._resetTouchState();
               }
            }
         }

         // Setup for 2 finger gestures.
         this._initTwoFingerTouch(WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[0]),
            WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[1]));
         // Always allow default behavior, this allows the user to pinch to zoom
         return true;
      } else if (e.targetTouches.length === 3) {
         // Three fingers, toggle keyboard only if no gesture is detected.
         if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.none) {
            _TAP_STATE.opType = WMKS.CONST.TOUCH.OP.tap_3finger;
            this.toggleKeyboard();
            // Set touch fingers value, so touchend knows to clear state.
            _TAP_STATE.currentTouchFingers = 3;
         }
         return false;
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _onTouchMove
    *
    *    This function handler is invoked when touchmove is detected. Here we do
    *    the following:
    *    1. Keep a track of how many touchmove events happen.
    *    2. Clear out if any dragTimer as we see a touchmove.
    *    3. If we have already detected an opType, then we just apply the
    *       touchmove to that operation. Even if touch fingers changes midflight,
    *       ignore them, as the use has already started using the operation
    *       and hence should continue with that.
    *    4. If no operation is detected and the touch fingers changes midflight,
    *       then it could be the following:
    *       a) Downgrade (2 --> 1 finger): If there is no scale value(distance
    *          b/w touches didn't change), then its a right-click.
    *       b) Upgrade (1 --> 2 finger): This is technically the same as a
    *          2-finger touchstart at this point. NOTE: If there is a downgrade,
    *          there wont be an upgrade.( It never goes from 2 --> 1 and then
    *          1 --> 2 later).
    *       c) If neither of the above, then its something we don't handle, must
    *          be a zoom/pinch. Hence let the default behavior kick in.
    *    5. When the touch fingers is 1, then it could be one of the following:
    *       a) Wobbly fingers that we need to ignore move distance < threshold (10px).
    *       b) Quick fingers, that's described in the function that detects it.
    *          This can happen with a very specific set of data, and if so, detect
    *          this as an initialization to 2 finger touchstart event.
    *       c) If neither of the above, then panning is assumed, and leave this
    *          to the browser to handle.
    *    6. If the touch fingers = 2, then attempt to detect a scroll / zoom.
    *       This is done based on computing the angle b/w the lines created from
    *       the touch fingers starting point to their touchmoved destination.
    *       Based on the angle, we determine if its a scroll or not. Sample
    *       multiple times before making the decision.
    *
    *    During the computation, we use various touch state entities to manage
    *    the overall state and assists in detecting the opType.
    *
    *---------------------------------------------------------------------------
    */

   this._onTouchMove = function(e) {
      var dist, pos;

      // Reset the drag timer if there is one.
      if (_dragTimer !== null) {
         clearTimeout(_dragTimer);
         _dragTimer = null;
      }

      // Increment touchMove counter to keep track of move event count.
      _TAP_STATE.touchMoveCount++;

      /* if (_TAP_STATE.touchMoveCount < 10) {
         WMKS.LOGGER.debug('move#: ' + _TAP_STATE.touchMoveCount
            + ' touch#: ' + e.targetTouches.length);
      } */

      /*
       * 1. Current touchFingers can be -1, allow default browser behavior.
       * 2. If the opType is defined, allow those gestures to complete.
       * 3. Now see if we can determine any gestures.
       */
      if (_TAP_STATE.currentTouchFingers === -1) {
         return true;
      } else if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.scroll) {
         // Scroll is detected, stick to it irrespective of the change in touch
         // fingers, etc.
         // WMKS.LOGGER.trace('continue scroll.. fingers change midflight.');
         this._sendScrollEventMessage(e.targetTouches[0]);
         return false;
      } else if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.drag) {
         // Drag is now moved. Send mousemove.
         _TAP_STATE.currentTouch = WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[0]);
         this.moveCursor(e.targetTouches[0].pageX, e.targetTouches[0].pageY);
         pos = this._applyZoomCorrectionToTouchXY(e.targetTouches[0]);

         _widget.sendMouseMoveMessage(pos);
         // Inhibit the default so pan does not occur
         return false;
      } else if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.tap_3finger) {
         /*
          * keyboard is already toggled but we retain the state as is here
          * to avoid touch fingers changing midflight causing a state change
          * to something else.
          */
         return false;
      } else if (_TAP_STATE.currentTouchFingers !== e.targetTouches.length) {
         // WMKS.LOGGER.debug('# of fingers changed midflight ('
         //   + _TAP_STATE.currentTouchFingers + '->' + e.targetTouches.length
         //   + '), scale: ' + e.scale + ', type: ' + _TAP_STATE.opType);
         if (_TAP_STATE.currentTouchFingers === 2 && e.targetTouches.length === 1) {
            if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.none && e.scale === 1) {
               // Touch ended early, is not a pinch/zoom(scale = 1).
               // Flag as a right click & clear state.
               WMKS.LOGGER.debug('touch: 2 -> 1 & !scroll, hence right-click.');
               this._sendTwoTouchEvent(_TAP_STATE.firstTouch,
                                       _TAP_STATE.firstTouch,
                                       WMKS.CONST.CLICK.right, e);
               this._resetTouchState();
               return false;
            }
         } else if (_TAP_STATE.currentTouchFingers === 1 && e.targetTouches.length === 2) {
            // No touchstart before this, so handle it as a 2 finger init here.
            WMKS.LOGGER.debug('touch: 1 -> 2, init 2fingertap if no opType: ' + _TAP_STATE.opType);
            this._initTwoFingerTouch(WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[0]),
               WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[1]));
            // Since we do not know if this is a zoom/scroll/right-click, return true for now.
            return true;
         } else {
            WMKS.LOGGER.debug('touch: 2 -> 1: infer as PINCH/ZOOM.');
            this._resetTouchState();
            return true;
         }
      } else if (_TAP_STATE.currentTouchFingers === 1) {
         // e.targetTouches.length = 1 based on above condition check.
         dist = WMKS.UTIL.TOUCH.touchDistance(e.targetTouches[0], _TAP_STATE.currentTouch);
         // If we have quick fingers convert into 2 finger touch gesture.
         if(this._verifyQuickTouches(e, dist, _TAP_STATE.touchMoveCount)) {
            // Initialize setup for 2 finger gestures.
            this._initTwoFingerTouch(WMKS.UTIL.TOUCH.copyTouch(_TAP_STATE.firstTouch),
               WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[0]));

            // This occurred in touchmove, so not a right click, hence a scroll.
            _TAP_STATE.opType = WMKS.CONST.TOUCH.OP.scroll;
            return false;
         }
         else if (dist < WMKS.CONST.TOUCH.tapMoveCorrectionDistancePx){
            // If move is within a threshold, its may be a click by wobbly fingers.
            // Left click should not becomes a pan if within the threshold.
            return true;
         } else {
            /**
             * TODO: It would be nice to avoid the trackpad completely by
             * replacing trackpad functionality with a trackpad/relative mode.
             * This differs from the original/absolute touch mode by is relative
             * nature of the cursor location and the touch location. The
             * relative mode acts as a huge trackpad.
             */
           this._resetTouchState();
           return true;
         }
      } else if (_TAP_STATE.currentTouchFingers === 2) {
         // Determine type of operation if its not set, or the state is not cleaned up.
         if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.none) {
            if (_TAP_STATE.touchArray.length === 0 || _TAP_STATE.touchArray.length !== 2) {
               // If the the original touches were not captured, classify this as zoom/pinch.
               this._resetTouchState();
               return true;
            }

            // Initially scale = 1 is common, ignore event as this does not add any value.
            if (e.scale === 1 && _TAP_STATE.touchMoveCount < 5) {
               // No move detected so far, hence skip this touchmove, return true.
               return true;
            }

            /*
             * Compute the angle b/w the 2 lines. Each line is computed off of 2
             * touch points (_TAP_STATE.touchArray & e.TargetTouches). The angle
             * for each line (in radians) ranges from -Phi to +Phi (3.1416).
             * The difference in angle can tell us if the 2 finger swipes
             * are closer (scroll) to each other or farther away(zoom/pinch).
             */
            var angle = WMKS.UTIL.TOUCH.touchAngleBwLines(
                  _TAP_STATE.touchArray[0], e.targetTouches[0],
                  _TAP_STATE.touchArray[1], e.targetTouches[1]);
            angle = Math.abs(angle);
            // WMKS.LOGGER.debug(_TAP_STATE.touchMoveCount + ', scale:'
            //    + e.scale + ', angle: ' + angle);
            if (angle === 0) {
               // One of the touch fingers did not move, missing angle, do nothing.
               return true;
            } else if (angle < 1 || angle > 5.2) {
               // This is a scroll. Coz the smaller angle is under 1 radian.

               // Update scrollCount & scrollSkipCount before we finalize as a scroll.
               this._updatePreScrollState(e.targetTouches[0]);

               // If the minimum sampling count isn't met, sample again to be accurate.
               if (_TAP_STATE.scrollCount >= WMKS.CONST.TOUCH.touchMoveSampleMinCount) {
                  // Now we are sure this is a scroll with 2 data samples.
                  this._showFeedback(_ELEMENTS.scrollFeedback, _TAP_STATE.firstTouch,
                     { 'position': 'left', 'offsetLeft': -50, 'offsetTop': -25 });
                  _TAP_STATE.opType = WMKS.CONST.TOUCH.OP.scroll;
                  _TAP_STATE.currentTouch = WMKS.UTIL.TOUCH.copyTouch(e.targetTouches[0]);
                  // WMKS.LOGGER.debug('This is a scroll.');
                  return false;
               }
            } else {
               // The smaller angle b/w the 2 lines are > about 1 radian, hence a pinch/zoom.
               _TAP_STATE.zoomCount++;

               // If the minimum sampling count isn't met, sample again to be accurate.
               if (_TAP_STATE.zoomCount >= WMKS.CONST.TOUCH.touchMoveSampleMinCount) {
                  // Now we are sure this is a zoom/pinch.
                  // WMKS.LOGGER.debug('This is a zoom / pinch');
                  this._resetTouchState();
                  return true;
               }
            }
            return true;
         }
      }
      // For cases we don't deal with let default handle kick in.
      return true;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _onTouchEnd
    *
    *    Called when a touch operation ends. The following happens here:
    *    1. If the touch state does not exist we do nothing & allow the default
    *       handling to kick in.
    *    2. If an opType has been detected, we terminate its state and
    *       send appropriate termination signals if any.
    *    3. If no opType is detected, then it could be a a single finger
    *       left click or a 2 finger right click. In each case, send the
    *       appropriate signal and in case of left click, store the time when
    *       the click was initiated, so that double click could be detected.
    *
    *---------------------------------------------------------------------------
    */

   this._onTouchEnd = function(e) {
      var pos, touches;

      // Reset the drag timer if there is one.
      if (_dragTimer !== null) {
         clearTimeout(_dragTimer);
         _dragTimer = null;
      }
      if (_TAP_STATE.currentTouchFingers === -1) {
         return true;
      } else if (e.targetTouches.length === 0) {

         // Check if it is almost a scroll but user stopped scrolling after we detected.
         if (_TAP_STATE.skipScrollCount !== 0) {
            // WMKS.LOGGER.debug('Flag as scroll as there is a residual scroll data.');
            // Sometimes its already a scroll, won't hurt.
            _TAP_STATE.opType = WMKS.CONST.TOUCH.OP.scroll;
         }

         // Check against the known opTypes and at the last the unknown ones.
         switch(_TAP_STATE.opType) {
            case WMKS.CONST.TOUCH.OP.scroll:
               // WMKS.LOGGER.debug('scroll complete, send residual scroll & clear state.');
               this._sendResidualScrollEventMessage(e);
               this._resetTouchState();
               return false;
            case WMKS.CONST.TOUCH.OP.tap_twice:
               // WMKS.LOGGER.debug('Send tap twice with feedback: ' + _TAP_STATE.opType);
               this._sendTwoTouchEvent(_TAP_STATE.firstTouch, _TAP_STATE.currentTouch,
                                      WMKS.CONST.CLICK.left, e);
               this._resetTouchState();
               return false;
            case WMKS.CONST.TOUCH.OP.tap_3finger:
               // WMKS.LOGGER.debug('kb already handled, clear state.');
               this._resetTouchState();
               return false;
            case WMKS.CONST.TOUCH.OP.drag:
               // NOTE: Caret position is getting updated via the wts event.
               // for drag, send the mouse up at the end position
               touches = e.changedTouches;

               // There should only be one touch for dragging
               if (touches.length === 1) {
                  pos = this._applyZoomCorrectionToTouchXY(touches[0]);
                  _widget.sendMouseButtonMessage(pos, false, WMKS.CONST.CLICK.left);
               } else {
                  WMKS.LOGGER.warn('Unexpected touch# ' + touches.length
                     + ' changed in a drag operation!');
               }
               this._resetTouchState();
               return false;
            default:
               if (_TAP_STATE.currentTouchFingers === 1) {
                  // End a single tap - left click, send mousedown, mouseup together.
                  this._sendTwoTouchEvent(_TAP_STATE.firstTouch,
                                          _TAP_STATE.currentTouch,
                                          WMKS.CONST.CLICK.left, e);
                  this._resetTouchState(true);
                  return false;
               } else if (_TAP_STATE.currentTouchFingers === 2) {
                  // End a 2-finger tap, and if no opType is set this is a right-click.
                  // Send mousedown, mouseup together.
                  this._sendTwoTouchEvent(_TAP_STATE.firstTouch,
                                          _TAP_STATE.firstTouch,
                                          WMKS.CONST.CLICK.right, e);
                  this._resetTouchState();
                  return false;
               }
         }

         // Reset touch state as we are done with the gesture/tap, return false.
         this._resetTouchState();
         return false;
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _resetTouchState
    *
    *    Resets the touch state machine.
    *
    *---------------------------------------------------------------------------
    */

   this._resetTouchState = function(keepLastTouchState) {
      if (!keepLastTouchState) {
         _TAP_STATE.tapStartTime = null;
         _TAP_STATE.currentTouch = null;
      }
      _TAP_STATE.currentTouchFingers = -1;
      _TAP_STATE.opType = WMKS.CONST.TOUCH.OP.none;
      _TAP_STATE.firstTouch = null;
      _TAP_STATE.touchArray.length = 0;

      // Also reset the tap state clearing prev data.
      _TAP_STATE.touchMoveCount = 0;
      _TAP_STATE.skipScrollCount = 0;
      _TAP_STATE.scrollCount = 0;
      _TAP_STATE.zoomCount = 0;
   };


   /*
    *---------------------------------------------------------------------------
    * _sendTwoTouchEvent
    *
    *    This function sends the mousedown on first event and a mouseup on the
    *    second. This could be a brand new click or part of a two finger tap
    *---------------------------------------------------------------------------
    */

   this._sendTwoTouchEvent = function(firstTouch, secondTouch, button) {
      // Send modifier keys as well if any to support inputs like 'ctrl click'
      var pos = this._applyZoomCorrectionToTouchXY(firstTouch);
      _widget.sendMouseButtonMessage(pos, true, button);

      /*
      WMKS.LOGGER.warn('Zoom: ' +
         ' screenXY: ' + firstTouch.screenX + ',' + firstTouch.screenY +
         ' clientXY: ' + firstTouch.clientX + ',' + firstTouch.clientY +
         ' pageXY: '   + firstTouch.pageX   + ',' + firstTouch.pageY);
      */
      if (_TAP_STATE.opType === WMKS.CONST.TOUCH.OP.tap_twice) {
         _widget.sendMouseButtonMessage(pos, false, button);

         // Send the double click feedback with a throbbing effect (use showTwice).
         this._showFeedback(_ELEMENTS.clickFeedback, firstTouch, {showTwice: true});
      } else {
         pos = this._applyZoomCorrectionToTouchXY(secondTouch);
         _widget.sendMouseButtonMessage(pos, false, button);
         this._showFeedback(_ELEMENTS.clickFeedback, firstTouch);
      }
      return true;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * addToRepositionQueue
    *
    *    This function adds the element to the reposition queue and upon
    *    rotation, the private function _repositionFloatingElementsOnRotation()
    *    ensures these elements are positioned within the canvas region.
    *
    *---------------------------------------------------------------------------
    */

   this.addToRepositionQueue = function(element) {
      if (element) {
         _repositionElements.push(element);
      }
   };

   /*
    *---------------------------------------------------------------------------
    * widgetRepositionOnRotation
    *
    *    Widgets need to be repositioned on orientation change. This change is one
    *    of two forms and needs correction only when they are shown.
    *    1. Landscape -> portrait: Widget may be to the right of the visible area.
    *    2. Portrait -> Landscape: Widget may be to the bottom of the visible area.
    *
    *    The logic used to reposition the widget, is if the widget is beyond the
    *    visible area, ensure that the widget is pulled back within the screen.
    *    The widget is pulled back enough so the right/bottom is at least 5px away.
    *
    *    TODO:
    *    1. Yet to handle when keyboard is popped out (use window.pageYOffset)
    *    2. Also watch out for a case when the screen is zoomed in. This is tricky
    *       as the zoom out kicks in during landscape to portrait mode.
    *    3. window.pageXOffset is not reliable due coz upon rotation the white patch
    *       on the right appears and causes some additional window.pageXOffset
    *       value. Best bet is to store this value before rotation and apply after
    *       orientation change kicks in.
    *
    *    Returns true if the widget was repositioned, false if nothing changed.
    *---------------------------------------------------------------------------
    */

   this.widgetRepositionOnRotation = function(widget) {
      var w, h, size, screenW, screenH, hasPositionChanged = false;

      if (!WMKS.BROWSER.isTouchDevice()) {
         WMKS.LOGGER.warn('Widget reposition ignored, this is not a touch device.');
         return false;
      }

      if (!widget || widget.is(':hidden')) {
         return false;
      }

      w = widget.width();
      h = widget.height();
      // Get the current screen size.
      screenW = window.innerWidth;
      screenH = window.innerHeight;

      if (WMKS.UTIL.TOUCH.isPortraitOrientation()) {
         if ((widget.offset().left + w) > screenW) {
            widget.offset({ left: String(screenW - w - 5) });
            hasPositionChanged = true;
         }
      } else {
         if ((widget.offset().top + h) > screenH) {
            widget.offset({ top: String(screenH - h - 5) });
            hasPositionChanged = true;
         }
      }

      return hasPositionChanged;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _repositionFloatingElementsOnRotation
    *
    *    Called after the default orientation changes are applied. These are
    *    specific for the feedback icons, input textbox, the cursor icon and
    *    any element that was requested by addToRepositionQueue().
    *
    *    Cursor icon is visible and so is the input textbox and they need to be
    *    moved inside the canvas to avoid the viewport from growing larger than
    *    the canvas size.
    *
    *    TODO: If cursor position changed due to orientation changes, send the
    *    new location. This is only a few pixels away, so not worrying about it
    *    for now.
    *
    *---------------------------------------------------------------------------
    */

   this._repositionFloatingElementsOnRotation = function(e) {
      var self = this,
          canvasOffset = _canvas.offset();
      // Move them inside the canvas region if they are outside.
      this.widgetRepositionOnRotation(_ELEMENTS.inputProxy);
      this.widgetRepositionOnRotation(_ELEMENTS.cursorIcon);

      // Position these hidden elements within the canvas.
      // NOTE: Problem is on iOS-6.1.2, but not on iOS-6.0.2, see bug: 996595#15
      // WMKS.LOGGER.trace(JSON.stringify(canvasOffset));
      _ELEMENTS.clickFeedback.offset(canvasOffset);
      _ELEMENTS.dragFeedback.offset(canvasOffset);
      _ELEMENTS.pulseFeedback.offset(canvasOffset);
      _ELEMENTS.scrollFeedback.offset(canvasOffset);

      // Now handle the list of elements added via addToRepositionQueue()
      $.each(_repositionElements, function(i, element) {
         // Just to be safe, we try this out here.
         try {
            // WMKS.LOGGER.info('reposition req: ' + element.attr('id')
            //    + element.attr('class'));
            self.widgetRepositionOnRotation(element);
         } catch (err) {
            WMKS.LOGGER.warn('Custom element reposition failed: ' + err);
         }
      });
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _onOrientationChange
    *
    *    Called when the device's orientation changes.
    *
    *
    *---------------------------------------------------------------------------
    */

   this._onOrientationChange = function(e) {
      var self = this;

      if (this._isInputInFocus()) {
         // Listen to resize event.
         $(window).one('resize', function(e) {
            /*
             * Trigger orientationchange event to adjust the screen size.
             * When the keyboard is opened, resize happens after orientationchange.
             */
            setTimeout(function() {
               $(window).trigger('orientationchange');
               // Reposition widgets and icons.
               self._repositionFloatingElementsOnRotation();
            }, 500);
         });
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _applyZoomCorrectionToTouchXY
    *
    *    Compute the position of a touch event relative to the canvas and apply
    *    the zoom value correction to get the right location on the canvas.
    *
    *    TODO: Apply native zoom correction for touch location.
    *
    *---------------------------------------------------------------------------
    */

   this._applyZoomCorrectionToTouchXY = function(touch) {
      if (touch === null) {
         WMKS.LOGGER.warn('Unexpected: touch is null.');
         return null;
      }
      // Compute the x,y based on scroll / browser zoom values as well.
      return _widget.getEventPosition(touch);
   };

   /*
    *---------------------------------------------------------------------------
    *
    * _showFeedback
    *
    *    This function displays the feedback object passed to it for a brief
    *    moment. The feedback indicator is not positioned directly over the
    *    click location, but centered around it. The feedback jQuery object
    *    is cached to avoid repeated lookups.
    *
    *    The animation mimics the View Client: show indicator at the location
    *    and hide after some time. jQuery animations suffered from 2 animation
    *    queue overload and gets corrupted easily. Hence we rely on CSS3
    *    animations which are also crisp as its executed in the browser space.
    *
    *    No matter what you do, the caret container is also made visible and is
    *    moved to the location of the click, where it stays.
    *
    *    feedback  - the jQuery object to animate
    *    touch     - touch object from which to derive coords
    *    inputArgs - input args that change position, offsetLeft, offsetTop.
    *---------------------------------------------------------------------------
    */

   this._showFeedback = function(feedback,touch, inputArgs) {
      var multiplier, padLeft, padTop, args = inputArgs || {};
      if (!touch || !feedback) {
         WMKS.LOGGER.trace('No touch value / feedback object, skip feedback.');
         return;
      }
      // Calculate if there is any input padding offsets to be applied.
      padLeft = args.offsetLeft || 0;
      padTop = args.offsetTop || 0;
      // Get multiplier width & height to position feedback element accordingly.
      multiplier = WMKS.UTIL.TOUCH.getRelativePositionMultiplier(args.position);
      feedback.css({
         'left': touch.pageX + padLeft + feedback.outerWidth() * multiplier.width,
         'top': touch.pageY + padTop + feedback.outerHeight() * multiplier.height
      });

      //  Just move the icon to the right place.
      this.moveCursor(touch.pageX, touch.pageY);
      /*
       * Since the same feedback indicator is used for both double tap and single tap,
       * we have to remove all animation classes there were applied.
       * This may change once we have unique elements for each of the feedback indicators.
       */
      feedback.removeClass('animate-feedback-indicator animate-double-feedback-indicator');
      if (args.showTwice) {
         setTimeout(function() {
            feedback.addClass('animate-double-feedback-indicator');
         }, 0);
      } else {
         setTimeout(function() {
            feedback.addClass('animate-feedback-indicator');
         }, 0);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * moveCursor
    *
    *    Repositions the fake caret to match the given touch's location. Since
    *    the 'tip' of the caret represents the click location, no centering is
    *    desired.
    *
    *---------------------------------------------------------------------------
    */

   this.moveCursor = function(pageX, pageY) {
      if (_ELEMENTS.cursorIcon) {
         _ELEMENTS.cursorIcon.css({'left': pageX, 'top': pageY});
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * setCursorVisibility
    *
    *    Hide or show the fake caret.
    *
    *---------------------------------------------------------------------------
    */

   this.setCursorVisibility = function(visible) {
      if (_ELEMENTS.cursorIcon) {
         if (visible) {
            _ELEMENTS.cursorIcon.show();
         } else {
            _ELEMENTS.cursorIcon.hide();
         }
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _sendKeyInput
    *
    *    Sends a key plus the manual modifiers entered on the extended keyboard.
    *    Simulates the keydowns and keyups which would happen if this were entered
    *    on a physical keyboard.
    *
    *---------------------------------------------------------------------------
    */

   this._sendKeyInput = function(key) {
      _widget.sendKeyInput(key);
   };

   /*
    *---------------------------------------------------------------------------
    *
    * onCaretPositionChanged
    *
    *    Handler for when the caret position changes.
    *
    *    We use this to dynamically position our invisible input proxy
    *    such that focus events for it don't cause us to move away from
    *    the screen offset from where we are typing.
    *
    *---------------------------------------------------------------------------
    */

   this.onCaretPositionChanged = function(pos) {
      var offsetX, offsetY;

      if (_ELEMENTS.inputProxy) {
         offsetX = pos.x;
         offsetY = pos.y;

         // Ensure the position is bound in the visible area.
         if (offsetX < window.pageXOffset) {
            offsetX = window.pageXOffset;
         }
         if (offsetY < window.pageYOffset) {
            offsetY = window.pageYOffset;
         }

         _ELEMENTS.inputProxy.offset({left: offsetX, top: offsetY});
         // WMKS.LOGGER.warn('left: ' + _ELEMENTS.inputProxy.offset().left
         //   + ', top: ' + _ELEMENTS.inputProxy.offset().left);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _keyboardDisplay
    *
    *    The event triggered when user wants to explicitly show or hide the
    *    keyboard.
    *    show - true shows keyboard, false flips it.
    *
    *---------------------------------------------------------------------------
    */

   this._keyboardDisplay = function(show) {
      // WMKS.LOGGER.debug('kb show: ' + (show? 'true' : 'false'));

      if (show) {
         _canvas.focus();
         _ELEMENTS.inputProxy.focus().select();
      } else {
         if (WMKS.BROWSER.isAndroid()) {
            // If its set to readonly & disabled keyboard focus goes away.
            _ELEMENTS.inputProxy.attr('readonly', true)
                                .attr('disabled', true);
            // Reset the readonly and disabled property values after some time.
            setTimeout(function() {
               //If destory function is run before this, there will an error.
               if (_ELEMENTS) {
                  _ELEMENTS.inputProxy.attr('readonly', false)
                                      .attr('disabled', false);
                  _canvas.focus();
               }
            }, 100);
         }
         /*
          * The only method that seems to work on iOS to close the keyboard.
          *
          * http://uihacker.blogspot.com/2011/10/javascript-hide-ios-soft-keyboard.html
          */
         document.activeElement.blur();
         _KEYBOARD.visible = false;
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _isInputInFocus
    *
    *    Returns the state if the input-proxy is in focus. When it does, the
    *    keyboard should be showing as well.
    *
    *    TODO: Verify if this function is needed?
    *
    *---------------------------------------------------------------------------
    */

   this._isInputInFocus = function() {
      return (document.activeElement.id === 'input-proxy');
   };

   /*
    *---------------------------------------------------------------------------
    *
    * _onInputFocus
    *
    *    Event handler for focus event on the input-proxy. Sync the keyboard
    *    highlight state here.
    *
    *---------------------------------------------------------------------------
    */

   this._onInputFocus = function(e) {
      this._sendUpdatedKeyboardState(true);
      // Hide this while we're typing otherwise we'll see a blinking caret.
      e.stopPropagation();
      return true;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _onInputBlur
    *
    *    Event handler for blur event on the input-proxy. Sync the keyboard
    *    highlight state here. Also save the timestamp for the blur event.
    *
    *---------------------------------------------------------------------------
    */

   this._onInputBlur = function(e) {
      this._sendUpdatedKeyboardState(false);
      e.stopPropagation();
      return true;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * _sendUpdatedKeyboardState
    *
    *    Helper function to set the keyboard launcher button highlight state
    *    based on the keyboard visibility.
    *
    *---------------------------------------------------------------------------
    */

   this._sendUpdatedKeyboardState = function(kbState) {
      _KEYBOARD.visible = kbState;
      _KEYBOARD.lastToggleTime = $.now();
      // Trigger keyboard toggle callback function.
      if ($.isFunction(_onToggle)) {
         _onToggle.call(this, ['KEYBOARD', _KEYBOARD.visible]);
      }
   };


   /****************************************************************************
    * Public Functions
    ***************************************************************************/


   /*
    *---------------------------------------------------------------------------
    *
    * toggleKeyboard
    *
    *    Called when the user wants to toggle on-screen keyboard visibility.
    *    show - flag to explicitly request keyboard show or hide.
    *    (When not toggling)
    *
    *---------------------------------------------------------------------------
    */

   this.toggleKeyboard = function(options) {
      if (!WMKS.BROWSER.isTouchDevice()) {
         WMKS.LOGGER.warn('Mobile keyboard not supported, this is not a touch device.');
         return;
      }

      if (!_ELEMENTS.inputProxy) {
         // Mobile keyboard toggler is not initialized. Ignore this request.
         return;
      }
      if (!!options && options.show === _KEYBOARD.visible) {
         // WMKS.LOGGER.debug('Keyboard is in the desired state.');
         return;
      }

      // Check in case the keyboard toggler request is not handled properly.
      if ($.now() - _KEYBOARD.lastToggleTime < WMKS.CONST.TOUCH.minKeyboardToggleTime) {
         /*
          * Seems like a spurious keyboard event as its occurring soon after the
          * previous toggle request. This can happen when the keyboard launcher
          * event handler is not implemented properly.
          *
          * Expected: The callback handler should prevent the default handler
          *           and return false.
          */
         WMKS.LOGGER.warn('Ignore kb toggle - Got request soon after focus/blur.');
         return;
      }

      // Show / hide keyboard based on new kBVisible value.
      this._keyboardDisplay(!_KEYBOARD.visible);
   };


   /*
    *---------------------------------------------------------------------------
    *
    * toggleTrackpad
    *
    *    Called when the user wants to toggle trackpad visibility.
    *
    *---------------------------------------------------------------------------
    */

   this.toggleTrackpad = function(options) {
      if (!WMKS.BROWSER.isTouchDevice()) {
         WMKS.LOGGER.warn('Trackpad not supported. Not a touch device.');
         return;
      }

      if (_ELEMENTS.trackpad) {
         // Set toggle callback function.
         options = $.extend({}, options, {
            toggleCallback: _onToggle
         });
         // Show / hide trackpad.
         _ELEMENTS.trackpad.toggle(options);
      }
   };



   /*
    *---------------------------------------------------------------------------
    *
    * toggleExtendedKeypad
    *
    *    Called when the user wants to toggle ExtendedKeypad visibility.
    *
    *---------------------------------------------------------------------------
    */

   this.toggleExtendedKeypad = function(options) {
      if (!WMKS.BROWSER.isTouchDevice()) {
         WMKS.LOGGER.warn('Extended keypad not supported. Not a touch device.');
         return;
      }

      if (_ELEMENTS.keypad) {
         // Set toggle callback function.
         options = $.extend({}, options, {
            toggleCallback: _onToggle
         });
         // Show / hide keypad.
         _ELEMENTS.keypad.toggle(options);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * installTouchHandlers
    *
    *    Install event handlers for touch devices.
    *
    *---------------------------------------------------------------------------
    */

   this.installTouchHandlers = function() {
      var self = this,
          container = _canvas.parent();

      if (!WMKS.BROWSER.isTouchDevice()) {
         WMKS.LOGGER.log('Not a touch device, and hence skip touch handler');
         return;
      }

      // Set css values to disable unwanted default browser behavior.
      _canvas.css({
         '-webkit-user-select':     'none',  /* disable cut-copy-paste */
         '-webkit-touch-callout':   'none'   /* disable callout, image save panel */
      });

      _canvas
         .bind('touchmove.wmks', function(e) {
            return self._onTouchMove(e.originalEvent);
         })
         .bind('touchstart.wmks', function(e) {
            return self._onTouchStart(e.originalEvent);
         })
         .bind('touchend.wmks', function(e) {
            return self._onTouchEnd(e.originalEvent);
         })
         .bind('orientationchange.wmks', function(event) {
            return self._onOrientationChange(event);
         })
         .bind('orientationchange.wmks.elements', function(e) {
            // Handler for repositioning cursor, feedback icons, input textbox
            // and elements added externally.
            self._repositionFloatingElementsOnRotation(e);
         });

      // Create touch feedbacks.
      _ELEMENTS.cursorIcon = $('<div/>')
         .addClass('feedback-container cursor-icon')
         .appendTo(container);
      _ELEMENTS.clickFeedback = $('<div/>')
         .addClass('feedback-container tap-icon')
         .appendTo(container);
      _ELEMENTS.dragFeedback = $('<div/>')
         .addClass('feedback-container drag-icon')
         .appendTo(container);
      _ELEMENTS.pulseFeedback = $('<div/>')
         .addClass('feedback-container pulse-icon')
         .appendTo(container);
      _ELEMENTS.scrollFeedback = $('<div/>')
         .addClass('feedback-container scroll-icon')
         .appendTo(container);

      /*
       * Double tapping or tapping on the feedback icons will inevitably involve
       * the user tapping the feedback container while it's showing. In such
       * cases capture and process touch events from these as well.
       */
      container
         .find('.feedback-container')
            .bind('touchmove.wmks', function(e) {
               return self._onTouchMove(e.originalEvent);
            })
            .bind('touchstart.wmks', function(e) {
               return self._onTouchStart(e.originalEvent);
            })
            .bind('touchend.wmks', function(e) {
               return self._onTouchEnd(e.originalEvent);
            });
   };


   /*
    *---------------------------------------------------------------------------
    *
    * disconnectEvents
    *
    *    Remove touch event handlers.
    *
    *---------------------------------------------------------------------------
    */

   this.disconnectEvents = function() {
      if (!_canvas) {
         return;
      }
      _canvas
         .unbind('orientationchange.wmks.icons')
         .unbind('orientationchange.wmks')
         .unbind('touchmove.wmks')
         .unbind('touchstart.wmks')
         .unbind('touchend.wmks');

      _canvas.find('.feedback-container')
         .unbind('touchmove.wmks')
         .unbind('touchstart.wmks')
         .unbind('touchend.wmks');
   };


   /*
    *---------------------------------------------------------------------------
    *
    * initializeMobileFeature
    *
    *    This function initializes the touch feature that's requested.
    *
    *---------------------------------------------------------------------------
    */

   this.initializeMobileFeature = function(type) {
      if (!WMKS.BROWSER.isTouchDevice()) {
         // Not a touch device, and hence will not initialize keyboard.
         return;
      }

      switch (type) {
         case WMKS.CONST.TOUCH.FEATURE.Trackpad:
            _ELEMENTS.trackpad = new WMKS.trackpadManager(_widget, _canvas);
            _ELEMENTS.trackpad.initialize();
            break;

         case WMKS.CONST.TOUCH.FEATURE.ExtendedKeypad:
            _ELEMENTS.keypad = new WMKS.extendedKeypad({
                                  widget : _widget,
                                  parentElement: _canvas.parent(),
                                  keyboardManager: _keyboardManager
                               });
            _ELEMENTS.keypad.initialize();
            break;

         case WMKS.CONST.TOUCH.FEATURE.SoftKeyboard:
            _ELEMENTS.inputProxy = this.initSoftKeyboard();
            break;
         default:
            WMKS.LOGGER.error('Invalid mobile feature type: ' + type);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * initSoftKeyboard
    *
    *    This function installs an input element and installs event handlers
    *    that will be used for reading device keyboard inputs and translating
    *    into the corresponding server messages.
    *
    *    NOTE: Chrome on android returns in-valid keyCodes for keyDown/keyPress.
    *
    *---------------------------------------------------------------------------
    */

   this.initSoftKeyboard = function() {
      var self = this,
          kbHandler = _keyboardManager;

      /*
       * Add a textbox that which on gaining focus launches the keyboard.
       * Listen for key events on the textbox. Append the textbox to the canvas
       * parent so that to make listening for input events easier.
       *
       * Adding this to the canvas parent is better than to the document.body
       * as we can eliminate the need to detect the parent's offset from
       * the screen while positioning the inputbox.
       *
       * To make the textbox functional and still hidden from the user by using
       * transparent background, really small size (1x1 px) textbox without
       * borders. To hide the caret, we use 0px font-size and disable any of
       * the default selectable behavior for copy-paste, etc.
       */
       var inputDiv = $('<input type="text"/>')
         .val(WMKS.CONST.KB.keyInputDefaultValue)
         .attr({
            'id':                   'input-proxy',
            'autocorrect':          'off',    /* disable auto correct */
            'autocapitalize':       'off' })  /* disable capitalizing 1st char in a word */
         .css({
            'font-size':            '1px',    /* make the caret really small */
            'width':                '1px',    /* Non-zero facilitates keyboard launch */
            'height':               '1px',
            'background-color':     'transparent',    /* removes textbox background */
            'color':                'transparent',    /* removes caret color */
            'box-shadow':           0,        /* remove box shadow */
            'outline':              'none',   /* remove orange outline - android chrome */
            'border':               0,        /* remove border */
            'padding':              0,        /* remove padding */
            'left':                 -1,       /* start outside the visible region */
            'top':                  -1,
            'overflow':             'hidden',
            'position':             'absolute' })
         .bind('blur',     function(e) { return self._onInputBlur(e); })
         .bind('focus',    function(e) { return self._onInputFocus(e); })
         .bind('input',    function(e) { return kbHandler.onInputTextSoftKb(e); })
         .bind('keydown',  function(e) { return kbHandler.onKeyDownSoftKb(e); })
         .bind('keyup',    function(e) { return kbHandler.onKeyUpSoftKb(e); })
         .bind('keypress', function(e) { return kbHandler.onKeyPressSoftKb(e); })
         .insertBefore(_canvas.parent());

      if (WMKS.BROWSER.isIOS()) {
         // css to disable user select feature on iOS. Breaks android kb launch.
         inputDiv.css({
            '-webkit-touch-callout': 'none'    /* disable callout, image save panel */
         });
      }
      return inputDiv;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * removeMobileFeature
    *
    *    Based on the feature type, see if its initialized, if so, destroy and
    *    remove its references.
    *
    *---------------------------------------------------------------------------
    */

   this.removeMobileFeature = function(type) {
      switch (type) {
         case WMKS.CONST.TOUCH.FEATURE.Trackpad:
            if (_ELEMENTS.trackpad) {
               _ELEMENTS.trackpad.destroy();
               _ELEMENTS.trackpad = null;
            }
            break;

         case WMKS.CONST.TOUCH.FEATURE.ExtendedKeypad:
            if (_ELEMENTS.keypad) {
               _ELEMENTS.keypad.destroy();
               _ELEMENTS.keypad = null;
            }
            break;

         case WMKS.CONST.TOUCH.FEATURE.SoftKeyboard:
            if (_ELEMENTS.inputProxy) {
               if (_KEYBOARD.visible) {
                  // Input is in focus, and keyboard is up.
                  this.toggleKeyboard(false);
               }
               _ELEMENTS.inputProxy.remove();
               _ELEMENTS.inputProxy = null;
            }
            break;
         default:
            WMKS.LOGGER.error('Invalid mobile feature type: ' + type);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * destroy
    *
    *    Destroys the TouchHandler.
    *
    *    This will disconnect all (if active) and remove
    *    the widget from the associated element.
    *
    *    Consumers should call this before removing the element from the DOM.
    *
    *---------------------------------------------------------------------------
    */

   this.destroy = function() {
      this.disconnectEvents();
      this.removeMobileFeature(WMKS.CONST.TOUCH.FEATURE.SoftKeyboard);
      this.removeMobileFeature(WMKS.CONST.TOUCH.FEATURE.ExtendedKeypad);
      this.removeMobileFeature(WMKS.CONST.TOUCH.FEATURE.Trackpad);

      // Cleanup private variables.
      _widget = null;
      _canvas = null;
      _keyboardManager = null;
      _TAP_STATE = null;
      _ELEMENTS = null;
      _repositionElements.length = 0;
      _repositionElements = null;
   };

};


/*
 *------------------------------------------------------------------------------
 *
 * WMKS.UTIL.TOUCH
 *
 *    These util functions are very specific to this touch library and hence are
 *    created separately under this file. Anything that's more generic goes
 *    into WMKS.UTIL itself.
 *
 *    NOTE: Some of these functions use touch specific target data.
 *------------------------------------------------------------------------------
 */

WMKS.UTIL.TOUCH = {
   /*
    *---------------------------------------------------------------------------
    *
    * isLandscapeOrientation
    *
    *    Returns true if the device is in landscape orientation.
    *
    *---------------------------------------------------------------------------
    */

   isLandscapeOrientation: function() {
      return (window.orientation === 90 || window.orientation === -90);
   },

   /*
    *---------------------------------------------------------------------------
    *
    * isPortraitOrientation
    *
    *    Returns true if the device is in landscape orientation.
    *
    *---------------------------------------------------------------------------
    */

   isPortraitOrientation: function() {
      return (window.orientation === 0 || window.orientation === 180);
   },


   /*
    *---------------------------------------------------------------------------
    *
    * getRelativePositionMultiplier
    *
    *    This helper function provides the width and height multipliers for an
    *    element which multiplied to its width and height and added to the
    *    current location offset, will give the desired location as defined by
    *    the position string.
    *
    *    position - Possible values are: top/bottom + left/right or null.
    *               (Default center)
    *    Ex: position = 'top' --> returns {width: 0.5, height: -1}
    *
    *---------------------------------------------------------------------------
    */
   getRelativePositionMultiplier: function(position) {
      var wMultiply = -0.5, hMultiply = -0.5;
      if (!!position) {
         // Check for left or right positioning.
         if (position.indexOf('left') !== -1) {
            wMultiply = -1;
         } else if (position.indexOf('right') !== -1) {
            wMultiply = 1;
         }
         // Check for top or bottom positioning.
         if (position.indexOf('top') !== -1) {
            hMultiply = -1;
         } else if (position.indexOf('bottom') !== -1) {
            hMultiply = 1;
         }
      }
      // Return json response containing width and height multipliers.
      return {'width': wMultiply, 'height': hMultiply};
   },


   /*
    *---------------------------------------------------------------------------
    *
    * touchEqual
    *
    *    Convenience function to compare two touches and see if they correspond
    *    to precisely the same point.
    *
    *---------------------------------------------------------------------------
    */

   touchEqual: function(thisTouch, thatTouch) {
      return (thisTouch.screenX === thatTouch.screenX &&
              thisTouch.screenY === thatTouch.screenY);
   },


   /*
    *---------------------------------------------------------------------------
    *
    * touchDistance
    *
    *    Convenience function to get the pixel distance between two touches,
    *    in screen pixels.
    *
    *---------------------------------------------------------------------------
    */

   touchDistance: function(thisTouch, thatTouch) {
      return WMKS.UTIL.getLineLength((thatTouch.screenX - thisTouch.screenX),
                                     (thatTouch.screenY - thisTouch.screenY));
   },


   /*
    *---------------------------------------------------------------------------
    *
    * touchAngleBwLines
    *
    *    Convenience function to compute the angle created b/w 2 lines. Each of
    *    the two lines are defined by two touch points.
    *
    *---------------------------------------------------------------------------
    */

   touchAngleBwLines: function(l1p1, l1p2, l2p1, l2p2) {
      var a1 = Math.atan2(l1p1.screenY - l1p2.screenY,
                          l1p1.screenX - l1p2.screenX);
      var a2 = Math.atan2(l2p1.screenY - l2p2.screenY,
                          l2p1.screenX - l2p2.screenX);
      return a1 - a2;
   },


   /*
    *---------------------------------------------------------------------------
    *
    * copyTouch
    *
    *    Since touches are Objects, they need to be deep-copied. Note that we
    *    only copy the elements that we use for our own purposes, there are
    *    probably more.
    *
    *---------------------------------------------------------------------------
    */

   copyTouch: function(aTouch) {
      var newTouch = {
         'screenX': aTouch.screenX,
         'screenY': aTouch.screenY,
         'clientX': aTouch.clientX,
         'clientY': aTouch.clientY,
         'pageX'  : aTouch.pageX,
         'pageY'  : aTouch.pageY
      };
      return newTouch;
   },


   /*
    *---------------------------------------------------------------------------
    *
    * leftmostOf
    *
    *    Returns the touch event that contains the leftmost screen coords.
    *
    *---------------------------------------------------------------------------
    */

   leftmostOf: function(thisTouch, thatTouch) {
      return (thisTouch.screenX < thatTouch.screenX)? thisTouch : thatTouch;
   }
};
/*
 * wmks/widgetProto.js
 *
 *   WebMKS widget prototype for use with jQuery-UI.
 *
 *
 * A widget for displaying a remote MKS or VNC stream over a WebSocket.
 *
 * This widget can be dropped into any page that needs to display the screen
 * of a VM. It communicates over a WebSocket connection using VMware's
 * enhanced VNC protocol, which is compatible either with a VM's configured
 * VNC WebSocket port or with a proxied Remote MKS connection.
 *
 * A few options are provided to customize the behavior of the WebMKS:
 *
 *    * fitToParent (default: true)
 *      - Scales the guest screen size to fit within the WebMKS's
 *        allocated size. It's important to note that this does
 *        not resize the guest resolution.
 *
 *    * fitGuest (default: false)
 *      - Requests that the guest change its resolution to fit within
 *        the WebMKS's allocated size.  Compared with fitToParent, this
 *        does resize the guest resolution.
 *
 *    * useNativePixels (default: false)
 *      - Enables the use of native pixel sizes on the device. On iPhone 4+ or
 *        iPad 3+, turning this on will enable "Retina mode," which provides
 *        more screen space for the guest, making everything much smaller.
 *
 *    * allowMobileKeyboardInput (default: true)
 *      - Enables the use of a native on-screen keyboard for mobile devices.
 *        When enabled, the showKeyboard() and hideKeyboard() functions
 *        will pop up a keyboard that can be used to interact with the VM.
 *
 *    * allowMobileTrackpad (default: true)
 *      - Enables the use of trackpad on mobile devices for better accuracy
 *        compared to touch inputs. The trackpad dialog will not show-up when
 *        enabled, but will allow it to toggle (hide/show) by invoking the
 *        toggleTrackpad() function.
 *
 *    * allowMobileExtendedKeypad (default: true)
 *      - Enables the use of extended keypad on mobile devices to provision
 *        special keys: function keys, arrow keys, modifier keys, page
 *        navigation keys, etc. The keypad dialog will not show-up when
 *        enabled, but will allow it to toggle (hide/show) by invoking the
 *        toggleExtendedKeypad() function.
 *
 *    * useVNCHandshake (default: true)
 *      - Enables a standard VNC handshake. This should be used when the
 *        endpoint is using standard VNC authentication. Set to false if
 *        connecting to a proxy that authenticates through authd and does
 *        not perform a VNC handshake.
 *
 *    * fixANSIEquivalentKeys (default: false)
 *      - Enables fixing of any non-ANSI US layouts keyCodes to match ANSI US layout
 *        keyCodes equivalents. It attempts to fix any keys pressed where
 *        the client's international keyboard layout has a key that is also present
 *        on the ANSI US keyboard, but is in a different location or doesn't match
 *        the SHIFT or NO SHIFT status of an ANSI US keyboard. This is useful in the
 *        case where a user needs to login to the guest OS before they can change
 *        the keyboard layout to match the client layout.
 *        Example: On some french keyboard layouts, "!" is where the "8" key is on the
 *        ANSI US layout. When enabled, the guest OS would receive SHIFT + "1" instead
 *        of "8" and display the correct "!" character.
 *
 *    * enableVorbisAudioClips (default: false)
 *      - Enables the use of the OGG-encapsulated Vorbis audio codec for providing
 *        audio data in the form of short clips suitable for browser consumption.
 *
 *    * enableOpusAudioClips (default: false)
 *      - Enables the use of the OGG-encapsulated Opus audio codec for providing
 *        audio data in the form of short clips suitable for browser consumption.
 *
 *    * enableAacAudioClips (default: false)
 *      - Enables the use of the AAC/MP4 audio codec for providing audio data in
 *        the form of short clips suitable for browser consumption.
 *
 *    * enableVVC (default: true)
 *      - Enables the use of the vmware-vvc protocol for communication over
 *        the websocket.
 *
 *    * enableMP4 (default: false)
 *      - Enables the use of the MP4 encoding for frame buffer and MP4 decoding on
 *       the browser.
 *
 *    * enableRawH264 (default: false) - only for testing mode.
 *      - This maps to: VNCH264RectEnc @ bora/public/vnc.h
 *        Enables the use of the raw H264 (instead of MP4) encoding for frame buffer
 *        and raw H264 decoding on the browser.
 *        Actually, browser can't support raw H264 decoding - so, browser will just
 *        drop the packet.
 *
 *    * enableTopologyChange (default: false) - only for testing mode.
 *      - This maps to: VNCTopologyChangeEnc @ bora/public/vnc.h
 *        Enable the use of topology change request to server.
 *
 *    * enableH264Multimon (default: false) - only for testing mode.
 *      - This maps to: VNCH264MultimonEnc @ bora/public/vnc.h
 *        Enable the use of multimon in H264 mode.
 *
 *    * multimonRenderer (default: null) - only for testing mode.
 *      - The object who has have below API to provide customized render behavior
 *        after entering multimon:
 *        - onFrameEnd(decodeStart, updateReqId), which is used to help calculate
 *            the real rendering time and also make the rendering process async.
 *            unlike the onSuccess/onError, it should be called right after each
 *            monitor get the data, other than when finish the rendering.
 *        - onInit(type, param, onSuccess, onError), where type is either "mp4" or
 *            "rect", should only be called for "mp4" type for now.
 *        - onData(type, param, onSuccess, onError), where type is either "mp4" or
 *            "rect", and param will contains the rendering data as "param.data".
 *        - reset which will be called when the session disconnected to release
 *            resources.
 *
 *    * enableSubRectangleCache (default: true)
 *      - This controls whether supporting the encoding of
 *        VNC_UPDATECACHE_CAP_END_SUB_RECTANGLE @ bora/public/vnc.h
 *
 *    * enableUint8Utf8 (default: false)
 *      - Enables the use of the legacy uint8utf8 protocol for communication over
 *        the websocket.
 *
 *    * retryConnectionInterval (default: -1)
 *      - The interval(millisecond) for retrying connection when the first
 *        attempt to set up a connection between web client and server fails.
 *        if value is less or equal than 0, it won't perform retry.
 *
 *    * VCDProxyHandshakeVmxPath (default: null)
 *      - VMX path (string) for use during the VNC connection process to a VCD console
 *        proxy.
 *
 *    * mapMetaToCtrlForKeys (default: [])
 *      - Enables the mapping of CMD to CTRL when the command key is presses along side
 *        one of the keys specified in this array. Keys must be specified using their
 *        integer keycode value (ie 65 for A). Useful on OSX for mapping CMD-V CMD-C to
 *        Control-V Control-C respectively.
 *
 *    * enableWindowsKey (default: false)
 *      - Enables the simulation of Windows key. A Windows key is sent when Ctrl+Win
 *        on Windows or Ctrl+CMD on Mac are pressed.
 *
 *    * enableVMWSessionClose (default: false)
 *      - Enables the communication of session close msg between client and server. When
 *        each side is about to close the websocket intentionally, a session close msg is
 *        sent to the other side.
 *
 *    * enableVMWAudioMixer (default: false)
 *      - Enables the communication of audio volume information(e.g. volume,
 *        bass and treble...) from server to client. When the audio volume is
 *        changed on the server, an audio volume update is sent to client.
 *
 * Handlers can also be registered to be triggered under certain circumstances:
 *
 *    * connecting
 *      - called when the websocket to the server is opened.
 *
 *    * connected
 *      - called when the websocket connection to the server has completed, the protocol
 *        has been negotiated and the first update from the server has been received, but
 *        not yet parsed, decoded or displayed.
 *
 *    * beforedisconnected
 *     - called when websocket is about to be closed by server intentionally.
 *
 *    * disconnected
 *      - called when the websocket connection to the server has been lost, either
 *        due to a normal shutdown, a dropped connection, or a failure to negotiate
 *        a websocket upgrade with a server. This handler is passed a map of information
 *        including a text reason string (if available) and a disconnection code from
 *        RFC6455.
 *
 *    * authenticationfailed
 *      - called when the VNC authentication procedure has failed. NOTE: this is only
 *        applicable if VNC style auth is used, other authentication mechanisms outside
 *        of VNC (such as authd tickets) will NOT trigger this handler if a failure
 *        occurs.
 *
 *    * error
 *      - called when an error occurs on the websocket. It is passed the DOM Event
 *        associated with the error.
 *
 *    * protocolerror
 *      - called when an error occurs during the parsing or a received VNC message, for
 *        example if the server sends an unsupported message type or an incorrectly
 *        formatted message.
 *
 *    * resolutionchanged
 *      - called when the resolution of the server's desktop has changed. It's passed
 *        the width and height of the new resolution.
 *
 *  Handlers should be registered using jQuery bind and the 'wmks' prefix:
 *
 *     .bind("wmksdisconnected", function(evt, info) {
 *           // Your handler code
 *      });
 */

WMKS.widgetProto = {};

WMKS.widgetProto.options = {
   fitToParent: false,
   fitGuest: false,
   useNativePixels: false,
   allowMobileKeyboardInput: true,
   useUnicodeKeyboardInput: false,
   useVNCHandshake: true,
   VCDProxyHandshakeVmxPath: null,
   reverseScrollY: false,
   allowMobileExtendedKeypad: true,
   allowMobileTrackpad: true,
   enableVorbisAudioClips: false,
   enableOpusAudioClips: false,
   enableAacAudioClips: false,
   enableVMWAudioMixer: false,
   enableVVC: true,
   enableMP4: false,
   enableRawH264: false,
   enableTopologyChange: false,
   enableH264Multimon: false,
   multimonRenderer: null,
   enableSubRectangleCache: true,
   enableUint8Utf8: false,
   retryConnectionInterval: -1,
   ignoredRawKeyCodes: [],
   fixANSIEquivalentKeys : false,
   mapMetaToCtrlForKeys: [],
   enableWindowsKey: false,
   keyboardLayoutId: 'en-US',
   sendRelativeMouseEvent: false
};


/************************************************************************
 * Private Functions
 ************************************************************************/

/*
 *------------------------------------------------------------------------------
 *
 * _updatePixelRatio
 *
 *    Recalculates the pixel ratio used for displaying the canvas.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Stores new pixel ratio in this._pixelRatio.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._updatePixelRatio = function() {
   if (this.options.useNativePixels) {
      this._pixelRatio = window.devicePixelRatio || 1.0;
   } else {
      this._pixelRatio = 1.0;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _updateMobileFeature
 *
 *    This function is a wrapper function that requests touch features to be
 *    enabled / disabled depending on the allow flag that's sent.
 *
 *    If allow flag is true, enable feature defined in type, else disable it.
 *
 *    List of supported features are:
 *
 *    MobileKeyboardInput:
 *       This function initializes the touch keyboard inputs based on the option
 *       setting. Shows/hides an offscreen <input> field to force the virtual
 *       keyboard to show up on tablet devices.
 *
 *    MobileExtendedKeypad
 *       This function initializes the Extended keypad which provides the user
 *       with special keys that are not supported on the MobileKeyboardInput.
 *
 *    MobileTrackpad:
 *       This function initializes the trackpad. The trackpad allows users to
 *       perform more precise mouse operations that are not possible with touch
 *       inputs.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Modifies DOM.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._updateMobileFeature = function(allow, type) {
   if (allow) {
      this._touchHandler.initializeMobileFeature(type);
   } else {
      this._touchHandler.removeMobileFeature(type);
   }
};

/**
 *------------------------------------------------------------------------------
 *
 * _updateDisplayScale
 *
 *    Set the display scale value
 *    Display scale is supposed to work in the case guest DPI is different
 *    than the remove VM.  For example, when guest DPI is 200%, and remote
 *    VM DPI is 100%.  Set display scale to be 0.5 to decrease the VM
 *    resolution so that things get bigger.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Stores new display scale value in this._displayScaleRatio
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._updateDisplayScale = function(value) {
   this._displayScaleRatio = value;
   WMKS.LOGGER.debug("Display scale updated to " + this._displayScaleRatio);
};


/*
 *------------------------------------------------------------------------------
 *
 * _setOption
 *
 *    Changes a WMKS option.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Updates the given option in this.options.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._setOption = function(key, value) {
   $.Widget.prototype._setOption.apply(this, arguments);

   switch (key) {
      case 'fitToParent':
         this.rescaleOrResize(false);
         break;

      case 'fitGuest':
         this.rescaleOrResize(true);
         break;

      case 'displayScale':
         this._updateDisplayScale(value);
         break;

      case 'useNativePixels':
         // Return if useNativePixels is true and browser indicates no-support.
         if (value && !WMKS.UTIL.isHighResolutionSupported()) {
            WMKS.LOGGER.warn('Browser/device does not support this feature.');
            return;
         }
         this._updatePixelRatio();
         if (this.options.fitGuest) {
            // Apply the resize for fitGuest mode.
            this.updateFitGuestSize(true);
         } else {
            this.rescaleOrResize(false);
         }
         break;

      case 'allowMobileKeyboardInput':
         this._updateMobileFeature(value, WMKS.CONST.TOUCH.FEATURE.SoftKeyboard);
         break;

      case 'allowMobileTrackpad':
         this._updateMobileFeature(value, WMKS.CONST.TOUCH.FEATURE.Trackpad);
         break;

      case 'allowMobileExtendedKeypad':
         this._updateMobileFeature(value, WMKS.CONST.TOUCH.FEATURE.ExtendedKeypad);
         break;

      case 'reverseScrollY':
         this.options.reverseScrollY = value;
         break;

      case 'fixANSIEquivalentKeys':
         this._keyboardManager.fixANSIEquivalentKeys = value;
         break;

      case 'VCDProxyHandshakeVmxPath':
         this.setVCDProxyHandshakeVmxPath(value);
         break;

      case 'mapMetaToCtrlForKeys':
         this._keyboardManager.mapMetaToCtrlForKeys = value;

      case 'enableWindowsKey':
         this._keyboardManager.enableWindowsKey(value);
         break;

      case 'keyboardLayoutId':

         this._keyboardManager.keyboardLayoutId = value;
         this._keyboardManager.UnicodeToVScanMap = WMKS.CONST.KB.VScanMap[value];
         break;

      case 'ignoredRawKeyCodes':
         this._keyboardManager.setIgnoredRawKeyCodes(value);
         break;
      case 'sendRelativeMouseEvent':
         this._vncDecoder.options.sendRelativeMouseEvent = value;
         break;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * getCanvasPosition
 *
 *    Tracks the cursor throughout the document.
 *
 * Results:
 *    The current mouse position in the form { x, y }.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.getCanvasPosition = function (docX, docY) {
   var offset, scalePxRatio, maxX, maxY;

   if (isNaN(docX) || isNaN(docY)) {
      return { x: 0, y: 0 };
   }

   offset = this._canvas.offset();
   scalePxRatio = this._pixelRatio * this._displayScaleRatio / this._scale;

   var x = Math.ceil((docX - offset.left) * scalePxRatio);
   var y = Math.ceil((docY - offset.top) * scalePxRatio);

   /*
    * Clamp bottom and right border.
    */
   maxX = Math.ceil(this._canvas.width() * scalePxRatio) - 1;
   maxY = Math.ceil(this._canvas.height() * scalePxRatio) - 1;
   x = Math.min(x, maxX);
   y = Math.min(y, maxY);

   /*
    * Clamp left and top border.
    */
   x = Math.max(x, 0);
   y = Math.max(y, 0);

   return { x: x, y: y };
};

/*
 *------------------------------------------------------------------------------
 *
 * getRelativeMouseCanvasPosition
 *
 *    Tracks the cursor throughout the document.
 *
 * Results:
 *    The current mouse position in the form { x, y }.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.getRelativeMouseCanvasPosition = function (pos) {
   var offset, offsetParent, scalePxRatio;
   var docX = pos.x,
       docY = pos.y;

   if (isNaN(docX) || isNaN(docY)) {
      return { x: 0, y: 0 };
   }

   offset = this._canvas.offset();
   offsetParent = this._canvas.parent().offset();

   scalePxRatio = this._scale / this._pixelRatio;

   var x = Math.ceil(docX * scalePxRatio + offset.left);
   var y = Math.ceil(docY * scalePxRatio + offset.top);

   return { x: x, y: y };
};

/*
 *------------------------------------------------------------------------------
 *
 * getEventPosition
 *
 *    Gets the mouse event position within the canvas.
 *    Tracks the cursor throughout the document.
 *
 * Results:
 *    The current mouse position in the form { x, y }.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.getEventPosition = function (evt) {

   var docX, docY;

   if (evt.pageX || evt.pageY) {
      docX = evt.pageX;
      docY = evt.pageY;
   } else if (evt.clientX || evt.clientY) {
      docX = (evt.clientX +
              document.body.scrollLeft +
              document.documentElement.scrollLeft);
      docY = (evt.clientY +
              document.body.scrollTop +
              document.documentElement.scrollTop);
   } else {
      // ??
   }

   return this.getCanvasPosition(docX, docY);
};


/*
 *------------------------------------------------------------------------------
 *
 * _isCanvasMouseEvent
 *
 *    Checks if a mouse event should be consumed as if it was targeted at the
 *    canvas.
 *
 *    This is useful in the case that a user holds their mouse down and
 *    drags it outside of the canvas, either on to other elements or even
 *    outside the browser window. It will allow us to process the mouse up event
 *    and ensure we do not end up in the state where the remote thinks we are
 *    still holding the mouse button down but locally we are not.
 *
 * Results:
 *    Returns true if mouse event should be considered to be targeted at canvas
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._isCanvasMouseEvent = function(event) {
   var evt = event || window.event;
   var elm = evt.target || evt.srcElement;

   // If the mouse was pressed down on the canvas then continue to consume
   // all mouse events until mouse release.
   if (this._mouseDownBMask !== 0) {
       return true;
   } else {
      // Else, only consume mouse events for the canvas or video
      return (elm === this._canvas[0]) ||
             (this._video && (elm === this._video[0])) || (elm === $('#relativePadSurface')) ;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _onMouseButton
 *
 *    Mouse event handler for 'mousedown' and 'mouseup' events.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends a VMWPointerEvent message to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._onMouseButton = function(event, down) {
   if (this._vncDecoder && this._isCanvasMouseEvent(event)) {
      var evt = event || window.event;
      var pos = this.getEventPosition(evt);
      var bmask;

      /* evt.which is valid for all browsers except IE */
      if (evt.which) {
         /*
          * Firefox on Mac causes Ctrl + click to be a right click.  This kills
          * this ability to multi-select while clicking. Remap to left click in
          * this case. PR 878794 / 1085523.
          */
         if (WMKS.BROWSER.isMacOS() && WMKS.BROWSER.isGecko()
               && evt.ctrlKey && evt.button === 2) {
            WMKS.LOGGER.trace ('FF on OSX: Rewrite Ctrl+Right-click as Ctrl+Left-click.');
            bmask = 1 << 0;   // Left click.
         } else {
            bmask = 1 << evt.button;
         }
      } else {
         /* IE including 9 */
         bmask = (((evt.button & 0x1) << 0) |
                  ((evt.button & 0x2) << 1) |
                  ((evt.button & 0x4) >> 1));
      }
      return this.sendMouseButtonMessage(pos, down, bmask);
   }
};

/*
 *------------------------------------------------------------------------------
 *
 * sendMouseButtonMessage
 *
 *    Sends the mouse message for 'mousedown' / 'mouseup' at a given position.
 *
 *    Sends a VMWPointerEvent message to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.sendMouseButtonMessage = function(pos, down, bmask) {
   if (this._vncDecoder) {
      if (down) {
         this._mouseDownBMask |= bmask;
      } else {
         this._mouseDownBMask &= ~bmask;
      }
      /*
       * Send MouseMove event first, to ensure the pointer is at the
       * coordinates where the click should happen. This fixes the
       * erratic mouse behaviour when using touch devices to control
       * a Windows machine.
       */
      if (this._mousePosGuest.x !== pos.x || this._mousePosGuest.y !== pos.y) {
         // Send the mousemove message and update state.
         this.sendMouseMoveMessage(pos);
      }

      // WMKS.LOGGER.warn(pos.x + ',' + pos.y + ', down: ' + down + ', mask: ' + bmask);
      this._vncDecoder.onMouseButton(pos.x, pos.y, down, bmask);
   }
   return true;
};


/*
 *------------------------------------------------------------------------------
 *
 * _onMouseWheel
 *
 *    Mouse wheel handler. Normalizes the deltas from the event and
 *    sends it to the guest.
 *
 * Results:
 *    true, always.
 *
 * Side Effects:
 *    Sends data.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._onMouseWheel = function(event) {
   if (this._vncDecoder && this._isCanvasMouseEvent(event)) {
      var evt = event || window.event;
      var pos = this.getEventPosition(evt);
      var dx = Math.max(Math.min(event.wheelDeltaX, 1), -1);
      var dy = Math.max(Math.min(event.wheelDeltaY, 1), -1);

      if (this.options.reverseScrollY) {
         dy = dy * -1;
      }
      // Abstract the sending message part and updating state for reuse by
      // touchHandler.
      this.sendScrollMessage(pos, dx, dy);

      // Suppress default actions
      event.stopPropagation();
      event.preventDefault();
      return false;
   }

};


/*
 *------------------------------------------------------------------------------
 *
 * sendScrollMessage
 *
 *    Mouse wheel handler. Normalizes the deltas from the event and
 *    sends it to the guest.
 *
 *    Sends a VMWPointerEvent message to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.sendScrollMessage = function(pos, dx, dy) {
   if (this._vncDecoder) {
      /*
       * Send MouseMove event first, to ensure the pointer is at the
       * coordinates where the click should happen. This fixes the
       * erratic mouse behaviour when using touch devices to control
       * a Windows machine.
       */
      //
      // TODO: This is commented out for now as it seems to break browser scrolling.
      //       We may need to revisit this for iPad scrolling.
      //
      // if (this._mousePosGuest.x !== pos.x || this._mousePosGuest.y !== pos.y) {
      //   // Send the mousemove message and update state.
      //   this.sendMouseMoveMessage(pos);
      // }
      // WMKS.LOGGER.debug('scroll: ' + pos.x + ',' + pos.y + ', dx, dy: ' + dx + ',' + dy);
      this._vncDecoder.onMouseWheel(pos.x, pos.y, dx, dy);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * _onMouseMove
 *
 *    Mouse event handler for 'mousemove' event.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends a VMWPointerEvent message to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._onMouseMove = function(event) {
   if (this._vncDecoder && this._isCanvasMouseEvent(event)) {
      var evt = event || window.event;
      var pos = this.getEventPosition(evt);

      this.sendMouseMoveMessage(pos);
   }
   return true;
};


/*
 *------------------------------------------------------------------------------
 *
 * sendMouseMoveMessage
 *
 *    The mouse move message is sent to server and the state change is noted.
 *
 *    Sends a VMWPointerEvent message to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.sendMouseMoveMessage = function(pos) {
   if (this._vncDecoder) {
      this._vncDecoder.onMouseMove(pos.x, pos.y);
      this._mousePosGuest = pos;

      // Inform the input text field regarding the caret position change.
      if (this._touchHandler) {
      this._touchHandler.onCaretPositionChanged(pos);
   }
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * sendKeyMessage
 *
 *    The key message is sent to server and the state change is noted.
 *
 *    VScanCodes or Unicode will be sent to the server depending on the config.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.sendKeyMessage = function(message) {
   var messageType = message.type,
      event = message.event;
   if (messageType == "KeyDown") {
      this.updateUserActivity();
      return this._keyboardManager.onKeyDown(event);
   } else if (messageType == "KeyPress") {
      this.updateUserActivity();
      return this._keyboardManager.onKeyPress(event);
   } else if (messageType == "KeyUp") {
      this.updateUserActivity();
      return this._keyboardManager.onKeyUp(event);
   };
};


/*
 *------------------------------------------------------------------------------
 *
 * onBlur
 *
 *    Expose _onBlur to avoid tricky codes in the UI layer for supporting
 *    multimon in 17Q1.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Releases all keys (calling cancelModifiers) and mouse buttons by checking
 *    and clearing their tracking variables (this._mouseDownBMask) and
 *    sending the appropriate VMWKeyEvent and VMWPointerEvent messages.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.onBlur = function(event) {
   this._onBlur(event);
};


/*
 *------------------------------------------------------------------------------
 *
 * onBlur
 *
 *    Expose _onBlur to avoid tricky codes in the UI layer for supporting
 *    multimon in 17Q1.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Releases all keys (calling cancelModifiers) and mouse buttons by checking
 *    and clearing their tracking variables (this._mouseDownBMask) and
 *    sending the appropriate VMWKeyEvent and VMWPointerEvent messages.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.onBlur = function(event) {
   this._onBlur(event);
};


/*
 *------------------------------------------------------------------------------
 *
 * _onBlur
 *
 *    Event handler for 'blur' event.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Releases all keys (calling cancelModifiers) and mouse buttons by checking
 *    and clearing their tracking variables (this._mouseDownBMask) and
 *    sending the appropriate VMWKeyEvent and VMWPointerEvent messages.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._onBlur = function(event) {
   if (this.connected) {
      /*
       * The user switched to a different element or window,
       * so release all keys.
       */

      // Cancel all modifiers that are held.
      this._keyboardManager.cancelModifiers();

      this._vncDecoder.onMouseButton(this._mousePosGuest.x,
                                     this._mousePosGuest.y,
                                     0,
                                     this._mouseDownBMask);
      this._mouseDownBMask = 0;
   }

   return true;
};


/*
 *------------------------------------------------------------------------------
 *
 * _onPaste
 *
 *    Clipboard paste handler.
 *
 * Results:
 *    true, always.
 *
 * Side Effects:
 *    Calls any user-defined callback with pasted text.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto._onPaste = function(event) {
   var e = event.originalEvent;
   var self = this;
   if (e && e.clipboardData) {
      var items = e.clipboardData.items;
      if (items) {
         for (var i = 0; i < items.length; i++) {
            if (items[i].kind === 'string' && items[i].type === 'text/plain') {
               items[i].getAsString(function(txt) {
                  self._keyboardManager.processInputString(txt);
               });
            }
         }
      }
   }
   return true;
};


/************************************************************************
 * Public API
 ************************************************************************/

/*
 *------------------------------------------------------------------------------
 *
 * disconnectEvents
 *
 *    Disconnects the events from the owner document.
 *
 *    This can be called by consumers of WebMKS to disconnect all the events
 *    used to interact with the guest.
 *
 *    The consumer may need to carefully manage the events (for example, if
 *    there are multiple WebMKS's in play, some hidden and some not), and can
 *    do this with connectEvents and disconnectEvents.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Disconnects the event handlers from the events in the WMKS container.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.disconnectEvents = function() {
   /*
    * Remove our own handler for the 'keypress' event and the context menu.
    */
   this.element
      .unbind('contextmenu.wmks')
      .unbind('keydown.wmks')
      .unbind('keypress.wmks')
      .unbind('keyup.wmks')
      .unbind('mousedown.wmks')
      .unbind('mousewheel.wmks');

   this.element
      .unbind('mousemove.wmks')
      .unbind('mouseup.wmks')
      .unbind('blur.wmks');

   $(window)
      .unbind('blur.wmks' + this._wmksId);
   $(window)
      .unbind('mousemove.wmks' + this._wmksId);
   $(window)
      .unbind('mousewheel.wmks' + this._wmksId);
   $(window)
      .unbind('mouseup.wmks' + this._wmksId);
   $(window)
      .unbind('mousedown.wmks' + this._wmksId);

   // Disconnect event handlers from the touch handler.
   if (this._touchHandler) {
      this._touchHandler.disconnectEvents();
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * connectEvents
 *
 *    Connects the events to the owner document.
 *
 *    This can be called by consumers of WebMKS to connect all the
 *    events used to interact with the guest.
 *
 *    The consumer may need to carefully manage the events (for example,
 *    if there are multiple WebMKS's in play, some hidden and some not),
 *    and can do this with connectEvents and disconnectEvents.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Connects the event handlers to the events in the WMKS container.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.connectEvents = function() {
   var self = this;

   /*
    * Paste event only works on the document (When using Browser's Edit->Paste)
    * This feature also has drawbacks.
    * 1. It only works on Chrome browser.
    * 2. Performing paste on any other element on this document causes the
    *    event to get triggered by bubbling up. Technically the bubbling up
    *    should be enabled only if the element can handle paste in the first
    *    place (i.e., only if its textbox / textarea or an element with
    *    contenteditable set to true.)
    *
    * Due to above limitations, this is disabled. PR: 1091032
    */
   //$(this.element[0].ownerDocument)
   //   .bind('paste.wmks', function(e) { return self._onPaste(e); });

   this.element
      .bind('blur.wmks', function(e) { return self._onBlur(e); });

   /*
    * We have to register a handler for the 'keypress' event as it is the
    * only one reliably reporting the key pressed. It gives character
    * codes and not scancodes however.
    */
   this.element
      .bind('contextmenu.wmks', function(e) { return false; })
      .bind('keydown.wmks', function(e) {
         self.updateUserActivity();
         return self._keyboardManager.onKeyDown(e);
      })
      .bind('keypress.wmks', function(e) {
         return self._keyboardManager.onKeyPress(e);
      })
      .bind('keyup.wmks', function(e) {
         self.updateUserActivity();
         return self._keyboardManager.onKeyUp(e);
      });

   $(window)
      .bind('blur.wmks' + this._wmksId, function(e) {
         return self._onBlur(e);
      })
      .bind('mousemove.wmks' + this._wmksId, function(e) {
         self.updateUserActivity();
         if(self.options.sendRelativeMouseEvent) {
            return;
         } else {
            return self._onMouseMove(e);
         }
      })
      .bind('mousewheel.wmks' + this._wmksId, function(e) {
         self.updateUserActivity();
         if(self.options.sendRelativeMouseEvent) {
            return;
         } else {
            return self._onMouseWheel(e);
         }
      })
      .bind('mouseup.wmks' + this._wmksId, function(e) {
         self.updateUserActivity();
         if(self.options.sendRelativeMouseEvent) {
            return;
         } else {
            return self._onMouseButton(e, 0);
         }
      })
      .bind('mousedown.wmks' + this._wmksId, function(e) {
         self.updateUserActivity();
         if(self.options.sendRelativeMouseEvent) {
            return;
         } else {
            return self._onMouseButton(e, 1);
         }
      });

   // Initialize touch input handlers if applicable.
   if (this._touchHandler) {
      this._touchHandler.installTouchHandlers();
   }

   if (this._relativeMouseHandler) {
      this._relativeMouseHandler.installMouseHandlers();
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * maxFitWidth
 *
 *    This calculates the maximum screen size that could fit, given the
 *    currently allocated scroll width. Consumers can use this with
 *    maxFitHeight() to request a resolution change in the guest.
 *
 *    This value takes into account the pixel ratio on the device, if
 *    useNativePixels is on.
 *
 * Results:
 *    The maximum screen width given the current width of the WebMKS.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.maxFitWidth = function() {
   return this.element[0].scrollWidth * this._pixelRatio;
};


/*
 *------------------------------------------------------------------------------
 *
 * maxFitHeight
 *
 *    This calculates the maximum screen size that could fit, given the
 *    currently allocated scroll height. Consumers can use this with
 *    maxFitWidth() to request a resolution change in the guest.
 *
 *    This value takes into account the pixel ratio on the device, if
 *    useNativePixels is on.
 *
 * Results:
 *    The maximum screen height given the current height of the WebMKS.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.maxFitHeight = function() {
   return this.element[0].scrollHeight * this._pixelRatio;
};


/*
 *------------------------------------------------------------------------------
 *
 * hideKeyboard
 *
 *    Hides the keyboard on a mobile device.
 *
 *    If allowMobileKeyboardInput is on, this command will hide the
 *    mobile keyboard if it's currently shown.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Moves browser focus away from input widget and updates state.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.hideKeyboard = function(args) {
   args = args || {};
   args.show = false;

   this.toggleKeyboard(args);
};


/*
 *------------------------------------------------------------------------------
 *
 * showKeyboard
 *
 *    Shows the keyboard on a mobile device.
 *
 *    If allowMobileKeyboardInput is on, this command will display the
 *    mobile keyboard.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Moves browser focus to input widget and updates state.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.showKeyboard = function(args) {
   args = args || {};
   args.show = true;

   this.toggleKeyboard(args);
};



/*
 *------------------------------------------------------------------------------
 *
 * toggleKeyboard
 *
 *    toggles the keyboard visible state on a mobile device.
 *
 *    If allowMobileKeyboardInput is on, this command will toggle the
 *    mobile keyboard from show to hide or vice versa.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Moves browser focus to input widget and updates state.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.toggleKeyboard = function(args) {
   if (this.options.allowMobileKeyboardInput && this._touchHandler) {
      this._touchHandler.toggleKeyboard(args);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * toggleTrackpad
 *
 *    Show/Hide the trackpad dialog on a mobile device.
 *
 *    If allowMobileTrackpad is on, this command will toggle the
 *    trackpad dialog.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.toggleTrackpad = function(options) {
   if (this.options.allowMobileTrackpad && this._touchHandler) {
      this._touchHandler.toggleTrackpad(options);
   }
};

/*
 *------------------------------------------------------------------------------
 *
 * toggleTrackpad
 *
 *    Show/Hide the trackpad dialog on a mobile device.
 *
 *    If allowMobileTrackpad is on, this command will toggle the
 *    trackpad dialog.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.toggleRelativePad = function(options) {
   if ( this._relativeMouseHandler) {
      this._relativeMouseHandler.toggleRelativePad(options);
   }
};



/*
 *------------------------------------------------------------------------------
 *
 * toggleExtendedKeypad
 *
 *    Show/Hide the extended keypad dialog on a mobile device when the flag:
 *    allowMobileExtendedKeypad is set, this command will toggle the dialog.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.toggleExtendedKeypad = function(options) {
   if (this.options.allowMobileExtendedKeypad && this._touchHandler) {
      this._touchHandler.toggleExtendedKeypad(options);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * sendInputString
 *
 *    Sends a unicode string as keyboard input to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.sendInputString = function(str) {
   /*
    * Explicitly process newline as we are sending it as a string.
    * onPaste on the other hand only does not need to set this flag.
    */
   this._keyboardManager.processInputString(str, true);
};


/*
 *------------------------------------------------------------------------------
 *
 * sendKeyCodes
 *
 *    Sends a series of special key codes to the VM.
 *
 *    This takes an array of special key codes and sends keydowns for
 *    each in the order listed. It then sends keyups for each in
 *    reverse order.
 *
 *    Keys usually handled via keyPress are also supported: If a keycode
 *    is negative, it is interpreted as a Unicode value and sent to
 *    keyPress. However, these need to be the final key in a combination,
 *    as they will be released immediately after being pressed. Only
 *    letters not requiring modifiers of any sorts should be used for
 *    the latter case, as the keyboardMapper may break the sequence
 *    otherwise. Mixing keyDown and keyPress handlers is semantically
 *    incorrect in JavaScript, so this separation is unavoidable.
 *
 *    This can be used to send key combinations such as
 *    Control-Alt-Delete, as well as Ctrl-V to the guest, e.g.:
 *    [17, 18, 46]      Control-Alt-Del
 *    [17, 18, 45]      Control-Alt-Ins
 *    [17, -118]        Control-v (note the lowercase 'v')
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends keyboard data to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.sendKeyCodes = function(keyCodes) {
   var i, keyups = [];

   for (i = 0; i < keyCodes.length; i++) {
      var keyCode = keyCodes[i];

      if (keyCode > 0) {
         this._keyboardManager.sendKey(keyCode, false, false);
         /*
          * Keycode 20 is 'special' - it's the Javascript keycode for the Caps Lock
          * key. In regular usage on Mac OS the browser sends a down when the caps
          * lock light goes on and an up when it goes off. The key handling code
          * special cases this, so if we fake both a down and up here we'll just
          * flip the caps lock state right back to where we started (if this is
          * a Mac OS browser platform).
          */
         if (!(keyCode === 20) || WMKS.BROWSER.isMacOS()) {
            keyups.push(keyCode);
         }
      } else if (keyCode < 0) {
         this._keyboardManager.sendKey(0 - keyCode, true, true);
      }
   }

   for (i = keyups.length - 1; i >= 0; i--) {
      this._keyboardManager.sendKey(keyups[i], true, false);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * rescale
 *
 *    Rescales the WebMKS to match the currently allocated size.
 *
 *    This will update the placement and size of the canvas to match
 *    the current options and allocated size (such as the pixel
 *    ratio).  This is an external interface called by consumers to
 *    force an update on size changes, internal users call
 *    rescaleOrResize(), below.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Updates this._scale and modifies the canvas size and position.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.rescale = function() {
   this.rescaleOrResize(true);
};


/*
 *------------------------------------------------------------------------------
 *
 * updateFitGuestSize
 *
 *    This is a special function that should be used only with fitGuest mode.
 *    This function is used the first time a user initiates a connection.
 *    The fitGuest will not work until the server sends back a CAPS message
 *    indicating that it can handle resolution change requests.
 *
 *    This is used with toggling useNativePixels options in fitGuest mode
  *    and also display scale mode.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.updateFitGuestSize = function(compareAgainstGuestSize) {
   var newParentW = this.element.width() * this._pixelRatio *
         this._displayScaleRatio,
       newParentH = this.element.height() * this._pixelRatio *
          this._displayScaleRatio;

   // Return if its not fitGuest or when the old & new width/height are same
   // when the input param compareAgainstGuestSize is set.
   if (!this.options.fitGuest
         || (compareAgainstGuestSize
            && this._guestWidth === newParentW
            && this._guestWidth === newParentH)) {
      return;
   }

   if(!!this._resolutionHandler) {
      var resolution = this._resolutionHandler(newParentW, newParentH);
      newParentW = resolution[0];
      newParentH = resolution[1];
   }

   // New resolution based on pixelRatio in case of fitGuest.
   this._vncDecoder.onRequestResolution(newParentW, newParentH);
};


/*
 *------------------------------------------------------------------------------
 *
 * updateTopology
 *
 *    This function is used to send topology request to server.
 *
 *    The "useRawSetting" is an optimal boolean param which should be set as
 *    true if want to directly pass monitors settings in multiMonRects into
 *    agent without apply the _pixelRatio.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    None.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.updateTopology = function(multiMonRects, useRawSetting) {
   var i;

   /*
    * Return if its not fitGuest.
    * This does not check whether the current topology is the same or not. It
    * will always just send the request.
    */
   if (!this.options.fitGuest) {
      return;
   }

   if (!useRawSetting) {
      for (i = 0; i < multiMonRects.length; i++) {
         multiMonRects[i].left = multiMonRects[i].left * this._pixelRatio;
         multiMonRects[i].top = multiMonRects[i].top * this._pixelRatio;
         multiMonRects[i].requestedWidth =
            multiMonRects[i].requestedWidth * this._pixelRatio;
         multiMonRects[i].requestedHeight =
            multiMonRects[i].requestedHeight * this._pixelRatio;
      }
   }

   // New resolution based on pixelRatio in case of fitGuest.
   this._vncDecoder.onRequestTopology(multiMonRects);
};


/*
 *------------------------------------------------------------------------------
 *
 * setAudioStreamEnabled
 *
 *    Send a message to the server to enable or disable sending of audio data.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *    Can affect whether we receive audio data from the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.setAudioStreamEnabled = function(enabled) {
   if (this._vncDecoder) {
      this._vncDecoder.setAudioStreamEnabled(enabled);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * setVideoStreamEnabled
 *
 *    Send a message to the server to enable or disable sending of video data.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sends data.
 *    Can affect whether we receive video data from the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.setVideoStreamEnabled = function(enabled) {
   if (this._vncDecoder) {
      this._vncDecoder.setVideoStreamEnabled(enabled);
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * rescaleOrResize
 *
 *    Rescales the WebMKS to match the currently allocated size, or
 *    alternately fits the guest to match the current canvas size.
 *
 *    This will either:
 *         update the placement and size of the canvas to match the
 *         current options and allocated size (such as the pixel
 *         ratio).  This is normally called internally as the result
 *         of option changes, but can be called by consumers to force
 *         an update on size changes
 *    Or:
 *         issue a resolutionRequest command to the server to resize
 *         the guest to match the current WebMKS canvas size.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Updates this._scale and modifies the canvas size and position.
 *    Possibly triggers a resolutionRequest message to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.rescaleOrResize = function(tryFitGuest) {
   var newScale = 1.0, x = 0, y = 0;
   var parentWidth = this.element.width(),
       parentHeight = this.element.height();

   this._canvas.css({
      width: this._guestWidth / (this._pixelRatio * this._displayScaleRatio),
      height: this._guestHeight / (this._pixelRatio * this._displayScaleRatio)
   });

   if (this._video) {
      this._video.css({
         width: this._guestWidth / (this._pixelRatio * this._displayScaleRatio),
         height: this._guestHeight / (this._pixelRatio * this._displayScaleRatio)
      });
   }

   // Use offsetWidth and offsetHeight to get original canvas size before scaling.
   // Otherwise, it may end up scaling many times base on the same canvas size.
   var width = this._canvas[0].offsetWidth;
   var height = this._canvas[0].offsetHeight;

   if (this.transform !== null &&
       !this.options.fitToParent &&
       !this.options.fitGuest) {

      // scale = 1.0, x = 0, y = 0;

   } else if (this.transform !== null &&
              this.options.fitToParent) {
      var horizScale = parentWidth / width,
      vertScale = parentHeight / height;

      x = (parentWidth - width) / 2;
      y = (parentHeight - height) / 2;
      newScale = Math.max(0.1, Math.min(horizScale, vertScale));

   } else if (this.options.fitGuest && tryFitGuest) {
      // fitGuest does not rely on this.transform. It relies on the size
      // provided by the wmks consumer. However, it does have to update the
      // screen size when using high resolution mode.
      this.updateFitGuestSize(true);
   } else if (this.transform === null) {
      WMKS.LOGGER.warn("No scaling support");
   }

   if (this.transform !== null) {
      if (newScale !== this._scale) {
         this._scale = newScale;
         this._canvas.css(this.transform, "scale(" + this._scale + ")");
      }

      if (x !== this._x || y !== this._y) {
         this._x = x;
         this._y = y;
         this._canvas.css({top: y, left: x});
      }
   }
};

/*
 *------------------------------------------------------------------------------
 *
 * setVCDProxyHandshakeVmxPath
 *
 *    Set the VMX path for use during the VNC connection process to a VCD console
 *    proxy.
 *    This option adds a VMX header to VNC handshake.
 *
 *    Note: Setting VMX path after connecting has no effect.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Sets the VCDProxyHandshakeVmxPath option on the vncDecoder.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.setVCDProxyHandshakeVmxPath = function (value) {
   this.options.VCDProxyHandshakeVmxPath = value;

   if (this._vncDecoder && this._vncDecoder.options) {
      this._vncDecoder.options.VCDProxyHandshakeVmxPath = value;
   }
};


/*
 *------------------------------------------------------------------------------
 *
 * disconnect
 *
 *    Disconnects the WebMKS.
 *
 *    Consumers should call this when they are done with the WebMKS
 *    component. Destroying the WebMKS will also result in a disconnect.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Disconnects from the server and tears down the WMKS UI.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.disconnect = function() {
   this._vncDecoder.disconnect();
   this.disconnectEvents();

   // Cancel any modifiers that were inflight.
   this._keyboardManager.cancelModifiers();
};


/*
 *------------------------------------------------------------------------------
 *
 * connect
 *
 *    Connects the WebMKS to a WebSocket URL.
 *
 *    Consumers should call this when they've placed the WebMKS and
 *    are ready to start displaying a stream from the guest.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Connects to the server and sets up the WMKS UI.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.connect = function(url) {
   this.disconnect();
   this._vncDecoder.connect(url);
   this.connectEvents();
};


/*
 *------------------------------------------------------------------------------
 *
 * destroy
 *
 *    Destroys the WebMKS.
 *
 *    This will disconnect the WebMKS connection (if active) and remove
 *    the widget from the associated element.
 *
 *    Consumers should call this before removing the element from the DOM.
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Disconnects from the server and removes the WMKS class and canvas
 *    from the HTML code.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.destroy = function() {
   this.disconnect();
   this.element.removeClass("wmks");

   // Remove all event handlers and destroy the touchHandler.
   this._touchHandler.destroy();
   this._touchHandler = null;

   this._relativeMouseHandler.destroy();
   this._relativeMouseHandler = null;

   this._canvas.remove();
   if (this._video) {
      this._video.remove();
   }
   if (this._backCanvas) {
      this._backCanvas.remove();
   }
   if (this._blitTempCanvas) {
      this._blitTempCanvas.remove();
   }

   $.Widget.prototype.destroy.call(this);
};


/*
 *------------------------------------------------------------------------------
 *
 * requestElementReposition
 *
 *    Reposition html element so that it fits within the canvas region. This
 *    is used to reposition upon orientation change for touch devices. This
 *    function can be used once to perform the reposition immediately or can
 *    push the element to a queue that takes care of automatically performing
 *    the necessary repositioning upon orientation.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.requestElementReposition = function(element, addToQueue) {
   if(this._touchHandler){
   if (addToQueue) {
      // Add the element to a queue. Queue elements will be repositioned upon
      // orientation change.
      this._touchHandler.addToRepositionQueue(element);
      return;
   }
   // Just perform repositioning once.
   this._touchHandler.widgetRepositionOnRotation(element);
   }
};



/*
 *------------------------------------------------------------------------------
 *
 * updateUserActivity
 *
 *    Trigger an user activity event
 *
 *
 * Side Effects:
 *    Calls any user-defined callback with current time.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.updateUserActivity = function()
{
   this._trigger("useractivity", 0, $.now());
}


/************************************************************************
 * jQuery instantiation
 ************************************************************************/

/*
 *------------------------------------------------------------------------------
 *
 * _create
 *
 *    jQuery-UI initialisation function, called by $.widget()
 *
 * Results:
 *    None.
 *
 * Side Effects:
 *    Injects the WMKS canvas into the WMKS container HTML, sets it up
 *    and connects to the server.
 *
 *------------------------------------------------------------------------------
 */

WMKS.widgetProto.id = 1;
WMKS.widgetProto._create = function() {
   var self = this;

   // Initialize our state.
   this._mouseDownBMask = 0;
   this._mousePosGuest = { x: 0, y: 0 };
   this._scale = 1.0;
   this._pixelRatio = 1.0;
   this.connected = false;
   this.isCanvasActive = false;

   this._displayScaleRatio = 1;
   this._wmksId = WMKS.widgetProto.id++;
   this._canvas = WMKS.UTIL.createCanvas(true)
      .prop({
         id:         'mainCanvas',
         tabindex:   1
      });
   this._backCanvas = WMKS.UTIL.createCanvas(true);
   this._blitTempCanvas = WMKS.UTIL.createCanvas(true);

   this.element
      .addClass("wmks")
      .append(this._canvas);

   if (this.options.enableMP4) {
      this._video = WMKS.UTIL.createVideo(true);
      this.element.append(this._video);
   }

   var checkProperty = function (prop) {
      return typeof self._canvas[0].style[prop] !== 'undefined' ? prop : null;
   };

   this.transform = (checkProperty('transform') ||
                     checkProperty('WebkitTransform') ||
                     checkProperty('MozTransform') ||
                     checkProperty('msTransform') ||
                     checkProperty('OTransform'));

   this._vncDecoder = new WMKS.VNCDecoder({
      useVNCHandshake: this.options.useVNCHandshake,
      VCDProxyHandshakeVmxPath: this.options.VCDProxyHandshakeVmxPath,
      useUnicodeKeyboardInput: this.options.useUnicodeKeyboardInput,
      enableVorbisAudioClips: this.options.enableVorbisAudioClips,
      enableOpusAudioClips: this.options.enableOpusAudioClips,
      enableAacAudioClips: this.options.enableAacAudioClips,
      enableVVC: this.options.enableVVC,
      enableUint8Utf8: this.options.enableUint8Utf8,
      enableVMWSessionClose: this.options.enableVMWSessionClose,
      enableVMWAudioMixer: this.options.enableVMWAudioMixer,
      retryConnectionInterval: this.options.retryConnectionInterval,
      sendRelativeMouseEvent: this.options.sendRelativeMouseEvent,
      canvas: this._canvas[0],
      backCanvas: this._backCanvas[0],
      blitTempCanvas: this._blitTempCanvas[0],
      mediaPlayer: (this.options.enableMP4 ? this._video[0] : null),
      enableRawH264: this.options.enableRawH264,
      enableTopologyChange: this.options.enableTopologyChange,
      multimonRenderer: this.options.multimonRenderer,
      enableH264Multimon: this.options.enableH264Multimon,
      enableSubRectangleCache: this.options.enableSubRectangleCache,
      cursorHandler: this.options.cursorHandler,
      onConnecting: function(vvc, vvcSession) {
         self._trigger("connecting", 0, { 'vvc': vvc, 'vvcSession': vvcSession });
      },
      onConnected: function() {
         self.connected = true;
         self._trigger("connected");

         // Clear any keyboard specific state that was held earlier.
         self._keyboardManager.clearState();
         self.rescaleOrResize(true);
      },
      onBeforeDisconnected: function(closeReason) {
         self._trigger("beforedisconnected", 0, closeReason);
      },
      onDisconnected: function(reason, code) {
         self.connected = false;
         self._trigger("disconnected", 0, {'reason': reason, 'code': code});
      },
      onAuthenticationFailed: function() {
         self._trigger("authenticationFailed");
      },
      onError: function(err) {
         self._trigger("error", 0, err);
      },
      onProtocolError: function() {
         self._trigger("protocolError");
      },
      onNewDesktopSize: function(width, height) {
         self._guestWidth = width;
         self._guestHeight = height;
         var attrJson = {
            width: width,
            height: height
         };
         var cssJson = {
            width: width / self._pixelRatio,
            height: height / self._pixelRatio
         };
         self._canvas
            .attr(attrJson)
            .css(cssJson);

         attrJson.y = height;
         self._backCanvas
            .attr(attrJson)
            .css(cssJson);

         self._blitTempCanvas
            .attr(attrJson)
            .css(cssJson);

         if (self._video) {
            self._video
               .attr(attrJson)
               .css(cssJson);
         }
         self._trigger("resolutionchanged", null, attrJson);
         self.rescaleOrResize(false);
      },
      onEncodingChanged: function(currentEncoding) {
         if (currentEncoding === "TightPNG" && !self.isCanvasActive) {
            WMKS.LOGGER.info("Activate canvas element " +
                             "since we use TightPNG encoding.");
            self.isCanvasActive = true;
            if (self._video) {
               self._video.hide();
            }
            self._canvas.show();
         } else if (currentEncoding === "MP4" && self.isCanvasActive) {
            WMKS.LOGGER.info("Activate video element " +
                             "since we use MP4 encoding.");
            if (self._video) {
               self.isCanvasActive = false;
               self._canvas.hide();
               self._video.show();
            } else {
               WMKS.LOGGER.error("Video element doesn't exist.");
            }
         } else if (currentEncoding === "RawH264" && self.isCanvasActive) {
            /*
             * This is only happen in a test situation, where the webMKS is
             * simulating a client that can handle raw H264.
             * Since browser don't handle raw H264 natively, we are just
             * dropping the package.
             */
            WMKS.LOGGER.info("Activate video element " +
                             "since we use raw H264 encoding.");
         }
      },
      onKeyboardLEDsChanged: function(leds) {
         self._trigger("keyboardLEDsChanged", 0, leds);
      },
      onCursorStateChanged: function(visibility) {
         if(self._touchHandler){
            self._touchHandler.setCursorVisibility(visibility);
         }
      },
      onHeartbeat: function(interval) {
         self._trigger("heartbeat", 0, interval);
      },
      onUpdateCopyPasteUI: function (noCopyUI, noPasteUI) {
         var serverSendClipboardCaps = {
            noCopyUI: noCopyUI,
            noPasteUI: noPasteUI
         }
         self._trigger("updateCopyPasteUI", 0, serverSendClipboardCaps);
      },
      onMultimonCapacityUpdated: function (enabled) {
         self._trigger("updateMultimonCapacityUI", 0, enabled);
      },
      onCopy: function(data) {
         if (typeof data !== 'string') {
            WMKS.LOGGER.debug('data format is not string, ignore.');
            return false;
         }
         self._trigger("copy", 0, data);
         return true;
      },
      onSetReconnectToken: function(token) {
         self._trigger("reconnecttoken", 0, token);
      },
      onAudio: function(audioInfo) {
         self._trigger("audio", 0, [audioInfo]);
      },
      onAudioMixer: function(audioMixerInfo) {
         self._trigger("audiomixer", 0, audioMixerInfo);
      }
   });

   // Initialize the keyboard input handler.
   this._keyboardManager = new WMKS.KeyboardManager({
      vncDecoder: this._vncDecoder,
      ignoredRawKeyCodes: this.options.ignoredRawKeyCodes,
      fixANSIEquivalentKeys: this.options.fixANSIEquivalentKeys,
      mapMetaToCtrlForKeys: this.options.mapMetaToCtrlForKeys,
      enableWindowsKey: this.options.enableWindowsKey,
      keyboardLayoutId: this.options.keyboardLayoutId
   });

   // Initialize the touch handler
   this._touchHandler = new WMKS.TouchHandler({
      widgetProto: this,
      canvas: this._canvas,
      keyboardManager: this._keyboardManager,
      onToggle: function(data) {
         self._trigger("toggle", 0, data);
      }
   });

   // Initialize the touch handler
   this._relativeMouseHandler = new WMKS.RelativeMouseHandler({
      widgetProto: this,
      canvas: this._canvas,
      keyboardManager: this._keyboardManager,
      onToggle: function(data) {
         self._trigger("toggle", 0, data);
         self._setOption('sendRelativeMouseEvent',data[1]);
         self._relativeMouseHandler.setCursorVisibility(data[1]);
      }
   });

   // The resolution handler for application to adjust the resolution
   this._resolutionHandler = this.options.resolutionHandler;

   this._updatePixelRatio();
   /*
    * Send in a request to set the new resolution size in case of fitGuest mode.
    * This avoids the need to invoke the resize after successful connection.
    */
   this.updateFitGuestSize();

   // Initialize touch features if they are enabled.
   this._relativeMouseHandler.initializeRelativeMouseFeature();
   this._updateMobileFeature(this.options.allowMobileKeyboardInput,
                             WMKS.CONST.TOUCH.FEATURE.SoftKeyboard);
   this._updateMobileFeature(this.options.allowMobileTrackpad,
                             WMKS.CONST.TOUCH.FEATURE.Trackpad);
   this._updateMobileFeature(this.options.allowMobileExtendedKeypad,
                             WMKS.CONST.TOUCH.FEATURE.ExtendedKeypad);
};/*
 *------------------------------------------------------------------------------
 *
 * wmks/dialogManager.js
 *
 *   The base controller of popup dialog.
 *
 *------------------------------------------------------------------------------
 */

(function() {
   'use strict';

   WMKS.dialogManager = function() {
      this.dialog = null;
      this.visible = false;
      this.lastToggleTime = 0;
      this.options = {
         name: 'DIALOG_MGR',     // Should be inherited.
         toggleCallback: function(name, toggleState) {},
        /*
         * The minimum wait time before toggle can repeat. This is useful to
         * ensure we do not toggle twice due to our usage of the close event.
         */
        minToggleTime: 50
      };
   };


   /*
    *---------------------------------------------------------------------------
    *
    * setOption
    *
    *    Set value of the specified option.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.setOption = function(key, value) {
      this.options[key] = value;

      return this;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * setOptions
    *
    *    Set values of a set of options.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.setOptions = function(options) {
      var key;

      for (key in options) {
         this.setOption(key, options[key]);
      }

      return this;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * initialize
    *
    *    Create the dialog and initialize it.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.initialize = function(options) {
      this.options = $.extend({},
         this.options,
         options);

      this.dialog = this.create();
      this.init();
   };


   /*
    *---------------------------------------------------------------------------
    *
    * destroy
    *
    *    Remove the dialog functionality completely.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.destroy = function() {
      if (!!this.dialog) {
         this.disconnect();
         this.remove();
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * create
    *
    *    Construct the dialog.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.create = function() {
      // For subclass to override.
      return null;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * init
    *
    *    Initialize the dialog, e.g. register event handlers.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.init = function() {
      // For subclass to override.
   };


   /*
    *---------------------------------------------------------------------------
    *
    * disconnect
    *
    *    Cleanup data and events.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.disconnect = function() {
      // For subclass to override.
   };


   /*
    *---------------------------------------------------------------------------
    *
    * remove
    *
    *    Destroy the dialog.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.remove = function() {
      var dialog = this.dialog;

      if (!!dialog) {
         // Destroy the dialog and remove it from DOM.
         dialog
            .dialog('destroy')
            .remove();
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * toggle
    *
    *    Show / hide the dialog. If the options comes with a launcher element
    *    then upon open / close, send an event to the launcher element.
    *
    *    Ex: For Blast trackpad:
    *          options = {toggleCallback: function(name, toggleState) {}}
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.toggle = function(options) {
      var dialog = this.dialog,
          show = !this.visible,
          isOpen;

      if (!dialog) {
         return;
      }

      if (!!options) {
         this.setOptions(options);
      }

      isOpen = dialog.dialog('isOpen');
      if (show === isOpen) {
         return;
      }

      if ($.now() - this.lastToggleTime < this.options.minToggleTime) {
         // WMKS.LOGGER.debug('Ignore toggle time.');
         return;
      }

      if (isOpen) {
         // Hide dialog.
         this.close();
      } else {
         // Show dialog.
         this.open();
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * sendUpdatedState
    *
    *    Helper function to maintain the state of the widget and last toggle
    *    time. If the toggleCallback option is set, we invoke a callback for the
    *    state change (dialog state: open / close)
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.sendUpdatedState = function(state) {
      this.visible = state;
      this.lastToggleTime = $.now();

      // Triggers the callback event to toggle the selection.
      if ($.isFunction(this.options.toggleCallback)) {
         this.options.toggleCallback.call(this, [this.options.name, state]);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * open
    *
    *    Show the dialog. Send update state.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.open = function() {
      if (!!this.dialog) {
         this.visible = !this.visible;
         this.dialog.dialog('open');
         this.sendUpdatedState(true);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * close
    *
    *    Hide the dialog. Send update state.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.close = function() {
      if (!!this.dialog) {
         this.visible = !this.visible;
         this.dialog.dialog('close');
         this.sendUpdatedState(false);
      }
   };

}());
/*
 *------------------------------------------------------------------------------
 *
 * wmks/extendedKeypad.js
 *
 *    The controller of extended keypad widget. This widget provides special
 *    keys that are generally not found on soft keyboards on touch devices.
 *
 *    Some of these keys include: Ctrl, Shift, Alt, Arrow keys, Page navigation
 *    Win, function keys, etc.
 *
 *    TODO:
 *    This version of the extended keypad will have fixed number of keys that it
 *    supports, and it will be nice to extend the functionality to make these
 *    keys configurable.
 *
 *------------------------------------------------------------------------------
 */

(function() {
   'use strict';

   // Constructor of this class.
   WMKS.extendedKeypad = function(params) {
      if (!params || !params.widget || !params.keyboardManager) {
         return null;
      }

      // Call constructor so dialogManager's params are included here.
      WMKS.dialogManager.call(this);

      this._widget = params.widget;
      this._kbManager = params.keyboardManager;
      this._parentElement = params.parentElement;

      // Store down modifier keys.
      this.manualModifiers = [];

      $.extend(this.options,
               {
                  name: 'EXTENDED_KEYPAD'
               });
      WMKS.LOGGER.warn('Key pad : ' + this.options.name);
   };

   // Inherit from dialogManager.
   WMKS.extendedKeypad.prototype = new WMKS.dialogManager();

   /*
    *---------------------------------------------------------------------------
    *
    * create
    *
    *    This function creates the control pane dialog with the modifier
    *    and extended keys.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.extendedKeypad.prototype.create = function() {
      var self = this,
          ctrlPaneHolder = $('<div id="ctrlPanePopup"></div>');
      // Load the control pane popup with control icons and their key events.
      ctrlPaneHolder.append(this.getControlPaneHtml());

      // Initialize the popup for opening later.
      /*
       * Adding the show or hide effect makes the dialog not draggable on iOS 5.1
       * device. This could be a bug in Mobile Safari itself? For now we get rid
       * of the effects. TODO: Do a check of the iOS type and add the effects
       * back based on the version.
       */
      ctrlPaneHolder.dialog({
         autoOpen: false,
         closeOnEscape: true,
         resizable: false,
         position: {my: 'center', at: 'center', of: this._parentElement},
         zIndex: 1000,
         dialogClass: 'ctrl-pane-wrapper',
         close: function(e) {
            /*
             * Clear all modifiers and the UI state so keys don't
             * stay 'down' when the ctrl pane is dismissed. PR: 983693
             * NOTE: Need to pass param as true to apply for softKB case.
             */
            self._kbManager.cancelModifiers(true);
            ctrlPaneHolder.find('.ab-modifier-key.ab-modifier-key-down')
               .removeClass('ab-modifier-key-down');

            // Hide the keypad.
            self.toggleFunctionKeys(false);
            self.sendUpdatedState(false);
            return true;
         },
         dragStop: function(e) {
            self.positionFunctionKeys();
         }
      });

      return ctrlPaneHolder;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * init
    *
    *    This function initializes the control pane dialog with the necessary
    *    event listeners.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.extendedKeypad.prototype.init = function() {
      var self = this,
          ctrlPaneHolder = this.dialog,
          keyInputHandler = function(e) {
            var key = parseInt($(this).attr('abkeycode'), 10);
            self._kbManager.handleSoftKb(key, false);
            return false;
         };


      // Initialize modifier key functionality.
      ctrlPaneHolder.find('.ab-modifier-key').on('touchstart', function(e) {
         // compute if key is pressed now.
         var isDown = $(this).hasClass('ab-modifier-key-down');
         var key = parseInt($(this).attr('abkeycode'), 10);
         if (isNaN(key)) {
            WMKS.LOGGER.debug('Got NaN as modifier key. Skipping it.');
            return false;
         }

         // Toggle highlight class for modifiers keys.
         $(this).toggleClass('ab-modifier-key-down');

         // Currently in down state, send isUp = true.
         self._kbManager.updateModifiers(key, isDown);
         return false;
      });

      // Toggle function keys also toggles the key highlighting.
      ctrlPaneHolder.find('#fnMasterKey').off('touchstart').on('touchstart', function(e) {
         self.toggleFunctionKeys();
         return false;
      });

      // Initialize extended key functionality.
      ctrlPaneHolder.find('.ab-extended-key').off('touchstart')
         .on('touchstart', keyInputHandler);

      // Provide a flip effect to the ctrl pane to show more keys.
      ctrlPaneHolder.find('.ab-flip').off('touchstart').on('touchstart', function() {
         $(this).parents('.flip-container').toggleClass('perform-flip');
         // Hide the keypad if its open.
         self.toggleFunctionKeys(false);
         return false;
      });

      // Add an id to the holder widget
      ctrlPaneHolder.parent().prop('id', 'ctrlPaneWidget');

      // Attach the function key pad to the canvas parent.
      ctrlPaneHolder.parent().parent().append(this.getFunctionKeyHtml());

      // Set up the function key events
      $('#fnKeyPad').find('.ab-extended-key').off('touchstart')
         .on('touchstart', keyInputHandler);

      // Handle orientation changes for ctrl pane & fnKeys.
      ctrlPaneHolder.parent().off('orientationchange.ctrlpane')
         .on('orientationchange.ctrlpane', function() {
            self._widget.requestElementReposition($(this));
            self.positionFunctionKeys();
         });
   };


   /*
    *---------------------------------------------------------------------------
    *
    * disconnect
    *
    *    Cleanup data and events for control pane dialog.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.dialogManager.prototype.disconnect = function() {
      var ctrlPaneHolder = this.dialog;

      // Turn off all events.
      ctrlPaneHolder.find('#fnMasterKey').off('touchstart');
      ctrlPaneHolder.find('.ab-extended-key').off('touchstart');
      ctrlPaneHolder.find('.ab-flip').off('touchstart');

      ctrlPaneHolder.parent().off('orientationchange.ctrlpane');

      $('#fnKeyPad').find('.ab-extended-key').off('touchstart');

   };


   /*
    *---------------------------------------------------------------------------
    * getControlPaneHtml
    *
    *    Function to get the extended control keys layout.
    *---------------------------------------------------------------------------
    */

   WMKS.extendedKeypad.prototype.getControlPaneHtml = function() {
      var str =
         '<div class="ctrl-pane flip-container">\
            <div class="flipper">\
               <div class="back">\
                  <div class="ctrl-key-top-row ab-extended-key baseKey" abkeycode="36"><div>'
                     + 'Home' + '</div></div>\
                  <div class="ctrl-key-top-row ab-extended-key baseKey" abkeycode="38">\
                     <img class="touch-sprite up-arrow"/></div>\
                  <div class="ctrl-key-top-row ab-extended-key baseKey" abkeycode="35"><div>'
                     + 'End' + '</div></div>\
                  <div class="ctrl-key-top-row ab-extended-key baseKey" abkeycode="27"><div>'
                     + 'Esc' + '</div></div>\
                  <div class="ctrl-key-bottom-row ab-extended-key baseKey" abkeycode="37">\
                     <img class="touch-sprite left-arrow"/></div>\
                  <div class="ctrl-key-bottom-row ab-extended-key baseKey" abkeycode="40">\
                     <img class="touch-sprite down-arrow"/></div>\
                  <div class="ctrl-key-bottom-row ab-extended-key baseKey" abkeycode="39">\
                     <img class="touch-sprite right-arrow"/></div>\
                  <div class="ctrl-key-bottom-row ab-flip baseKey">\
                     <img class="touch-sprite more-keys"/></div>\
               </div>\
               <div class="front">\
                  <div class="ctrl-key-top-row ab-modifier-key baseKey" abkeycode="16"><div>'
                     + 'Shift' + '</div></div>\
                  <div class="ctrl-key-top-row ab-extended-key baseKey" abkeycode="46"><div>'
                     + 'Del' + '</div></div>\
                  <div class="ctrl-key-top-row ab-extended-key baseKey" abkeycode="33"><div>'
                     + 'PgUp' + '</div></div>\
                  <div id="fnMasterKey" class="ctrl-key-top-row baseKey">\
                     <div style="letter-spacing: -1px">'
                     + 'F1-12' + '</div></div>\
                  <div class="ctrl-key-bottom-row ab-modifier-key baseKey" abkeycode="17"><div>'
                     + 'Ctrl' + '</div></div>\
                  <div class="ctrl-key-bottom-row ab-modifier-key baseKey" abkeycode="18"><div>'
                     + 'Alt' + '</div></div>\
                  <div class="ctrl-key-bottom-row ab-extended-key baseKey" abkeycode="34"><div>'
                     + 'PgDn' + '</div></div>\
                  <div class="ctrl-key-bottom-row ab-flip baseKey">\
                     <img class="touch-sprite more-keys"/></div>\
               </div>\
            </div>\
         </div>';
      return str;
   };

   /*
    *---------------------------------------------------------------------------
    * getFunctionKeyHtml
    *
    *    Function to get the extended functional keys layout.
    *---------------------------------------------------------------------------
    */

   WMKS.extendedKeypad.prototype.getFunctionKeyHtml = function() {
      var str =
         '<div class="fnKey-pane-wrapper hide" id="fnKeyPad">\
             <div class="ctrl-pane">\
                <div class="key-group up-position">\
                  <div class="border-key-top-left">\
                     <div class="fn-key-top-row ab-extended-key baseKey" abkeycode="112"><div>F1</div></div>\
                  </div>\
                  <div class="fn-key-top-row ab-extended-key baseKey" abkeycode="113"><div>F2</div></div>\
                  <div class="fn-key-top-row ab-extended-key baseKey" abkeycode="114"><div>F3</div></div>\
                  <div class="fn-key-top-row ab-extended-key baseKey" abkeycode="115"><div>F4</div></div>\
                  <div class="fn-key-top-row ab-extended-key baseKey" abkeycode="116"><div>F5</div></div>\
                  <div class="border-key-top-right">\
                     <div class="fn-key-top-row ab-extended-key baseKey" abkeycode="117"><div>F6</div></div>\
                  </div>\
                  <div class="border-key-bottom-left">\
                     <div class="fn-key-bottom-row ab-extended-key baseKey" abkeycode="118"><div>F7</div></div>\
                  </div>\
                  <div class="fn-key-bottom-row ab-extended-key baseKey" abkeycode="119"><div>F8</div></div>\
                  <div class="fn-key-bottom-row ab-extended-key baseKey" abkeycode="120"><div>F9</div></div>\
                  <div class="fn-key-bottom-row ab-extended-key baseKey" abkeycode="121"><div>F10</div></div>\
                  <div class="fn-key-bottom-row ab-extended-key baseKey" abkeycode="122"><div>F11</div></div>\
                  <div class="border-key-bottom-right">\
                     <div class="fn-key-bottom-row ab-extended-key baseKey" abkeycode="123"><div>F12</div></div>\
                  </div>\
               </div>\
            </div>\
            <div class="fnKey-inner-border-helper" id="fnKeyInnerBorder"></div>\
         </div>';
      return str;
   };

   /*
    *---------------------------------------------------------------------------
    *
    * toggleCtrlPane
    *
    *    Must be called after onDocumentReady. We go through all the objects in
    *    the DOM with the keyboard icon classes, and bind them to listeners which
    *    process them.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.extendedKeypad.prototype.toggleCtrlPane = function() {
      var ctrlPane = this.dialog;
      // Toggle ctrlPage widget.
      if (ctrlPane.dialog('isOpen')) {
         ctrlPane.dialog('close');
      } else {
         ctrlPane.dialog('open');
      }
   };

   /*
    *---------------------------------------------------------------------------
    *
    * toggleFunctionKeys
    *
    *    Toggle the function key pad between show / hide. Upon show, position the
    *    function keys to align with the ctrlPane. It also manages the
    *    highlighting state for the function key master.
    *    show - true indicates display function keys, false indicates otherwise.
    *
    *---------------------------------------------------------------------------
    */
   WMKS.extendedKeypad.prototype.toggleFunctionKeys = function(show) {
      var fnKeyPad = $('#fnKeyPad');
      var showFunctionKeys = (show || (typeof show === 'undefined' && !fnKeyPad.is(':visible')));

      // Toggle the function key pad.
      fnKeyPad.toggle(showFunctionKeys);

      // Show / Hide the masterKey highlighting
      $('#fnMasterKey').toggleClass('ab-modifier-key-down', showFunctionKeys);

      // Position only if it should be shown.
      this.positionFunctionKeys();
   };


   /*
    *---------------------------------------------------------------------------
    *
    * positionFunctionKeys
    *
    *    Position the function keys div relative to the ctrl pane. This function
    *    is invoked upon orientation change or when the widget is shows.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.extendedKeypad.prototype.positionFunctionKeys = function() {
      var fnKeys = $('#fnKeyPad'), crtlPaneWidget = $('#ctrlPaneWidget');
      // Place the function key if it's now visible
      if (fnKeys.is(':visible')) {
         /*
          * Align the bottom left corner of the function key pad
          * with the top left corner of the control pane widget.
          * If not enough room, flip to the other side.
          */
         fnKeys.position({
            my:        'right bottom',
            at:        'right top',
            of:        crtlPaneWidget,
            collision: 'flip'
         });

         // Adjust the inner border div size so it won't overlap with the outer border
         $('#fnKeyInnerBorder').height(fnKeys.height()-2).width(fnKeys.width()-2);

         // Check if the function key has been flipped. If so, use the down-style
         var fnKeyBottom = fnKeys.offset().top + fnKeys.height();
         var isAbove = (fnKeyBottom <= crtlPaneWidget.offset().top + crtlPaneWidget.height());
         this.adjustFunctionKeyStyle(isAbove);

         // Move the function key above the ctrl key pane when shown below, and under if shown above
         var targetZOrder;
         if (isAbove) {
            targetZOrder =  parseInt(crtlPaneWidget.css('z-index'), 10) - 1;
            // Use different color for the inner border depending on the position
            $('#fnKeyInnerBorder').css('border-color', '#d5d5d5');
         } else {
            targetZOrder =  parseInt($('#ctrlPaneWidget').css('z-index'), 10) + 1;
            $('#fnKeyInnerBorder').css('border-color', '#aaa');
         }

         fnKeys.css('z-index', targetZOrder.toString());
      }
      return true;
   };

   /*
    *---------------------------------------------------------------------------
    *
    * adjustFunctionKeyStyle
    *
    *    Helper function to adjust the functional key pad CSS based on the position
    *
    *---------------------------------------------------------------------------
    */

   WMKS.extendedKeypad.prototype.adjustFunctionKeyStyle = function (isAbove) {
      var fnKeys = $('#fnKeyPad');
      var keyGroup = fnKeys.find('.key-group');
      if (isAbove) {
         // Check if the "down" classes are being used. If so switch to "up" classes.
         if (keyGroup.hasClass('down-position')) {
            keyGroup.removeClass('down-position');
            keyGroup.addClass('up-position');

            fnKeys.removeClass('fnKey-pane-wrapper-down');
            fnKeys.addClass('fnKey-pane-wrapper');
         }
      } else {
         // Check if the "up" classes are being used. If so switch to "down" classes.
         if (keyGroup.hasClass('up-position')) {
            keyGroup.removeClass('up-position');
            keyGroup.addClass('down-position');

            fnKeys.removeClass('fnKey-pane-wrapper');
            fnKeys.addClass('fnKey-pane-wrapper-down');
         }
      }
   };

}());/*
 *------------------------------------------------------------------------------
 *
 * wmks/trackpadManager.js
 *
 *   The controller of trackpad widget.
 *
 *------------------------------------------------------------------------------
 */

(function() {
   'use strict';

   // Trackpad related constants.
   WMKS.CONST.TRACKPAD = {
      STATE: {
         idle:         0,
         tap:          1,
         tap_2finger:  2,
         drag:         3,
         scroll:       4
      }
   };

   WMKS.trackpadManager = function(widget, canvas) {

      // Call constructor so dialogManager's params are included here.
      WMKS.dialogManager.call(this);

      this._widget = widget;
      this._canvas = canvas;

      // Initialize cursor state.
      this._cursorPosGuest = {x : 0, y : 0};
      // Timer
      this._dragTimer = null;
      // Dragging is started by long tap or not.
      this._dragStartedByLongTap = false;
      // Trackpad state machine.
      this.state = WMKS.CONST.TRACKPAD.STATE.idle,
      this.history = [];
      // Override default options with options here.
      $.extend(this.options,
               {
                  name: 'TRACKPAD',
                  speedControlMinMovePx: 5,
                  // Speed control for trackpad and two finger scroll
                  accelerator:           10,
                  minSpeed:              1,
                  maxSpeed:              10
               });
      WMKS.LOGGER.warn('trackpad : ' + this.options.name);
   };

   WMKS.trackpadManager.prototype =  new WMKS.dialogManager();

   /*
    *---------------------------------------------------------------------------
    *
    * getTrackpadHtml
    *
    *    Function to get the trackpad html layout.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.getTrackpadHtml = function() {
      var str = '<div id="trackpad" class="trackpad-container">\
                   <div class="left-border"></div>\
                   <div id="trackpadSurface" class="touch-area"></div>\
                   <div class="right-border"></div>\
                   <div class="bottom-border">\
                      <div class="button-container">\
                         <div id="trackpadLeft" class="button-left"></div>\
                         <div id="trackpadRight" class="button-right"></div>\
                      </div>\
                   </div>\
               </div>';

      return str;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * create
    *
    *    This function initializes the trackpad dialog, toggle highlighting on close
    *    handler.
    *
    * HACK
    *    There is no easy way to determine close by menu click vs clicking close
    *    icon. Hence using the event.target to determine it was from clicking
    *    close icon. It will not work well when closeOnEscape is true. We don't
    *    need this on ipad, so its good.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.create = function() {
      var dialog,
          self = this;

      if (!this._widget ||
          !this._canvas) {
         WMKS.LOGGER.debug('Trackpad dialog creation has been aborted. Widget or Canvas is not ready.');
         return null;
      }

      dialog = $(this.getTrackpadHtml());
      dialog.dialog({
         autoOpen: false,
         closeOnEscape: true,
         resizable: false,
         position: {my: 'center', at: 'center', of: this._canvas},
         zIndex: 1000,
         draggable: true,
         dialogClass: 'trackpad-wrapper',
         close: function(e) {
            self.sendUpdatedState(false);
         },
         create: function(e) {
            self.layout($(this).parent());
         }
      });

      return dialog;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * init
    *
    *    This function initializes the event handlers for the trackpad.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.init = function() {
      var dialog = this.dialog,
          self = this,
          trackpad,
          left,
          right;

      if (!dialog) {
         WMKS.LOGGER.debug('Trackpad init aborted. Dialog is not created successfully.');
         return;
      }

      // Request reposition of trackpad dialog upon orientation changes.
      this._widget.requestElementReposition(dialog.parent(), true);

      // Initialize event handlers for the trackpad.
      trackpad = dialog
         .find('#trackpadSurface')
         .on('touchstart', function(e) {
            return self.trackpadTouchStart(e.originalEvent);
         })
         .on('touchmove', function(e) {
            return self.trackpadTouchMove(e.originalEvent);
         })
         .on('touchend', function(e) {
            return self.trackpadTouchEnd(e.originalEvent);
         });

      left = dialog
         .find('#trackpadLeft')
         .on('touchstart', function(e) {
            return self.trackpadClickStart(e, WMKS.CONST.CLICK.left);
         })
         .on('touchend', function(e) {
            return self.trackpadClickEnd(e, WMKS.CONST.CLICK.left);
         });

      right = dialog
         .find('#trackpadRight')
         .on('touchstart', function(e) {
            return self.trackpadClickStart(e, WMKS.CONST.CLICK.right);
         })
         .on('touchend', function(e) {
            return self.trackpadClickEnd(e, WMKS.CONST.CLICK.right);
         });
   };


   /*
    *---------------------------------------------------------------------------
    *
    * disconnect
    *
    *    This function unbinds the event handlers for the trackpad.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.disconnect = function() {
      var dialog = this.dialog,
          trackpad,
          left,
          right;

      if (!dialog) {
         return;
      }

      // Unregister event handlers for the trackpad.
      trackpad = dialog
         .find('#trackpadSurface')
         .off('touchmove')
         .off('touchstart')
         .off('touchend');

      left = dialog
         .find('#trackpadLeft')
         .off('touchstart')
         .off('touchend');

      right = dialog
         .find('#trackpadRight')
         .off('touchstart')
         .off('touchend');
   };


   /*
    *---------------------------------------------------------------------------
    *
    * layout
    *
    *    Reposition the dialog in order to center it to the canvas.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.layout = function(dialog) {
      var canvas = this._canvas,
          dialogParent,
          canvasParent;

      if (!dialog ||
          !canvas) {
         return;
      }

      dialogParent = dialog.parent();
      canvasParent = canvas.parent();

      if (dialogParent !== canvasParent) {
         // Append the dialog to the parent of the canvas,
         // so that it's able to center the dialog to the canvas.
         canvasParent.append(dialog);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * trackpadClickStart
    *
    *    Fires when either one of the virtual trackpad's buttons are clicked. Sends
    *    a mousedown operation and adds the button highlight.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.trackpadClickStart = function(e, buttonClick) {
      if (buttonClick !== WMKS.CONST.CLICK.left &&
          buttonClick !== WMKS.CONST.CLICK.right) {
         WMKS.LOGGER.debug('assert: unknown button ' + buttonClick);
         return false;
      }

      // Highlight click button.
      $(e.target).addClass('button-highlight');

      // Sends a mousedown message.
      this._widget.sendMouseButtonMessage(this.getMousePosition(), true, buttonClick);
      return false;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * trackpadClickEnd
    *
    *    Fires when either one of the virtual trackpad's buttons are released.
    *    Sends a mouseup operation and removes the highlight on the button.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.trackpadClickEnd = function(e, buttonClick) {
      if (buttonClick !== WMKS.CONST.CLICK.left &&
          buttonClick !== WMKS.CONST.CLICK.right) {
         WMKS.LOGGER.debug('assert: unknown button ' + buttonClick);
         return false;
      }

      // Remove highlight.
      $(e.target).removeClass('button-highlight');

      // Sends a mouseup message.
      this._widget.sendMouseButtonMessage(this.getMousePosition(), false, buttonClick);
      return false;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * computeMovingDistance
    *
    *    Based on a current point and point history, gets the amount of distance
    *    the mouse should move based on this data.
    *
    * Results:
    *    A 2-tuple of (dx, dy)
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.computeMovingDistance = function(x, y) {
      var dx, dy, dist, speed;

      dx = this.getTrackpadSpeed(x,
         this.history[0].x,
         this.history[1].x,
         this.history[2].x);
      dy = this.getTrackpadSpeed(y,
         this.history[0].y,
         this.history[1].y,
         this.history[2].y);

      dist = WMKS.UTIL.getLineLength(dx, dy);

      speed = dist * this.options.accelerator;
      if (speed > this.options.maxSpeed) {
         speed = this.options.maxSpeed;
      } else if (speed < this.options.minSpeed) {
         speed = this.options.minSpeed;
      }

      return [dx * speed, dy * speed];
   };


   /*
    *---------------------------------------------------------------------------
    *
    * getTrackpadSpeed
    *
    *    Performs a linear least squares operation to get the slope of the line
    *    that best fits all four points. This slope is the current speed of the
    *    trackpad, assuming equal time between samples.
    *
    *    Returns the speed as a floating point number.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.getTrackpadSpeed = function(x0, x1, x2, x3) {
      return x0 * 0.3 + x1 * 0.1 - x2 * 0.1 - x3 * 0.3;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * trackpadTouchStart
    *
    *    Fires when a finger lands on the trackpad's touch area. Depending on the
    *    number of touch fingers, assign the initial tap state. Subsequently
    *    ontouchmove event we promote tap --> drag, tap_2finger --> scroll.
    *    If the state was tap / tap_2finger, then its the default click event.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.trackpadTouchStart = function(e) {
      var self = this;

      if (e.targetTouches.length > 2) {
         // Dis-allow a third finger touchstart to reset scroll state.
         if (this.state === WMKS.CONST.TRACKPAD.STATE.scroll) {
            WMKS.LOGGER.debug('Ignore new touchstart, currently scrolling, touch#: '
               + e.targetTouches.length);
         } else {
            WMKS.LOGGER.debug('Aborting touch, too many fingers #: ' + e.targetTouches.length);
            this.resetTrackpadState();
         }
      } else if (e.targetTouches.length === 2) {
         // Could be a scroll. Store first finger location.
         this.state = WMKS.CONST.TRACKPAD.STATE.tap_2finger;
      } else {
         this.state = WMKS.CONST.TRACKPAD.STATE.tap;

         // ontouchmove destroys this timer. The finger must stay put.
         if (this._dragTimer !== null) {
            clearTimeout(this._dragTimer);
            this._dragTimer = null;
         }

         this._dragTimer = setTimeout(function() {
            self._dragTimer = null;

            // Send the left mousedown at the location.
            self._widget.sendMouseButtonMessage(self.getMousePosition(), true, WMKS.CONST.CLICK.left);
            self._dragStartedByLongTap = true;
         }, WMKS.CONST.TOUCH.leftDragDelayMs);
      }
      return false;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * trackpadTouchMove
    *
    *    Fires when a finger moves within the trackpad's touch area. If the touch
    *    action is currently marked as a tap, promotes it into a drag or
    *    if it was a tap_2finger, promote to a scroll. If it is already one or
    *    the other, stick to that type.
    *
    *    However, if the touch moves outside the area while dragging, then set the
    *    state back to the tap and clear up history in case user comes back into
    *    the hot region.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.trackpadTouchMove = function(e) {
      var pX, pY, newLocation,
          self = $(e.target),
          widget = this._widget;

      // Reset the drag timer if there is one.
      if (this._dragTimer !== null) {
         clearTimeout(this._dragTimer);
         this._dragTimer = null;
      }

      if (this.state === WMKS.CONST.TRACKPAD.STATE.idle) {
         return false;
      }

      pX = e.targetTouches[0].pageX;
      pY = e.targetTouches[0].pageY;
      // Verify if the touchmove is outside business (hot) region of trackpad.
      if (pY < self.offset().top || pY > (self.offset().top + self.height()) ||
            pX < self.offset().left || pX > (self.offset().left + self.width())) {
         // Reset to tap start state, as the user went outside the business region.
         if (this.state === WMKS.CONST.TRACKPAD.STATE.drag) {
            // Send mouse up event if drag is started by long tap.
            if (this._dragStartedByLongTap) {
               widget.sendMouseButtonMessage(this.getMousePosition(), false, WMKS.CONST.CLICK.left);
            }
            this.state = WMKS.CONST.TRACKPAD.STATE.tap;
            this.history.length = 0;
         }
         return false;
      }

      if (this.state === WMKS.CONST.TRACKPAD.STATE.drag) {
         newLocation = this.computeNewCursorLocation(pX, pY);

         // Perform the actual move update by sending the corresponding message.
         if (!!widget._touchHandler) {
            widget._touchHandler.moveCursor(newLocation.x, newLocation.y);
         }
         widget.sendMouseMoveMessage(newLocation);
         // WMKS.LOGGER.debug('new loc: ' + newLocation.x + ',' + newLocation.y);

         // Make room for a new history entry
         this.history.shift();

         // Push a new history entry
         this.history.push({x: pX, y: pY });
      } else if (this.state === WMKS.CONST.TRACKPAD.STATE.scroll) {
         // Sends the mouse scroll message.
         this.sendScrollMessageFromTrackpad(e.targetTouches[0]);
      }

      // Detect if this is a drag or a scroll. If so, add a history entry.
      if (this.state === WMKS.CONST.TRACKPAD.STATE.tap) {
         this.state = WMKS.CONST.TRACKPAD.STATE.drag;
         // Make up history based on the current point if there isn't any yet.
         this.history.push({x: pX, y: pY}, {x: pX, y: pY}, {x: pX, y: pY});
      } else if (this.state === WMKS.CONST.TRACKPAD.STATE.tap_2finger
            && e.targetTouches.length === 2) {
         this.state = WMKS.CONST.TRACKPAD.STATE.scroll;
         // Create a history entry based on the current point if there isn't any yet.
         this.history[0] = {x: pX, y: pY};
      }
      return false;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * computeNewCursorLocation
    *
    *    This function takes the new location and computes the destination mouse
    *    cursor location. The computation is based on the acceleration to be used,
    *    making sure the new location is within the screen area.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.computeNewCursorLocation = function(pX, pY) {
      var dist,
          point = this.getMousePosition();

      // First compute the distance from the last location.
      dist = WMKS.UTIL.getLineLength(
         (pX - this.history[2].x), (pY - this.history[2].y));
      if (isNaN(dist) || dist === 0) {
         // There is no change, return the old location.
         return point;
      } else if (dist < this.options.speedControlMinMovePx) {
         // The cursor has only moved a few pixels, apply the delta directly.
         point.x += (pX - this.history[2].x);
         point.y += (pY - this.history[2].y);
      } else {
         // From now on, though, use device pixels (later, compensate for hi-DPI)
         dist = this.computeMovingDistance(pX, pY);
         point.x += Math.floor(dist[0]);
         point.y += Math.floor(dist[1]);
      }

      return this._widget.getCanvasPosition(point.x, point.y);
   };


   /*
    *---------------------------------------------------------------------------
    *
    * trackpadTouchEnd
    *
    *    Fires when a finger lifts off the trackpad's touch area. If the touch
    *    action is currently marked as a tap, sends off the mousedown and mouseup
    *    operations. Otherwise, simply resets the touch state machine.
    *
    * Results:
    *    Always false (preventing default behavior.)
    *
    * Side Effects:
    *    None.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.trackpadTouchEnd = function(e) {
      var pos;

      // Reset the drag timer if there is one.
      if (this._dragTimer !== null) {
         clearTimeout(this._dragTimer);
         this._dragTimer = null;
      }

      if (e.targetTouches.length !== 0 ||
            this.state === WMKS.CONST.TRACKPAD.STATE.idle) {
         return false;
      }

      pos = this.getMousePosition();
      if (this.state === WMKS.CONST.TRACKPAD.STATE.tap) {
         // Send mousedown & mouseup together
         this._widget.sendMouseButtonMessage(pos, true, WMKS.CONST.CLICK.left);
         this._widget.sendMouseButtonMessage(pos, false, WMKS.CONST.CLICK.left);
      } else if (this.state === WMKS.CONST.TRACKPAD.STATE.tap_2finger) {
         // Send right-click's mousedown & mouseup together.
         this._widget.sendMouseButtonMessage(pos, true, WMKS.CONST.CLICK.right);
         this._widget.sendMouseButtonMessage(pos, false, WMKS.CONST.CLICK.right);
      } else if (this.state === WMKS.CONST.TRACKPAD.STATE.drag && this._dragStartedByLongTap) {
         this._widget.sendMouseButtonMessage(pos, false, WMKS.CONST.CLICK.left);
      }

      this.resetTrackpadState();
      return false;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * resetTrackpadState
    *
    *    Resets the virtual trackpad's state machine.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.resetTrackpadState = function() {
      this.state = WMKS.CONST.TRACKPAD.STATE.idle;
      this.history.length = 0;
      this._dragStartedByLongTap = false
   };


   /*
    *---------------------------------------------------------------------------
    *
    * sendScrollMessageFromTrackpad
    *
    *    This function is similar to the sendScrollEventMessage() used for scrolling
    *    outside the trackpad. The state machine is managed differently and hence
    *    the separate function.
    *
    *    Check if the scroll distance is above the minimum threshold, if so, send
    *    the scroll. And upon sending it, update the history with the last scroll
    *    sent location.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.sendScrollMessageFromTrackpad = function(curLocation) {
      // This is a two finger scroll, are we going up or down?
      var dx = 0,
          dy = 0,
          deltaX,
          deltaY,
          wheelDeltas,
          firstPos;

      deltaX = curLocation.pageX - this.history[0].x;
      deltaY = curLocation.pageY - this.history[0].y;

      if (!!this._widget._touchHandler) {
         wheelDeltas = this._widget._touchHandler._calculateMouseWheelDeltas(deltaX, deltaY);
         dx = wheelDeltas.wheelDeltaX;
         dy = wheelDeltas.wheelDeltaY;
      }

      // Only send if at least one of the deltas has a value.
      if (dx !== 0 || dy !== 0) {
         this._widget.sendScrollMessage(this.getMousePosition(), dx, dy);

         if (dx !== 0) {
            this.history[0].x = curLocation.pageX;
         }

         if (dy !== 0) {
            this.history[0].y = curLocation.pageY;
         }
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * getMousePosition
    *
    *    Get the current position of the mouse cursor.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.trackpadManager.prototype.getMousePosition = function() {
      var pos = this._widget._mousePosGuest;

      if (pos.x === 0 && pos.y === 0) {
         // If mouse position is not specified, the current cursor position is used.
         if (this._cursorPosGuest.x !== pos.x || this._cursorPosGuest.y !== pos.y) {
            // Send mousemove message and update state.
            pos = this._cursorPosGuest;
            this._widget.sendMouseMoveMessage(pos);
         }
      } else {
         // Mark current cursor position.
         this._cursorPosGuest = pos;
      }

      return pos;
   };

}());
'use strict';

/*
 * wmks/packet.js
 *
 *   A useful class for reading and writing binary data to and from a Uint8Array
 *
 */

/**
 * Use {@link Packet#createNewPacket} or {@link Packet#createFromBuffer}.
 * to create a new Packet.
 *
 * @classdesc A packet is a Uint8Array of binary data!
 *
 * @constructor
 * @private
 * @param {Uint8Array} buffer The buffer.
 * @param {Number}     length The length of data in the buffer.
 * @param {WMKS.Packet.BYTE_ORDER} [byteOrder] Byte order of words in buffer.
  */
WMKS.Packet = function(buffer, length, byteOrder) {
   /**
    * The length of the packet.
    * @type {Number}
    */
   this.length = length;

   /**
    * The internal buffer.
    * @private
    * @type {Uint8Array}
    */
   this._buffer = buffer;

   /**
    * The current read position of the buffer.
    * @private
    * @type {Number}
    */
   this._readPosition = 0;

   /**
    * The byte order of words in the buffer.
    * @private
    * @type {Number}
    */
   this._byteOrder = byteOrder || WMKS.Packet.BYTE_ORDER.NETWORK_ORDER;

   if (this._byteOrder == WMKS.Packet.BYTE_ORDER.LITTLE_ENDIAN) {
      this.setInt16 = this.setInt16le;
      this.setInt32 = this.setInt32le;
      this.setUint16 = this.setUint16le;
      this.setUint32 = this.setUint32le;
      this.getInt16 = this.getInt16le;
      this.getInt32 = this.getInt32le;
      this.getUint16 = this.getUint16le;
      this.getUint32 = this.getUint32le;
   } else if (this._byteOrder == WMKS.Packet.BYTE_ORDER.BIG_ENDIAN) {
      this.setInt16 = this.setInt16be;
      this.setInt32 = this.setInt32be;
      this.setUint16 = this.setUint16be;
      this.setUint32 = this.setUint32be;
      this.getInt16 = this.getInt16be;
      this.getInt32 = this.getInt32be;
      this.getUint16 = this.getUint16be;
      this.getUint32 = this.getUint32be;
   }
};


/**
 * Byte order of words in a packet.
 * @enum {Number}
 * @readonly
 */
WMKS.Packet.BYTE_ORDER = {
   LITTLE_ENDIAN: 1,
   BIG_ENDIAN: 2,
   NETWORK_ORDER: 2
};


/**
 * Create a new packet and allocates a fixed size buffer.
 *
 * @param {Number} [size=512] Size of the buffer
 * @param {WMKS.Packet.BYTE_ORDER} [byteOrder] Byte order of words in buffer.
 */
WMKS.Packet.createNewPacket = function(size, byteOrder)
{
   size = size || 512;
   return new WMKS.Packet(new Uint8Array(size), 0, byteOrder);
};


/**
 * Create a new packet with the provided buffer.
 * Intended to be used for reading data out of a Uint8Array.
 *
 * @param {Uint8Array|ArrayBuffer} buffer Buffer to use.
 * @param {WMKS.Packet.BYTE_ORDER} [byteOrder] Byte order of words in buffer.
 */
WMKS.Packet.createFromBuffer = function(buffer, byteOrder)
{
   if (buffer instanceof ArrayBuffer) {
      buffer = new Uint8Array(buffer);
   } else if (!(buffer instanceof Uint8Array)) {
      return null;
   }

   return new WMKS.Packet(buffer, buffer.length, byteOrder);
};


/**
 * Create a new big endian packet and allocates a fixed size buffer.
 *
 * @param {Number} [size=512] Size of the buffer
 */
WMKS.Packet.createNewPacketBE = function(size)
{
   return WMKS.Packet.createNewPacket(size, WMKS.Packet.BYTE_ORDER.BIG_ENDIAN);
};


/**
 * Create a new little endian packet and allocates a fixed size buffer.
 *
 * @param {Number} [size=512] Size of the buffer
 */
WMKS.Packet.createNewPacketLE = function(size)
{
   return WMKS.Packet.createNewPacket(size, WMKS.Packet.BYTE_ORDER.LITTLE_ENDIAN);
};


/**
 * Create a new big endian packet with the provided buffer.
 * Intended to be used for reading data out of a Uint8Array.
 *
 * @param {Uint8Array|ArrayBuffer} buffer Buffer to use.
 */
WMKS.Packet.createFromBufferBE = function(buffer)
{
   return WMKS.Packet.createFromBuffer(buffer, WMKS.Packet.BYTE_ORDER.BIG_ENDIAN);
};


/**
 * Create a new little endian packet with the provided buffer.
 * Intended to be used for reading data out of a Uint8Array.
 *
 * @param {Uint8Array|ArrayBuffer} buffer Buffer to use.
 */
WMKS.Packet.createFromBufferLE = function(buffer)
{
   return WMKS.Packet.createFromBuffer(buffer, WMKS.Packet.BYTE_ORDER.LITTLE_ENDIAN);
};


/**
 * Resets the packet write length and read position.
 * Does not reallocate the buffer.
 */
WMKS.Packet.prototype.reset = function()
{
   this.length = 0;
   this._readPosition = 0;
};


/**
 * Get an Uint8Array representing the whole packets content, returns only the
 * written data and not the whole buffer.
 *
 * @return {Uint8Array} The packet's data
 */

WMKS.Packet.prototype.getData = function()
{
   return this._buffer.subarray(0, this.length);
};


/**
 * Returns the amount of bytes left available for reading.
 *
 * @return {Number} The number of bytes left to read.
 */
WMKS.Packet.prototype.bytesRemaining = function()
{
   return this.length - this._readPosition;
}

/**
 * Get an ArrayBuffer representing the whole packets content, returns only the
 * written data and not the whole buffer.
 *
 * @return {ArrayBuffer} The packet's data
 */

WMKS.Packet.prototype.getDataAsArrayBuffer = function()
{
   return this._buffer.buffer.slice(this._buffer.byteOffset,
                                    this._buffer.byteOffset + this.length);
};


/**
 * Writes an 8 bit unsigned integer value to the end of the packet.
 *
 * @param {Number} value Value
 */
WMKS.Packet.prototype.writeUint8 = function(value)
{
   this._ensureWriteableBytes(1);
   this.setUint8(this.length, value);
   this.length += 1;
};


/**
 * Writes a 16 bit unsigned integer value to the end of the packet.
 *
 * @param {Number} value Value
 */
WMKS.Packet.prototype.writeUint16 = function(value)
{
   this._ensureWriteableBytes(2);
   this.setUint16(this.length, value);
   this.length += 2;
};


/**
 * Writes a 32 bit unsigned integer value to the end of the packet.
 *
 * @param {Number} value Value
 */
WMKS.Packet.prototype.writeUint32 = function(value)
{
   this._ensureWriteableBytes(4);
   this.setUint32(this.length, value);
   this.length += 4;
};


/**
 * Writes a 8 bit signed integer value to the end of the packet.
 *
 * @param {Number} value Value
 */
WMKS.Packet.prototype.writeInt8 = function(value)
{
   this._ensureWriteableBytes(1);
   this.setInt8(this.length, value);
   this.length += 1;
};


/**
 * Writes a 16 bit signed integer value to the end of the packet.
 *
 * @param {Number} value Value
 */
WMKS.Packet.prototype.writeInt16 = function(value)
{
   this._ensureWriteableBytes(2);
   this.setInt16(this.length, value);
   this.length += 2;
};


/**
 * Writes a 32 bit signed integer value to the end of the packet.
 *
 * @param {Number} value Value
 */
WMKS.Packet.prototype.writeInt32 = function(value)
{
   this._ensureWriteableBytes(4);
   this.setInt32(this.length, value);
   this.length += 4;
};


/**
 * Writes a string to the end of the packet in ASCII format.
 *
 * @param {String} value Value
 */
WMKS.Packet.prototype.writeStringASCII = function(value)
{
   var i;
   this._ensureWriteableBytes(value.length);

   for (i = 0; i < value.length; ++i) {
      this.setUint8(this.length++, value.charCodeAt(i));
   }
};


/**
 * Writes a byte array to the end of the packet.
 *
 * @param {Uint8Array} value Value
 */
WMKS.Packet.prototype.writeArray = function(value)
{
   if (value && value.length) {
      this._ensureWriteableBytes(value.length);
      this._buffer.set(value, this.length);
      this.length += value.length;
   }
};


/**
 * Reads a 8 bit value from the current read position.
 * Increases the read position by 1 byte.
 *
 * @return {Number} Value
 */
WMKS.Packet.prototype.readUint8 = function()
{
   var value;

   if (this._checkReadableBytes(1)) {
      value = this.getUint8(this._readPosition);
      this._readPosition += 1;
   }

   return value;
};


/**
 * Reads a 16 bit value from the current read position.
 * Increases the read position by 2 bytes.
 *
 * @return {Number} Value
 */
WMKS.Packet.prototype.readUint16 = function()
{
   var value;

   if (this._checkReadableBytes(2)) {
      value = this.getUint16(this._readPosition);
      this._readPosition += 2;
   }

   return value;
};


/**
 * Reads a 32 bit value from the current read position.
 * Increases the read position by 4 bytes.
 *
 * @return {Number} Value
 */
WMKS.Packet.prototype.readUint32 = function()
{
   var value;

   if (this._checkReadableBytes(4)) {
      value = this.getUint32(this._readPosition);
      this._readPosition += 4;
   }

   return value;
};


/**
 * Reads a 8 bit signed value from the current read position.
 * Increases the read position by 1 byte.
 *
 * @return {Number} Value
 */
WMKS.Packet.prototype.readInt8 = function()
{
   var value;

   if (this._checkReadableBytes(1)) {
      value = this.getInt8(this._readPosition);
      this._readPosition += 1;
   }

   return value;
};


/**
 * Reads a 16 bit signed value from the current read position.
 * Increases the read position by 2 bytes.
 *
 * @return {Number} Value
 */
WMKS.Packet.prototype.readInt16 = function()
{
   var value;

   if (this._checkReadableBytes(2)) {
      value = this.getInt16(this._readPosition);
      this._readPosition += 2;
   }

   return value;
};


/**
 * Reads a 32 bit signed value from the current read position.
 * Increases the read position by 4 bytes.
 *
 * @return {Number} Value
 */
WMKS.Packet.prototype.readInt32 = function()
{
   var value;

   if (this._checkReadableBytes(4)) {
      value = this.getInt32(this._readPosition);
      this._readPosition += 4;
   }

   return value;
};


/**
 * Reads a byte array from the current read position.
 * Increases the read position by length.
 *
 * @param  {Number}      length Length of the array to read in bytes.
 * @return {Uint8Array?}        Array
 */
WMKS.Packet.prototype.readArray = function(length)
{
   var value;

   if (this._checkReadableBytes(length)) {
      if (length === 0) {
         value = null;
      } else {
         value = this.getArray(this._readPosition, length);
         this._readPosition += length;
      }
   }

   return value;
};


/**
 * Reads an ASCII string from the current read position.
 * Increases the read position by length.
 *
 * @param  {Number} length Length of the string to read in bytes.
 * @return {String}        String
 */
WMKS.Packet.prototype.readStringASCII = function(length)
{
   var value = this.readArray(length);

   if (value) {
      value = String.fromCharCode.apply(String, value);
   }

   return value;
};


/**
 * Sets a 8 bit unsigned integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setUint8 = function(position, value)
{
   this._buffer[position] = value & 0xff;
};


/**
 * Sets a 16 bit big endian unsigned integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setUint16be = function(position, value)
{
   this._buffer[position + 1] = value & 0xff;
   this._buffer[position + 0] = (value >> 8) & 0xff;
};


/**
 * Sets a 32 bit big endian unsigned integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setUint32be = function(position, value)
{
   this._buffer[position + 3] = value & 0xff;
   this._buffer[position + 2] = (value >> 8) & 0xff;
   this._buffer[position + 1] = (value >> 16) & 0xff;
   this._buffer[position + 0] = (value >> 24) & 0xff;
};


/**
 * Sets a 16 bit little endian unsigned integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setUint16le = function(position, value)
{
   this._buffer[position + 0] = value & 0xff;
   this._buffer[position + 1] = (value >> 8) & 0xff;
};


/**
 * Sets a 32 bit little endian unsigned integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setUint32le = function(position, value)
{
   this._buffer[position + 0] = value & 0xff;
   this._buffer[position + 1] = (value >> 8) & 0xff;
   this._buffer[position + 2] = (value >> 16) & 0xff;
   this._buffer[position + 3] = (value >> 24) & 0xff;
};


/*
 * Due to how the javascript bitwise operators convert Numbers for writing
 * values we can use the same operation for signed and unsigned integers.
 */

/**
 * Sets a 8 bit signed integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setInt8 = function(position, value)
{
   return this.setUint8(position, value);
};


/**
 * Sets a 16 bit big endian signed integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setInt16be = function(position, value)
{
   return this.setUint16be(position, value);
};


/**
 * Sets a 32 bit big endian signed integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setInt32be = function(position, value)
{
   return this.setUint32be(position, value);
};


/**
 * Sets a 16 bit little endian signed integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setInt16le = function(position, value)
{
   return this.setUint16le(position, value);
};


/**
 * Sets a 32 bit little endian signed integer value at a specified position.
 *
 * @param {Number} position Position in bytes
 * @param {Number} value    Value
 */
WMKS.Packet.prototype.setInt32le = function(position, value)
{
   return this.setUint32le(position, value);
};


/**
 * Gets a subarray view from the buffer.
 *
 * @param  {Number}     start  Position in bytes
 * @param  {Number}     length Length in bytes
 * @return {Uint8Array}        The subarray
 */
WMKS.Packet.prototype.getArray = function(start, length)
{
   return this._buffer.subarray(start, start + length);
};


/**
 * Gets a 8 bit unsigned integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getInt8 = function(position)
{
   var value = this._buffer[position];

   if (value & 0x80) {
      value = value - 0xff - 1;
   }

   return value;
};


/**
 * Gets a 16 bit big endian signed integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getInt16be = function(position)
{
   var value;
   value  = this._buffer[position + 1];
   value |= this._buffer[position + 0] << 8;

   if (value & 0x8000) {
      value = value - 0xffff - 1;
   }

   return value;
};


/**
 * Gets a 32 bit big endian signed integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getInt32be = function(position)
{
   var value;
   value  = this._buffer[position + 3];
   value |= this._buffer[position + 2] << 8;
   value |= this._buffer[position + 1] << 16;
   value |= this._buffer[position + 0] << 24;
   return value;
};


/**
 * Gets a 16 bit little endian signed integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getInt16le = function(position)
{
   var value;
   value  = this._buffer[position + 0];
   value |= this._buffer[position + 1] << 8;

   if (value & 0x8000) {
      value = value - 0xffff - 1;
   }

   return value;
};


/**
 * Gets a 32 bit little endian signed integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getInt32le = function(position)
{
   var value;
   value  = this._buffer[position + 0];
   value |= this._buffer[position + 1] << 8;
   value |= this._buffer[position + 2] << 16;
   value |= this._buffer[position + 3] << 24;
   return value;
};


/**
 * Gets a 8 bit unsigned integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getUint8 = function(position)
{
   var value = this._buffer[position];
   return value;
};


/**
 * Gets a 16 bit big endian unsigned integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getUint16be = function(position)
{
   var value;
   value  = this._buffer[position + 1];
   value |= this._buffer[position + 0] << 8;
   return value;
};


/**
 * Gets a 32 bit big endian unsigned integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getUint32be = function(position)
{
   var value;
   value  = this._buffer[position + 3];
   value |= this._buffer[position + 2] << 8;
   value |= this._buffer[position + 1] << 16;
   value |= this._buffer[position + 0] << 24;

   if (value < 0) {
      value = 0xffffffff + value + 1;
   }

   return value;
};


/**
 * Gets a 16 bit little endian unsigned integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getUint16le = function(position)
{
   var value;
   value  = this._buffer[position + 0];
   value |= this._buffer[position + 1] << 8;
   return value;
};


/**
 * Gets a 32 bit little endian unsigned integer value from a position.
 *
 * @param  {Number} position Position in bytes
 * @return {Number}          Value
 */
WMKS.Packet.prototype.getUint32le = function(position)
{
   var value;
   value  = this._buffer[position + 0];
   value |= this._buffer[position + 1] << 8;
   value |= this._buffer[position + 2] << 16;
   value |= this._buffer[position + 3] << 24;

   if (value < 0) {
      value = 0xffffffff + value + 1;
   }

   return value;
};


/**
 * Changes the buffer size without modifying contents.
 *
 * @private
 * @param {Number} size New size of the buffer
 */
WMKS.Packet.prototype._resizeBuffer = function(size)
{
   if (size > 0) {
      var buffer = new Uint8Array(size);
      buffer.set(this._buffer);
      this._buffer = buffer;
   }
};


/**
 * Increases the buffer size to ensure there is enough size to write length
 * bytes in to the buffer. Grows the buffer size by factors of 1.5.
 *
 * @private
 * @param {Number} length The amount of bytes to ensure we fit in the buffer.
 */
WMKS.Packet.prototype._ensureWriteableBytes = function(length)
{
   if (length > 0) {
      var reqLength = this.length + length;
      var newLength = this._buffer.length;

      while (newLength < reqLength) {
         newLength = Math.floor(newLength * 1.5);
      }

      if (newLength > this._buffer.length) {
         this._resizeBuffer(newLength);
      }
   }
};


/**
 * Checks if we have enough bytes available to read from the buffer.
 *
 * @private
 * @param  {Number} length The number of bytes left.
 * @return {Boolean} [description]
 */
WMKS.Packet.prototype._checkReadableBytes = function(length)
{
   return this._readPosition + length <= this.length;
};
'use strict';

/**
 * Creates a new VVC instance.
 *
 * @classdesc The root VVC instance which owns listeners and sessions.
 * @constructor
 * @protected
 * @return {VVC}
 */
var VVC = function()
{
   /**
    * Array of open sessions.
    * @type {VVCSession[]}
    */
   this._sessions = [];

   /**
    * Array of active listeners.
    * @type {VVCListener[]}
    */
   this._listeners = [];

   /**
    * The last error to occur within this VVC instance and all objects it owns.
    * @type {VVCError}
    */
   this._lastError = null;

   return this;
};


/**
 * Enable probe channel.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.ENABLE_PROBE_CHANNEL = 1;


/**
 * Major version number.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.MAJOR_VER = 3;


/**
 * Minor version number.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.MINOR_VER = 0;


/**
 * Array of supported versions in objects of { MAJOR, MINOR }.
 *
 * @type {Array}
 * @readonly
 * @default
 */
VVC.SUPPORTED_VER = [
  { MAJOR: 2, MINOR: 0, FLAGS: 0 },
  { MAJOR: 1, MINOR: 0, FLAGS: 0 },
];


/**
 * Version 1 caps part 1.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CAPS_V10_1 = 0;


/**
 * Version 1 caps part 2.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CAPS_V10_2 = 0;


/**
 * Used for createListener to listen on all sessions.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.ALL_SESSIONS = -1;


/**
 * The maximum number of round trip times to remember.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.RTT_HISTORY_SIZE = 30;


/**
 * Minimum length of a channel name.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.MIN_CHANNEL_NAME_LEN = 1;


/**
 * Maximum length of a channel name.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.MAX_CHANNEL_NAME_LEN = 255;


/**
 * Maximum length of 'initialData'.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.MAX_INITIAL_DATA_LEN = 4096;


/**
 * VVC status codes.
 * @enum {Number}
 * @readonly
 */
VVC.STATUS = {
   SUCCESS:         0,
   ERROR:           1,
   OUT_OF_MEMORY:   2,
   INVALID_ARGS:    3,
   INVALID_STATE:   4,
   CLOSED:          5,
   PROTOCOL_ERROR:  6,
   TRANSPORT_ERROR: 7,
   OPEN_REJECTED:   8,
   OPEN_TIMEOUT:    9
};


/**
 * Creates a session object and wraps it around a WebSocket.
 *
 * @param  {WebSocket}   socket A valid connected WebSocket.
 * @return {?VVCSession}        The new VVCSession object.
 */
VVC.prototype.openSession = function(socket)
{
   var session;
   session = new VVCSession(this);
   session.attachToWebSocket(socket);
   this._sessions.push(session);
   return session;
};


/**
 * Closes a session.
 *
 * @param  {VVCSession} session A valid open VVCSession.
 * @return {Boolean}            Returns true on success.
 */
VVC.prototype.closeSession = function(session)
{
   var index;

   if (!(session instanceof VVCSession)) {
      this.setLastError(VVC.STATUS.INVALID_ARGS,
                         'VVC.closeSession',
                         'Invalid session, not instanceof VVCSession');
      return false;
   }

   if (session.state === VVC.SESSION_STATE.CLOSING) {
      return true;
   }

   index = this._sessions.indexOf(session);

   if (index === -1) {
      this.setLastError(VVC.STATUS.INVALID_ARGS,
                         'VVC.closeSession',
                         'Invalid session, '
                         + 'session is not registered with this vvc instance');
      return false;
   }

   session.onSessionClose();
   this._sessions = this._sessions.splice(index, 1);
   return true;
};


/**
 * Creates a listener object.
 *
 * @param  {VVCSession|VVC.ALL_SESSIONS} session A valid open VVCSession.
 * @param  {String}                      name    Name of the new listener.
 * @return {?VVCListener}                        The new VVCListener object.
 */
VVC.prototype.createListener = function(session, name)
{
   var listener, sessionListeners, i;

   if (!(session instanceof VVCSession)) {
      this.setLastError(VVC.STATUS.INVALID_ARGS,
                         'VVC.createListener',
                         'Invalid session: not an instanceof VVCSession');
      return null;
   }

   if (name.length < VVC.MIN_CHANNEL_NAME_LEN ||
       name.length > VVC.MAX_CHANNEL_NAME_LEN) {
      this.setLastError(VVC.STATUS.INVALID_ARGS,
                         'VVC.createListener',
                         'Invalid name "' + name + '",'
                         + ' length must be between ' + VVC.MIN_CHANNEL_NAME_LEN
                         + ' and ' + VVC.MAX_CHANNEL_NAME_LEN
                         + ' characters.');
      return null;
   }

   sessionListeners = this._findSessionListeners(session);

   for (i = 0; i < sessionListeners.length; ++i) {
      if (sessionListeners[i].name === name) {
         this.setLastError(VVC.STATUS.INVALID_ARGS,
                            'VVC.createListener',
                            'Invalid name "' + name + '",'
                            + ' a listener on this session'
                            + ' with this name already exists.');
         return null;
      }
   }

   listener = new VVCListener(this, session, name);
   this._listeners.push(listener);
   return listener;
};


/**
 * Closes a VVC listener.
 *
 * @param  {VVCListener} listener A valid connected VVCListener.
 * @return {Boolean}              Returns true on success.
 */
VVC.prototype.closeListener = function(listener)
{
   var index = this._listeners.indexOf(listener);

   if (!(listener instanceof VVCListener)) {
      this.setLastError(VVC.STATUS.INVALID_ARGS,
                         'VVC.closeListener',
                         'Invalid listener, not instanceof VVCListener');
      return false;
   }

   if (listener.state === VVC.LISTENER_STATE.CLOSING) {
      return true;
   }

   if (index === -1) {
      this.setLastError(VVC.STATUS.INVALID_ARGS,
                         'VVC.closeListener',
                         'Invalid listener, '
                         + 'listener is not registered with this vvc instance');
      return false;
   }

   if (listener.onclose) {
      listener.onclose();
   }

   this._listeners = this._listeners.splice(index, 1);
   return true;
};


/**
 * Finds a registered listener with a specific name.
 *
 * @protected
 * @param  {String}       name
 * @return {?VVCListener} listener
 */
VVC.prototype._findListenerByName = function(name)
{
   var listener, i;

   for (i = 0; i < this._listeners.length; ++i) {
      listener = this._listeners[i];

      if (listener.name === name) {
         return listener;
      }
   }

   return null;
};


/**
 * Finds all listeners for a session.
 *
 * @protected
 * @param  {VVCSession}    session
 * @return {VVCListener[]} listeners
 */
VVC.prototype._findSessionListeners = function(session)
{
   var listener, i, sessionListeners = [];

   for (i = 0; i < this._listeners.length; ++i) {
      listener = this._listeners[i];

      if (listener.session === VVC.ALL_SESSIONS ||
          listener.session === session) {
         sessionListeners.push(listener);
      }
   }

   return sessionListeners;
};


/**
 * Creates a new VVC Error object.
 *
 * @classdesc A container for a VVC error status.
 *
 * @constructor
 * @private
 * @param {VVC.STATUS} status The VVC status code.
 * @param {String} where      What function the error occurred in.
 * @param {String} msg        A description of the error.
 * @return {VVCError}
 */
var VVCError = function(status, where, msg)
{
   /**
    * The VVC status code.
    * @type {VVC.STATUS}
    */
   this.status = status;

   /**
    * What function the error occurred in.
    * @type {String}
    */
   this.where = where;

   /**
    * A description of what caused the error.
    * @type {String}
    */
   this.msg = msg;

   return this;
};


/**
 * Returns the last error to occur within this VVC instance and all objects
 * that it owns.
 *
 * @return {VVCError?} error
 */
VVC.prototype.getLastError = function()
{
   return this._lastError;
};


/**
 * Sets the last error.
 * Also will output the error to console.
 *
 * @protected
 * @param {VVC.STATUS} status The VVC status code.
 * @param {String} where      What function the error occurred in.
 * @param {String} msg        A full description of the error.
 */
VVC.prototype.setLastError = function(status, where, msg)
{
   this._lastError = new VVCError(status, where, msg);

   if (status !== VVC.STATUS.SUCCESS) {
      console.error(where + ': ' + msg);
   }
};
'use strict';

/**
 * Use {@link VVCSession#openChannel} to create a channel.
 *
 * @classdesc  Represents a VVC channel which exposes a websocket-like API.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket}
 *
 * @constructor
 * @protected
 * @param {VVCSession} session  Session this channel belongs to.
 * @param {String}     name     Channel name.
 * @param {Number}     priority Channel priority.
 * @param {Number}     flags    Channel flags.
 * @param {Number}     timeout  Channel connect timeout.
 * @return {VVCChannel}
 */
var VVCChannel = function(session, id, name, priority, flags, timeout)
{
   /**
    * Channel id.
    * @type {Number}
    */
   this.id = id;

   /**
    * Channel name.
    * @type {String}
    */
   this.name = name;

   /**
    * Channel priority.
    * @type {Number}
    */
   this.priority = priority || 0;

   /**
    * Channel flags.
    * @type {Number}
    */
   this.flags = flags || 0;

   /**
    * Channel timeout.
    * @type {Number}
    */
   this.timeout = timeout || 0;

   /**
    * The protocol used by the channel, currently fixed to binary.
    * @type {String}
    */
   this.protocol = 'binary';

   /**
    * The current state of the channel.
    * @type {VVC.CHANNEL_STATE}
    */
   this.state = VVC.CHANNEL_STATE.INIT;

   /**
    * Callback for when the channel opens.
    * @type {VVCChannel~onopen?}
    */
   this.onopen = this.onopen || null;

   /**
    * Callback for when the channel closes.
    * @type {VVCChannel~onclose?}
    */
   this.onclose = this.onclose || null;

   /**
    * Callback for when there is an error on the channel.
    * @type {VVCChannel~onerror?}
    */
   this.onerror = this.onerror || null;

   /**
    * Callback for when a message is received on the channel.
    * @type {VVCChannel~onmessage?}
    */
   this.onmessage = this.onmessage || null;

   /**
    * The session this channel belongs to.
    * @protected
    * @type {VVCSession}
    */
   this._session     = session;

   /**
    * The VVC instance this channel belongs to.
    * @protected
    * @type {VVC}
    */
   this._vvcInstance = session.vvcInstance;

   return this;
};


/**
 * VVCChannel state
 * @enum {Number}
 * @readonly
 */
VVC.CHANNEL_STATE = {
   INIT:         0,
   OPEN_FAILED:  1,
   OPEN:         2,
   CLOSING:      3,
   PEER_CLOSING: 4,
   PEER_CLOSED:  5,
   CLOSED:       6
};


/**
 * Sends data over a channel
 *
 * @param  {Uint8Array|ArrayBuffer} data    Data to send
 * @return {Boolean}                success True on success
 */
VVCChannel.prototype.send = function(data)
{
   return this._session.send(this, data);
};


/**
 * Closes this channel
 *
 * @return {Boolean} success True on success
 */
VVCChannel.prototype.close = function()
{
   return this._session.closeChannel(this);
};


/**
 * Called when the channel opens
 *
 * @callback VVCChannel~onopen
 * @param {Event} event
 */


/**
 * Called when the channel closes
 *
 * @callback VVCChannel~onclose
 * @param {CloseEvent} event
 */


/**
 * Called when there is an error with the channel
 *
 * @callback VVCChannel~onerror
 * @param {Event} event
 */


/**
 * Called when a message is received from the channel
 *
 * @callback VVCChannel~onmessage
 * @param {MessageEvent} event
 */
'use strict';

/**
 * This is only to be created by a VVCSession.
 *
 * @classdesc The control channel created and owned by a VVCSession.
 *
 * @constructor
 * @protected
 * @extends {VVCChannel}
 * @param {VVCSession} session The session this control channel belongs to
 * @return {VVCControlChannel}
 */
var VVCControlChannel = function(session)
{
   VVCChannel.call(this, session,
                   VVC.CONTROL_CHANNEL_ID,
                   VVC.CONTROL_CHANNEL_NAME,
                   0, 0, 0);

   this.state = VVC.CHANNEL_STATE.OPEN;

   /**
    * The negotiated major version.
    * @type {Number}
    */
   this.versionMajor = 0;


   /**
    * The negotiated minor version.
    * @type {Number}
    */
   this.versionMinor = 0;


   /**
    * The current rtt ping send time.
    * @type {Number}
    */
   this._rttSendTimeMS = 0;
};


VVCControlChannel.prototype = Object.create(VVCChannel.prototype);


/**
 * Size of CTRL header.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CTRL_HEADER_SIZE = 4;


/**
 * Control channel id.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CONTROL_CHANNEL_ID = 0;


/**
 * Control channel name.
 *
 * @type {String}
 * @readonly
 * @default
 */
VVC.CONTROL_CHANNEL_NAME = 'vvcctrl';


/**
 * Control channel message opcodes.
 * @enum {Number}
 * @readonly
 */
VVC.CTRL_OP = {
   /** Receive acknowledgement, used for bandwidth estimation */
   RECV_ACK:            0x01,

   /** Initiate VVC, first op sent from client to server */
   INIT:                0x02,

   /** Initiate VVC acknowledgement */
   INIT_ACK:            0x03,

   /** Open channel */
   OPEN_CHAN:           0x04,

   /** Open channel acknowledgement */
   OPEN_CHAN_ACK:       0x05,

   /** Open channel cancel */
   OPEN_CHAN_CANCEL:    0x06,

   /** Close channel */
   CLOSE_CHAN:          0x07,

   /** Close channel acknowledgement */
   CLOSE_CHAN_ACK:      0x08,

   /** Round trip time ping */
   RTT:                 0x09,

   /** Round trip time pong */
   RTT_ACK:             0x0A,
};


/**
 * Control channel message header flags.
 * @enum {Number}
 * @readonly
 */
VVC.CTRL_FLAG = {
   /** The control packet has data */
   ODAT:                0x80,
};


/**
 * Init extension header flags.
 * @enum {Number}
 * @readonly
 */
VVC.INIT_EXT_FLAG = {
   /** The extension has data */
   EDAT:                0x8000,
};


/**
 * Init extension types.
 * @enum {Number}
 * @readonly
 */
VVC.INIT_EXT_TYPE = {
   /** Additional supported version. */
   VERSION: 0x01,

   /** Probe channel support. */
   PROBE: 0x02,
};


/**
 * Init extension probe flags.
 * @enum {Number}
 * @readonly
 */
VVC.INIT_EXT_PROBE_FLAG = {
   /** Probe channel is supported */
   SUPPORTED:           0x01,
};


/**
 * Open channel acknowledgement status
 * @enum {Number}
 * @readonly
 */
VVC.OPEN_CHAN_STATUS = {
   SUCCESS: 0,
   REJECT:  1,
   TIMEOUT: 2,
};


/**
 * Close channel reason
 * @enum {Number}
 * @readonly
 */
VVC.CLOSE_CHAN_REASON = {
   NORMAL: 0,
   ERROR:  1,
};


/**
 * Close channel acknowledgement status
 * @enum {Number}
 * @readonly
 */
VVC.CLOSE_CHAN_STATUS = {
   SUCCESS: 0,
   ERROR:   1,
};


/**
 * Expected size of data for each control message
 * @type {Number[]}
 * @readonly
 */
VVC.CTRL_OP.SIZE = [];
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.RECV_ACK]         = 0;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.INIT]             = 12;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.INIT_ACK]         = 12;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.OPEN_CHAN]        = 20;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.OPEN_CHAN_ACK]    = 12;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.OPEN_CHAN_CANCEL] = 0;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.CLOSE_CHAN]       = 8;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.CLOSE_CHAN_ACK]   = 8;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.RTT]              = 0;
VVC.CTRL_OP.SIZE[VVC.CTRL_OP.RTT_ACK]          = 0;


/**
 * Text name of each CTRL_OP for debugging and error messages
 * @type {String[]}
 * @readonly
 */
VVC.CTRL_OP.NAME = [];
VVC.CTRL_OP.NAME[VVC.CTRL_OP.RECV_ACK]         = 'VVC.CTRL_OP.RECV_ACK';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.INIT]             = 'VVC.CTRL_OP.INIT';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.INIT_ACK]         = 'VVC.CTRL_OP.INIT_ACK';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.OPEN_CHAN]        = 'VVC.CTRL_OP.OPEN_CHAN';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.OPEN_CHAN_ACK]    = 'VVC.CTRL_OP.OPEN_CHAN_ACK';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.OPEN_CHAN_CANCEL] = 'VVC.CTRL_OP.OPEN_CHAN_CANCEL';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.CLOSE_CHAN]       = 'VVC.CTRL_OP.CLOSE_CHAN';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.CLOSE_CHAN_ACK]   = 'VVC.CTRL_OP.CLOSE_CHAN_ACK';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.RTT]              = 'VVC.CTRL_OP.RTT';
VVC.CTRL_OP.NAME[VVC.CTRL_OP.RTT_ACK]          = 'VVC.CTRL_OP.RTT_ACK';


/**
 * Sends a VVC.CTRL_OP.INIT message.
 * Requests to initiate the connection.
 *
 * @protected
 * @param  {VVC.CTRL_OP} [code] The CTRL_OP code to use so we can reuse this
 *                              function as both the INIT and INIT_ACK messages
 *                              have identical data.
 * @return {Boolean}            Returns true on successful send
 */
VVCControlChannel.prototype.sendInit = function(code)
{
   var extensionLen, i, packet;

   if (code === undefined) {
      code = VVC.CTRL_OP.INIT;
   }

   if (code !== VVC.CTRL_OP.INIT && code !== VVC.CTRL_OP.INIT_ACK) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_ARGS,
                                      'VVCControlChannel.sendInit',
                                      'Invalid code, '
                                      + ' expected INIT or INIT_ACK');
      return false;
   }

   packet = this._createControlPacket(code);
   packet.writeUint16(VVC.MAJOR_VER);
   packet.writeUint16(VVC.MINOR_VER);
   packet.writeUint32(VVC.CAPS_V10_1);
   packet.writeUint32(VVC.CAPS_V10_2);

   if (VVC.MAJOR_VER >= 2) {
      extensionLen = 16 * VVC.SUPPORTED_VER.length;

      if (VVC.ENABLE_PROBE_CHANNEL) {
         extensionLen += 8;
      }

      packet.writeUint32(extensionLen);

      // Add all supported versions
      for (i = 0; i < VVC.SUPPORTED_VER.length; ++i) {
         // Extension header
         packet.writeUint16(VVC.INIT_EXT_TYPE.VERSION);
         packet.writeUint16(VVC.INIT_EXT_FLAG.EDAT);
         packet.writeUint32(8);

         // Extension data
         packet.writeUint16(VVC.SUPPORTED_VER[i].MAJOR);
         packet.writeUint16(VVC.SUPPORTED_VER[i].MINOR);
         packet.writeUint32(VVC.SUPPORTED_VER[i].FLAGS);
      }

      // Probe channel support
      if (VVC.ENABLE_PROBE_CHANNEL) {
         packet.writeUint16(VVC.INIT_EXT_TYPE.PROBE);
         packet.writeUint16(0);
         packet.writeUint32(VVC.INIT_EXT_PROBE_FLAG.SUPPORTED);
      }
   }

   return this._sendControlPacket(packet);
};


/**
 * Sends a VVC.CTRL_OP.RTT message.
 * Used as a ping/pong system for measuring round trip times.
 *
 * @protected
 * @return {Boolean} Returns true on successful send
 */
VVCControlChannel.prototype.sendRtt = function()
{
   this._rttSendTimeMS = Date.now();
   return this._sendControlPacket(this._createControlPacket(VVC.CTRL_OP.RTT));
};


/**
 * Sends a VVC.CTRL_OP.RECV_ACK message.
 * Acknowledges receiving of chunk data.
 * Will send multiple messages if bytes is above 0xffff.
 *
 * @protected
 * @param  {Number}  bytes The number of bytes to acknowledge
 * @return {Boolean}       Returns true on successful send
 */
VVCControlChannel.prototype.sendRecvAck = function(bytes)
{
   var packet;

   while (bytes > 0xffff) {
      packet = this._createControlPacket(VVC.CTRL_OP.RECV_ACK, 0, 0xffff - 1);
      this._sendControlPacket(packet);
      bytes -= 0xffff;
   }

   if (bytes > 0) {
      packet = this._createControlPacket(VVC.CTRL_OP.RECV_ACK, 0, bytes - 1);
      this._sendControlPacket(packet);
   }

   return true;
};


/**
 * Sends a VVC.CTRL_OP.OPEN_CHAN message.
 *
 * Requests to open a new channel.
 *
 * @protected
 * @param  {VVCChannel} channel       The channel to open
 * @param  {Uint8Array} [initialData] Initial data to send with the open request
 * @return {Boolean}                  Returns true on successful send
 */
VVCControlChannel.prototype.sendOpenChannel = function(channel, initialData)
{
   var packet, initialDataLen = 0;

   if (!(channel instanceof VVCChannel)) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_ARGS,
                                      'VVCControlChannel.sendOpenChannel',
                                      'Invalid channel, '
                                      + ' expected instanceof VVCChannel');
      return false;
   }

   initialDataLen = 0;

   if (!!initialData) {
      initialDataLen = initialData.length;
   }

   packet = this._createControlPacket(VVC.CTRL_OP.OPEN_CHAN);
   packet.writeUint32(channel.id);
   packet.writeUint32(channel.priority);
   packet.writeUint32(channel.flags);
   packet.writeUint32(channel.timeout);
   packet.writeUint16(0);  // Reserved
   packet.writeUint8(0);   // Reserved2
   packet.writeUint8(channel.name.length);
   packet.writeUint32(initialDataLen);
   packet.writeStringASCII(channel.name);

   if (initialDataLen) {
      packet.writeArray(initialData);
   }

   return this._sendControlPacket(packet);
};


/**
 * Sends a VVC.CTRL_OP.OPEN_CHAN_ACK message.
 *
 * Responds to requests to open a new channel.
 *
 * @protected
 * @param  {VVCChannel}           channel       The channel to open
 * @param  {VVC.OPEN_CHAN_STATUS} status        The acknowledgement status
 * @param  {Uint8Array}           [initialData] Initial data to send with ack
 * @return {Boolean}                            Returns true on successful send
 */
VVCControlChannel.prototype.sendOpenChannelAck = function(channel,
                                                          status,
                                                          initialData)
{
   var packet = this._createControlPacket(VVC.CTRL_OP.OPEN_CHAN_ACK);
   packet.writeUint32(channel.id);
   packet.writeUint32(status);

   if (!!initialData) {
      packet.writeUint32(initialData.length);
      packet.writeArray(initialData);
   } else {
      packet.writeUint32(0);
   }

   return this._sendControlPacket(packet);
};


/**
 * Sends a VVC.CTRL_OP.CLOSE_CHAN message.
 *
 * Requests to close a channel.
 *
 * @protected
 * @param  {VVCChannel}            channel The channel to close
 * @param  {VVC.CLOSE_CHAN_REASON} reason  The reason for closing
 * @return {Boolean}                       Returns true on successful send
 */
VVCControlChannel.prototype.sendCloseChannel = function(channel, reason)
{
   var packet = this._createControlPacket(VVC.CTRL_OP.CLOSE_CHAN);
   packet.writeUint32(channel.id);
   packet.writeUint32(reason);
   return this._sendControlPacket(packet);
};


/**
 * Sends a VVC.CTRL_OP.CLOSE_CHAN message.
 *
 * Responds to a close channel request.
 *
 * @protected
 * @param  {VVCChannel}            channel The channel to close
 * @param  {VVC.CLOSE_CHAN_STATUS} status  The close acknowledgement status
 * @return {Boolean}                       Returns true on successful send
 */
VVCControlChannel.prototype.sendCloseChannelAck = function(channel, status)
{
   var packet = this._createControlPacket(VVC.CTRL_OP.CLOSE_CHAN_ACK);
   packet.writeUint32(channel.id);
   packet.writeUint32(status);
   return this._sendControlPacket(packet);
};


/**
 * Called when the control channel receives a message.
 * Reads the message header and forwards it to the correct handler function.
 * Implements VVCChannel~onmessage.
 *
 * @protected
 * @param {MessageEvent} evt
 */
VVCControlChannel.prototype.onmessage = function(evt)
{
   var packet = WMKS.Packet.createFromBuffer(evt.data);
   var opcode = packet.readUint8();
   var flags  = packet.readUint8();
   var param  = packet.readUint16();

   switch (opcode) {
      case VVC.CTRL_OP.INIT:
      case VVC.CTRL_OP.INIT_ACK:
         this._onInit(packet, opcode);
         break;
      case VVC.CTRL_OP.RTT:
         this._onRtt(packet);
         break;
      case VVC.CTRL_OP.RTT_ACK:
         this._onRttAck(packet);
         break;
      case VVC.CTRL_OP.OPEN_CHAN:
         this._onOpenChannel(packet);
         break;
      case VVC.CTRL_OP.OPEN_CHAN_ACK:
         this._onOpenChannelAck(packet);
         break;
      case VVC.CTRL_OP.CLOSE_CHAN:
         this._onCloseChannel(packet);
         break;
      case VVC.CTRL_OP.CLOSE_CHAN_ACK:
         this._onCloseChannelAck(packet);
         break;
      case VVC.CTRL_OP.RECV_ACK:
         this._onRecvAck(packet, param);
         break;
      default:
         this._session.onSessionError(VVC.STATUS.PROTOCOL_ERROR,
                                       'VVCControlChannel.onmessage',
                                       'Unknown control opcode: ' + opcode);
         return false;
   }

   return true;
};


/**
 * Called when we receive a VVC.CTRL_OP.RTT message.
 * Immediately replies with a VVC.CTRL_OP.RTT_ACK.
 *
 * @private
 * @param  {Packet}  packet  Incoming message packet
 * @return {Boolean} success Returns true on success
 */
VVCControlChannel.prototype._onRtt = function(packet)
{
   var ack;

   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.RTT, packet)) {
      return false;
   }

   ack = this._createControlPacket(VVC.CTRL_OP.RTT_ACK);
   return this._sendControlPacket(ack);
};


/**
 * Called when we receive a VVC.CTRL_OP.RTT_ACK message.
 * Records the time taken for the RTT_ACK to arrive since we sent the request.
 *
 * @private
 * @param  {Packet}  packet  Incoming message packet
 * @return {Boolean} success Returns true on success
 */
VVCControlChannel.prototype._onRttAck = function(packet)
{
   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.RTT_ACK, packet)) {
      return false;
   }

   this._session.addRttTime(Date.now() - this._rttSendTimeMS);
   return true;
};


/**
 * Called when we receive a VVC.CTRL_OP.RECV_ACK message.
 * Does nothing.
 *
 * @private
 * @param  {Packet}  packet  Incoming message packet
 * @return {Boolean} success Returns true on success
 */
VVCControlChannel.prototype._onRecvAck = function(packet, bytesReceived)
{
   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.RECV_ACK, packet)) {
      return false;
   }

   return true;
};


/**
 * Check if a major+minor version is supported.
 *
 * @private
 * @param  {Number}  major   Major version
 * @param  {Number}  minor   Minor version
 * @return {Boolean} success Returns true if version is supported.
 */
VVCControlChannel.prototype._isVersionSupported = function(major, minor)
{
   if (VVC.MAJOR_VER == major && VVC.MINOR_VER == minor) {
      return true;
   }

   for (var i = 0; i < VVC.SUPPORTED_VER.length; ++i) {
      if (VVC.SUPPORTED_VER[i].MAJOR == major
       && VVC.SUPPORTED_VER[i].MINOR == minor) {
         return true;
      }
   }

   return false;
};


/**
 * Called when we receive a VVC.CTRL_OP.INIT or VVC.CTRL_OP.INIT_ACK message.
 * If receiving an INIT then responds with an INIT_ACK message.
 * Will trigger the listener.onconnect callback.
 *
 * @private
 * @param {VVC.CTRL_OP} opcode  The opcode, expected to be INIT or INIT_ACK
 * @param {Packet}      packet  The INIT / INIT_ACK packet
 * @return {Boolean}    success Returns true on success
 */
VVCControlChannel.prototype._onInit = function(packet, opcode)
{
   var major, minor, caps1, caps2;
   var extVersions = [];

   if (!this._checkErrorMinimumSize(opcode, packet)) {
      return false;
   }

   if (!this._checkErrorSessionState(opcode, VVC.SESSION_STATE.INIT)) {
      return false;
   }

   major = packet.readUint16();
   minor = packet.readUint16();
   caps1 = packet.readUint32();
   caps2 = packet.readUint32();

   if (major >= 2) {
      var extLen;

      if (!this._checkErrorRemainingSize(opcode, packet, 4)) {
         return false;
      }

      extLen = packet.readUint32();

      if (!this._checkErrorRemainingSize(opcode, packet, extLen)) {
         return false;
      }

      // Read extension data
      while (packet.bytesRemaining() >= 8) {
         var extType, extFlags, extParam, extDataLen,
             extVerMajor, extVerMinor, extVerFlags,
             extReadPos, extReadBytes;

         // Read extension header
         extType = packet.readUint16();
         extFlags = packet.readUint16();
         extParam = packet.readUint32();

         if (extFlags & VVC.INIT_EXT_FLAG.EDAT) {
            extDataLen = extParam;
         } else {
            extDataLen = 0;
         }

         if (!this._checkErrorRemainingSize(opcode, packet, extDataLen)) {
            return false;
         }

         // Save current bytes remaining so we can skip past unread extData
         extReadPos = packet.bytesRemaining();

         switch (extType) {
         case VVC.INIT_EXT_TYPE.VERSION:
            if (!this._checkErrorRemainingSize(opcode, packet, 8)) {
               return false;
            }

            extVerMajor = packet.readUint16();
            extVerMinor = packet.readUint16();
            extVerFlags = packet.readUint32();
            extVersions.push({ major: extVerMajor, minor: extVerMinor });
            break;
         case VVC.INIT_EXT_TYPE.PROBE:
            if (extParam & VVC.INIT_EXT_PROBE_FLAG.SUPPORTED) {
               this._session.createProbeChannel();
            }
            break;
         }

         // Ensure we have fully read the extension data
         extReadBytes = extReadPos - packet.bytesRemaining();

         if (extReadBytes < extDataLen) {
            packet.readArray(extDataLen - extReadBytes);
         }
      }
   }

   // Try to find a compatible version
   this.versionMajor = 0;
   this.versionMinor = 0;

   if (this._isVersionSupported(major, minor)) {
      this.versionMajor = major;
      this.versionMinor = minor;
   } else {
      for (var i = 0; i < extVersions.length; i++) {
         extVerMajor = extVersions[i].major;
         extVerMinor = extVersions[i].minor;

         if (this._isVersionSupported(extVerMajor, extVerMinor)) {
            if (extVerMajor >= this.versionMajor
             && extVerMinor >= this.versionMinor) {
               this.versionMajor = extVerMajor;
               this.versionMinor = extVerMinor;
            }
         }
      }
   }

   if (this.versionMajor == 0 && this.versionMinor == 0) {
      this._vvcInstance.setLastError(VVC.STATUS.PROTOCOL_ERROR,
                                     'VVCControlChannel._onInit',
                                     'Failed to negotiate compatible protocol '
                                     + ' version.');

      return false;
   }

   if (opcode === VVC.CTRL_OP.INIT) {
      this.sendInit(VVC.CTRL_OP.INIT_ACK);
   }

   this._session.onConnect();
   return true;
};


/**
 * Called when we receive a VVC.CTRL_OP.OPEN_CHAN message.
 * Will trigger the listener.onpeeropen callback.
 *
 * @private
 * @param  {Packet}  packet  Incoming message packet
 * @return {Boolean} success Returns true on success
 */
VVCControlChannel.prototype._onOpenChannel = function(packet)
{
   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.OPEN_CHAN, packet)) {
      return false;
   }

   var name, initialData, channel,
       id             = packet.readUint32(),
       priority       = packet.readUint32(),
       flags          = packet.readUint32(),
       timeout        = packet.readUint32(),
       reserved       = packet.readUint16(),
       reserved2      = packet.readUint8(),
       nameLen        = packet.readUint8(),
       initialDataLen = packet.readUint32();

   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.OPEN_CHAN, packet,
                                    nameLen + initialDataLen)) {
      return false;
   }

   name         = packet.readStringASCII(nameLen);
   initialData  = packet.readArray(initialDataLen);

   channel      = this._session.createChannel(id,
                                              name,
                                              priority,
                                              flags,
                                              timeout);
   channel.initialData = initialData;
   this._session.onPeerOpen(channel);
   return true;
};


/**
 * Called when we receive a VVC.CTRL_OP.OPEN_CHAN_ACK message.
 * Will trigger the channel.onopen callback.
 *
 * @private
 * @param  {Packet}  packet  Incoming message packet
 * @return {Boolean} success Returns true on success
 */
VVCControlChannel.prototype._onOpenChannelAck = function(packet)
{
   var id, status, initialDataLen, initialData;

   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.OPEN_CHAN_ACK, packet)) {
      return false;
   }

   id             = packet.readUint32();
   status         = packet.readUint32();
   initialDataLen = packet.readUint32();

   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.OPEN_CHAN_ACK, packet,
                                    initialDataLen)) {
      return false;
   }

   initialData = packet.readArray(initialDataLen);

   if (!this._checkErrorValidChannel(VVC.CTRL_OP.OPEN_CHAN_ACK, id,
                                     VVC.CHANNEL_STATE.INIT)) {
      return false;
   }

   this._session.onChannelOpen(this._session.getChannel(id),
                               status,
                               initialData);
   return true;
};


/**
 * Called when we receive a VVC.CTRL_OP.CLOSE_CHAN message.
 * Will trigger the channel.onclose callback.
 *
 * @private
 * @param  {Packet}  packet  Incoming message packet
 * @return {Boolean} success Returns true on success
 */
VVCControlChannel.prototype._onCloseChannel = function(packet)
{
   var id, reason;

   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.CLOSE_CHAN, packet)) {
      return false;
   }

   id     = packet.readUint32();
   reason = packet.readUint32();

   if (!this._checkErrorValidChannel(VVC.CTRL_OP.CLOSE_CHAN, id)) {
      return false;
   }

   this._session.onChannelClose(this._session.getChannel(id), reason);
   return true;
};


/**
 * Called when we receive a VVC.CTRL_OP.CLOSE_CHAN_ACK message.
 * Will trigger the channel.onclose callback.
 *
 * @private
 * @param  {Packet}  packet  Incoming message packet
 * @return {Boolean} success Returns true on success
 */
VVCControlChannel.prototype._onCloseChannelAck = function(packet)
{
   var id, status;

   if (!this._checkErrorMinimumSize(VVC.CTRL_OP.CLOSE_CHAN_ACK, packet)) {
      return false;
   }

   id     = packet.readUint32();
   status = packet.readUint32();

   if (!this._checkErrorValidChannel(VVC.CTRL_OP.CLOSE_CHAN_ACK, id,
                                     VVC.CHANNEL_STATE.CLOSING)) {
      return false;
   }

   this._session.onChannelClose(this._session.getChannel(id),
                                status);

   return true;
};


/**
 * Checks that the size of the incoming packet is correct.
 * Triggers a session error if the size is unexpected.
 *
 * @private
 * @param  {VVC.CTRL_OP} opcode      The message opcode
 * @param  {Packet}      packet      The packet to check
 * @param  {Number}      [extraSize] Extra size needed
 * @return {Boolean}     success     Returns true on correct size
 */
VVCControlChannel.prototype._checkErrorMinimumSize = function(opcode,
                                                              packet,
                                                              extraSize)
{
   var packetSize = packet.length - 4;
   var expectSize = VVC.CTRL_OP.SIZE[opcode];
   extraSize      = extraSize || 0;

   if (packetSize < expectSize + extraSize) {
      var name = VVC.CTRL_OP.NAME[opcode];

      this._session.onSessionError(VVC.STATUS.PROTOCOL_ERROR,
                                    'VVCControlChannel._checkErrorMinimumSize',
                                    'Received invalid ' + name + ' message, '
                                     + 'message too small, received '
                                     + packetSize + ' bytes, expected '
                                     + expectSize + ' + ' + extraSize);
      return false;
   }

   return true;
};


/**
 * Checks that the remaining size of a packet is large enough.
 * Triggers a session error if the size is unexpected.
 *
 * @private
 * @param  {VVC.CTRL_OP} opcode      The message opcode
 * @param  {Packet}      packet      The packet to check
 * @param  {Number}      size        Size needed
 * @return {Boolean}     success     Returns true on valid size
 */
VVCControlChannel.prototype._checkErrorRemainingSize = function(opcode,
                                                                packet,
                                                                size)
{
   var remaining = packet.bytesRemaining();

   if (remaining < size) {
      var name = VVC.CTRL_OP.NAME[opcode];

      this._session.onSessionError(VVC.STATUS.PROTOCOL_ERROR,
                                    'VVCControlChannel._checkErrorRemainingSize',
                                    'Received invalid ' + name + ' message, '
                                     + 'message too small, expected '
                                     + (size - remaining) + ' more bytes.');
      return false;
   }

   return true;
};


/**
 * Checks the session state.
 * Triggers a session error if the state is invalid.
 *
 * @private
 * @param  {VVC.CTRL_OP}        opcode  The message opcode
 * @param  {VVC.SESSSION_STATE} state   The state to check
 * @return {Boolean}            success Returns true on valid session state
 */
VVCControlChannel.prototype._checkErrorSessionState = function(opcode,
                                                               state)
{
   var opname = VVC.CTRL_OP.NAME[opcode];

   if (this._session.state !== state) {
      this._session.onSessionError(VVC.STATUS.PROTOCOL_ERROR,
                                    'VVCControlChannel._checkErrorSessionState',
                                    'Received invalid ' + opname + ' message, '
                                     + 'invaild session state, '
                                     + 'found ' + this._session.state
                                     + ' expected ' + state);
      return false;
   }

   return true;
};


/**
 * Checks if the channel id is valid.
 * Ensures it is not the control channel.
 * Ensures channel exists.
 * Optionally checks the channel state;
 *
 * @private
 * @param  {VVC.CTRL_OP}       opcode  The message opcode
 * @param  {Number}            id      The channel id to check
 * @param  {VVC.CHANNEL_STATE} [state] The state the channel must be in
 * @return {Boolean}           success Returns true on valid channel id.
 */
VVCControlChannel.prototype._checkErrorValidChannel = function(opcode,
                                                               id,
                                                               state)
{
   var opname  = VVC.CTRL_OP.NAME[opcode];
   var channel = this._session.getChannel(id);

   if (id === VVC.CONTROL_CHANNEL_ID) {
      this._session.onSessionError(VVC.STATUS.PROTOCOL_ERROR,
                                    'VVCControlChannel._checkErrorValidChannel',
                                    'Received invalid ' + opname + ' message, '
                                     + 'unexpected use of control channel id');
      return false;
   }

   if (!channel) {
      this._session.onSessionError(VVC.STATUS.PROTOCOL_ERROR,
                                    'VVCControlChannel._checkErrorValidChannel',
                                    'Received invalid ' + opname + ' message, '
                                     + 'unknown channel ' + id);
      return false;
   }

   if (state !== undefined && channel.state !== state) {
      this._session.onSessionError(VVC.STATUS.PROTOCOL_ERROR,
                                    'VVCControlChannel._checkErrorValidChannel',
                                    'Received invalid ' + opname + ' message, '
                                     + 'unexpected channel state, '
                                     + 'found ' + channel.state + ' '
                                     + ' expected ' + state);
      return false;
   }

   return true;
};


/**
 * Creates a control packet.
 * Returns a new instance of Packet and inserts the control message header.
 *
 * @private
 * @param  {VVC.CTRL_OP} code
 * @param  {Number}      [flags]
 * @param  {Number}      [param]
 * @return {Packet}
 */
VVCControlChannel.prototype._createControlPacket = function(code, flags, param)
{
   var packet = WMKS.Packet.createNewPacket();

   param = param || 0;
   flags = flags || 0;

   packet.control = {
      code:  code,
      flags: flags,
      param: param
   };

   packet.writeUint8(code);
   packet.writeUint8(flags);
   packet.writeUint16(param);

   return packet;
};


/**
 * Send a control packet.
 * Automatically updates the length and data flag if required and then sends the
 * control packet using the normal VVCChannel.send.
 *
 * @private
 * @param  {Packet}  packet The packet to send
 * @return {Boolean}        Returns true on successful send
 */
VVCControlChannel.prototype._sendControlPacket = function(packet)
{
   if (packet.length > VVC.CTRL_HEADER_SIZE) {
      packet.control.flags |= VVC.CTRL_FLAG.ODAT;
      packet.control.param = packet.length - VVC.CTRL_HEADER_SIZE;
   }

   packet.setUint8(1, packet.control.flags);
   packet.setUint16(2, packet.control.param);

   return this.send(packet.getData());
};
'use strict';

/**
 * Use {@link VVC#createListener} to create a listener.
 *
 * @classdesc A VVC listener provides callbacks to notifiy the user about events
 *            on one or more VVC sessions.
 *
 * @constructor
 * @protected
 * @param  {VVC}                         vvcInstance The owner VVC instance
 * @param  {VVCSession|VVC.ALL_SESSIONS} session     Session to listen to
 * @param  {String}                      name        Name of the new listener
 * @return {VVCListener}
 */

var VVCListener = function(vvcInstance, session, name)
{
   /**
    * Listener name.
    * @type {String}
    */
   this.name    = name;

   /**
    * Session to listen to.
    * @type {VVCSession|VVC.ALL_SESSIONS}
    */
   this.session = session;

   /**
    * Listener state.
    * @type {VVC.LISTENER_STATE}
    */
   this.state   = VVC.LISTENER_STATE.ACTIVE;

   /**
    * Called when the VVC connection has been established on a session that is
    * being listened to.
    * @type {VVCListener~onconnect?}
    */
   this.onconnect = null;

   /**
    * Called when the remote peer opens a channel on a session that is being
    * listened to.
    * @type {VVCListener~onpeeropen?}
    */
   this.onpeeropen = null;

   /**
    * Called when the listener closes.
    * @type {VVCListener~onclose?}
    */
   this.onclose = null;

   /**
    * The VVC instance this listener belongs to.
    * @type {VVC}
    */
   this._vvcInstance = vvcInstance;

   return this;
};


/**
 * VVCListener state.
 * @enum {Number}
 * @readonly
 */
VVC.LISTENER_STATE = {
   INIT:    0,
   ACTIVE:  1,
   CLOSING: 2
};


/**
 * Closes the listener.
 *
 * @return {Boolean} Success
 */
VVCListener.prototype.close = function()
{
   return this._vvcInstance.closeListener(this);
};


/**
 * Matches the listeners name to the given name.
 * Listener name can have wildcards.
 *
 * @param  {String}  name    The given name to match against.
 * @return {Boolean} matches Returns true if the name matches.
 */
VVCListener.prototype.matchName = function(name)
{
   var wildcard = this.name.indexOf('*');

   if (wildcard !== -1) {
      return this.name.substr(0, wildcard) === name.substring(0, wildcard);
   }

   return this.name === name;
};


/**
 * Called when the VVC connection has been established on a session
 *
 * @callback VVCListener~onconnect
 * @param {VVCSession} session The session which has connected
 */


/**
 * Called when the remote peer opens a channel on a session
 *
 * @callback VVCListener~onpeeropen
 * @param {VVCSession} session The session on which the channel was created
 * @param {VVCChannel} channel The new channel which is being created
 */


/**
 * Called when the listener is closed
 *
 * @callback VVCListener~onclose
 */
'use strict';

/**
 * This is only to be created by a VVCSession.
 *
 * @classdesc The probe channel created and owned by a VVCSession.
 *
 * @constructor
 * @protected
 * @extends {VVCChannel}
 * @param {VVCSession} session The session this probe channel belongs to
 * @return {VVCProbeChannel}
 */
var VVCProbeChannel = function(session)
{
   VVCChannel.call(this, session,
                   VVC.PROBE_CHANNEL_ID,
                   VVC.PROBE_CHANNEL_NAME,
                   0, 0, 0);

   this.state = VVC.CHANNEL_STATE.OPEN;
};


VVCProbeChannel.prototype = Object.create(VVCChannel.prototype);

/**
 * Probe channel id.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.PROBE_CHANNEL_ID = 1;


/**
 * Probe channel name.
 *
 * @type {String}
 * @readonly
 * @default
 */
VVC.PROBE_CHANNEL_NAME = 'vvcprobe';
'use strict';

/**
 * Use {@link VVC#openSession} to create a session.
 *
 * @classdesc A VVC session represents a physical connection to a remote server
 *
 * @constructor
 * @protected
 * @param {VVC}    vvcInstance The owner VVC instance
 * @param {Object} options     Optional settings
 * @return {VVCSession}
 */
var VVCSession = function(vvcInstance, options)
{
   var server = false;

   if (options) {
      if ('server' in options) {
         server = options.server;
      }
   }

   /**
    * The current state of the session.
    * @type {VVC.SESSION_STATE}
    */
   this.state = VVC.SESSION_STATE.INIT;

   /**
    * Callback for when an error occurs on the session.
    * @type {VVCSession~onerror?}
    */
   this.onerror = null;

   /**
    * Callback for when the transport closes.
    * @type {VVCSession~ontransportclose?}
    */
   this.ontransportclose = null;

   /**
    * Callback for when there is an error on the transport.
    * @type {VVCSession~ontransporterror?}
    */
   this.ontransporterror = null;

   /**
    * The VVC instance this session belongs to.
    * @private
    * @type {VVC}
    */
   this._vvcInstance     = vvcInstance;

   /**
    * Is this session a server or client.
    * @private
    * @type {Boolean}
    */
   this._server          = server;

   /**
    * The channels opened on this session.
    * @private
    * @type {VVCChannel[]}
    */
   this._channels        = [];

   /**
    * Used for unique channel id generation, always an odd or even number
    * depending on whether we are server or client respectively.
    * @private
    * @type {Number}
    */
   this._channelIdCtrl   = this._server ? 3 : 2;

   /**
    * Bytes read of current chunk.
    * @private
    * @type {Number}
    */
   this._bytesRead       = 0;

   /**
    * Bytes requested of current chunk.
    * @private
    * @type {Number}
    */
   this._bytesRequested  = VVC.CHUNK_COMMON_HEADER_SIZE;

   /**
    * History of round trip times, limited to VVC.RTT_HISTORY_SIZE.
    * @private
    * @type {Number[]}
    */
   this._rttHistory      = [];

   /**
    * Current index used for the circular buffer of VVCSession._rttHistory.
    * @private
    * @type {Number[]}
    */
   this._rttHistoryIndex = 0;

   /**
    * Current read chunk.
    * @private
    * @type {Object}
    */
   this._chunk = {};
   this._chunk.channel = 0;
   this._chunk.flags   = 0;
   this._chunk.length  = 0;
   this._chunk.ext = {};
   this._chunk.ext.code   = 0;
   this._chunk.ext.flags  = 0;
   this._chunk.ext.param  = 0;
   this._chunk.ext.length = 0;

   /**
    * Reusable buffers for reading and writing.
    * @private
    * @type {Object}
    */
   this._buffers = {};
   this._buffers.ext = null;
   this._buffers.data = [];
   this._buffers.send = WMKS.Packet.createNewPacket(32);
   this._buffers.header = WMKS.Packet.createNewPacket(VVC.CHUNK_COMMON_HEADER_SIZE +
                                                      VVC.CHUNK_LARGE_HEADER_SIZE +
                                                      VVC.CHUNK_EXTENSION_HEADER_SIZE);

   /**
    * The current receive state.
    * @private
    * @type {VVC.SESSION_RECEIVE_STATE}
    */
   this._receiveState = VVC.SESSION_RECEIVE_STATE.COMMON_HEADER;
   this._setReceiveState(VVC.SESSION_RECEIVE_STATE.COMMON_HEADER);

   return this;
};


/**
 * Size of the COMMON chunk header.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CHUNK_COMMON_HEADER_SIZE = 4;


/**
 * Size of the LARGE chunk header.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CHUNK_LARGE_HEADER_SIZE = 4;


/**
 * Size of the EXTENSION chunk header.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CHUNK_EXTENSION_HEADER_SIZE = 4;


/**
 * Maximum COMMON chunk data length.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CHUNK_MAX_LEN = 0x00010000;


/**
 * Maximum LARGE chunk data length.
 *
 * @type {Number}
 * @readonly
 * @default
 */
VVC.CHUNK_LARGE_MAX_LEN = 0xfffffc00;


/**
 * VVCSession state
 * @enum {Number}
 * @readonly
 */
VVC.SESSION_STATE = {
   INIT:        0,
   ESTABLISHED: 1,
   ERROR:       2,
   CLOSING:     3
};


/**
 * VVCSession receive state
 * @enum {Number}
 * @readonly
 */
VVC.SESSION_RECEIVE_STATE = {
   COMMON_HEADER:    0,
   LARGE_HEADER:     1,
   EXTENSION_HEADER: 2,
   EXTENSION_DATA:   3,
   DATA:             4
};


/**
 * Chunk header flags
 * @enum {Number}
 * @readonly
 */
VVC.CHUNK_FLAG = {
   /** Chunk and extension data are padded to a multiple of 4 */
   PAD: 0x10,

   /** Extension header is present */
   EXT: 0x20,

   /** Large chunk data length is present */
   LC:  0x40,

   /** Indicates last chunk in a message */
   FIN: 0x80,
};


/**
 * Chunk extension header flags
 * @enum {Number}
 * @readonly
 */
VVC.CHUNK_EXT_FLAG = {
   /** This is the last chunk extension header */
   ELST: 0x40,

   /** Extension data is present */
   EDAT: 0x80,
};


/**
 * Chunk extension codes
 * @enum {Number}
 * @readonly
 */
VVC.CHUNK_EXT_CODE = {
   /** Use a large 32 bit channel id */
   LARGE_CHANNEL_ID: 0x01,
};


/**
 * Closes the session
 *
 * @return {Boolean} Returns true on success
 */
VVCSession.prototype.close = function()
{
   return this._vvcInstance.closeSession(this);
};


/**
 * Opens a channel on this session
 *
 * @param  {String}      name          Name of the channel to open
 * @param  {Number}      [priority]    Priority of the channel
 * @param  {Number}      [flags]       Channel flags
 * @param  {Number}      [timeout]     Channel timeout
 * @param  {Uint8Array}  [initialData] Data to send with the open request
 * @return {?VVCChannel}               A VVCChannel object, or null on error.
 */
VVCSession.prototype.openChannel = function(name,
                                            priority,
                                            flags,
                                            timeout,
                                            initialData)
{
   var channel;

   priority    = priority || 0;
   flags       = flags || 0;
   timeout     = timeout || 0;
   initialData = initialData || null;

   if (!this._checkErrorNameLength('openChannel', name)) {
      return null;
   }

   if (!this._checkErrorSessionState('openChannel',
                                     VVC.SESSION_STATE.ESTABLISHED)) {
      return null;
   }

   if (!this._checkErrorInitialData('openChannel', initialData)) {
      return null;
   }

   channel = this.createChannel(this._nextChannelId(),
                                name,
                                priority,
                                flags,
                                timeout);

   this.controlChannel.sendOpenChannel(channel, initialData);
   return channel;
};


/**
 * Accepts a channel on this session
 *
 * @param  {VVCChannel}  channel       The channel provided by onpeeropen
 * @param  {Number}      [flags]       Accept channel flags
 * @param  {Uint8Array}  [initialData] Data to send with the accept message
 * @return {?VVCChannel}               A VVCChannel object, or null on error.
 */
VVCSession.prototype.acceptChannel = function(channel,
                                              flags,
                                              initialData)
{
   flags       = flags || 0;
   initialData = initialData || null;

   if (!this._checkErrorSessionState('acceptChannel',
                                     VVC.SESSION_STATE.ESTABLISHED)) {
      return null;
   }

   if (!this._checkErrorInitialData('acceptChannel', initialData)) {
      return null;
   }

   if (!this._checkErrorIsChannel('acceptChannel', channel)) {
      return null;
   }

   this.controlChannel.sendOpenChannelAck(channel,
                                          VVC.OPEN_CHAN_STATUS.SUCCESS,
                                          initialData);

   this.onChannelOpen(channel,
                      VVC.OPEN_CHAN_STATUS.SUCCESS,
                      channel.initialData);

   delete channel.initialData;
   return channel;
};


/**
 * Rejects a channel open request
 *
 * @param  {VVCChannel} channel       The channel to reject opening
 * @param  {Uint8Array} [initialData] Data to send with the reject channel op
 * @return {Boolean}                  Returns true on succes
 */
VVCSession.prototype.rejectChannel = function(channel, initialData)
{
   initialData = initialData || null;

   if (!this._checkErrorSessionState('rejectChannel',
                                     VVC.SESSION_STATE.ESTABLISHED)) {
      return false;
   }

   if (!this._checkErrorInitialData('rejectChannel', initialData)) {
      return false;
   }

   if (!this._checkErrorIsChannel('rejectChannel', channel)) {
      return false;
   }

   this.controlChannel.sendOpenChannelAck(channel,
                                          VVC.OPEN_CHAN_STATUS.REJECT,
                                          initialData);

   channel.state = VVC.CHANNEL_STATE.CLOSED;
   this._releaseChannel(channel);
   return true;
};


/**
 * Closes a channel
 *
 * @param  {VVCChannel} channel A valid VVCChannel to close
 * @return {Boolean}            Returns true on success
 */
VVCSession.prototype.closeChannel = function(channel)
{
   if (!this._checkErrorSessionState('closeChannel',
                                     VVC.SESSION_STATE.ESTABLISHED)) {
      return false;
   }

   if (!this._checkErrorIsChannel('closeChannel', channel)) {
      return false;
   }

   if (!this._checkErrorChannelState('closeChannel', channel,
                                     VVC.CHANNEL_STATE.OPEN)) {
      return false;
   }

   channel.state = VVC.CHANNEL_STATE.CLOSING;
   this.controlChannel.sendCloseChannel(channel, VVC.CLOSE_CHAN_REASON.NORMAL);
   return true;
};


/**
 * Add a RTT time to our circular buffer history.
 *
 * @protected
 * @param {Number} rttMS
 */
VVCSession.prototype.addRttTime = function(rttMS)
{
   this._rttHistory[this._rttHistoryIndex] = rttMS;
   this._rttHistoryIndex++;

   if (this._rttHistoryIndex >= VVC.RTT_HISTORY_SIZE) {
      this._rttHistoryIndex = 0;
   }
};


/**
 * Attaches the session to a websocket.
 * Modifies the websocket's callbacks to point to our internal functions.
 * Sets the websocket's binary type to ArrayBuffer.
 *
 * @protected
 * @param  {WebSocket} socket   A websocket to attach to.
 * @return {Boolean}            Returns true on success.
 */
VVCSession.prototype.attachToWebSocket = function(socket)
{
   var self = this;
   this.socket = socket;

   socket.onopen = function(evt) {
      this.binaryType = 'arraybuffer';
      self._onTransportOpen();
   };

   socket.onclose = function(evt) {
      self._onTransportClose(evt);
   };

   socket.onerror = function(evt) {
      self._onTransportError(evt);
   };

   socket.onmessage = function(evt) {
      if (!(evt.data instanceof ArrayBuffer)) {
         throw 'Expected ArrayBuffer from websocket';
      }

      self._onTransportRecv(new Uint8Array(evt.data));
   };

   // If socket is already open lets fake call onopen to start our session
   if (socket.readyState) {
      socket.onopen({});
   }

   return true;
};


/**
 * Generates an id value for a new channel.
 *
 * @private
 * @return {Number} New channel id
 */
VVCSession.prototype._nextChannelId = function()
{
   var id = this._channelIdCtrl;
   this._channelIdCtrl += 2;
   return id;
};


/**
 * Creates a VVCChannel object and adds it to the channel list.
 *
 * @protected
 * @param  {Number}     id
 * @param  {String}     name
 * @param  {Number}     [priority]
 * @param  {Number}     [flags]
 * @param  {Number}     [timeout]
 * @return {VVCChannel}
 */
VVCSession.prototype.createChannel = function(id,
                                              name,
                                              priority,
                                              flags,
                                              timeout)
{
   var channel;

   priority = priority || 0;
   timeout  = timeout || 0;
   flags    = flags || 0;

   channel = new VVCChannel(this, id, name, priority, flags, timeout);
   this._channels[id] = channel;
   this._buffers.data[id] = [];
   return channel;
};


/**
 * Removes a channel from this session
 *
 * @private
 * @param  {VVCChannel} channel
 */
VVCSession.prototype._releaseChannel = function(channel)
{
   if (channel.state === VVC.CHANNEL_STATE.OPEN) {
      this._vvcInstance.setLastError(VVC.STATUS.PROTOCOL_ERROR,
                                     'VVCSession._releaseChannel',
                                     'Releasing an open channel!');
   }

   delete this._channels[channel.id];
   delete this._buffers.data[channel.id];
};


/**
 * Gets a channel by id
 *
 * @protected
 * @param  {Number}      id      Channel ID
 * @return {?VVCChannel} channel
 */
VVCSession.prototype.getChannel = function(id)
{
   if (!!this._channels[id]) {
      return this._channels[id];
   }

   return null;
};


/**
 * Called when there is a error within the session.
 * Triggers the session.onerror callback.
 *
 * @protected
 * @param {VVC.STATUS} status  Error status code
 * @param {String}     where   Where the error occurred
 * @param {String}     message A hopefully useful description of error
 */
VVCSession.prototype.onSessionError = function(status, where, message)
{
   this.state = VVC.SESSION_STATE.ERROR;
   this._vvcInstance.setLastError(status, where, message);

   if (this.onerror) {
      this.onerror(status);
   }
};


/**
 * Called when the session is closed.
 * Closes all open channels and calls either channel.onerror or channel.onclose
 *
 * @protected
 */
VVCSession.prototype.onSessionClose = function()
{
   var channel, closeChanReason, i;

   if (this.state === VVC.SESSION_STATE.ERROR) {
      closeChanReason = VVC.CLOSE_CHAN_REASON.ERROR;
   } else {
      closeChanReason = VVC.CLOSE_CHAN_REASON.NORMAL;
   }

   this.state = VVC.SESSION_STATE.CLOSING;

   try {
      this.socket.close();
   } catch (exc) {
      this._onTransportException(exc);
   }

   for (i = 0; i < this._channels.length; ++i) {
      channel = this._channels[i];

      if (channel) {
         if (channel.state === VVC.CHANNEL_STATE.INIT) {
            this.onChannelOpen(channel, VVC.STATUS.ERROR);
         } else if (channel.state === VVC.CHANNEL_STATE.OPEN
                 || channel.state === VVC.CHANNEL_STATE.CLOSING) {
            channel.state = VVC.CHANNEL_STATE.CLOSING;
            this.onChannelClose(channel, closeChanReason);
         }
      }
   }
};


/**
 * Called when the control channel receives an INIT or INIT_ACK message.
 * Triggers the listener.onconnect callback.
 *
 * @protected
 */
VVCSession.prototype.onConnect = function()
{
   var i, listener, listeners;

   listeners = this._vvcInstance._findSessionListeners(this);
   this.state = VVC.SESSION_STATE.ESTABLISHED;

   for (i = 0; i < listeners.length; ++i) {
      listener = listeners[i];

      if (listener.onconnect) {
         listener.onconnect(this);
      }
   }
};


/**
 * Called when the control channel receives an OPEN_CHAN message.
 * Triggers the listener.onpeeropen callback.
 *
 * @protected
 * @param {VVCChannel} channel The new channel being opened
 */
VVCSession.prototype.onPeerOpen = function(channel)
{
   var i, listener, listeners;

   listeners = this._vvcInstance._findSessionListeners(this);

   for (i = 0; i < listeners.length; ++i) {
      listener = listeners[i];

      if (listener.matchName(channel.name)) {
         if (listener.onpeeropen) {
            listener.onpeeropen(this, channel);
         }
      }
   }
};


/**
 * Called when the control channel receives an OPEN_CHAN_ACK message.
 * Triggers the channel.onopen callback.
 *
 * @protected
 * @param {VVCChannel}           channel     The new channel being opened
 * @param {VVC.OPEN_CHAN_STATUS} status      The status of the open
 * @param {Uint8Array?}          initialData Data that came with the open msg
 */
VVCSession.prototype.onChannelOpen = function(channel, status, initialData)
{
   if (status === VVC.OPEN_CHAN_STATUS.SUCCESS) {
      channel.state = VVC.CHANNEL_STATE.OPEN;
      if (channel.onopen) {
         channel.onopen(this._createEvent('open', { data: initialData }));
      }
   } else {
      channel.state = VVC.CHANNEL_STATE.OPEN_FAILED;
      this._releaseChannel(channel);
      this.onChannelError(channel);
   }
};


/**
 * Called when an error occurs on a channel.
 * Triggers the channel.onerror callback.
 *
 * @protected
 * @param {VVCChannel} channel The channel which had the error
 */
VVCSession.prototype.onChannelError = function(channel)
{
   if (channel.onerror) {
      channel.onerror(this._createEvent('error'));
   }
};


/**
 * Called when a channel receives a message.
 * Triggers the channel.onmessage callback.
 *
 * @protected
 * @param {VVCChannel} channel The channel receiving the message
 * @param {ArrayBuffer} data   The message data
 */
VVCSession.prototype.onChannelMessage = function(channel, data)
{
   if (!channel) {
      // Ignore any unknown channel messages if the socket is closing or closed.
      if (this.socket.readyState === WebSocket.OPEN) {
         this.onSessionError(VVC.STATUS.PROTOCOL_ERROR,
                             'VVCSession.onChannelMessage',
                             'Unknown channel in chunk');
      }

      return;
   }

   if (channel.onmessage) {
      channel.onmessage(this._createEvent('message', { data: data }));
   }
};


/**
 * Called when the control channel receives an CLOSE_CHAN or CLOSE_CHAN_ACK.
 * Triggers the channel.onclose callback.
 * Removes the channel from the session's channel list.
 *
 * @protected
 * @param {VVCChannel}            channel The channel being close
 * @param {VVC.CLOSE_CHAN_REASON} reason  The reason for closing
 */
VVCSession.prototype.onChannelClose = function(channel, reason)
{
   var code;

   if (reason === VVC.CLOSE_CHAN_REASON.NORMAL) {
      code = 1000; // WebSocket 'normal close'

      if (channel.state === VVC.CHANNEL_STATE.CLOSING) {
         channel.state = VVC.CHANNEL_STATE.PEER_CLOSED;
      } else {
         channel.state = VVC.CHANNEL_STATE.PEER_CLOSING;
         this.controlChannel.sendCloseChannelAck(channel, VVC.CLOSE_CHAN_STATUS.SUCCESS);
      }
   } else {
      code = 1002; // WebSocket 'protocol error'
   }

   if (channel.onclose) {
      channel.onclose(this._createEvent('close', {
         wasClean: (reason === VVC.CLOSE_CHAN_REASON.NORMAL),
         reason: reason,
         code: code
      }));
   }

   channel.state = VVC.CHANNEL_STATE.CLOSED;
   this._releaseChannel(channel);
};


/**
 * Creates the probe channel.
 * @protected
 */
VVCSession.prototype.createProbeChannel = function()
{
   // Create probe channel and add it to channel list
   this.probeChannel = new VVCProbeChannel(this);
   this._channels[this.probeChannel.id] = this.probeChannel;
   this._buffers.data[this.probeChannel.id] = [];
};


/**
 * Creates the control channel.
 * @private
 */
VVCSession.prototype._createControlChannel = function()
{
   // Create control channel and add it to channel list
   this.controlChannel = new VVCControlChannel(this);
   this._channels[this.controlChannel.id] = this.controlChannel;
   this._buffers.data[this.controlChannel.id] = [];
};


/**
 * Called when the transport opens.
 * @private
 */
VVCSession.prototype._onTransportOpen = function()
{
   this._createControlChannel();

   // It is the clients responsibility to send the first control init message
   if (!this._server) {
      this.controlChannel.sendInit(VVC.CTRL_OP.INIT);
   }
};


/**
 * Called when the transport closes.
 * @private
 */
VVCSession.prototype._onTransportClose = function(evt)
{
   if (this.state === VVC.SESSION_STATE.ESTABLISHED) {
      this.onSessionError(VVC.TRANSPORT_ERROR,
                          'VVCSession._onTransportClose',
                          'The WebSocket closed whilst the session was open.');
   }

   if (this.ontransportclose) {
      this.ontransportclose(evt);
   }
};


/**
 * Called when the transport errors.
 * @private
 */
VVCSession.prototype._onTransportError = function(evt)
{
   this.onSessionError(VVC.TRANSPORT_ERROR,
                       'VVCSession._onTransportError',
                       'An error occurred in the WebSocket.');

   if (this.ontransporterror) {
      this.ontransporterror(evt);
   }
};


/**
 * Called when the transport throws exceptions.
 * @private
 */
VVCSession.prototype._onTransportException = function(exc)
{
   this.onSessionError(VVC.TRANSPORT_ERROR,
                       'VVCSession._onTransportException',
                       'An exception occurred in the WebSocket: ' + exc.message);

   if (this.ontransporterror) {
      this.ontransporterror(this._createEvent('error'));
   }
};


/**
 * Combines multiple Uint8Array into a single ArrayBuffer.
 *
 * @private
 * @param  {Uint8Array[]} buffers  The split multiple Uint8Array buffers.
 * @return {ArrayBuffer}  combined The combined single ArrayBuffer
 */
VVCSession.prototype._combineBuffers = function(buffers)
{
   var array, buffer, i, size;

   if (buffers.length === 0) {
      return null;
   }

   size = 0;

   for (i = 0; i < buffers.length; ++i) {
      size += buffers[i].length;
   }

   buffer = new ArrayBuffer(size);
   array  = new Uint8Array(buffer);
   size   = 0;

   for (i = 0; i < buffers.length; ++i) {
      array.set(buffers[i], size);
      size += buffers[i].length;
   }

   return buffer;
};


/**
 * Sets the next receive state.
 * Asks for the appropriate amount of bytes to be read from transport.
 *
 * @private
 * @param  {VVC.SESSION_RECEIVE_STATE} state The next receive state
 */
VVCSession.prototype._setReceiveState = function(state)
{
   this._receiveState = state;

   switch(state) {
      case VVC.SESSION_RECEIVE_STATE.COMMON_HEADER:
         this._bytesRequested = VVC.CHUNK_COMMON_HEADER_SIZE;
         this._bytesRead = 0;
         this._buffers.header.reset();
         break;
      case VVC.SESSION_RECEIVE_STATE.LARGE_HEADER:
         this._bytesRequested += VVC.CHUNK_LARGE_HEADER_SIZE;
         break;
      case VVC.SESSION_RECEIVE_STATE.EXTENSION_HEADER:
         this._bytesRequested += VVC.CHUNK_EXTENSION_HEADER_SIZE;
         break;
      case VVC.SESSION_RECEIVE_STATE.EXTENSION_DATA:
         this._bytesRequested += this._chunk.ext.length;
         break;
      case VVC.SESSION_RECEIVE_STATE.DATA:
         this._bytesRequested += this._chunk.length;
         break;
   }
};


/**
 * Called when the underlying transport receives data.
 * Reads the chunk headers and forwards messages to the correct channel.
 *
 * @private
 * @param  {Uint8Array} data The raw binary data from the transport.
 */
VVCSession.prototype._onTransportRecv = function(data)
{
   var buffer, bytesNeeded, bytesRead, dataRead;

   bytesNeeded = this._bytesRequested - this._bytesRead;
   bytesRead   = Math.min(data.length, bytesNeeded);
   dataRead    = data.subarray(0, bytesRead);
   buffer      = null;

   switch(this._receiveState) {
   case VVC.SESSION_RECEIVE_STATE.COMMON_HEADER:
   case VVC.SESSION_RECEIVE_STATE.LARGE_HEADER:
   case VVC.SESSION_RECEIVE_STATE.EXTENSION_HEADER:
      buffer = this._buffers.header;
      break;
   case VVC.SESSION_RECEIVE_STATE.EXTENSION_DATA:
      buffer = this._buffers.ext;
      break;
   case VVC.SESSION_RECEIVE_STATE.DATA:
      this._buffers.data[this._chunk.channel].push(dataRead);

      if (this._chunk.channel !== VVC.CONTROL_CHANNEL_ID && bytesRead) {
         this.controlChannel.sendRecvAck(bytesRead);
      }
      break;
   }

   if (buffer) {
      buffer.writeArray(dataRead);
   }

   this._bytesRead += bytesRead;

   if (data.length < bytesNeeded) {
      return;
   }

   switch (this._receiveState) {
   case VVC.SESSION_RECEIVE_STATE.COMMON_HEADER:
      this._chunk.channel = buffer.readUint8();
      this._chunk.flags   = buffer.readUint8();
      this._chunk.length  = buffer.readUint16() + 1;

      if (this._chunk.flags & VVC.CHUNK_FLAG.LC) {
         this._setReceiveState(VVC.SESSION_RECEIVE_STATE.LARGE_HEADER);
      } else if (this._chunk.flags & VVC.CHUNK_FLAG.EXT) {
         this._setReceiveState(VVC.SESSION_RECEIVE_STATE.EXTENSION_HEADER);
      } else {
         this._setReceiveState(VVC.SESSION_RECEIVE_STATE.DATA);
      }
      break;
   case VVC.SESSION_RECEIVE_STATE.LARGE_HEADER:
      this._chunk.length = buffer.readUint32() + 1;

      if (this._chunk.flags & VVC.CHUNK_FLAG.EXT) {
         this._setReceiveState(VVC.SESSION_RECEIVE_STATE.EXTENSION_HEADER);
      } else {
         this._setReceiveState(VVC.SESSION_RECEIVE_STATE.DATA);
      }
      break;
   case VVC.SESSION_RECEIVE_STATE.EXTENSION_HEADER:
      this._chunk.ext.code  = buffer.readUint8();
      this._chunk.ext.flags = buffer.readUint8();
      this._chunk.ext.param = buffer.readUint16();

      if (this._chunk.ext.flags & VVC.CHUNK_EXT_FLAG.EDAT) {
         this._chunk.ext.length = this._chunk.ext.param + 1;
         this._buffers.ext = new WMKS.Packet.createNewPacket(this._chunk.ext.length);
         this._setReceiveState(VVC.SESSION_RECEIVE_STATE.EXTENSION_DATA);
      } else {
         this._chunk.ext.length = 0;

         if (this._chunk.ext.flags & VVC.CHUNK_EXT_FLAG.ELST) {
            this._setReceiveState(VVC.SESSION_RECEIVE_STATE.DATA);
         } else {
            this._setReceiveState(VVC.SESSION_RECEIVE_STATE.EXTENSION_HEADER);
         }
      }
      break;
   case VVC.SESSION_RECEIVE_STATE.EXTENSION_DATA:
      if (this._chunk.ext.code == VVC.CHUNK_EXT_CODE.LARGE_CHANNEL_ID) {
         if (buffer.bytesRemaining() >= 4) {
            this._chunk.channel = buffer.readUint32();
         }
      }

      this._buffers.ext = null;

      if (this._chunk.ext.flags & VVC.CHUNK_EXT_FLAG.ELST) {
         this._setReceiveState(VVC.SESSION_RECEIVE_STATE.DATA);
      } else {
         this._setReceiveState(VVC.SESSION_RECEIVE_STATE.EXTENSION_HEADER);
      }
      break;
   case VVC.SESSION_RECEIVE_STATE.DATA:
      if (this._chunk.flags & VVC.CHUNK_FLAG.FIN) {
         buffer = this._combineBuffers(this._buffers.data[this._chunk.channel]);
         this.onChannelMessage(this._channels[this._chunk.channel], buffer);
         this._buffers.data[this._chunk.channel] = [];
      }

      this._setReceiveState(VVC.SESSION_RECEIVE_STATE.COMMON_HEADER);
      break;
   }

   if (data.length > bytesRead) {
      this._onTransportRecv(data.subarray(bytesRead));
   }
};


/**
 * Send data on a channel.
 * Constructs the appropriate chunk header.
 *
 * @protected
 * @param  {VVCChannel}             channel The channel to send data on
 * @param  {Uint8Array|ArrayBuffer} data    The data to send
 * @return {Boolean}                        Returns true on succesful send.
 */
VVCSession.prototype.send = function(channel, data)
{
   var header, flags, length;

   if (!this._checkErrorIsChannel('send', channel)) {
      return false;
   }

   if (!this._checkErrorChannelState('send', channel,
                                     VVC.CHANNEL_STATE.OPEN)) {
      return false;
   }

   if (!(data instanceof Uint8Array) && !(data instanceof ArrayBuffer)) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_ARGS,
                                     'VVCSession.send',
                                     'Invalid data, must be Uint8Array'
                                     + ' or ArrayBuffer');
      return false;
   }

   header = this._buffers.send;
   header.reset();
   header.writeUint8(channel.id);

   length = data.byteLength;
   flags  = VVC.CHUNK_FLAG.FIN;

   if (length > VVC.CHUNK_MAX_LEN) {
      header.writeUint8(VVC.CHUNK_FLAG.LC | flags);
      header.writeUint16(0);
      header.writeUint32(length - 1);
   } else {
      header.writeUint8(flags);
      header.writeUint16(length - 1);
   }

   try {
      this.socket.send(header.getData());
      this.socket.send(data);
   } catch (exc) {
      this._onTransportException(exc);
   }

   return true;
};


/**
 * Creates an Event object.
 *
 * Needed because Internet Explorer does not allow new Event();
 *
 * @private
 * @param {String} name       The event name
 * @param {Object} properties Properties to copy to the event
 * @return {Event}            Returns newly constructed event
 */
VVCSession.prototype._createEvent = function(name, properties)
{
   var evt = document.createEvent('Event');
   evt.initEvent(name, false, false);

   for (var key in properties) {
      evt[key] = properties[key];
   }

   return evt;
};


/**
 * Returns false and sets an error if the provided object is not a channel.
 * object must be instanceof VVCChannel
 *
 * @private
 * @param  {String}  func   Function name for error logging
 * @param  {Object}  object Object to check type of
 * @return {Boolean}        Returns true if object is a VNCChannel
 */
VVCSession.prototype._checkErrorIsChannel = function(func, object)
{
   if (!(object instanceof VVCChannel)) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_ARGS,
                                     'VVCSession.' + func,
                                     'Invalid channel,'
                                      + ' must be instanceof VVCChannel');
      return false;
   }

   return true;
};


/**
 * Returns false and sets an error if the session state is not a value.
 *
 * @private
 * @param  {String}            func  Function name for error logging
 * @param  {VVC.SESSION_STATE} state State the session must be in
 * @return {Boolean}                 Returns true if state is correct
 */
VVCSession.prototype._checkErrorSessionState = function(func, state)
{
   if (this.state !== state) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_STATE,
                                     'VVCSession.' + func,
                                     'Invalid state ' + this.state
                                     + ' expected ' + state);
      return false;
   }

   return true;
};


/**
 * Returns false and sets an error if the channel state is not a value.
 *
 * @private
 * @param  {String}            func    Function name for error logging
 * @param  {VVCChannel}        channel The channel for which state to check
 * @param  {VVC.SESSION_STATE} state   State the session must be in
 * @return {Boolean}                   Returns true if state is correct
 */
VVCSession.prototype._checkErrorChannelState = function(func, channel, state)
{
   if (channel.state !== state) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_STATE,
                                     'VVCSession.' + func,
                                     'Invalid state ' + channel.state
                                     + ' expected ' + state);
      return false;
   }

   return true;
};


/**
 * Returns false and sets an error if the length of name is invalid.
 * name must be between VVC.MIN_CHANNEL_NAME_LEN and VVC.MAX_CHANNEL_NAME_LEN.
 *
 * @private
 * @param  {String}  func Function name for error logging
 * @param  {String}  name Name to check
 * @return {Boolean}      Returns true if name length is valid
 */
VVCSession.prototype._checkErrorNameLength = function(func, name)
{
   if (name.length < VVC.MIN_CHANNEL_NAME_LEN ||
       name.length > VVC.MAX_CHANNEL_NAME_LEN) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_ARGS,
                                     'VVCSession.' + func,
                                     'Invalid name ' + name
                                     + ' length must be between '
                                     + VVC.MIN_CHANNEL_NAME_LEN + ' and '
                                     + VVC.MAX_CHANNEL_NAME_LEN + ' bytes');
      return false;
   }

   return true;
};


/**
 * Returns false and sets an error if the initialData is invalid.
 * initialData must be a Uint8Array smaller than VVC.MAX_INITIAL_DATA_LEN.
 *
 * @private
 * @param  {String}     func        Function name for error logging
 * @param  {Uint8Array} initialData Data to check
 * @return {Boolean}                Returns true if initialData is valid
 */
VVCSession.prototype._checkErrorInitialData = function(func, initialData)
{
   if (initialData && !(initialData instanceof Uint8Array)) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_ARGS,
                                     'VVCSession.' + func,
                                     'Invalid initial data,'
                                      + ' must be instanceof Uint8Array');
      return false;
   }

   if (initialData && initialData.length > VVC.MAX_INITIAL_DATA_LEN) {
      this._vvcInstance.setLastError(VVC.STATUS.INVALID_ARGS,
                                     'VVCSession.' + func,
                                     'Invalid initial data,'
                                      + ' must be smaller than '
                                      + VVC.MAX_INITIAL_DATA_LEN + ' bytes');
      return false;
   }

   return true;
};


/**
 * Called when there is an error with the channel.
 * @callback VVCSession~onerror
 */


/**
 * Called when the transport closes.
 * @callback VVCSession~ontransportclose
 * @param {Event} event
 */


/**
 * Called when there is an error on the transport.
 * @callback VVCSession~ontransporterror
 * @param {Event} event
 */
/* global $:false, WMKS:false */

/*
 *------------------------------------------------------------------------------
 * wmks/relativeMouseHandler.js
 *
 *    This class abstracts relative mouse management and decouples this
 *    functionality from the widgetProto.
 *
 *    All variables are defined as private variables. Functions that do not
 *    need to be exposed should be private too.
 *
 *------------------------------------------------------------------------------
 */

WMKS.RelativeMouseHandler = function(options) {
   'use strict';
   if (!options || !options.canvas ||
       !options.widgetProto) {
      WMKS.LOGGER.warn('Invalid params set for RelativeMouseHandler.');
      return null;
   }

   var _widget = options.widgetProto,
       _canvas = options.canvas,     // Canvas where all the action happens.
       _onToggle = options.onToggle; // Toggle callback function.

   // List of jQuery objects that are used frequently.
   var _ELEMENTS = {
         inputProxy        : null,
         cursorIcon        : null,
         clickFeedback     : null,
         dragFeedback      : null,
         pulseFeedback     : null,
         scrollFeedback    : null,
         keypad            : null,
         relativePad       : null
       };

   /****************************************************************************
    * Public Functions
    ***************************************************************************/
   /*
    *---------------------------------------------------------------------------
    *
    * toggleTrackpad
    *
    *    Called when the user wants to toggle trackpad visibility.
    *
    *---------------------------------------------------------------------------
    */

   this.toggleRelativePad = function(options) {
      if (_ELEMENTS.relativePad) {
         // Set toggle callback function.
         options = $.extend({}, options, {
            toggleCallback: _onToggle
         });
         // Show / hide trackpad.
         _ELEMENTS.relativePad.toggle(options);
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * installTouchHandlers
    *
    *    Install event handlers for touch devices.
    *
    *---------------------------------------------------------------------------
    */

   this.installMouseHandlers = function() {
      var self = this,
          container = _canvas.parent();

      // Set css values to disable unwanted default browser behavior.
      _canvas.css({
         '-webkit-user-select':     'none',  /* disable cut-copy-paste */
         '-webkit-touch-callout':   'none'   /* disable callout, image save panel */
      });

      // Create touch feedbacks.
      _ELEMENTS.cursorIcon = $('<div/>')
         .addClass('feedback-container cursor-icon')
         .appendTo(container);
      _ELEMENTS.clickFeedback = $('<div/>')
         .addClass('feedback-container tap-icon')
         .appendTo(container);
      _ELEMENTS.dragFeedback = $('<div/>')
         .addClass('feedback-container drag-icon')
         .appendTo(container);
      _ELEMENTS.pulseFeedback = $('<div/>')
         .addClass('feedback-container pulse-icon')
         .appendTo(container);
      _ELEMENTS.scrollFeedback = $('<div/>')
         .addClass('feedback-container scroll-icon')
         .appendTo(container);
   };

   /*
    *---------------------------------------------------------------------------
    *
    * initializeRelativeMouseFeature
    *
    *    This function initializes the touch feature that's requested.
    *
    *---------------------------------------------------------------------------
    */

   this.initializeRelativeMouseFeature = function() {
      _ELEMENTS.relativePad = new WMKS.relativePadManager(_widget, _canvas);
      _ELEMENTS.relativePad.initialize();
   };

      /*
    *---------------------------------------------------------------------------
    *
    * moveCursor
    *
    *    Repositions the fake caret to match the given touch's location. Since
    *    the 'tip' of the caret represents the click location, no centering is
    *    desired.
    *
    *---------------------------------------------------------------------------
    */

   this.moveCursor = function(pageX, pageY) {
      if (_ELEMENTS.cursorIcon) {
         _ELEMENTS.cursorIcon.css({'left': pageX, 'top': pageY});
      }
   };


   /*
    *---------------------------------------------------------------------------
    *
    * setCursorVisibility
    *
    *    Hide or show the fake caret.
    *
    *---------------------------------------------------------------------------
    */

   this.setCursorVisibility = function(visible) {
      if (_ELEMENTS.cursorIcon) {
         if (visible) {
            _ELEMENTS.cursorIcon.show();
         } else {
            _ELEMENTS.cursorIcon.hide();
         }
      }
   };
   /*
    *---------------------------------------------------------------------------
    *
    * destroy
    *
    *    Destroys the TouchHandler.
    *
    *    This will disconnect all (if active) and remove
    *    the widget from the associated element.
    *
    *    Consumers should call this before removing the element from the DOM.
    *
    *---------------------------------------------------------------------------
    */

   this.destroy = function() {
      // Cleanup private variables.
      _widget = null;
      _canvas = null;
      _ELEMENTS = null;
   };

};/*
 *------------------------------------------------------------------------------
 *
 * wmks/relativePadManager.js
 *
 *   The controller of relativepad widget.
 *
 *------------------------------------------------------------------------------
 */
(function() {
   'use strict';

   // Trackpad related constants.
   WMKS.CONST.RELATIVEPAD = {
      STATE: {
         idle:         0,
         click:        1,
         move:         3,
         scroll:       4
      }
   };

   WMKS.relativePadManager = function(widget, canvas) {
      // Call constructor so dialogManager's params are included here.
      WMKS.dialogManager.call(this);
      this._widget = widget;
      this._canvas = canvas;
      // Trackpad state machine.
      this.state = WMKS.CONST.RELATIVEPAD.STATE.idle;
      this.history = [];
      // Override default options with options here.
      $.extend(this.options,
               {
                  name: 'RELATIVEPAD',
                  speedControlMinMovePx: 5,
                  // Speed control for relative trackpad
                  accelerator:           10,
                  minSpeed:              1,
                  maxSpeed:              10
               });
      WMKS.LOGGER.warn('relativepad : ' + this.options.name);
   };

   WMKS.relativePadManager.prototype =  new WMKS.dialogManager();

   /*
    *---------------------------------------------------------------------------
    *
    * getRelativepadHtml
    *
    *    Function to get the relativepad html layout.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.getTrackpadHtml = function() {
      var str = '<div id="relativePad" class="relativepad-container">\
                   <div class="left-border"></div>\
                   <div id="relativePadSurface" style="height:200px; border:1px solid black;"></div>\
                   <div class="right-border"></div>\
                   <div class="bottom-border">\
                      <div class="button-container">\
                         <div id="relativepadLeft" class="button-left"></div>\
                         <div id="relativepadRight" class="button-right"></div>\
                      </div>\
                   </div>\
               </div>';

      return str;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * create
    *
    *    This function initializes the relativepad dialog, toggle highlighting on close
    *    handler.
    *
    * HACK
    *    There is no easy way to determine close by menu click vs clicking close
    *    icon. Hence using the event.target to determine it was from clicking
    *    close icon. It will not work well when closeOnEscape is true. We don't
    *    need this on ipad, so its good.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.create = function() {
      var dialog,
          self = this;

      if (!this._widget ||
          !this._canvas) {
         WMKS.LOGGER.debug('Trackpad dialog creation has been aborted. Widget or Canvas is not ready.');
         return null;
      }

      dialog = $(this.getTrackpadHtml());
      dialog.dialog({
         autoOpen: false,
         closeOnEscape: true,
         resizable: false,
         position: {my: 'center', at: 'center', of: this._canvas},
         zIndex: 1000,
         draggable: true,
         dialogClass: 'relativepad-wrapper',
         close: function(e) {
            self.sendUpdatedState(false);
         },
         create: function(e) {
            self.layout($(this).parent());
         }
      });

      return dialog;
   };


   /*
    *---------------------------------------------------------------------------
    *
    * init
    *
    *    This function initializes the event handlers for the relativepad.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.init = function() {
      var dialog = this.dialog,
          self = this,
          relativepad,
          left,
          right;
      if (!dialog) {
         WMKS.LOGGER.debug('Relativepad init aborted. Dialog is not created successfully.');
         return;
      }

      // Request reposition of relativepad dialog upon orientation changes.
      this._widget.requestElementReposition(dialog.parent(), true);

      // Initialize event handlers for the relativepad.
      relativepad = dialog
         .find('#relativePadSurface')
         .on('mousemove', function(e) {
            return self.relativepadMouseMove(e.originalEvent);
         }).on('mouseup', function(e) {
            return self.relativepadMouseClick(e,0);
         }).on('mousedown', function(e) {
            return self.relativepadMouseClick(e,1);
         }).on('contextmenu',function(){
            return false;
         });
   };


   /*
    *---------------------------------------------------------------------------
    *
    * disconnect
    *
    *    This function unbinds the event handlers for the relativepad.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.disconnect = function() {
      var dialog = this.dialog,
          relativepad;

      if (!dialog) {
         return;
      }

      // Unregister event handlers for the relativepad.
      relativepad = dialog
         .find('#relativepadSurface')
         .off('mousemove')
         .off('mouseup')
         .off('mousedown');
   };

   /*
    *---------------------------------------------------------------------------
    *
    * layout
    *
    *    Reposition the dialog in order to center it to the canvas.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.layout = function(dialog) {
      var canvas = this._canvas,
          dialogParent,
          canvasParent;

      if (!dialog ||
          !canvas) {
         return;
      }

      dialogParent = dialog.parent();
      canvasParent = canvas.parent();

      if (dialogParent !== canvasParent) {
         // Append the dialog to the parent of the canvas,
         // so that it's able to center the dialog to the canvas.
         canvasParent.append(dialog);
      }
   };

   /*
    *---------------------------------------------------------------------------
    *
    * relativepadMouseMove
    *
    *    Fires when a mouse moves within the relative trackpad's  area. If the
    *    action is currently marked as a click, promotes it into a move. If it
    *    is already one or the other, stick to that type.
    *
    *    However, if the mouse moves outside the area while moving, then set the
    *    state back to the click and clear up history in case user comes back into
    *    the hot region.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.relativepadMouseMove = function(e) {
      var pX, pY, newLocation, diffLocation,
          self = $(e.target),
          widget = this._widget;
      if (this.state === WMKS.CONST.RELATIVEPAD.STATE.idle) {
         return false;
      }

      pX = e.pageX;
      pY = e.pageY;

      // Verify if the touchmove is outside business (hot) region of trackpad.
      if (pY < self.offset().top || pY > (self.offset().top + self.height()) ||
            pX < self.offset().left || pX > (self.offset().left + self.width())) {
         // Reset to tap start state, as the user went outside the business region.
         if (this.state === WMKS.CONST.RELATIVEPAD.STATE.move) {
            this.state = WMKS.CONST.RELATIVEPAD.STATE.idle;
            this.history.length = 0;
         }
         return false;
      }

      if (this.state === WMKS.CONST.RELATIVEPAD.STATE.move) {
         newLocation = this.computeNewCursorLocation(pX, pY);
         if (WMKS.VNCDecoder.cursorPosition) {
            diffLocation = this._widget.getRelativeMouseCanvasPosition(WMKS.VNCDecoder.cursorPosition);
            widget._relativeMouseHandler.moveCursor(diffLocation.x, diffLocation.y);
         }
         widget.sendMouseMoveMessage(newLocation);
         // Make room for a new history entry
         this.history.shift();

         // Push a new history entry
         this.history.push({x: pX, y: pY });
      }

      // Detect if this is a drag or a scroll. If so, add a history entry.
      if (this.state === WMKS.CONST.RELATIVEPAD.STATE.click) {
         this.state = WMKS.CONST.RELATIVEPAD.STATE.move;
         // Make up history based on the current point if there isn't any yet.
         this.history.push({x: pX, y: pY}, {x: pX, y: pY}, {x: pX, y: pY});
      }
      return false;
   };

   /*
    *---------------------------------------------------------------------------
    *
    * computeNewCursorLocation
    *
    *    This function takes the new location and computes the destination mouse
    *    cursor location. The computation is based on the acceleration to be used,
    *    making sure the new location is within the screen area.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.computeNewCursorLocation = function(pX, pY) {
      var dist,
          point = { x:0,y:0 };
      // First compute the distance from the last location.
      dist = WMKS.UTIL.getLineLength(
         (pX - this.history[2].x), (pY - this.history[2].y));
      if (isNaN(dist) || dist === 0) {
         // There is no change, return the old location.
         return point;
      } else if (dist < this.options.speedControlMinMovePx) {
         // The cursor has only moved a few pixels, apply the delta directly.
         point.x = pX - this.history[2].x;
         point.y = pY - this.history[2].y;
      } else {
         // From now on, though, use device pixels (later, compensate for hi-DPI)
         dist = this.computeMovingDistance(pX, pY);
         point.x = Math.floor(dist[0]);
         point.y = Math.floor(dist[1]);
      }
      return point;
   };

   /*
    *---------------------------------------------------------------------------
    *
    * computeMovingDistance
    *
    *    Based on a current point and point history, gets the amount of distance
    *    the mouse should move based on this data.
    *
    * Results:
    *    A 2-tuple of (dx, dy)
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.computeMovingDistance = function(x, y) {
      var dx, dy, dist, speed;

      dx = this.getTrackpadSpeed(x,
         this.history[0].x,
         this.history[1].x,
         this.history[2].x);
      dy = this.getTrackpadSpeed(y,
         this.history[0].y,
         this.history[1].y,
         this.history[2].y);

      dist = WMKS.UTIL.getLineLength(dx, dy);

      speed = dist * this.options.accelerator;
      if (speed > this.options.maxSpeed) {
         speed = this.options.maxSpeed;
      } else if (speed < this.options.minSpeed) {
         speed = this.options.minSpeed;
      }

      return [dx * speed, dy * speed];
   };

   /*
    *---------------------------------------------------------------------------
    *
    * getTrackpadSpeed
    *
    *    Performs a linear least squares operation to get the slope of the line
    *    that best fits all four points. This slope is the current speed of the
    *    trackpad, assuming equal time between samples.
    *
    *    Returns the speed as a floating point number.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.getTrackpadSpeed = function(x0, x1, x2, x3) {
      return x0 * 0.3 + x1 * 0.1 - x2 * 0.1 - x3 * 0.3;
   };
   /*
    *---------------------------------------------------------------------------
    *
    * relativepadMouseClick
    *
    *    Fires when either one of the virtual trackpad's buttons are clicked. Sends
    *    a mousedown operation and adds the button highlight.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.relativepadMouseClick = function(event, down) {
      if (this.state == WMKS.CONST.RELATIVEPAD.STATE.idle) {
         this.state = WMKS.CONST.RELATIVEPAD.STATE.click;
         return false;
      } else {
         this.state = WMKS.CONST.RELATIVEPAD.STATE.click;
         var evt = event || window.event;
         var pos = { x:0, y:0 };
         var bmask;

         /* evt.which is valid for all browsers except IE */
         if (evt.which) {
            if (evt.which == 1) {
               bmask = 0x01; //left button
            } else if (evt.which == 2) {
               bmask = 0x04; //middle button
            } else if (evt.which == 3) {
               bmask = 0x02; //right button
            }
         } else {
            /* IE including 9 */
            if (evt.button == 0) {
               bmask = 0x01; //left button
            } else if (evt.button == 1) {
               bmask = 0x04; //middle button
            } else if (evt.button == 2) {
               bmask = 0x02; //right button
            }
         }
         // Sends a mousedown message.
         this._widget.sendMouseButtonMessage(pos, down, bmask);
         this.resetRelativepadState();
         return false;
      }

   };

   /*
    *---------------------------------------------------------------------------
    *
    *    resetRelativepadState
    *
    *    Resets the virtual relative trackpad's state machine.
    *
    *---------------------------------------------------------------------------
    */

   WMKS.relativePadManager.prototype.resetRelativepadState = function() {
      this.history.length = 0;
   };

}());
$.widget("wmks.wmks", WMKS.widgetProto);
})();


/*** EXPORTS FROM exports-loader ***/
module.exports = window.WMKS;
}.call(window));
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/******************************************************************************
 * Copyright 2014-2017 VMware, Inc.  All rights reserved.
 *****************************************************************************/

/**
 * appblast-log.js
 *
 *    Implement logging in a way that takes advantage of modern
 *    browser debugging features but gracefully degrades on older
 *    browsers.
 *
 */

var log = function () {
   var nullFunc = function nullFunc() {},
       ret = {},
       levels = ["trace", "debug", "info", "warn", "error"];

   ret.LEVEL_TRACE = 0;
   ret.LEVEL_DEBUG = 1;
   ret.LEVEL_INFO = 2;
   ret.LEVEL_WARN = 3;
   ret.LEVEL_ERROR = 4;

   /**
    * getMethod
    *
    *    Bind to the named console method, or provide a fallback
    *    implementation. If console or console.log are not defined, we
    *    return dummy implementation which does nothing.
    *
    *    If the named method exists on the console, then we return a
    *    binding of that method. If it does not exist, we return
    *    console.log with the log level curried in.
    *
    *    If Function.prototype.bind does not exist, we raise an error.
    */

   function getMethod(name) {
      if (nullFunc.bind === undefined) {
         throw new Error("log requires Function.prototype.bind");
      }

      if (console === undefined || console.log === undefined) {
         return nullFunc;
      } else if (console[name] !== undefined) {
         return console[name].bind(console);
      } else {
         return console.log.bind(console, name);
      }
   }

   /**
    * setLevel
    *
    *    sets the current log level.
    */

   ret.setLevel = function (level) {
      var i;

      if (typeof level !== "number" || level < 0 || level > levels.length - 1) {
         throw new Error("Invalid log level: " + level);
      }

      for (i = 0; i < level; i++) {
         ret[levels[i]] = nullFunc;
      }

      for (i = level; i < levels.length; i++) {
         // log level trace is implemented as debug.
         // see: log.stackTrace() below.
         if (levels[i] === "trace") {
            ret.trace = getMethod("debug");
         } else {
            ret[levels[i]] = getMethod(levels[i]);
         }
      }

      ret.logLevel = level;
   };

   /**
    * log
    *
    *    binding of console.log or a dummy implementation.
    */

   ret.log = getMethod("log");

   /**
    * log
    *
    *    In modern browsers, console.trace() is not trace level
    *    logging, but actually a means to produce a stacktrace on the
    *    console. Our code defines LEVEL_TRACE as the loweset level of
    *    logging, so we expose console.trace here as log.stackTrace().
    */

   ret.stackTrace = getMethod("trace");

   /**
    * setLevel
    *
    *    Change the current log level. Log level must be an integer
    *    from LEVEL_TRACE to LEVEL_ERROR. Changing the log level to
    *    suppress a logging prevents the browser's console methods
    *    from ever being called, so they will never apear in the
    *    console regardless of the console filter settings used.
    */

   ret.setLevel(ret.LEVEL_DEBUG);

   return ret;
}();

/**
 *  NOTE: this is the workaround for RTAV workers.
 *  We don't use webpack for these workers as there are many complex function
 *  in them. As a result, we have to use this ugly way to expose 'log' to other
 *  webpack module, but not for worker context.
 */
if (typeof module !== "undefined" && module.exports) {
   module.exports = log;
}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _stringUtils = __webpack_require__(32);

var _stringUtils2 = _interopRequireDefault(_stringUtils);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _vdpservice = __webpack_require__(22);

var _vdpservice2 = _interopRequireDefault(_vdpservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Unity = {
   /**
    * These constants represent the various capabilities that we could receive
    * from the server.  Note: they are *not* bitmasks.
    *
    * Refer to bora/public/remoteUnity.h for more info.
    */
   CAP_UNITY: 1,
   CAP_STATUS: 2,
   CAP_WORK_AREA: 3,
   CAP_MULTIMON: 4,
   CAP_TASKBAR: 5,
   CAP_WINDOW_CONTENTS: 6,
   CAP_SHELL_ACTION_RUN: 7,
   CAP_SET_FOCUSED_WINDOW: 8,
   CAP_MOUSE_BUTTON_SWAPPING: 9,
   CAP_SET_APP_ENTITLEMENT_MAP: 10,
   CAP_TRAY_ICONS: 11,

   /**
    * These constants represent the features bitmask which can be provided
    * to Unity.Mgr.On().
    *
    * Refer to bora/public/unityCommon.h for more info.
    */
   ADD_HIDDEN_WINDOWS_TO_TRACKER: 1,
   INTERLOCK_MINIMIZE_OPERATION: 2,
   SEND_WINDOW_CONTENTS: 4,
   DISABLE_COMPOSITING_IN_GUEST: 8,
   DISABLE_MOUSE_BUTTON_SWAPPING: 16,
   SHOW_FLOATING_LANGUAGE_BAR: 32,

   /**
    * These constants represent possible window types for Unity windows.
    * Some may be deprecated, so refer to bora/public/unityCommon.h for more
    * info.
    */
   WINDOW_TYPE_NONE: -1,
   WINDOW_TYPE_NORMAL: 0,
   WINDOW_TYPE_PANEL: 1,
   WINDOW_TYPE_DIALOG: 2,
   WINDOW_TYPE_MENU: 3,
   WINDOW_TYPE_TOOLTIP: 4,
   WINDOW_TYPE_SPLASH: 5,
   WINDOW_TYPE_TOOLBAR: 6,
   WINDOW_TYPE_DOCK: 7,
   WINDOW_TYPE_DESKTOP: 8,
   WINDOW_TYPE_COMBOBOX: 9,
   WINDOW_TYPE_WIDGET: 10,
   WINDOW_TYPE_METRO_OBSOLETE: 11,
   WINDOW_TYPE_START_SCREEN: 12,
   WINDOW_TYPE_SLIDE_IN_PANEL: 13,
   WINDOW_TYPE_TASKBAR: 14,
   WINDOW_TYPE_METRO_FULLSCREEN_APP: 15,
   WINDOW_TYPE_METRO_DOCKED_APP: 16,
   MAX_WINDOW_TYPES: 17, // Final, sentinel attribute entry.

   /**
    * These constants represent possible window attributes for Unity windows.
    * Some may be deprecated, so refer to bora/public/unityCommon.h for more
    * info.
    */
   WINDOW_ATTR_BORDERLESS: 0,
   WINDOW_ATTR_MINIMIZABLE: 1,
   WINDOW_ATTR_MAXIMIZABLE: 2,
   WINDOW_ATTR_MAXIMIZED: 3,
   WINDOW_ATTR_CLOSABLE: 5,
   WINDOW_ATTR_HAS_TITLEBAR: 6,
   WINDOW_ATTR_VISIBLE: 7,
   WINDOW_ATTR_CHILD_WINDOW: 8,
   WINDOW_ATTR_HAS_TASKBAR_BTN: 9,
   WINDOW_ATTR_MOVABLE: 10,
   WINDOW_ATTR_RESIZABLE: 11,
   WINDOW_ATTR_ALWAYS_ABOVE: 12,
   WINDOW_ATTR_ALWAYS_BELOW: 13,
   WINDOW_ATTR_DISABLED: 14,
   WINDOW_ATTR_NOACTIVATE: 15,
   WINDOW_ATTR_SYSMENU: 16,
   WINDOW_ATTR_TOOLWINDOW: 17,
   WINDOW_ATTR_APPWINDOW: 18,
   WINDOW_ATTR_FULLSCREENABLE: 19,
   WINDOW_ATTR_FULLSCREENED: 20,
   WINDOW_ATTR_ATTN_WANTED: 21,
   WINDOW_ATTR_SHADEABLE: 22,
   WINDOW_ATTR_SHADED: 23,
   WINDOW_ATTR_STICKABLE: 24,
   WINDOW_ATTR_STICKY: 25,
   WINDOW_ATTR_MODAL: 26,
   WINDOW_ATTR_MINIMIZED: 27,
   WINDOW_ATTR_FOCUSED: 28,
   WINDOW_ATTR_TRANSPARENT: 29,
   MAX_ATTRIBUTES: 30, // Final, sentinel attribute entry.

   /**
    * Various constants defining the RPCs that we currently use.
    *
    * Some may be deprecated, so refer to bora/public/unityCommon.h for more
    * info.
    */
   RPC_ENTER: 'unity.enter',
   RPC_GET_BINARY_INFO: 'unity.get.binary.info',
   RPC_WINDOW_SETTOP: 'unity.window.settop',
   RPC_WINDOW_CLOSE: 'unity.window.close',
   RPC_GET_ICON_DATA: 'unity.get.icon.data',
   RPC_EXIT: 'unity.exit',
   RPC_GET_UPDATE_FULL: 'unity.get.update.full',
   RPC_GET_UPDATE_INCREMENTAL: 'unity.get.update.incremental',
   RPC_WINDOW_UNMINIMIZE: 'unity.window.restore',
   RPC_SET_OPTIONS: 'unity.set.options',
   RPC_GET_EXEC_INFO_HASH: 'ghi.guest.getExecInfoHash',

   // Guest-to-Host RPCs that we may receive.
   RPC_PUSH_UPDATE_CMD: 'tools.unity.push.update',
   RPC_ACTIVE: 'unity.active',
   RPC_NOTIFY_CLIENT: 'unity.notify.client',

   // VDPService command IDs.
   SERVER_UNITY_INFO_MSG: 0,
   SERVER_UNITY_PLUGIN_MSG: 1,
   CLIENT_UNITY_PLUGIN_MSG: 2,

   // Version enums used when XDR-encoding some Unity message parameters.
   OPTIONS_V1: 1,
   EXEC_INFO_HASH_V1: 1,
   ACTIVE_V1: 1,

   // Constants used by getIconData().
   ICON_TYPE_MAIN: 0,
   DEFAULT_ICON_CHUNK_SIZE: 32 * 1024, // 32KB

   /**
    * Unity.Mgr
    *
    * Constructor used to create a new instance of the Unity.Mgr object.
    *
    * @param vdpService   vdpService object that has been opened by the webmks.
    */

   Mgr: function Mgr(vdpService, mainChannel) {
      var self = this,


      /*
       * VDPService provides no built-in functionality to correlated RPC
       * responses previous requests.  As a result, we track in-flight requests with a
       * sequence number that the server treats as a cookie and returns back with the
       * response.  seqNo is a sequentially increasing number used as the cookie and
       * requests is the map of a cookie to optional callback functions.
       */
      requests = {},
          seqNo = 1,
          pendingIconRequests = {},


      // The various channel names and object names we use.
      unitySvcObject = 'UnitySvcObject',


      /*
       * Private functions that will be defined later in the file.
       * These are forward-defined here to avoid jslint errors from hoisting.
       */
      getIconDataChunk = null,
          _sendRPC = null,
          _serializeRPCParameter = null,
          parseUnityMessage = null,
          parseUnityCapabilities = null,
          parseUnityUpdate = null,
          splitStringComponents = null,
          removeWindow = null,
          handleGetBinaryInfoMessage = null,
          handleGetIconDataMessage = null,
          handleGetExecInfoHashMessage = null,
          handleUnityUpdateMessage = null,
          handleUnityActiveMessage = null,
          handleNotifyReadyMessage = null,
          vdpServiceMainChannel = mainChannel;

      if (mainChannel) {
         mainChannel.addMessageHandler(this);
      }

      /*
       * The Unity.Mgr owner can retrieve information about windows directly using the
       * .windows object by using the windowId as the key.  A window object has the
       * following attributes:
       *    .attributes: Object with attribute name as the key and a boolean as the value.
       *    .title: Title of the window.
       *    .type: Window type.
       *    .windowId: Window ID.
       *    .windowPath: Window path in remote desktop.
       *    .execPath: Executable path in remote desktop.
       */
      this.windows = {};
      this.windowCount = 0;
      this.isOn = false;
      this.paused = false;

      /**
       * Unity.Mgr.on
       *
       * Requests that the remote desktop enters Unity mode with the specified
       * feature mask.
       *
       * @param features  Bitmask of features.
       */
      this.on = function (features) {
         features = features || 0;

         /*
          * Sends RPC_SET_OPTIONS, then RPC_ENTER, then RPC_GET_UPDATE_FULL.
          * Doesn't wait for each RPC to complete before sending the next.
          */
         if (_sendRPC(true, null, null, Unity.RPC_SET_OPTIONS, Unity.OPTIONS_V1, 1, features) && _sendRPC(false, null, null, Unity.RPC_ENTER)) {
            self.requestUpdate(true);

            /*
             * Note: cui::UnityMgr has a much more complicated state process including an
             * "on pending" state that times out after 20 seconds.  I don't believe that it
             * is necessary for View and often times does more harm than good for us.
             */
            self.isOn = true;
            self.paused = false;
         }
      };

      /**
       * Unity.Mgr.off
       *
       * Requests that the remote desktop exits Unity mode.
       */
      this.off = function () {
         var windowId = void 0,
             removedWindow = false;

         // Clear this data even if sending the RPC failed.
         self.paused = false;
         self.isOn = false;
         for (windowId in self.windows) {
            if (self.windows.hasOwnProperty(windowId)) {
               if (removeWindow(windowId)) {
                  removedWindow = true;
               }
            }
         }

         // We faked window remove updates so we need to fake
         // onUpdateComplete() as well.
         if (removedWindow && !!self.onUpdateComplete) {
            self.onUpdateComplete();
         }

         // Send RPC_EXIT.
         _sendRPC(false, null, null, Unity.RPC_EXIT);
      };

      /**
       * Unity.Mgr.requestUpdate
       *
       * Requests either a full or incremental Unity update.
       *
       * @param fullUpdate Set to true if the update should be full, false
       *    otherwise.
       */
      this.requestUpdate = function (fullUpdate) {
         if (!!fullUpdate) {
            _sendRPC(false, null, null, Unity.RPC_GET_UPDATE_FULL);
         } else {
            _sendRPC(false, null, null, Unity.RPC_GET_UPDATE_INCREMENTAL);
         }
      };

      /**
       * Unity.Mgr.getBinaryInfo
       *
       * Requests the binary information for the specified Unity window path.
       *
       * @param windowPath The window path to retrieve the binary information
       *    for.
       * @param onDone   A callback function triggered upon RPC success.  Takes
       *    parameters: name       Name of the application. icons      Array of
       *    icon objects.  Each icon has:
       *                            .width  Width of the icon
       *                            .height Height of the icon
       *                            .bgra   Array with icon BGRA information
       * @param onAbort  A callback function triggered upon RPC failure.  Takes
       *    parameters: error      Error string sent by the remote desktop.
       */
      this.getBinaryInfo = function (windowPath, onDone, onAbort) {
         // Send Unity.RPC_GET_BINARY_INFO.
         if (!!windowPath && !!onDone) {
            _sendRPC(false, onDone, onAbort, Unity.RPC_GET_BINARY_INFO, windowPath);
         }
      };

      /**
       * Unity.Mgr.setTopWindows
       *
       * Requests that the remote desktop raise a group of Unity windows to the
       * top of the window stacking order.
       *
       * @param windowIds An array of Unity window IDs.
       */
      this.setTopWindows = function (windowIds) {
         // Send Unity.RPC_WINDOW_SETTOP.
         if (windowIds instanceof Array && windowIds.length > 0) {
            _sendRPC(false, null, null, Unity.RPC_WINDOW_SETTOP, windowIds);
         }
      };

      /**
       * Unity.Mgr.closeWindow
       *
       * Requests that the remote desktop close the specified window.
       *
       * @param windowId ID of window to close.
       */
      this.closeWindow = function (windowId) {
         // Send Unity.RPC_WINDOW_CLOSE.
         if (!!windowId) {
            _sendRPC(false, null, null, Unity.RPC_WINDOW_CLOSE, windowId);
         }
      };

      /**
       * Unity.Mgr.getIconData
       *
       * Requests an icon for the specified window.
       *
       * @param windowId ID of window to request icon data for.
       * @param size     Size of icon (e.g. 16, 32, 48).
       * @param onDone   A callback function triggered upon RPC success.  Takes
       *    parameters: bgra        Array with icon BGRA information.
       * @param onAbort  A callback function triggered upon RPC failure.  Takes
       *    parameters: error      Error string sent by the remote desktop.
       * @param chunkSize Optional chunk size that the caller can pass in.
       *    Defaults to Unity.DEFAULT_ICON_CHUNK_SIZE.
       */
      this.getIconData = function (windowId, size, onDone, onAbort, iconChunkSize) {
         iconChunkSize = iconChunkSize || Unity.DEFAULT_ICON_CHUNK_SIZE;

         // Send Unity.RPC_GET_ICON_DATA.
         if (!!windowId && size > 0 && !!onDone && iconChunkSize > 0) {
            getIconDataChunk(windowId, size, onDone, onAbort, iconChunkSize);
         }
      };

      /**
       * Unity.Mgr.unminimize
       *
       * Requests that the specified window be unminimized.
       *
       * @param windowId ID of window to unminimize.
       */
      this.unminimize = function (windowId) {
         // Send RPC_WINDOW_UNMINIMIZE.
         if (!!windowId) {
            _sendRPC(false, null, null, Unity.RPC_WINDOW_UNMINIMIZE, windowId);
         }
      };

      /**
       * Unity.Mgr.getExecInfoHash
       *
       * Requests a hash of the executable info used to save binary information
       * to an internal hash.
       *
       * @param execPath     Executable path received by onAdd listener.
       * @param onDone   A callback function triggered upon RPC success.  Takes
       *    parameters: execInfoHash Executable info hash.
       * @param onAbort  A callback function triggered upon RPC failure.  Takes
       *    parameters: error      Error string sent by the remote desktop.
       */
      this.getExecInfoHash = function (execPath, onDone, onAbort) {
         // Send Unity.RPC_GET_EXEC_INFO_HASH.
         if (!!execPath && !!onDone) {
            _sendRPC(true, onDone, onAbort, Unity.RPC_GET_EXEC_INFO_HASH, Unity.EXEC_INFO_HASH_V1, 1, execPath);
         }
      };

      /**
       * Unity.Mgr.pause
       *
       * Requests that Unity be paused.  Usually called by the UI as a result
       * of receiving the Unity "not ready" signal.
       *
       * This function doesn't send any RPCs, but does clear any internal Unity
       * window state the object maintains and sets a variable to prevent
       * dispatching most Unity updates.
       */
      this.pause = function () {
         var windowId = void 0,
             removedWindow = false;

         self.paused = true;

         for (windowId in self.windows) {
            if (self.windows.hasOwnProperty(windowId)) {
               if (removeWindow(windowId)) {
                  removedWindow = true;
               }
            }
         }

         // We faked window remove updates so we need to fake
         // onUpdateComplete() as well.
         if (removedWindow && !!self.onUpdateComplete) {
            self.onUpdateComplete();
         }
      };

      /**
       * Unity.Mgr.unpause
       *
       * Requests that Unity be unpaused.  Usually called by the UI as a result
       * of receiving the Unity "ready" signal after we were previously paused.
       *
       * This function resumes all Unity updates and requests a full Unity
       * update.
       */
      this.unpause = function () {
         /*
          * Set a variable to start dispatching Unity updates.
          * Also call self.requestUpdate(true).
          */
         self.paused = false;
         self.requestUpdate(true);
      };

      /**
       * Unity.Mgr.getPendingIconRequestCount
       *
       * Returns the number of in-flight icon requests.  Used by the unit tests
       * to confirm that the map was cleaned up properly.
       *
       * @return     Total icon request count.
       */
      this.getPendingIconRequestCount = function () {
         var request = void 0,
             count = 0;

         for (request in pendingIconRequests) {
            if (pendingIconRequests.hasOwnProperty(request)) {
               count++;
            }
         }

         return count;
      };

      /**
       * Unity.Mgr.getPendingRPCCount
       *
       * Returns the number of in-flight RPCs.
       *
       * @return     Total RPC count.
       */
      this.getPendingRPCCount = function () {
         var rpc = void 0,
             count = 0;

         for (rpc in requests) {
            if (requests.hasOwnProperty(rpc)) {
               count++;
            }
         }

         return count;
      };

      /**
       * getIconDataChunk
       *
       * Helper function to request an icon for the specified window at a
       * specified offset.
       *
       * @param windowId ID of window to request icon data for.
       * @param size     Size of icon (e.g. 16, 32, 48).
       * @param onDone   A callback function triggered upon RPC success.  Takes
       *    parameters: bgra        Array with icon BGRA information.
       * @param onAbort  A callback function triggered upon RPC failure.  Takes
       *    parameters: error      Error string sent by the remote desktop.
       * @param chunkSize        Icon chunk size.
       * @param iconPosition     Optional index to start at.  Defaults to 0.
       * @param previousCookie   Optional previous cookie used in a different
       *    RPC request for the same icon.  Should be sent if iconPosition > 0.
       */
      getIconDataChunk = function getIconDataChunk(windowId, size, onDone, onAbort, iconChunkSize, iconPosition, previousCookie) {
         var newCookie = void 0,
             pendingRequest = null;

         iconPosition = iconPosition || 0;
         newCookie = seqNo.toString();

         if (!!newCookie) {
            if (!!previousCookie) {
               pendingRequest = pendingIconRequests[previousCookie];
               delete pendingIconRequests[previousCookie];
            }
            if (!pendingRequest) {
               pendingRequest = {};
               pendingRequest.iconData = null;
            }

            pendingRequest.cookie = newCookie;
            pendingRequest.iconChunkSize = iconChunkSize;
            pendingRequest.windowId = windowId;
            pendingRequest.size = size;
            pendingRequest.onDone = onDone;
            pendingRequest.onAbort = onAbort;
            pendingRequest.iconPosition = iconPosition;
            pendingIconRequests[newCookie] = pendingRequest;
         }

         _sendRPC(false, onDone, onAbort, Unity.RPC_GET_ICON_DATA, windowId, Unity.ICON_TYPE_MAIN, size, iconPosition, iconChunkSize);
      };

      /**
       * sendRPC
       *
       * Function that owns the process of sending an RPC.
       *
       * @param xdrEncodeArgs  true if the arguments after the RPC string
       *    should be xdr-encoded if using vdpService.
       * @param onDone     Optional callback function triggered upon RPC
       *    success. Parameters depend on the RPC specifics.
       * @param onAbort    Optional callback function triggered upon RPC
       *    failure. Takes parameters: error      Error string sent by the
       *    remote desktop.
       * @param name       Name of the RPC
       * @param <params>   Optional extra parameters to be appended to string.
       * @return           true if successfully sent the RPC, false otherwise.
       */
      _sendRPC = function sendRPC(xdrEncodeArgs, onDone, onAbort, name) {
         var rpcString = name,
             i = 0,
             cookie = seqNo.toString(),
             xdrBuffer = void 0;

         if (!mainChannel) {
            _jscdkLogger2.default.error('Failed to send Unity RPC. vdpService channel is closed.');
            return false;
         }

         if (xdrEncodeArgs) {
            xdrBuffer = new _vdpservice2.default.XDRBuffer();
            xdrBuffer.initEncoder();

            for (i = _sendRPC.length; i < arguments.length; i++) {
               xdrBuffer.write(arguments[i]);
            }

            if (xdrBuffer.length > 0) {
               rpcString += ' ' + _stringUtils2.default.uint8ArrayToString(xdrBuffer.getData());
            }
         } else {
            // Add all extra parameters to the RPC string.
            for (i = _sendRPC.length; i < arguments.length; i++) {
               rpcString += _serializeRPCParameter(arguments[i]);
            }
         }

         /*
          * If neither onDone and onAbort are provided, that means that this request will
          * not result in a response being sent by the server.  For those RPCs, we should
          * not create an entry in requests, because it would never be cleaned up.
          */
         if (!!onDone && !!onAbort) {
            requests[cookie] = { onDone: onDone, onAbort: onAbort };
         }

         /*
          * Note: The RdeServer expects the message string to be null-terminated,
          * which StringUtils.stringToUint8Array does here.
          */
         if (0 === vdpServiceMainChannel.invoke({
            command: Unity.CLIENT_UNITY_PLUGIN_MSG,
            type: _vdpservice2.default.RPC_TYPE.POST,
            params: [0, 0, _stringUtils2.default.stringToUint8Array(rpcString, true), cookie, 0],
            objName: unitySvcObject
         })) {
            _jscdkLogger2.default.error('Failed to send Unity RPC.');
            delete requests[cookie]; // For if onDone callback was
            // provided.
            delete pendingIconRequests[cookie]; // For if it's an icon request.
            return false;
         }

         seqNo++;
         return true;
      };

      /**
       * serializeRPCParameter
       *
       * Helper function used to recursively add parameters to an RPC string.
       * Expands any arrays that it encounters.
       *
       * @param parameter    Parameter to add.
       * @return             Serialized RPC params string with leading space if
       *    > 0 params.
       */
      _serializeRPCParameter = function serializeRPCParameter(parameter) {
         var serializedString = '',
             i = 0;

         if (parameter instanceof Array) {
            for (i = 0; i < parameter.length; i++) {
               serializedString += _serializeRPCParameter(parameter[i]);
            }
         } else {
            serializedString += ' ' + parameter;
         }

         return serializedString;
      };

      /**
       * handleRPCFromServer
       *
       * Helper function used to parse the RPC data that we receive from a
       * server.
       *
       * @param rpc      RPC object that was posted by VDPService.
       */
      this.handleRPCFromServer = function (rpc) {
         var rpcName = void 0,
             cookie = void 0,
             messageContents = void 0,
             status = void 0,
             capabilities = void 0,
             capsCount = void 0,
             timestamp = void 0,
             invalidRPCCommand = false,
             lastTokenIndex = void 0,
             tokenIndex = void 0,
             spaceCharCode = 32;

         switch (rpc.command) {
            case Unity.SERVER_UNITY_INFO_MSG:
               if (rpc.type === _vdpservice2.default.RPC_TYPE.REQUEST && rpc.params.length >= 6) {
                  _jscdkLogger2.default.trace('Received Unity server info: ' + rpc.params);

                  capsCount = rpc.params[3];
                  capabilities = rpc.params[4];

                  if (!!capabilities) {
                     parseUnityCapabilities(capsCount, capabilities);
                  }
               } else {
                  invalidRPCCommand = true;
               }
               break;
            case Unity.SERVER_UNITY_PLUGIN_MSG:

               /*
                * The parameters sent by the server are in the format:
                *    rpc.params[0]: ?
                *    rpc.params[1]: ?
                *    rpc.params[2]: Uint8Array with string data of the format
                *                   <RPC name> <optional_RPC_parameters>
                *    rpc.params[3]: String containing cookie ('' means no cookie).
                *    rpc.params[4]: Integer containing status (0 means success).
                *    rpc.params[5]: ?
                */
               if (rpc.type === _vdpservice2.default.RPC_TYPE.POST && rpc.params.length === 6 && rpc.params[2] instanceof Uint8Array) {
                  /*
                   * Note: some messages (e.g. RPC_GET_BINARY_INFO) contain binary
                   * data that causes StringUtils.uint8ArrayToString to fail.
                   */
                  tokenIndex = _stringUtils2.default.uint8ArrayIndexOf(rpc.params[2], spaceCharCode);
                  if (tokenIndex === -1) {
                     _jscdkLogger2.default.error('unity.js: Failed to find first string in response.');
                     return;
                  }

                  rpcName = _stringUtils2.default.uint8ArrayToString(rpc.params[2].subarray(0, tokenIndex));
                  if (rpcName.indexOf('time:') === 0) {
                     // This first string is a timestamp and the next string is
                     // the RPC name.
                     timestamp = Date.parse(rpcName.slice(5));

                     lastTokenIndex = _stringUtils2.default.uint8ArrayIndexOf(rpc.params[2], spaceCharCode, tokenIndex + 1);
                     if (lastTokenIndex === -1) {
                        _jscdkLogger2.default.error('unity.js: Failed to find second string in response.');
                        return;
                     }

                     rpcName = _stringUtils2.default.uint8ArrayToString(rpc.params[2].subarray(tokenIndex + 1, lastTokenIndex));

                     if (!!timestamp) {
                        _jscdkLogger2.default.trace('Receiving Unity message ' + rpcName + ' took ' + (Date.now() - timestamp) + 'ms.');
                     }
                  } else {
                     lastTokenIndex = tokenIndex;
                  }

                  if (rpcName.length === 0) {
                     _jscdkLogger2.default.error('unity.js: Failed to parse RPC name from server.');
                     return;
                  }

                  messageContents = rpc.params[2].subarray(lastTokenIndex + 1);

                  cookie = rpc.params[3];
                  status = rpc.params[4];

                  parseUnityMessage(cookie, status, rpcName, messageContents);
               } else {
                  invalidRPCCommand = true;
               }
               break;
            default:
               return 1;
         }

         if (invalidRPCCommand) {
            _jscdkLogger2.default.error('Unity message ' + rpc.command + ' with type ' + rpc.type + ' was in an unexpected format: ' + rpc.params);
         }
         return 0;
      };

      /**
       * parseUnityMessage
       *
       * Helper function used to parse a Unity message that is received by
       * vdpService.
       *
       * @param cookie        String containing the request cookie.
       * @param status        Status integer (literal) sent by server.  0 means
       *    success.
       * @param messageName   Name of the message sent.  Usually corresponds to
       *    an RPC.
       * @param messageContents  The message-specific contents in a Uint8Array.
       */
      parseUnityMessage = function parseUnityMessage(cookie, status, messageName, messageContents) {
         var success = !status,
             rpcContentsInvalid = false,
             callbacks = void 0,
             onDone = void 0,
             onAbort = void 0;

         if (!!cookie && cookie.length > 0) {
            callbacks = requests[cookie];
            if (!!callbacks) {
               onDone = callbacks.onDone;
               onAbort = callbacks.onAbort;
               delete requests[cookie];
            }
         }

         if (!success) {
            if (messageName === Unity.RPC_GET_ICON_DATA) {
               // Icon request failed, so delete the request.
               delete pendingIconRequests[cookie];
            }

            /*
             * Note: Don't log messageContents because it may contain null characters,
             * which causes the unit test framework to fail.
             */
            _jscdkLogger2.default.error('Unity RPC ' + messageName + ' failed (status=' + status + ').');
            if (!!onAbort) {
               onAbort(_stringUtils2.default.uint8ArrayToString(messageContents));
            }
            return;
         }

         switch (messageName) {
            case Unity.RPC_GET_BINARY_INFO:
               rpcContentsInvalid = !handleGetBinaryInfoMessage(messageContents, onDone);
               break;
            case Unity.RPC_GET_ICON_DATA:
               rpcContentsInvalid = !handleGetIconDataMessage(messageContents, onDone, cookie);
               /**
                * In web client, RPC_GET_BINARY_INFO: ‘unity.get.binary.info’
                * is the latest time to show application. But when network
                * disconnect and reconnect, we don’t get this message again.
                * This will cause application not display.
                * So we choose to use RPC_GET_ICON_DATA: ‘unity.get.icon.data’.
                * Which is a little earlier than binary info.
                * On windows client, they don’t even go into get binary info functions.
                * The latest messageName is OnGetWindowIconDone,
                * so we use the same messageName to check application display time.
                * 60ms will make user experience better. As it's an average time between
                * get icon and RPC_GET_BINARY_INFO.
                * No timer could also fix the bug 1869835.
                */
               setTimeout(function () {
                  if (!!self.onVisibilityChanged) {
                     self.onVisibilityChanged(true);
                  }
               }, 60);
               break;
            case Unity.RPC_GET_EXEC_INFO_HASH:
               rpcContentsInvalid = !handleGetExecInfoHashMessage(messageContents, onDone);
               break;
            case Unity.RPC_PUSH_UPDATE_CMD:
               rpcContentsInvalid = !handleUnityUpdateMessage(messageContents);
               break;
            case Unity.RPC_ACTIVE:
               rpcContentsInvalid = !handleUnityActiveMessage(messageContents);
               break;
            case Unity.RPC_NOTIFY_CLIENT:
               rpcContentsInvalid = !handleNotifyReadyMessage(messageContents);
               break;
         }

         if (rpcContentsInvalid) {
            if (messageName === Unity.RPC_GET_ICON_DATA) {
               // Icon request received an invalid response, so delete the
               // request.
               delete pendingIconRequests[cookie];
            }

            _jscdkLogger2.default.error('Unexpectedly unable to dispatch response for RPC ' + messageName);

            if (!!onAbort) {
               onAbort('Unexpected failure');
            }
         }
      };

      /**
       * parseUnityCapabilities
       *
       * Helper function used to parse a capabilities string sent by the server.
       * If successful, also triggers the .onCapsChanged listener.
       *
       * @param count        Number of capabilities sent.
       * @param capabilities String of form "1=1;2=1;4=1;5=1;".
       */
      parseUnityCapabilities = function parseUnityCapabilities(count, capabilities) {
         var capsArray = capabilities.split(';'),
             capArray = void 0,
             serverCaps = [],
             i = 0;

         if (capsArray instanceof Array && capsArray.length > 0) {
            /*
             * The last entry may be empty due to a trailing semicolon.
             * Remove it so we can accurately check the count.
             */
            if (capsArray[capsArray.length - 1].length === 0) {
               capsArray.pop();
            }

            if (count > capsArray.length) {
               /*
                * This isn't a fatal error but may be indicative of a
                * parsing failure.
                */
               _jscdkLogger2.default.error('Unity capabilities count ' + count + ' is unexpectedly larger than actual count ' + capsArray.length + '. Caps: ' + capabilities);
               return;
            }

            for (i = 0; i < count; i++) {
               // Each individual capability is of the form 'type=1'.
               capArray = capsArray[i].split('=');
               if (!!capArray && capArray instanceof Array && capArray.length === 2) {
                  if (capArray[1] === '1') {
                     serverCaps.push(parseInt(capArray[0], 10));
                  }
               } else {
                  _jscdkLogger2.default.error('Unable to parse Unity capability entry ' + i + ' with contents: ' + capabilities[i]);
                  return;
               }
            }

            _jscdkLogger2.default.trace('Received Unity capabilities: ' + serverCaps);

            if (!!self.onCapsChanged) {
               self.onCapsChanged(serverCaps);
            }
         }
      };

      /**
       * parseUnityUpdate
       *
       * Helper function used to parse a single Unity update.
       *
       * @param update        Unity update string.
       * @return              true if a listener was triggered, false otherwise.
       */
      parseUnityUpdate = function parseUnityUpdate(update) {
         var updateComponents = void 0,
             type = void 0,
             windowId = void 0,
             shouldCheckExists = void 0,
             shouldExist = void 0,
             window = void 0,
             exists = void 0,
             updateContentsInvalid = false,
             i = void 0,
             temp1 = void 0,
             temp2 = void 0;

         if (update.trim().indexOf('title') === 0) {
            /*
             * The window title may have spaces so we must separate it into exactly
             * three components: the update name, the window ID, and the title.
             */
            updateComponents = splitStringComponents(update, 3);
         } else {
            updateComponents = update.split(' ');
         }

         if (!(updateComponents instanceof Array) || updateComponents.length < 2) {
            _jscdkLogger2.default.error('Received invalid Unity update: "' + update + '"');
            return false;
         }

         type = updateComponents[0];
         windowId = updateComponents[1];
         shouldExist = type !== 'add';
         window = self.windows[windowId];
         exists = !!window;

         // A few update types don't have the Unity window ID first, so don't
         // check.
         shouldCheckExists = type !== 'rect' && type !== 'zorder' && type !== 'activedesktop';

         if (shouldCheckExists && shouldExist !== exists) {
            _jscdkLogger2.default.trace('Received Unity update "' + type + '" for ' + (exists ? 'existing windowId ' : 'nonexistent windowId ') + windowId);
            return false;
         }

         _jscdkLogger2.default.trace('Received Unity update "' + type + '" for windowId: ' + windowId);

         switch (type) {
            case 'add':
               if (updateComponents.length >= 4) {
                  /*
                   * Initialize the window object.  We may eventually move this code
                   * into its own constructor.
                   */
                  window = {
                     attributes: {}, title: '', type: Unity.WINDOW_TYPE_NONE,
                     windowId: windowId
                  };

                  // Initialize all attributes.
                  for (i = Unity.WINDOW_ATTR_BORDERLESS; i < Unity.MAX_ATTRIBUTES; i++) {
                     window.attributes[i] = false;
                  }

                  // The rest of the components, including windowPath and
                  // execPath.
                  for (i = 2; i < updateComponents.length; i++) {
                     temp1 = updateComponents[i].indexOf('=');
                     temp2 = updateComponents[i].substr(0, temp1);

                     if (temp2.length > 0) {
                        window[temp2] = updateComponents[i].substr(temp1 + 1);
                     }
                  }

                  if (!window.windowPath || window.windowPath.length === 0) {
                     _jscdkLogger2.default.error('Window id ' + windowId + ' did not have a ' + 'window path.');
                     updateContentsInvalid = true;
                  } else {
                     if (!window.execPath || window.execPath.length === 0) {
                        _jscdkLogger2.default.trace('Window id ' + windowId + ' did not have an ' + 'exec path. Using window path instead.');
                        window.execPath = window.windowPath;
                     }

                     self.windows[windowId] = window;
                     self.windowCount++;

                     if (!!self.onAdd) {
                        self.onAdd(windowId, window.windowPath, window.execPath);
                        return true;
                     }
                  }
               } else {
                  _jscdkLogger2.default.error('Expected at least 4 components for Unity add ' + 'update, but received ' + updateComponents.length);
                  updateContentsInvalid = true;
               }
               break;
            case 'remove':
               if (removeWindow(windowId)) {
                  return true;
               }
               break;
            case 'move':
               // We are not currently respecting this update type.
               break;
            case 'title':
               if (updateComponents.length >= 3) {
                  window.title = updateComponents[2];

                  if (!!self.onTitleChanged) {
                     self.onTitleChanged(windowId, window.title);
                     return true;
                  }
               } else {
                  updateContentsInvalid = true;
               }
               break;
            case 'zorder':
               // We are not currently respecting this update type.
               break;
            case 'region':
               // We are not currently respecting this update type.
               break;
            case 'state':
               // State is deprecated so we don't use it.
               break;
            case 'attr':
               if (updateComponents.length >= 4) {
                  temp1 = parseInt(updateComponents[2], 10);
                  temp2 = updateComponents[3] === '1';

                  if (temp1 >= Unity.WINDOW_ATTR_BORDERLESS && temp1 < Unity.MAX_ATTRIBUTES) {
                     window.attributes[temp1] = temp2;

                     if (!!self.onAttrChanged) {
                        self.onAttrChanged(windowId, temp1, temp2);
                        return true;
                     }
                  }
               } else {
                  updateContentsInvalid = true;
               }
               break;
            case 'type':
               if (updateComponents.length >= 3) {
                  temp1 = parseInt(updateComponents[2], 10);

                  if (temp1 >= Unity.WINDOW_TYPE_NORMAL && temp1 < Unity.MAX_WINDOW_TYPES) {
                     window.type = temp1;

                     if (!!self.onTypeChanged) {
                        self.onTypeChanged(windowId, window.type);
                        return true;
                     }
                  } else {
                     updateContentsInvalid = true;
                  }
               }
               break;
            case 'icon':
               // Note: The icon type is in updateComponents[2] but we don't
               // need it.
               if (!!self.onIconChanged) {
                  self.onIconChanged(windowId);
                  return true;
               }
               break;
            case 'desktop':
               // We are not currently respecting this update type.
               break;
            case 'activedesktop':
               // We are not currently respecting this update type.
               break;
            case 'titlebararea':
               // We are not currently respecting this update type.
               break;
            case 'primarywindow':
               // We are not currently respecting this update type.
               break;
            case 'secondarywindows':
               // We are not currently respecting this update type.
               break;
            case 'rect':
               // We are not currently respecting this update type.
               break;
            default:
               _jscdkLogger2.default.trace('Received unknown Unity update? ' + update);
               break;
         }

         if (updateContentsInvalid) {
            _jscdkLogger2.default.error('Contents were invalid for Unity update of type: ' + type);
         }

         return false;
      };

      /**
       * splitStringComponents
       *
       * Helper function used to split a string into a certain number of
       * components at the space character.  The last word will contain the
       * rest of the string, possibly including spaces.
       *
       * @param string  String to split.
       * @param count   Number of components to split it into.
       * @return        If successful, Array of string.  Otherwise null.
       */
      splitStringComponents = function splitStringComponents(string, count) {
         var components = null,
             i = 0,
             regex = '';

         if (!!string && string.match instanceof Function) {
            // Add regex components for all words other than the last one.
            for (i = 0; i < count - 1; i++) {
               regex += '(\\S+)\\s+';
            }
            // The last word should include all of the rest of the string.
            regex += '(.*)';

            components = new RegExp(regex).exec(string);

            if (components instanceof Array) {
               // The first index has the full update, which we don't want.
               components.shift();
            }
         }

         return components;
      };

      /**
       * removeWindow
       *
       * Helper function used to remove a window from the internal tracker
       * and call a listener to notify the consumer of the window removal.
       *
       * @param windowId   Window ID to remove.
       * @return           true if a listener was triggered, false otherwise.
       */
      removeWindow = function removeWindow(windowId) {
         if (!!windowId) {
            delete self.windows[windowId];
            self.windowCount--;

            if (!!self.onRemove) {
               self.onRemove(windowId);
               return true;
            }
         }
         return false;
      };

      /**
       * handleGetBinaryInfoMessage
       *
       * Helper function used to parse and handle the response to
       * RPC_GET_BINARY_INFO.
       *
       * @param messageContents  The message-specific contents in a Uint8Array.
       * @param onDone           Done slot that caller passed into
       *    getBinaryInfo().
       * @return                 true if successfully parsed the message, false
       *    otherwise.
       */
      handleGetBinaryInfoMessage = function handleGetBinaryInfoMessage(messageContents, onDone) {
         var tokenObject = void 0,
             name = void 0,
             images = [],
             imageCount = void 0,
             image = void 0,
             imageBGRASize = void 0,
             i = void 0;

         tokenObject = _stringUtils2.default.uint8ArrayTokenize(messageContents, 0);
         name = _stringUtils2.default.uint8ArrayToString(tokenObject.result);
         if (name.length === 0) {
            _jscdkLogger2.default.error('Unable to parse application name from ' + 'getBinaryInfo response.');
            return false;
         }

         tokenObject = _stringUtils2.default.uint8ArrayTokenize(messageContents, 0, tokenObject.index + 1);
         if (tokenObject.result.length === 0) {
            _jscdkLogger2.default.error('Unable to parse image count for application "' + name + '" from getBinaryInfo response.');
            return false;
         }

         imageCount = parseInt(_stringUtils2.default.uint8ArrayToString(tokenObject.result), 10);

         for (i = 0; i < imageCount; i++) {
            image = {};

            // The first null-separated string is the image width.
            tokenObject = _stringUtils2.default.uint8ArrayTokenize(messageContents, 0, tokenObject.index + 1);
            image.width = parseInt(_stringUtils2.default.uint8ArrayToString(tokenObject.result), 10);

            // Next is the image height.
            tokenObject = _stringUtils2.default.uint8ArrayTokenize(messageContents, 0, tokenObject.index + 1);
            image.height = parseInt(_stringUtils2.default.uint8ArrayToString(tokenObject.result), 10);

            /*
             * Next is the image size, which tells us how many image bytes are after
             * the next null.
             */
            tokenObject = _stringUtils2.default.uint8ArrayTokenize(messageContents, 0, tokenObject.index + 1);
            imageBGRASize = parseInt(_stringUtils2.default.uint8ArrayToString(tokenObject.result), 10);

            // Next is the image data.
            image.bgra = messageContents.subarray(tokenObject.index + 1, tokenObject.index + imageBGRASize + 1);
            tokenObject.index += imageBGRASize + 1; // Skip the following null
            // byte too.

            // Now do some sanity checking
            if (image.width <= 0 || image.height <= 0 || imageBGRASize <= 0 || imageBGRASize !== image.bgra.length) {
               _jscdkLogger2.default.error('Failed to parse image index ' + i + ' for application "' + name + '", image=' + JSON.stringify(image) + ', image.bgra.length=' + image.bgra.length + ', imageBGRASize=' + imageBGRASize);
            } else {
               images.push(image);
            }
         }

         if (!!onDone) {
            onDone(name, images);
         }

         return true;
      };

      /**
       * handleGetIconDataMessage
       *
       * Helper function used to parse and handle the response to
       * RPC_GET_ICON_DATA.
       *
       * @param messageContents  The message-specific contents in a Uint8Array.
       * @param onDone           Done slot that caller passed into
       *    getIconData().
       * @param cookie           cookie that was used for last
       *    RPC_GET_ICON_DATA message.
       * @return                 true if successfully parsed the message, false
       *    otherwise.
       */
      handleGetIconDataMessage = function handleGetIconDataMessage(messageContents, onDone, cookie) {
         var iconRequest = void 0,
             tokenObject = void 0,
             fullIconLength = void 0,
             returnedIconLength = void 0,
             iconChunk = void 0,
             spaceCharCode = 32;

         iconRequest = pendingIconRequests[cookie];
         if (!iconRequest) {
            // We need callback info because that's where we store icon chunks.
            _jscdkLogger2.default.error('Unexpectedly unable to find request info for ' + ' getIconData response with cookie ' + cookie);
            return false;
         }

         // The first token returned is the full image length.
         tokenObject = _stringUtils2.default.uint8ArrayTokenize(messageContents, spaceCharCode);
         if (tokenObject.result.length === 0) {
            _jscdkLogger2.default.error('Unable parse full image length from ' + 'getIconData response.');
            return false;
         }

         fullIconLength = parseInt(_stringUtils2.default.uint8ArrayToString(tokenObject.result), 10);

         tokenObject = _stringUtils2.default.uint8ArrayTokenize(messageContents, spaceCharCode, tokenObject.index + 1);
         if (tokenObject.result.length === 0) {
            _jscdkLogger2.default.error('Unable to parse returned image length from ' + 'getIconData response.');
            return false;
         }

         returnedIconLength = parseInt(_stringUtils2.default.uint8ArrayToString(tokenObject.result), 10);

         if (fullIconLength <= 0 || returnedIconLength <= 0) {
            _jscdkLogger2.default.error('getIconData response had bad icon lengths: ' + fullIconLength + ', ' + returnedIconLength);
            return false;
         }

         if (iconRequest.iconPosition + returnedIconLength > fullIconLength) {
            _jscdkLogger2.default.error('getIconData response overflowed end of buffer. Expected ' + 'end to be ' + fullIconLength + ' but received end of ' + (iconRequest.iconPosition + returnedIconLength));
            return false;
         }

         tokenObject.index++;
         iconChunk = messageContents.subarray(tokenObject.index, tokenObject.index + returnedIconLength);

         if (iconChunk.length !== returnedIconLength) {
            _jscdkLogger2.default.error('getIconData response had bad icon data. ' + 'Expected ' + returnedIconLength + ' bytes but ' + 'only received ' + iconChunk.length + ' bytes.');
            return false;
         }

         if (returnedIconLength === fullIconLength && !iconRequest.iconData) {
            // Avoid an extra copy by just using the array directly.
            iconRequest.iconData = iconChunk;
         } else {
            if (!iconRequest.iconData) {
               // There is more image data to come, so allocate the full length.
               iconRequest.iconData = new Uint8Array(fullIconLength);
            }
            iconRequest.iconData.set(iconChunk, iconRequest.iconPosition);
         }

         iconRequest.iconPosition += iconChunk.length;

         if (iconRequest.iconPosition < fullIconLength) {
            _jscdkLogger2.default.trace('Received ' + iconRequest.iconPosition + ' of ' + fullIconLength + ' icon bytes for cookie ' + cookie + ', so sending another RPC.');

            getIconDataChunk(iconRequest.windowId, iconRequest.size, iconRequest.onDone, iconRequest.onAbort, iconRequest.iconChunkSize, iconRequest.iconPosition, cookie);
         } else {
            _jscdkLogger2.default.trace('Received full ' + iconRequest.iconPosition + ' bytes for cookie ' + cookie + ', so all done.');

            delete pendingIconRequests[cookie];
            if (!!onDone) {
               onDone(iconRequest.iconData);
            }
         }

         return true;
      };

      /**
       * handleGetExecInfoHashMessage
       *
       * Helper function used to parse and handle the response to
       * RPC_GET_EXEC_INFO_HASH.
       *
       * @param messageContents  The message-specific contents in a Uint8Array.
       * @param onDone           Done slot that caller passed into
       *    getExecInfoHash().
       * @return                 true if successfully parsed the message, false
       *    otherwise.
       */
      handleGetExecInfoHashMessage = function handleGetExecInfoHashMessage(messageContents, onDone) {
         var xdrBuffer = void 0,
             xdrObjectVersion = void 0,
             xdrObjectMoreData = void 0,
             xdrObjectData = void 0;

         /*
          * We need to XDR decode the response, which we read in the following order:
          *   uint32 with struct version, 4-byte-aligned bool explaining whether
          *   there is more data (should be true), then string with exec info hash.
          */
         xdrBuffer = new _vdpservice2.default.XDRBuffer();
         xdrBuffer.initDecoder(messageContents);
         xdrObjectVersion = xdrBuffer.readUint32();
         xdrObjectMoreData = xdrBuffer.readUint32() !== 0;

         // Note: We treat an empty exec info hash as success for now.
         if (xdrObjectVersion === Unity.EXEC_INFO_HASH_V1 && xdrObjectMoreData) {
            xdrObjectData = xdrBuffer.readString();

            _jscdkLogger2.default.trace('Received exec info hash: ' + xdrObjectData);
            if (!!onDone) {
               onDone(xdrObjectData);
            }

            return true;
         } else {
            _jscdkLogger2.default.error('Received unexpected exec info hash response. version=' + xdrObjectVersion + ', moreData=' + xdrObjectMoreData);
            return false;
         }
      };

      /**
       * handleUnityUpdateMessage
       *
       * Helper function used to parse and handle a Unity update message.
       *
       * @param messageContents  The message-specific contents in a Uint8Array.
       * @return                 true if successfully parsed the message, false
       *    otherwise.
       */
      handleUnityUpdateMessage = function handleUnityUpdateMessage(messageContents) {
         var messageComponents = void 0,
             i = void 0,
             listenerCalled = false;

         if (!self.paused) {
            messageComponents = _stringUtils2.default.uint8ArrayToString(messageContents).split('\x00');
            if (messageComponents instanceof Array) {
               for (i = 0; i < messageComponents.length; i++) {
                  if (messageComponents[i].length !== 0) {
                     if (parseUnityUpdate(messageComponents[i])) {
                        listenerCalled = true;
                     }
                  }
               }

               if (messageComponents.length > 0) {
                  _jscdkLogger2.default.debug('Finished parsing current Unity update. One or ' + 'more listeners ' + (listenerCalled ? 'were' : 'were not') + ' called.');
                  if (listenerCalled && !!self.onUpdateComplete) {
                     self.onUpdateComplete();
                  }
               }
            } else {
               return false;
            }
         }

         return true;
      };

      /**
       * handleUnityActiveMessage
       *
       * Helper function used to parse and handle a Unity active message.
       *
       * @param messageContents  The message-specific contents in a Uint8Array.
       * @return                 true if successfully parsed the message, false
       *    otherwise.
       */
      handleUnityActiveMessage = function handleUnityActiveMessage(messageContents) {
         var xdrBuffer = void 0,
             xdrActiveVersion = void 0,
             xdrActiveData = void 0;

         xdrBuffer = new _vdpservice2.default.XDRBuffer();
         xdrBuffer.initDecoder(messageContents);
         xdrActiveVersion = xdrBuffer.readUint32();
         xdrActiveData = xdrBuffer.readUint32();

         if (xdrActiveVersion === Unity.ACTIVE_V1) {
            if (!!self.onActiveChanged) {
               self.onActiveChanged(xdrActiveData);
            }
            return true;
         } else {
            return false;
         }
      };

      /**
       * handleNotifyReadyMessage
       *
       * Helper function used to parse and handle a Unity ready message.
       *
       * @param messageContents  The message-specific contents in a Uint8Array.
       * @return                 true if successfully parsed the message, false
       *    otherwise.
       */
      handleNotifyReadyMessage = function handleNotifyReadyMessage(messageContents) {
         var messageComponents = _stringUtils2.default.uint8ArrayToString(messageContents).split('\x00');

         if (messageComponents instanceof Array && messageComponents.length >= 1) {
            if (!!self.onReadyChanged) {
               self.onReadyChanged(messageComponents[0] === 'ready');
            }
            return true;
         } else {
            return false;
         }
      };
   }
}; /*********************************************************
    * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
    *********************************************************/

/**
 * unity.js --
 *
 * Interface used to send and receive Unity RPCs and updates.
 * The full Unity documentation can be found in bora/public/unityCommon.h and the
 * RPC constants referenced in the code are described there.
 *
 * Consumers of this interface should set the following optional listeners in the object
 * after it is instantiated:
 *
 *    .onAdd           Called when Unity window is added.  Takes parameters:
 *       windowId         ID of window to add.
 *       windowPath       String tying the window ID to an executable.
 *       execPath         String uniquely identifying just the executable.
 *    .onRemove        Called when Unity window is removed.  Takes parameters:
 *       windowId         ID of window to remove.
 *    .onTitleChanged  Called when Unity window title changes.  Takes parameters:
 *       windowId         ID of window to update.
 *       windowTitle      New window title.
 *    .onAttrChanged   Called when Unity window attribute changes.  Takes parameters:
 *       windowId         ID of window to update.
 *       type             Attribute type.
 *       value            Attribute value (boolean).
 *    .onTypeChanged   Called when Unity window type changes.  Takes parameters:
 *       windowId         ID of window whose type changed.
 *       type             New window type.
 *    .onIconChanged   Called when Unity window icon changes.  Takes parameters:
 *       windowId         ID of window whose icon changed.
 *    .onReadyChanged  Called when the remote desktop signals a change in whether
 *                     or not it is ready for Unity.  Takes parameters:
 *       ready            true if ready, false if not ready.
 *    .onActiveChanged Called when the remote desktops signals a change in whether
 *                     Unity is on or off.  Takes parameters:
 *       active           true if Unity is on, false if it is off.
 *    .onCapsChanged   Called when the remote desktop signals their capabilities.
 *                     Takes parameters:
 *       caps             Array containing capabilities that the server advertised.
 *    .onUpdateComplete Called after a Unity update (RPC_PUSH_UPDATE_CMD) has been
 *                      completely parsed and one or more listeners called.
 */

if (Object.freeze) {
   Unity = Object.freeze(Unity);
}

exports.default = Unity;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DoLockHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * doLockHandler.js --
 *
 *      Implementation of the message handler to send doLock.
 */

function DoLockHandler() {
   // member variables below
   this.messageName = "do-lock";
   this.messageText = "do-lock";
   this.responseTag = "lock";

   // register dependencies here
   var router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
DoLockHandler.prototype = new _messageHandler.MessageHandler();
DoLockHandler.constructor = DoLockHandler;

DoLockHandler.prototype.setRequestXML = function () {
   this.requestXML = "";
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
DoLockHandler.prototype.onUpdated = function () {
   var doLockAction = void 0,
       router = _util2.default.getObject(_jscdkClient.globalArray, "router"),
       idleTimeoutTimerController = _util2.default.getObject(_jscdkClient.globalArray, "idle-timeout-timer");

   if (!idleTimeoutTimerController) {
      _jscdkLogger2.default.error("do lock should only be triigered by the idleTimeoutTimerController");
      return;
   }

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
      _jscdkLogger2.default.debug("doLock result is OK.");
      if (idleTimeoutTimerController.needDisplayDialogs) {
         doLockAction = { name: "DoLock", result: "ok" };
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(doLockAction));
      } else if (idleTimeoutTimerController.notifyLockEventToUI) {
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify({ name: "AlreadyLock" }));
      }
   } else {
      _jscdkLogger2.default.error("doLock failed.");
   }

   // push error to UI
   router.pushErrorToUser(this);
};

/**
 * parse locale information from the response XML of GetConfiguration
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return Object. key-value pairs parsed from response, if error then return
 *    null
 */
DoLockHandler.prototype.parseResult = function (responseXML) {
   var responseBody = void 0,
       brokerTag = void 0,
       responses = void 0,
       resultText = void 0,
       doLockResponse = {},
       errorCodeElem = void 0,
       errorMessageElem = void 0,
       userMessageElem = void 0;

   if (!responseXML || responseXML === "") {
      return null;
   }
   responseBody = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(responseBody.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of getAuthenticationStatus error");
      return null;
   }
   responses = brokerTag.children(this.responseTag);
   resultText = responses.children("result").text();
   if (!!resultText && resultText.trim() !== "") {
      doLockResponse["result"] = resultText;
   } else {
      _jscdkLogger2.default.error("response of getAuthenticationStatus error, no valid result tag");
      return null;
   }
   if (resultText === "error") {
      errorCodeElem = responseBody.find("error-code");
      doLockResponse["error-code"] = errorCodeElem.text();
      errorMessageElem = responseBody.find("error-message");
      doLockResponse["error-message"] = errorMessageElem.text();
      userMessageElem = responseBody.find("user-message");
      doLockResponse["user-message"] = userMessageElem.text();
   }
   return doLockResponse;
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.HaveAuthTypesEnum = undefined;
exports.GetConfigurationHandler = GetConfigurationHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _jscdkBrokerError = __webpack_require__(15);

var _jscdkBrokerError2 = _interopRequireDefault(_jscdkBrokerError);

var _getAuthenticationStatusHandler = __webpack_require__(40);

var _getAuthenticationStatusHandler2 = _interopRequireDefault(_getAuthenticationStatusHandler);

var _jscdkClientController = __webpack_require__(52);

var _jscdkClientController2 = _interopRequireDefault(_jscdkClientController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// all auth types here
var HaveAuthTypesEnum = exports.HaveAuthTypesEnum = {
   HAVEAUTHTYPE_DEFAULT: "",
   HAVEAUTHTYPE_SAML: "saml",
   HAVEAUTHTYPE_UNAUTH: "unauthenticated"
}; /*********************************************************
    * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
    *********************************************************/

/**
 * getConfigurationHandler.js --
 *
 *      Implementation of the message handler to get configuration.
 */

var PasscodeAuthLabel = {
   PASSCODE_AUTH_LABEL_RSA_SECURID: "RSA SecurID"
};

function GetConfigurationHandler() {
   // member variables below
   this.messageName = "get-configuration";
   this.messageText = "get-configuration";
   this.responseTag = "configuration";
   this.authTypes = HaveAuthTypesEnum.HAVEAUTHTYPE_DEFAULT;

   // register dependencies below, only involve setlocale when first sending
   var setLocaleObject = void 0;
   var router = void 0;
   setLocaleObject = _util2.default.getObject(_jscdkClient.globalArray, "set-locale");
   if (!!setLocaleObject) {
      this.registerHandler(setLocaleObject, "state");
   }
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
   this.ignoreResponseFlag = false;
}

// inherits MessageHandler prototype
GetConfigurationHandler.prototype = new _messageHandler.MessageHandler();
// constructor
GetConfigurationHandler.constructor = GetConfigurationHandler;

/**
 * Set the request XML for Windows password authentication.
 *
 */
GetConfigurationHandler.prototype.setRequestXML = function (ignoreResponse) {
   // handle SAML
   var samlNameElem = void 0,
       unauthNameElem = void 0,
       haveAuthTypesElem = void 0,
       contentElem = "",
       supprotedFeatures = void 0,
       urlHandler = null,
       authTypes = void 0;
   authTypes = this.getAuthTypes();

   if (authTypes === HaveAuthTypesEnum.HAVEAUTHTYPE_SAML) {
      samlNameElem = _util2.default.createElement("name", "saml");
      haveAuthTypesElem = _util2.default.createElement("have-authentication-types", samlNameElem);
      contentElem = haveAuthTypesElem;
   } else if (authTypes === HaveAuthTypesEnum.HAVEAUTHTYPE_UNAUTH) {
      unauthNameElem = _util2.default.createElement("name", "unauthenticated");
      haveAuthTypesElem = _util2.default.createElement("have-authentication-types", unauthNameElem);
      contentElem = haveAuthTypesElem;
   }

   supprotedFeatures = _util2.default.createElement("feature", "lastUserActivity");
   supprotedFeatures += _util2.default.createElement("feature", "reauthentication");
   supprotedFeatures += _util2.default.createElement("feature", "nameResolution");
   supprotedFeatures += _util2.default.createElement("feature", "redirection");
   supprotedFeatures += _util2.default.createElement("feature", "workspaceOneMode");
   urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");
   if (!!urlHandler && urlHandler.params.allowCollaboration === "1") {
      supprotedFeatures += _util2.default.createElement("feature", "shadowSessions");
   }
   contentElem += _util2.default.createElement("supported-features", supprotedFeatures);

   this.requestXML = contentElem;
   if (ignoreResponse === true) {
      this.ignoreResponseFlag = true;
   } else {
      this.ignoreResponseFlag = false;
   }
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
GetConfigurationHandler.prototype.onUpdated = function () {
   var errorObj = void 0,
       errorCode = void 0,
       router = _util2.default.getObject(_jscdkClient.globalArray, "router"),
       sendGetAuthenticationStatus = function sendGetAuthenticationStatus() {
      var getAuthenticationStatusObject = _jscdkClient.globalArray["get-authentication-status"],
          handlerList = void 0;
      if (!getAuthenticationStatusObject) {
         getAuthenticationStatusObject = new _getAuthenticationStatusHandler2.default();
         _jscdkClient.globalArray[getAuthenticationStatusObject.messageName] = getAuthenticationStatusObject;
         _jscdkClient.globalArray[getAuthenticationStatusObject.responseTag] = getAuthenticationStatusObject;
      } else {
         getAuthenticationStatusObject.resetData();
      }

      if (!!getAuthenticationStatusObject && !!router) {
         getAuthenticationStatusObject.setRequestXML(false);
         handlerList = getAuthenticationStatusObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   };

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.ignoreResponseFlag === false) {
      if (this.state === _messageHandler.StateEnum.DONE) {
         this.handleParsedResult(this.content["parsedResult"]);
      }
      // if the error is special for this handler, alert
      router.pushErrorToUser(this);
   } else {
      // treat already authed error as success
      errorObj = this.content["error"];
      if (!!errorObj && !!errorObj[this.messageName]) {
         errorCode = errorObj[this.messageName]["errorCode"];
         if (errorCode === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_ALREADY_AUTHENTICATED) {
            //treat as success to set state to done. cause further step info is
            // already in error message
            this.setState(_messageHandler.StateEnum.DONE);
         }

         /**
          * If in workspace one mode, push error to UI layer directly.
          * No need to get authentication status in this case.
          */
         if (!!errorObj[this.messageName]["workspaceOneServerHostname"]) {
            router.pushErrorToUser(this);
            return;
         }
      }

      /**
       * Try send get-authentication-status XML, and use its response to
       * decide next action
       */
      sendGetAuthenticationStatus();
   }
};

/**
 * compose list of message handlers who can be sent together in a single message
 * @return handler list whose messages can be sent together in a single message
 */
GetConfigurationHandler.prototype.composeHandlerList = function () {
   var setLocaleObject = void 0,
       composedHandlerList = this.composedHandlerList;
   if (composedHandlerList.length > 0) {
      return composedHandlerList;
   }
   if (!!_jscdkClient.globalArray) {
      setLocaleObject = _jscdkClient.globalArray["set-locale"];
      if (!!setLocaleObject) {
         composedHandlerList.push(setLocaleObject);
      }
   }
   composedHandlerList.push(this);
   return composedHandlerList;
};

/**
 * parse configuration information from the response XML of GetConfiguration
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return Object. key-value pairs parsed from response, if error then return null
 */
GetConfigurationHandler.prototype.parseResult = function (responseXML) {
   var responseBody = (0, _jquery2.default)(responseXML);
   var authentication = {};
   var brokerElem = void 0;
   var responseTagElem = void 0;
   var resultElem = void 0;
   var resultText = void 0;
   var authElem = void 0;
   var authScreenElem = void 0;
   var clientConfigElem = void 0;
   var clientConfiguration = {};
   var workspaceElem = void 0;
   var screenNameElem = void 0;
   var screenNameText = void 0;
   var paramsElem = void 0;
   var paramsLength = void 0;
   var errorCodeElem = void 0;
   var errorMessageElem = void 0;
   var userMessageElem = void 0;
   if (!responseXML || responseXML === "") {
      return null;
   }
   brokerElem = responseBody.find("broker");
   if (!brokerElem) {
      _jscdkLogger2.default.error("response of GetConfiguration error");
      return null;
   }
   responseTagElem = brokerElem.find(this.responseTag);
   resultElem = responseTagElem.find("result");
   resultText = resultElem.text();
   if (!!resultText && resultText.trim() !== "") {
      authentication["result"] = resultText;
   } else {
      return null;
   }
   if (resultText === "ok") {
      authElem = brokerElem.find("authentication");
      if (!authElem) {
         _jscdkLogger2.default.error("No authentication element in response of getConfiguration");
         return null;
      }

      authScreenElem = authElem.children("screen");
      if (!authScreenElem) {
         _jscdkLogger2.default.error("No screen element in response of getConfiguration");
         return null;
      }
      screenNameText = (0, _jquery2.default)(authScreenElem).children("name").text();
      _util2.default.addItemForJson(authentication, "screen", (0, _jquery2.default)(authScreenElem).children("name").text());
      (0, _jquery2.default)(authScreenElem).children("params").children("param").each(function () {
         var child = (0, _jquery2.default)(this);
         var nameText = child.find("name").text();
         var valueList = [];
         child.find("value").each(function () {
            // Special handle for unauthenticated login
            if (screenNameText === 'unauthenticated' && nameText === 'username') {
               valueList.push({
                  value: (0, _jquery2.default)(this).text(),
                  default: !!(0, _jquery2.default)(this).attr('default')
               });
            } else {
               valueList.push((0, _jquery2.default)(this).text());
            }
         });
         _util2.default.addItemForJson(authentication, nameText, valueList);
      });

      // Parse client-configuration section
      clientConfigElem = brokerElem.find("client-configuration");
      if (!!clientConfigElem) {
         (0, _jquery2.default)(clientConfigElem).children("params").children("param").each(function () {
            var child = (0, _jquery2.default)(this);
            var nameText = child.find("name").text();
            var valueList = [];
            child.find("value").each(function () {
               valueList.push((0, _jquery2.default)(this).text());
            });
            _util2.default.addItemForJson(clientConfiguration, nameText, valueList);
         });
         _util2.default.addItemForJson(authentication, "clientConfiguration", clientConfiguration);
      }
   } else if (resultText === "error") {
      errorCodeElem = responseBody.find("error-code");
      authentication["error-code"] = errorCodeElem.text();
      errorMessageElem = responseBody.find("error-message");
      authentication["error-message"] = errorMessageElem.text();
      userMessageElem = responseBody.find("user-message");
      authentication["user-message"] = userMessageElem.text();
   }

   // Parse workspaceOneServerHostname
   workspaceElem = brokerElem.find("workspace-one-server-hostname");
   if (!!workspaceElem && !!workspaceElem.text()) {
      _util2.default.addItemForJson(authentication, "workspaceOneServerHostname", workspaceElem.text());

      // Once broker returns ws1 server name, enable ws1 mode
      _jscdkClient.globalArray['ws1Mode'] = true;
      _jscdkClient.globalArray['workspaceOneServerHostname'] = workspaceElem.text();
   }

   return authentication;
};

GetConfigurationHandler.prototype.setAuthTypes = function (authTypes) {
   this.authTypes = authTypes;
};

GetConfigurationHandler.prototype.getAuthTypes = function () {
   return this.authTypes;
};

/**
 * handle parsed xml response to show different authentication dialgs.
 *
 * @param parsedResult [in] the result of parsed response.
 */

GetConfigurationHandler.prototype.handleParsedResult = function (parsedResult, isReauth) {
   var urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler"),
       urlParams = void 0,
       samlSecret = void 0,
       submitAuthInfoAction = {},
       label = PasscodeAuthLabel.PASSCODE_AUTH_LABEL_RSA_SECURID,
       authenticationAction = {},
       actionContent = {},
       router = _util2.default.getObject(_jscdkClient.globalArray, "router"),
       authType = void 0,
       authChallenge = void 0;

   if (parsedResult["screen"] === "windows-password") {
      authenticationAction.name = "WindowsPassword";
      actionContent.domains = parsedResult["domain"];

      if (!!urlHandler) {
         urlParams = urlHandler.params;
         if (!!urlParams.userName) {
            actionContent.username = urlParams.userName;
         }
         if (!!urlParams.domainName) {
            actionContent.domainName = urlParams.domainName;
         }
      }
   } else if (parsedResult["screen"] === "windows-password-expired") {
      authenticationAction.name = "WindowsPasswordExpired";
   } else if (parsedResult["screen"] === "securid-passcode") {
      if (!!urlHandler) {
         urlParams = urlHandler.params;
         if (!!urlParams.tokenUserName) {
            actionContent.username = urlParams.tokenUserName;
         } else if (!!urlHandler.params.userName) {
            actionContent.username = urlParams.userName;
         }
      }
      authenticationAction.name = "SecurIDPasscode";
      if (!!parsedResult["auth-label"]) {
         label = parsedResult["auth-label"][0];
      }
      if (!!parsedResult["auth-type"]) {
         authType = parsedResult["auth-type"][0];
      }

      actionContent.label = label;
      actionContent.authType = authType;
   } else if (parsedResult["screen"] === "securid-nexttokencode") {
      if (!!parsedResult["auth-label"]) {
         label = parsedResult["auth-label"][0];
      }
      if (!!parsedResult["auth-type"]) {
         authType = parsedResult["auth-type"][0];
      }
      if (!!parsedResult["auth-challenge-string"]) {
         authChallenge = parsedResult["auth-challenge-string"][0];
      }
      authenticationAction.name = "SecurIDNextTokenCode";
      actionContent.label = label;
      actionContent.authType = authType;
      actionContent.authChallenge = authChallenge;
   } else if (parsedResult["screen"] === "securid-pinchange") {
      authenticationAction.name = "SecurIDPinChange";
      if (parsedResult["message"] && parsedResult["message"][0]) {
         actionContent.message = parsedResult["message"][0];

         /**
          * "user-selectable" is currently not used because the information
          * it provides us (whether there is a PIN and whether that PIN is
          * read-only) are provided in another form by the broker
          */
         actionContent["user-selectable"] = parsedResult["user-selectable"][0];
      }
      if (parsedResult["pin1"] && parsedResult["pin1"][0]) {
         actionContent["pin1"] = parsedResult["pin1"][0];
         actionContent["pin1ReadOnly"] = parsedResult["pin1ReadOnly"];
      }
   } else if (parsedResult["screen"] === "securid-wait") {
      authenticationAction.name = "SecurIDWait";
   } else if (parsedResult["screen"] === "saml") {
      authenticationAction.name = "SAML";
      samlSecret = _util2.default.getObject(_jscdkClient.globalArray, "samlArt");
      submitAuthInfoAction.method = "SubmitAuthInfo";
      submitAuthInfoAction.type = "SAML";
      submitAuthInfoAction.secret = samlSecret;
      submitAuthInfoAction.reAuth = isReauth;
      delete _jscdkClient.globalArray["samlArt"];
      // SAML submit authentication information directly
      _jscdkClientController2.default.getInstance().execute(submitAuthInfoAction);
   } else if (parsedResult["screen"] === "cert-auth") {
      /**
       * If we have been asked to confirm "cert-auth", that means that the
       * user already performed it as part of the SSL handshake when
       * initially connecting to the server.  As a result, it is best to
       * always accept it.
       */
      authenticationAction.name = "CertAuth";
      submitAuthInfoAction.method = "SubmitAuthInfo";
      submitAuthInfoAction.type = "CertAuth";
      submitAuthInfoAction.accept = "true";
      _jscdkClientController2.default.getInstance().execute(submitAuthInfoAction);
   } else if (parsedResult["screen"] === "disclaimer") {
      authenticationAction.name = "Disclaimer";
      actionContent.label = parsedResult["text"][0];
   } else if (parsedResult["screen"] === "unauthenticated") {
      authenticationAction.name = "Unauthenticated";
      actionContent.usernames = parsedResult["username"];
   }

   // Don't set the username when use unauthenticated
   if (authenticationAction.name !== "Unauthenticated" && !!parsedResult["username"] && !!parsedResult["username"][0]) {
      actionContent.username = parsedResult["username"][0];
      actionContent.usernameReadOnly = parsedResult.usernameReadOnly;
   }
   if (!!parsedResult["domain"] && !!parsedResult["domain"][0]) {
      actionContent.domain = parsedResult["domain"][0];
      actionContent.domainReadOnly = parsedResult.domainReadOnly;
   }

   if (parsedResult["error"] && parsedResult["error"][0]) {
      actionContent.error = parsedResult["error"][0];
   }

   if (!!parsedResult["clientConfiguration"]) {
      actionContent.clientConfig = {};
      var clientConfiguration = parsedResult["clientConfiguration"];

      if (!!clientConfiguration["enableCredentialCleanupForHTMLAccess"]) {
         actionContent.clientConfig['enableCredentialCleanupForHTMLAccess'] = clientConfiguration["enableCredentialCleanupForHTMLAccess"][0] === "true";
      }
      if (!!clientConfiguration["clientHideServerInformation"]) {
         actionContent.clientConfig['clientHideServerInformation'] = clientConfiguration["clientHideServerInformation"][0] === "true";
      }
      if (!!clientConfiguration["clientHideDomainList"]) {
         actionContent.clientConfig['clientHideDomainList'] = clientConfiguration["clientHideDomainList"][0] === "true";
      }
   }

   if (!!parsedResult["workspaceOneServerHostname"]) {
      actionContent.workspaceOneServerHostname = parsedResult["workspaceOneServerHostname"];
   }

   actionContent.brokerUrl = encodeURIComponent(router.brokerUrl);
   authenticationAction.content = actionContent;
   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(authenticationAction));
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = GetUserGlobalPrefHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * GetUserGlobalPrefHandler.js --
 *
 *      Implementation of the message handler to get user global setting.
 */

function GetUserGlobalPrefHandler() {
   // member variables
   this.messageName = "get-user-global-preferences";
   this.messageText = "get-user-global-preferences";
   this.responseTag = "user-global-preferences";

   this.notifyUI = true;

   this.subHandlerList = [];
   this.composedHandlerList = [];

   this.prefData = {
      favorites: [] //favorites is an array
   };
}

// inherits MessageHandler prototype
GetUserGlobalPrefHandler.prototype = new _messageHandler.MessageHandler();
GetUserGlobalPrefHandler.constructor = GetUserGlobalPrefHandler;

/**
 * Reset handler's state and content.
 *
 */
GetUserGlobalPrefHandler.prototype.resetData = function () {
   _messageHandler.MessageHandler.prototype.resetData.apply(this);
};

/**
 * set the request XML for getting user global preference
 */
GetUserGlobalPrefHandler.prototype.setRequestXML = function () {
   this.requestXML = _util2.default.createElement("get-user-global-preferences");
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
GetUserGlobalPrefHandler.prototype.onUpdated = function () {
   var launchitemsHandler = _jscdkClient.globalArray['get-launch-items'];

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this);

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (!!launchitemsHandler && !!launchitemsHandler.content["parsedResult"]) {
         this.markFavorite(launchitemsHandler.content.parsedResult.desktops);
         this.markFavorite(launchitemsHandler.content.parsedResult.applications);
      }
   }
   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify({
      ignoreData: true,
      name: 'GetUserGlobalPref'
   }));
};

GetUserGlobalPrefHandler.prototype.markFavorite = function (items) {
   var key = void 0;
   for (key in items) {
      if (items.hasOwnProperty(key)) {
         if (this.prefData.favorites.indexOf(items[key].id) >= 0) {
            items[key].favorite = true;
         } else {
            items[key].favorite = false;
         }
      }
   }
};

/**
 * parse user global preference information from the response XML
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
GetUserGlobalPrefHandler.prototype.parseResult = function (responseXML) {
   var responseBody = responseXML,
       brokerTag = _util2.default.getChildNode(responseBody, "broker", 0),
       result = void 0,
       errorCodeNode = void 0,
       errorMessageNode = void 0,
       resultElem = void 0,
       favoriteItems = {},
       prefNodes = void 0,
       resp = {},
       i = void 0,
       pref = {},
       value = "",
       len = void 0,
       name = void 0,
       key = void 0;

   if (!brokerTag) {
      _jscdkLogger2.default.error("response of GetUserGlobalPref error.");
      return null;
   }
   this.prefData = {
      favorites: [] //favorites is an array
   };

   resultElem = _util2.default.getChildNode(brokerTag, this.responseTag, 0);
   resultElem = _util2.default.getChildNode(resultElem, 'result', 0);
   if (!resultElem || !resultElem.hasChildNodes()) {
      return null;
   }
   result = resultElem.childNodes[0].nodeValue;
   resp["result"] = result;
   if (result === "ok") {
      prefNodes = brokerTag.getElementsByTagName("preference");
      for (i = 0, len = prefNodes.length; i < len; i++) {
         name = prefNodes[i].getAttribute("name");
         if (!!name) {
            value = (0, _jquery2.default)(prefNodes[i]).text();
            if (name.substring(0, 'favorite'.length) === 'favorite') {
               pref = {
                  name: name,
                  id: value
               };
               // pref["name"] = name;
               // pref["id"] = value;
               favoriteItems[Object.keys(favoriteItems).length] = pref;

               this.prefData.favorites.push(value);
            } else {
               this.prefData[name] = value;
            }
         }
      }

      _jscdkLogger2.default.debug("favorite items: " + JSON.stringify(favoriteItems));
      resp["items"] = favoriteItems;
   } else if (result === "error") {
      errorCodeNode = _util2.default.getChildNode(responseBody, "error-code", 0);
      if (!!errorCodeNode) {
         resp["error-code"] = (0, _jquery2.default)(errorCodeNode).text();
      }
      errorMessageNode = _util2.default.getChildNode(responseBody, "error-message", 0);
      if (!!errorMessageNode) {
         resp["error-message"] = (0, _jquery2.default)(errorMessageNode).text();
      }
   }
   return resp;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _frontController = __webpack_require__(204);

var _frontController2 = _interopRequireDefault(_frontController);

var _setViewURICommand = __webpack_require__(193);

var _setViewURICommand2 = _interopRequireDefault(_setViewURICommand);

var _connectToBrokerCommand = __webpack_require__(172);

var _connectToBrokerCommand2 = _interopRequireDefault(_connectToBrokerCommand);

var _submitAuthInfoCommand = __webpack_require__(194);

var _submitAuthInfoCommand2 = _interopRequireDefault(_submitAuthInfoCommand);

var _connectToDesktopCommand = __webpack_require__(173);

var _connectToDesktopCommand2 = _interopRequireDefault(_connectToDesktopCommand);

var _cancelAuthenticationCommand = __webpack_require__(169);

var _cancelAuthenticationCommand2 = _interopRequireDefault(_cancelAuthenticationCommand);

var _logoutBrokerCommand = __webpack_require__(185);

var _logoutBrokerCommand2 = _interopRequireDefault(_logoutBrokerCommand);

var _resetDesktopCommand = __webpack_require__(187);

var _resetDesktopCommand2 = _interopRequireDefault(_resetDesktopCommand);

var _restartDesktopCommand = __webpack_require__(188);

var _restartDesktopCommand2 = _interopRequireDefault(_restartDesktopCommand);

var _killSessionCommand = __webpack_require__(184);

var _killSessionCommand2 = _interopRequireDefault(_killSessionCommand);

var _rollbackDesktopCommand = __webpack_require__(189);

var _rollbackDesktopCommand2 = _interopRequireDefault(_rollbackDesktopCommand);

var _getDesktopsCommand = __webpack_require__(178);

var _getDesktopsCommand2 = _interopRequireDefault(_getDesktopsCommand);

var _getLaunchItemsCommand = __webpack_require__(179);

var _getLaunchItemsCommand2 = _interopRequireDefault(_getLaunchItemsCommand);

var _cancelCurrentRequestCommand = __webpack_require__(170);

var _cancelCurrentRequestCommand2 = _interopRequireDefault(_cancelCurrentRequestCommand);

var _handleURICommand = __webpack_require__(182);

var _handleURICommand2 = _interopRequireDefault(_handleURICommand);

var _getTunnelConnectionCommand = __webpack_require__(180);

var _getTunnelConnectionCommand2 = _interopRequireDefault(_getTunnelConnectionCommand);

var _connectToApplicationCommand = __webpack_require__(171);

var _connectToApplicationCommand2 = _interopRequireDefault(_connectToApplicationCommand);

var _reconnectApplicationSessionsCommand = __webpack_require__(186);

var _reconnectApplicationSessionsCommand2 = _interopRequireDefault(_reconnectApplicationSessionsCommand);

var _disconnectSessionCommand = __webpack_require__(174);

var _disconnectSessionCommand2 = _interopRequireDefault(_disconnectSessionCommand);

var _doLockCommand = __webpack_require__(175);

var _doLockCommand2 = _interopRequireDefault(_doLockCommand);

var _getAuthenticationStatusCommand = __webpack_require__(177);

var _getAuthenticationStatusCommand2 = _interopRequireDefault(_getAuthenticationStatusCommand);

var _doUnlockCommand = __webpack_require__(176);

var _doUnlockCommand2 = _interopRequireDefault(_doUnlockCommand);

var _setLastUserActivityCommand = __webpack_require__(191);

var _setLastUserActivityCommand2 = _interopRequireDefault(_setLastUserActivityCommand);

var _timerCtrlCommand = __webpack_require__(195);

var _timerCtrlCommand2 = _interopRequireDefault(_timerCtrlCommand);

var _initRouterCommand = __webpack_require__(183);

var _initRouterCommand2 = _interopRequireDefault(_initRouterCommand);

var _setUserGlobalPrefCommand = __webpack_require__(192);

var _setUserGlobalPrefCommand2 = _interopRequireDefault(_setUserGlobalPrefCommand);

var _getUserGlobalPrefCommand = __webpack_require__(181);

var _getUserGlobalPrefCommand2 = _interopRequireDefault(_getUserGlobalPrefCommand);

var _setEnvironmentInfoCommand = __webpack_require__(190);

var _setEnvironmentInfoCommand2 = _interopRequireDefault(_setEnvironmentInfoCommand);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * jscdkClientController.js --
 *
 * JSCDKClientController is the centralized request handling class,
 * that delegates requests to appropriate command classes.
 *
 * Singleton Class
 *
 */

var JSCDKClientController = function () {

   /**
    * AuthenticationController derives from FrontController
    *
    * @returns {AuthenticationController}
    */
   function JSCDKFrontController() {
      this.addCommand("SetViewURI", _setViewURICommand2.default);
      this.addCommand("ConnectToBroker", _connectToBrokerCommand2.default);
      this.addCommand("SubmitAuthInfo", _submitAuthInfoCommand2.default);
      this.addCommand("ConnectToDesktop", _connectToDesktopCommand2.default);
      this.addCommand("ConnectToApplication", _connectToApplicationCommand2.default);
      this.addCommand("ReconnectSession", _reconnectApplicationSessionsCommand2.default);
      this.addCommand("CancelAuthentication", _cancelAuthenticationCommand2.default);
      this.addCommand("LogoutFromBroker", _logoutBrokerCommand2.default);
      this.addCommand("ResetDesktop", _resetDesktopCommand2.default);
      this.addCommand("RestartDesktop", _restartDesktopCommand2.default);
      this.addCommand("KillSession", _killSessionCommand2.default);
      this.addCommand("RollbackDesktop", _rollbackDesktopCommand2.default);
      this.addCommand("GetDesktops", _getDesktopsCommand2.default);
      this.addCommand("GetLaunchItems", _getLaunchItemsCommand2.default);
      this.addCommand("CancelCurrentRequest", _cancelCurrentRequestCommand2.default);
      this.addCommand("HandleURI", _handleURICommand2.default);
      this.addCommand("GetTunnelConnection", _getTunnelConnectionCommand2.default);
      this.addCommand("DisconnectSession", _disconnectSessionCommand2.default);
      this.addCommand("DoLock", _doLockCommand2.default);
      this.addCommand("GetAuthenticationStatus", _getAuthenticationStatusCommand2.default);
      this.addCommand("SetLastUserActivity", _setLastUserActivityCommand2.default);
      this.addCommand("DoUnlock", _doUnlockCommand2.default);
      this.addCommand("TimerCtrl", _timerCtrlCommand2.default);
      this.addCommand("InitRouter", _initRouterCommand2.default);
      this.addCommand("SetUserGlobalPref", _setUserGlobalPrefCommand2.default);
      this.addCommand("GetUserGlobalPref", _getUserGlobalPrefCommand2.default);
      this.addCommand("SetEnvironmentInfo", _setEnvironmentInfoCommand2.default);
   }

   JSCDKFrontController.prototype = new _frontController2.default();
   JSCDKFrontController.constructor = JSCDKFrontController;

   /**
    * single instance of authenticate controller
    */
   var _instance = void 0;

   return {

      /**
       * @returns  A singleton instance of {AuthenticationController}
       */
      getInstance: function getInstance() {
         if (!_instance) {
            _instance = new JSCDKFrontController();
         }

         return _instance;
      }
   };
}();

exports.default = JSCDKClientController;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = RestartDesktopHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function RestartDesktopHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "perform-action";
   this.messageText = "perform-action";
   this.responseTag = "perform-action";
   this.composedHandlerList = [];
   // requestId will increase when a new instance is created
   // use prototype requestId to share in all instances
   RestartDesktopHandler.prototype.requestId += 1;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * restartDesktopHandler.js --
 *
 *      Implementation of the message handler to restart desktop.
 */

RestartDesktopHandler.prototype = new _messageHandler.MessageHandler();
// constructor
RestartDesktopHandler.constructor = RestartDesktopHandler;

/**
 * parse information from the response XML of restart-desktop
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
RestartDesktopHandler.prototype.parseResult = function (responseXML) {
   var responseBody = responseXML;
   var brokerTag = void 0;
   var responses = void 0;
   var result = void 0;
   var tokenText = void 0;
   var restartDesktopResponse = {};
   var xmlDoc = void 0;

   xmlDoc = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   if (result === "ok" || result === "error") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases.
       */
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(restartDesktopResponse, nameText, (0, _jquery2.default)(this).text());
      });
   }
   return restartDesktopResponse;
};

/**
 * Set the request XML for restart-desktop
 * @param desktopId[in] desktop id to restart
 *
 */
RestartDesktopHandler.prototype.setRequestXML = function (desktopId) {
   var idElem = _util2.default.createElement("id", desktopId),
       typeElem = _util2.default.createElement("type", 'restart'),
       content = idElem + typeElem,
       desktopElem = _util2.default.createElement("desktop", content);

   this.requestXML = desktopElem;
};

/**
 * callback when received notification from handlers in dependency list or
 * router
 *
 */
RestartDesktopHandler.prototype.onUpdated = function () {
   var restartDesktopAction = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
         _jscdkLogger2.default.debug('Restart desktop succeeds.');

         // Kill session succeeds
         restartDesktopAction = { name: "RestartDesktop", result: "ok" };
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(restartDesktopAction));
      }
   }

   // push error if it exists
   _router2.default.prototype.pushErrorToUser(this);
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SetLastUserActivityHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SetLastUserActivityHandler() {
   var router = void 0;

   // member variables
   this.messageName = "set-last-user-activity";
   this.messageText = "set-last-user-activity";
   this.responseTag = "set-last-user-activity";

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * setLastUserActivityHandler.js --
 *
 *      Implementation of the message handler to set last user activity time.
 */

SetLastUserActivityHandler.prototype = new _messageHandler.MessageHandler();
SetLastUserActivityHandler.constructor = SetLastUserActivityHandler;

/**
  * Set the request XML for set last activity.
  *
  * @param inactiveTime [in] t1-t0, in which t0 is the last time user have
  *    activities, t1 is current time, both in seconds from 1970.
  */
SetLastUserActivityHandler.prototype.setRequestXML = function (inactiveTime) {
   this.requestXML = _util2.default.createElement("last-user-activity", inactiveTime);
};

/**
  * callback when received notification from handlers in dependency list or
  * network
  *
  */
SetLastUserActivityHandler.prototype.onUpdated = function () {
   var parsedResult = void 0,
       errorInfo = void 0,
       errorCode = void 0,
       router = _util2.default.getObject(_jscdkClient.globalArray, "router");

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's onUpdated

   if (this.content["error"]) {
      parsedResult = this.content["error"];
      if (!!parsedResult[this.responseTag]) {
         errorInfo = parsedResult[this.responseTag];
         errorCode = errorInfo["error-code"];
         if (errorCode === "OUT_OF_SEQUENCE_ERROR") {
            this.setState(_messageHandler.StateEnum.DONE);
            _jscdkLogger2.default.debug("ignore error: " + errorCode);
         }
      }
   }

   // ensure handler has done its task and request is from "WindowsPassword" to
   // JSCDK
   if (this.state === _messageHandler.StateEnum.DONE) {
      _jscdkLogger2.default.debug("SetLastUserActivity success"); //ok
   }
   // push error to UI
   router.pushErrorToUser(this);
};

/**
  * parse desktops information from the response XML
  *
  * @param responseXML[in] response of xmlhttprequest from view broker
  * @return key-value pairs parsed from response, if error then return null
  */
SetLastUserActivityHandler.prototype.parseResult = function (responseXML) {
   var responseBody = void 0,
       brokerTag = void 0,
       responses = void 0,
       resultText = void 0,
       setLastUserActivityResponse = {};

   if (!responseXML || responseXML === "") {
      return null;
   }
   responseBody = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(responseBody.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of getAuthenticationStatus error");
      return null;
   }
   responses = brokerTag.children(this.responseTag);
   resultText = responses.children("result").text();
   if (!!resultText && resultText.trim() !== "") {
      setLastUserActivityResponse["result"] = resultText;
   } else {
      _jscdkLogger2.default.error("response of getAuthenticationStatus error, no valid result tag");
      return null;
   }
   //no need to deal with 'ok'
   if (resultText === "error") {
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(setLastUserActivityResponse, nameText, (0, _jquery2.default)(this).text());
      });
   }
   return setLastUserActivityResponse;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

/**
 * urlHandler.js --
 *
 *      Implementation of the handler to deal with url
 */

exports.default = UrlHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkClient = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// the list for action names.
var ActionEnum = {
   STARTSESSION: "start-session",
   BROWSE: "browse",
   LOGOFF: "logoff",
   RESET: "reset"
};
var UrlHandlerError = {
   URI_ERROR_INVALID_URL_PARAMETER: "INVALID_URL_PARAMETER"
   // XXX TODO: add more error type if needed in the future.
};

function UrlHandler() {
   // member variables below
   this.name = "url-handler";

   this.params = {
      samlArt: null,
      userName: null,
      tokenUserName: null,
      domainName: null,
      host: null,
      port: null,
      desktopId: null,
      desktopName: null,
      desktopProtocol: null,
      allowCollaboration: null,
      collabSessionId: null,
      applicationId: null,
      applicationName: null,
      schemeName: null,
      path: null,
      action: null,
      horizonId: null,
      mid: null,
      args: null,
      unauthenticatedAccessEnabled: null,
      unauthenticatedAccessAccount: null,
      spID: null
   };
}

UrlHandler.constructor = UrlHandler;

/**
 * handle url params in url
 *
 * @param url [in] url to be handled, such as window.location.search
 *
 */
UrlHandler.prototype.handleUrlParams = function (url) {
   var parsedUriInfo = {};
   try {
      if ((typeof url === 'undefined' ? 'undefined' : _typeof(url)) === 'object') {
         this.fillParams(url);
         if (this.isErrorInParameters()) {
            _jscdkLogger2.default.error('Url has invalid param');
            return;
         }

         _jscdkLogger2.default.debug('Url has valid param');

         parsedUriInfo.name = 'ParsedUriInfo';
         parsedUriInfo.content = this.params;
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(parsedUriInfo));
      } else if (typeof url === 'string') {
         this.loadParams(url);

         parsedUriInfo.name = 'Brokers';
         parsedUriInfo.params = this.params;
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(parsedUriInfo));
      }
   } catch (error) {
      _jscdkLogger2.default.error('Url params are invalid: ' + error);

      parsedUriInfo.name = 'Brokers';
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(parsedUriInfo));
   }
};

/**
 * validate params in url and fill params
 *
 * @param url [in] url to be handled, such as window.location.search
 *
 */
UrlHandler.prototype.fillParams = function (url) {
   var urlKey = void 0,
       paramKey = void 0;

   for (urlKey in url) {
      if (url.hasOwnProperty(urlKey)) {
         for (paramKey in this.params) {
            if (this.params.hasOwnProperty(paramKey)) {
               if (paramKey.toLowerCase() === urlKey.toLowerCase()) {
                  this.params[paramKey] = url[urlKey];
                  break;
               }
            }
         }
      }
   }

   if (!!this.params.samlArt) {
      this.params.samlArt = decodeURIComponent(this.params.samlArt);
   }

   if (!!this.params.userName) {
      this.params.userName = decodeURIComponent(this.params.userName);
   }

   if (!!this.params.host) {
      this.params.host = decodeURIComponent(this.params.host);
   }

   // the vcsId is not decoded, and will be returned and used directly

   /* The desktop id is indicated in the path param.
    * The path param starts with "/", so it needs to be removed to get the desktop id.
    */
   if (!!this.params.path && this.params.path.length > 1) {
      this.params.desktopId = decodeURIComponent(this.params.path.substring(1));
   }

   // At present RDP is the only supported protocol for Metro client.
   if (!this.params.desktopProtocol) {
      this.params.desktopProtocol = 'RDP';
   }
};
/**
 * This is done according to
 * https://wiki.eng.vmware.com/VDM/ClientBrokerXml#Request_23 and
 * https://wiki.eng.vmware.com/EUCBU/RX/SupportRDSHApplicationParameters
 * @sideeffects before this function, this.params.args is the escaped command
 *    line string, after, this.params.args will be an array of splited command
 *    lines according to XML spec
 */
UrlHandler.prototype.formatArgs = function () {
   var arg = void 0;
   if (!!this.params.args) {
      // use whole input string as the first and only param as spec requires
      arg = this.params.args;
      this.params.args = [arg];
   }
};

UrlHandler.prototype.loadParams = function (url) {
   var a = void 0,
       key = void 0,
       value = void 0;

   a = (0, _jquery2.default)('<a>', {
      href: url
   })[0];
   this.params.host = a.hostname;
   this.params.port = a.port;
   this.params.schemeName = a.protocol;

   // Load mandatory params.
   for (key in this.params) {
      if (this.params.hasOwnProperty(key)) {
         value = this.parseParam(a.search, key);
         if (!!value) {
            this.params[key] = value;
         }
      }
   }

   // BLAST is the default protocol.
   if (!this.params.desktopProtocol) {
      this.params.desktopProtocol = 'BLAST';
   }

   this.formatArgs();
};

/**
 * parse param value from url, param name is considered case-insensitiv
 *   param value is considered case-sensitive
 *
 * @param url [in] url to be handled, such as window.location.search
 * @param name [in] name of param key
 * @return param value
 *
 */
UrlHandler.prototype.parseParam = function (url, name) {
   // use 'i' here to ignore case of param name
   return decodeURIComponent((new RegExp('.*([?|&]' + name + '=' + '([^&;]+?)(&|#|;|$))', 'i').exec(url) || [null, null, ''])[2]);
};

/**
 * refresh data
 *
 */
UrlHandler.prototype.refresh = function () {
   this.params = null;
};

/**
 * reset all params.
 */
UrlHandler.prototype.resetParams = function () {
   var key = void 0;
   for (key in this.params) {
      if (this.params.hasOwnProperty(key)) {
         this.params[key] = null;
      }
   }
};

/**
 * Check wherther there is an error in parameters.
 *
 * @return true if there is an error, otherwise false.
 */
UrlHandler.prototype.isErrorInParameters = function () {
   var pushErrorToUI = {};

   pushErrorToUI.content = {};

   if (!this.params.action || this.params.action.toLowerCase() === ActionEnum.BROWSE) {
      return false;
   }

   // For other actions like "start-session" there should be a desktopId.
   if (!this.params.desktopId) {
      // push error to UI
      pushErrorToUI.name = "ShowError";
      pushErrorToUI.content.errorType = UrlHandlerError.URI_ERROR_INVALID_URL_PARAMETER;
      pushErrorToUI.content.errorText = _util2.default._("The URL is invalid because it is missing the name of the desktop.");
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(pushErrorToUI));
      return true;
   }
   return false;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = IdleTimeoutTimerController;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _timer = __webpack_require__(220);

var _setLastUserActivityHandler = __webpack_require__(54);

var _setLastUserActivityHandler2 = _interopRequireDefault(_setLastUserActivityHandler);

var _userActiveTimeSyncCtrl = __webpack_require__(221);

var _userActiveTimeSyncCtrl2 = _interopRequireDefault(_userActiveTimeSyncCtrl);

var _doLockHandler = __webpack_require__(49);

var _doLockHandler2 = _interopRequireDefault(_doLockHandler);

var _timerUtil = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * idleTimeoutTimerController.js --
 *
 * timer and logic for idle timeout.
 *
 */

function IdleTimeoutTimerController() {
   if (this.brokerVersionInvalid()) {
      return;
   }
   _jscdkLogger2.default.debug("IdleTimeoutTimerController created");
   this.timeSyncBuff = { ui: null, broker: null, local: null };
   this.globalName = "idle-timeout-timer";
   this.idleTimeout = -1;
   this.aboutToIdleTimeout = -1;
   this.userActivityInterval = -1;
   this.hintTime = -1; //hint = idleTimeout - aboutToIdleTimeout
   this.intervalTimer = new _timer.Timer(_timer.timerTypeEnum.interval);
   this.aboutToTimeoutTimer = new _timer.Timer(_timer.timerTypeEnum.timeout);
   this.timeoutTimer = new _timer.Timer(_timer.timerTypeEnum.timeout);
   this.needDisplayDialogs = null;
   this.notifyLockEventToUI = true;
   this.requestLastActiveTimeFunction = null;
}

// only store functions
IdleTimeoutTimerController.prototype = {};
IdleTimeoutTimerController.constructor = IdleTimeoutTimerController;

(function () {
   //private functions:
   //----------------------------------------------------------------------------------------------
   function userActivityEvent(params) {
      var self = params[0];

      if (typeof self.requestLastActiveTimeFunction === "function") {
         self.requestLastActiveTimeFunction();
      } else {
         _jscdkLogger2.default.debug("requestLastActiveTimeFunction is not a function");
      }
   }

   function aboutToIdleTimeoutEvent() {
      var requestLastUserActiveTimeAction = {};

      _jscdkLogger2.default.debug("aboutToIdleTimeout event reached");
      requestLastUserActiveTimeAction.name = "AboutToTimeout";
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(requestLastUserActiveTimeAction));
   }

   function idleTimeoutEvent() {
      var requestLastUserActiveTimeAction = {};

      _jscdkLogger2.default.debug("idleTimeout event reached");
      requestLastUserActiveTimeAction.name = "Timeout";
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(requestLastUserActiveTimeAction));
   }

   function initCore(initType) {
      /*jshint validthis: true*/
      var idleTimeout = void 0;

      switch (initType) {
         // work on portal page for both webClient and chromeClient
         case "Portal":
            this.requestLastActiveTimeFunction = _timerUtil.requestLastActiveTimeFromPortal;
            this.needDisplayDialogs = false;
            break;
         // work on desktop page for webClient
         case "Desktop":
            this.requestLastActiveTimeFunction = _timerUtil.requestLastActiveTimeFromRemoteSession;
            this.needDisplayDialogs = false;
            break;
         default:
            _jscdkLogger2.default.debug("error: the initType is invalid");
            return;
      }

      // set timers enable property
      idleTimeout = this.idleTimeout;
      this.intervalTimer.setEnable();
      if (idleTimeout <= 0) {
         this.aboutToTimeoutTimer.setDisable();
         this.timeoutTimer.setDisable();
         this.idleTimeout = -1; // -1 means invalid
         this.aboutToIdleTimeout = -1; // -1 means invalid
      } else {
         this.timeoutTimer.setEnable();
         if (this.hintTime >= idleTimeout) {
            _jscdkLogger2.default.error("invalid time setting params for IdleTimeoutTimerController.init()!!");
            this.aboutToTimeoutTimer.setDisable();
            this.aboutToIdleTimeout = -1; // -1 means invalid
         } else {
            this.aboutToTimeoutTimer.setEnable();
         }
      }

      //init timer and bounding callback
      this.intervalTimer.init(userActivityEvent, this.userActivityInterval * 1000, [this]);
      if (this.needDisplayDialogs) {
         this.aboutToTimeoutTimer.init(aboutToIdleTimeoutEvent, this.aboutToIdleTimeout * 1000);
      } else {
         this.aboutToTimeoutTimer.setDisable();
      }
      this.timeoutTimer.init(idleTimeoutEvent, this.idleTimeout * 1000);
      _jscdkLogger2.default.debug("idle timeout controller inited");
   }

   function sendSetLastUserActivityXMLtoBrokerWith(inactiveTime) {
      var setLastUserActivityObject = void 0,
          handlerList = void 0,
          router = _jscdkClient.globalArray["router"],
          inactiveTimeVar = void 0,
          inactiveTimeStr = void 0;

      setLastUserActivityObject = _jscdkClient.globalArray["set-last-user-activity"];
      if (!setLastUserActivityObject) {
         setLastUserActivityObject = new _setLastUserActivityHandler2.default();
         _jscdkClient.globalArray[setLastUserActivityObject.messageName] = setLastUserActivityObject;
         _jscdkClient.globalArray[setLastUserActivityObject.responseTag] = setLastUserActivityObject;
      } else {
         setLastUserActivityObject.resetData();
      }

      if (!!setLastUserActivityObject && !!router) {
         inactiveTimeVar = inactiveTime; //accept both number and string format
         inactiveTimeStr = inactiveTimeVar.toString();
         setLastUserActivityObject.setRequestXML(inactiveTimeStr);
         handlerList = setLastUserActivityObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }

   function sendDoLockXML() {
      var doLockObject = void 0,
          handlerList = void 0,
          router = _jscdkClient.globalArray["router"];

      doLockObject = _jscdkClient.globalArray["do-lock"];
      if (!doLockObject) {
         doLockObject = new _doLockHandler2.default();
         _jscdkClient.globalArray[doLockObject.messageName] = doLockObject;
         _jscdkClient.globalArray[doLockObject.responseTag] = doLockObject;
      } else {
         doLockObject.resetData();
      }

      if (!!doLockObject && !!router) {
         doLockObject.setRequestXML();
         handlerList = doLockObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }

   //called in the this.compareToAct
   function setlocalTimeForCompare() {
      /*jshint validthis: true*/
      var localTargetTime = this.timeoutTimer.getTargetTime();
      this.timeSyncBuff.local = localTargetTime - this.idleTimeout * 1000;
   }

   // public functions:
   //----------------------------------------------------------------------------------------------
   // class method to varify the version validation(using
   // IdleTimeoutTimerController as a namespace)
   IdleTimeoutTimerController.prototype.init = function (userActivityInterval, idleTimeout, initType) {
      if (this.brokerVersionInvalid()) {
         return;
      }
      _jscdkLogger2.default.debug("init timer controller with userActivityInterval:" + userActivityInterval + ", idleTimeout:" + idleTimeout);

      // this value should be changed, in seconds
      this.hintTime = 30;

      //copy a set of time value
      this.idleTimeout = idleTimeout; // in s
      this.userActivityInterval = userActivityInterval; // in s
      this.aboutToIdleTimeout = this.idleTimeout - this.hintTime; // in s

      initCore.call(this, initType);
   };

   IdleTimeoutTimerController.prototype.reset = function (initType) {
      if (this.brokerVersionInvalid()) {
         return;
      }
      _jscdkLogger2.default.debug("reset timer controller for chrome: with type: " + initType);

      initCore.call(this, initType);
   };

   IdleTimeoutTimerController.prototype.brokerVersionInvalid = function () {
      if (!_util2.default.brokerSupportApplication()) {
         _jscdkLogger2.default.error("timerController related functions should only be involved when is broker version is new enough");
         return true;
      }
      return false;
   };

   IdleTimeoutTimerController.prototype.ensureUpdatedOrStarted = function () {
      this.intervalTimer.ensureUpdatedOrStarted();
      sendSetLastUserActivityXMLtoBrokerWith(0);
      this.aboutToTimeoutTimer.ensureUpdatedOrStarted();
      this.timeoutTimer.ensureUpdatedOrStarted();
      _jscdkLogger2.default.info("----all timer are ensureUpdatedOrStarted");
   };

   IdleTimeoutTimerController.prototype.start = function () {
      this.intervalTimer.start();
      sendSetLastUserActivityXMLtoBrokerWith(0);
      this.aboutToTimeoutTimer.start();
      this.timeoutTimer.start();
      _jscdkLogger2.default.info("----all timer started");
   };

   IdleTimeoutTimerController.prototype.stop = function () {
      //stop controller by discarding all timers
      this.intervalTimer.discard();
      this.aboutToTimeoutTimer.discard();
      this.timeoutTimer.discard();
      _jscdkLogger2.default.info("----all timer discarded");
   };

   IdleTimeoutTimerController.prototype.refresh = function (inactiveTime) {
      this.aboutToTimeoutTimer.updateTimeoutValue(this.aboutToIdleTimeout * 1000 - inactiveTime);
      this.timeoutTimer.updateTimeoutValue(this.idleTimeout * 1000 - inactiveTime);
      _jscdkLogger2.default.info("----all timer refreshed with passed time:" + inactiveTime);
   };

   IdleTimeoutTimerController.prototype.ensureStopped = function () {
      this.intervalTimer.ensureStopped();
      this.aboutToTimeoutTimer.ensureStopped();
      this.timeoutTimer.ensureStopped();
      _jscdkLogger2.default.debug("all timers is ensure to be stopped");
   };

   IdleTimeoutTimerController.prototype.getIdleTimeoutValue = function () {
      _jscdkLogger2.default.debug("in getIdleTimeoutValue return:" + this.idleTimeout);
      return this.idleTimeout;
   };

   IdleTimeoutTimerController.prototype.getSendIntervalValue = function () {
      _jscdkLogger2.default.debug("in getSendIntervalValue return:" + this.userActivityInterval);
      return this.userActivityInterval;
   };

   IdleTimeoutTimerController.prototype.setlastUserActiveTime = function (lastUserActiveTime, needSendXML, needRefreshTimer) {
      var inactiveTime = void 0,
          currentTime = void 0;

      currentTime = new Date().getTime();
      inactiveTime = currentTime - lastUserActiveTime; //in ms
      _jscdkLogger2.default.debug("the lastUserActiveTime that passed in setlastUserActiveTime is: " + inactiveTime + "ms");
      if (needRefreshTimer) {
         this.refresh(inactiveTime);
      }
      if (needSendXML) {
         sendSetLastUserActivityXMLtoBrokerWith(parseInt(inactiveTime / 1000, 10));
      }
   };

   IdleTimeoutTimerController.prototype.setUITimeForCompare = function (UIlastUserActiveTime) {
      this.timeSyncBuff.ui = UIlastUserActiveTime;
   };

   //send getAuthStatus with actionTrigger
   IdleTimeoutTimerController.prototype.requestBrokerTimeForCompareFor = function (actionTrigger) {
      var userActiveTimeSyncCtrl = _jscdkClient.globalArray["get-broker-sso-time-ctrl"],
          callBackType = actionTrigger;
      if (!userActiveTimeSyncCtrl) {
         userActiveTimeSyncCtrl = new _userActiveTimeSyncCtrl2.default();
         _jscdkClient.globalArray[userActiveTimeSyncCtrl.ctrlName] = userActiveTimeSyncCtrl;
      }
      userActiveTimeSyncCtrl.requestBrokerSSOTime(callBackType);
   };

   //called in the onupdate of getAuthStatusHandler
   IdleTimeoutTimerController.prototype.setBrokerTimeForCompare = function (timeToBrokerLocked) {
      var brokerAheadTime = 11,
          //extra time for broker is like 11s
      brokerlastUserActiveTime = new Date().getTime() - (this.idleTimeout - (timeToBrokerLocked - brokerAheadTime)) * 1000; //now-(timeout-rest)
      this.timeSyncBuff.broker = brokerlastUserActiveTime;
   };

   //called in the onupdate of getAuthStatusHandler
   IdleTimeoutTimerController.prototype.compareToAct = function (actionTrigger) {
      var newestTime = void 0,
          needSendLastUserActivityXML = void 0,
          timeDelayTolerance = 3000,
          showAboutToTimeoutDialoagAction = {};

      setlocalTimeForCompare.apply(this);
      if (this.timeSyncBuff.ui > this.timeSyncBuff.broker) {
         newestTime = this.timeSyncBuff.ui;
         needSendLastUserActivityXML = true;
      } else {
         newestTime = this.timeSyncBuff.broker;
         needSendLastUserActivityXML = false;
      }

      //if already synced, this is a valid trigger, do actions
      if (Math.abs(newestTime - this.timeSyncBuff.local) < timeDelayTolerance) {
         if (actionTrigger === "syncWithTimer4AboutToTimeout") {
            //show about to timeout dialog
            _jscdkLogger2.default.debug("showAboutTimeOut dialog");
            showAboutToTimeoutDialoagAction.name = "showAboutToTimeoutDialog";
            showAboutToTimeoutDialoagAction.showTime = this.hintTime;
            (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(showAboutToTimeoutDialoagAction));
         } else if (actionTrigger === "syncWithTimer4Timeout") {
            //send dolock
            _jscdkLogger2.default.debug("send dolock");
            sendDoLockXML();
         }
      } else {
         // else sync the time first
         this.setlastUserActiveTime(newestTime, needSendLastUserActivityXML, true);
      }
      this.timeSyncBuff = { ui: null, broker: null, local: null };
   };

   IdleTimeoutTimerController.prototype.detectBrokerLocked = function () {
      var doLockAction = void 0;

      _jscdkLogger2.default.debug("detect broker is already locked");
      if (this.needDisplayDialogs) {
         doLockAction = { name: "DoLock", type: "detectBrokerLocked" };
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(doLockAction));
      } else if (this.notifyLockEventToUI) {
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify({ name: "AlreadyLock" }));
      }
   };
})();

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/desktop-small2x.png";

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/shadow-desktop-small2x.png";

/***/ }),
/* 59 */
/***/ (function(module, exports) {

var path = 'common/aboutdialog/about_dialog.html';
var html = "<scrollable-dialog ng-controller=\"AboutDialogCtrl\">\n   <div class=\"dialog-title\">{{ 'ABOUT_T' | i18n }}</div>\n   <div class=\"dialog-content\" fuzzy-free>\n      <div class=\"about-dialog-content selectable\">\n         <div class=\"about-dialog-logo\"></div>\n         <span class=\"about-dialog-product-name-text\">{{ 'COMPANY_NAME_T' | i18n }}<sup>®</sup> {{ 'PRODUCT_NAME_T' | i18n }}</span>\n         <br>\n         <span class=\"bold-text\">{{ 'VERSION_NUMBER_M' | i18n : \"4.6.0\" : \"1\"}}</span>\n         <br><br>\n         {{ 'COPYRIGHT_BODY_M' | i18n }}\n\n         <a href=\"{{ 'PATENT_URL' | i18n }}\" id=\"patentUrlLink\" target=\"_blank\">{{ 'PATENT_URL' | i18n }}</a>.\n\n         <br><br>\n         {{ 'COPYRIGHT_FOOT_M' | i18n}}\n      </div>\n   </div>\n   <div class=\"dialog-button-row\">\n      <button id=\"aboutDialogCloseBtn\" class=\"modal-button-base modal-button-right modal-button-blue\" ng-click=\"closeThisDialog()\" dialog-prevent-key-up>\n         {{ 'OK' | i18n }}\n      </button>\n      <a id=\"aboutDialogHelpUrl\" class=\"modal-button-base modal-button-right modal-button-blue\" target=\"_blank\" ng-href=\"{{helpUrl}}\">\n         {{ 'HELP' | i18n }}\n      </a>\n   </div>\n</scrollable-dialog>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 60 */
/***/ (function(module, exports) {

var path = 'desktop/common/clip_ft_help_template.html';
var html = "<scrollable-dialog>\n   <div class=\"dialog-title\">{{ngDialogData.title | i18n }}</div>\n   <div class=\"dialog-content\">\n      <div class=\"clipboard-help-dialog-content selectable\">{{ngDialogData.msg | i18n : ngDialogData.modKey : ngDialogData.modKey : ngDialogData.modKey : ngDialogData.modKey}}</div>\n   </div>\n   <div class=\"dialog-button-row\">\n      <div class=\"modal-button-base modal-button-right modal-button-blue\" ng-click=\"closeThisDialog()\">\n         {{ 'OK' | i18n }}\n      </div>\n   </div>\n</scrollable-dialog>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 61 */,
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.AppCenterController = AppCenterController;
exports.config = config;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AppCenterController($scope, $rootScope, constants, $window, baseViewService, connectionURIModel) {
   /**
    * If input URL is https://xxxxx/portal/webclient/index.html#/desktop
    * that means user wants to enter desktop mode directly.
    * Otherwise, redirect page to launcher.
    */
   if ($window.location.hash.indexOf('#/desktop') === 0) {
      $rootScope.CLIENT_MODE = constants.CLIENT_MODE.DESKTOP;
   } else {
      $rootScope.CLIENT_MODE = constants.CLIENT_MODE.LAUNCHER;
   }

   /**
    * Show preference button as default.
    * The value can be set to false if in anonymous mode
    * Use $rootScope here because we have to access it in multiple controllers
    */
   $rootScope.showPreference = true;

   // Listen to any location change event for whole application
   $rootScope.$on('$locationChangeStart', function (event, next, current) {
      if (baseViewService.isBackInLauncher(next, current) && !baseViewService.locationChange) {
         event.preventDefault();
      } else if (baseViewService.isBackFromDesktop(next, current)) {
         event.preventDefault();
         /**
          * NOTE: using connectionURIModel.isHWSession here is based on that
          * we don't remove params in URI
          */
         if (!connectionURIModel.isHWSession()) {
            /**
             *  NOTE: Do not try to maintain the dependencies between
             *  launcher and desktop module now. We just need to go back to
             *  launcher with a refresh action.
             */
            baseViewService.goBackToLauncherFromDesktop();
         }
      }

      baseViewService.locationChange = false;

      // it will just run routeChangeStart not Success.
      if (baseViewService.isRefreshingLauncher(next, current)) {
         $scope.transitionState = "showPage";
      }
   });

   $rootScope.$on("$routeChangeSuccess", function (scope, next, current) {
      $scope.transitionState = "showPage";
   });

   $rootScope.$on("$routeChangeStart", function (scope, next, current) {
      $scope.transitionState = "hidePage";
   });

   /**
    * We're going to detect log off event!
    * constants.CLIENT_LOGIN_KEY is deleted in 'view-service.js',
    * 'entitleditems-service.js' and 'main-service.js'
    */
   (0, _jquery2.default)(window).bind('storage', function (e) {
      if (e.originalEvent.key !== constants.CLIENT_LOGIN_KEY) {
         return;
      }
      if (!!e.originalEvent.oldValue && (e.originalEvent.newValue === null || e.originalEvent.newValue === '')) {
         // Once user logs off broker, return any other tabs to portal page
         var launchPageURL = void 0;
         if (!window.location.origin) {
            launchPageURL = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');
         } else {
            launchPageURL = window.location.origin;
         }

         window.location.href = launchPageURL;
      }
   });
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * app-center-controller.js --
 *
 * The center controller for whole angular application.
 *
 */

function config($window) {
   // Prevent browser read page from cache
   $window.onpageshow = function (event) {
      if (event.persisted) {
         $window.location.reload();
      }
   };

   /**
    *  Refreshing any page (except desktop page) triggers launching the
    *  home page.
    */
   if (!!$window.location.hash && $window.location.hash !== '#/' && $window.location.hash !== '#/desktop') {
      $window.location.hash = '#/';
   }
}

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _WMKS = __webpack_require__(43);

var _WMKS2 = _interopRequireDefault(_WMKS);

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _module = __webpack_require__(27);

var _module2 = _interopRequireDefault(_module);

var _module3 = __webpack_require__(136);

var _module4 = _interopRequireDefault(_module3);

var _angularRoute = __webpack_require__(11);

var _angularRoute2 = _interopRequireDefault(_angularRoute);

var _ngDialog = __webpack_require__(9);

var _ngDialog2 = _interopRequireDefault(_ngDialog);

var _route = __webpack_require__(146);

var _route2 = _interopRequireDefault(_route);

var _mksvchan = __webpack_require__(12);

var _mksvchan2 = _interopRequireDefault(_mksvchan);

var _vdpservice = __webpack_require__(22);

var _vdpservice2 = _interopRequireDefault(_vdpservice);

var _unity = __webpack_require__(48);

var _unity2 = _interopRequireDefault(_unity);

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

var _rtavService = __webpack_require__(155);

var _rtavService2 = _interopRequireDefault(_rtavService);

var _verticalSlider = __webpack_require__(168);

var _verticalSlider2 = _interopRequireDefault(_verticalSlider);

var _sidebar = __webpack_require__(167);

var _contextMenuManager = __webpack_require__(166);

var _contextMenuManager2 = _interopRequireDefault(_contextMenuManager);

var _settingsWindowController = __webpack_require__(165);

var _settingsWindowController2 = _interopRequireDefault(_settingsWindowController);

var _unityService = __webpack_require__(145);

var _unityService2 = _interopRequireDefault(_unityService);

var _reauthController = __webpack_require__(144);

var _reauthController2 = _interopRequireDefault(_reauthController);

var _changepasswordController = __webpack_require__(143);

var _changepasswordController2 = _interopRequireDefault(_changepasswordController);

var _multimonSettingWindowController = __webpack_require__(142);

var _multimonSettingWindowController2 = _interopRequireDefault(_multimonSettingWindowController);

var _fileTransferUploadService = __webpack_require__(132);

var _fileTransferUploadService2 = _interopRequireDefault(_fileTransferUploadService);

var _fileTransferService = __webpack_require__(131);

var _fileTransferService2 = _interopRequireDefault(_fileTransferService);

var _fileTransferPanel = __webpack_require__(130);

var _fileTransferHelper = __webpack_require__(129);

var _fileTransferHelper2 = _interopRequireDefault(_fileTransferHelper);

var _fileTransferDownloadService = __webpack_require__(128);

var _fileTransferDownloadService2 = _interopRequireDefault(_fileTransferDownloadService);

var _wmksServiceEventHandler = __webpack_require__(126);

var _wmksServiceEventHandler2 = _interopRequireDefault(_wmksServiceEventHandler);

var _wmksService = __webpack_require__(127);

var _wmksService2 = _interopRequireDefault(_wmksService);

var _runningitemsModel = __webpack_require__(125);

var _runningitemsModel2 = _interopRequireDefault(_runningitemsModel);

var _printService = __webpack_require__(124);

var _panelService = __webpack_require__(123);

var _panelService2 = _interopRequireDefault(_panelService);

var _messagehandlerService = __webpack_require__(122);

var _messagehandlerService2 = _interopRequireDefault(_messagehandlerService);

var _jscdkDesktopInvoker = __webpack_require__(121);

var _jscdkDesktopInvoker2 = _interopRequireDefault(_jscdkDesktopInvoker);

var _idleSessionService = __webpack_require__(120);

var _idleSessionService2 = _interopRequireDefault(_idleSessionService);

var _entitleditemsService = __webpack_require__(119);

var _entitleditemsService2 = _interopRequireDefault(_entitleditemsService);

var _entitleditemsModel = __webpack_require__(118);

var _entitleditemsModel2 = _interopRequireDefault(_entitleditemsModel);

var _desktopController = __webpack_require__(117);

var _desktopController2 = _interopRequireDefault(_desktopController);

var _blastWmksService = __webpack_require__(116);

var _blastWmksService2 = _interopRequireDefault(_blastWmksService);

var _audioService = __webpack_require__(115);

var _audioService2 = _interopRequireDefault(_audioService);

var _applicationsessionsModel = __webpack_require__(114);

var _applicationsessionsModel2 = _interopRequireDefault(_applicationsessionsModel);

var _ajaxBusyOverlay = __webpack_require__(113);

var _clipboard = __webpack_require__(112);

var _rdeMainChannel = __webpack_require__(109);

var _rdeMainChannel2 = _interopRequireDefault(_rdeMainChannel);

var _tsdrChannel = __webpack_require__(111);

var _tsdrChannel2 = _interopRequireDefault(_tsdrChannel);

var _commonSvcService = __webpack_require__(108);

var _commonSvcService2 = _interopRequireDefault(_commonSvcService);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _angular2.default.module("com.vmware.vdi.htmlaccess.desktop", [_ngDialog2.default, _angularRoute2.default, _module2.default, _module4.default]).constant('WMKS', _WMKS2.default).constant('Unity', _unity2.default).constant('VDPService', _vdpservice2.default).constant('MKSVchan', _mksvchan2.default).constant('RTAVService', _rtavService2.default).constant('AB', _appblastUtil2.default).constant('jQuery', _jquery2.default).config(['$routeProvider', _route2.default]).factory("contextMenuManager", ['$window', _contextMenuManager2.default]).factory("unityService", ['$window', 'wmksService', 'Unity', 'wmksServiceEventHandler', _unityService2.default]).factory('FTUploadService', ['AB', 'wmksService', '$timeout', 'translate', 'fileTransferService', _fileTransferUploadService2.default]).factory('fileTransferService', ['AB', 'ngDialog', 'wmksService', '$timeout', 'translate', _fileTransferService2.default]).factory('TransferHelper', ['wmksService', 'FTDownloadService', 'FTUploadService', 'wmksServiceEventHandler', _fileTransferHelper2.default]).factory('FTDownloadService', ['AB', 'wmksService', '$timeout', 'fileTransferService', 'translate', _fileTransferDownloadService2.default]).factory('wmksService', ['blastWmks', 'safeStorageService', 'entitledItemsModel', 'entitledItemsService', 'messageHandlerService', 'MKSVchan', 'WMKS', 'AB', 'jQuery', '$timeout', '$window', '$rootScope', 'wmksServiceEventHandler', 'multimonService', 'commonSvcService', 'userGlobalPref', _wmksService2.default]).factory('panelService', ['$window', 'AB', _panelService2.default]).factory("blastWmks", ['$window', 'ngDialog', 'audioService', 'safeStorageService', 'VDPService', 'MKSVchan', 'RTAVService', 'multimonRenderingService', '$timeout', 'WMKS', 'AB', 'jQuery', 'translate', '$rootScope', '$q', 'mainChannelService', 'tsdrChannelService', _blastWmksService2.default]).factory("audioService", ['AB', '$window', 'WMKS', _audioService2.default]).factory("mainChannelService", _rdeMainChannel2.default).factory("tsdrChannelService", _tsdrChannel2.default).factory("commonSvcService", ['AB', 'wmksServiceEventHandler', 'dpiService', 'userGlobalPref', 'constants', _commonSvcService2.default]).filter("runningItemsFilter", _sidebar.runningItemsFilter)
// Filter for available items given a search query string and whether only
// favorites should be shown.
.filter("availableItemsFilter", _sidebar.availableItemsFilter).controller("SidebarController", ['$scope', '$window', '$rootScope', '$timeout', 'unityService', 'runningItemsModel', 'contextMenuManager', 'wmksService', 'entitledItemsModel', 'entitledItemsService', 'userGlobalPref', 'ngDialog', 'messageHandlerService', 'RTAVService', 'translate', 'WMKS', 'idleSessionService', 'wmksServiceEventHandler', 'commonSvcService', 'normalizationService', _sidebar.SidebarController]).controller('settingsWindowController', ['$scope', '$rootScope', '$timeout', 'wmksService', 'userGlobalPref', 'entitledItemsService', 'ngDialog', 'WMKS', 'translate', _settingsWindowController2.default]).controller('reAuthCtrl', ['$scope', '$rootScope', '$timeout', 'connectionServerModel', 'jscdkDesktopInvoker', 'viewClientModel', 'usernameUtil', 'entitledItemsService', 'ngDialog', _reauthController2.default]).controller('reAuthChangePasswordCtrl', ['$scope', '$rootScope', '$timeout', 'connectionServerModel', 'jscdkDesktopInvoker', _changepasswordController2.default]).controller('multimonSettingWindowController', ['$scope', '$rootScope', '$timeout', 'wmksService', 'userGlobalPref', 'ngDialog', 'translate', _multimonSettingWindowController2.default]).controller('fileTransferController', ['$window', '$scope', '$rootScope', '$timeout', 'ngDialog', 'wmksService', 'WMKS', 'TransferHelper', 'translate', 'toastService', 'wmksServiceEventHandler', 'panelService', _fileTransferPanel.fileTransferController]).controller('PrintController', ['AB', '$scope', '$timeout', 'WMKS', 'wmksService', 'translate', 'TransferHelper', 'toastService', 'wmksServiceEventHandler', _printService.PrintController]).controller('DesktopCtrl', ['$window', 'AB', '$scope', '$location', 'wmksService', 'entitledItemsService', _desktopController2.default]).controller('ajaxBusyOverlayController', ['$scope', '$rootScope', '$timeout', _ajaxBusyOverlay.ajaxBusyOverlayController]).controller('clipboardController', ['AB', '$scope', '$rootScope', '$timeout', 'ngDialog', 'wmksService', 'translate', 'wmksServiceEventHandler', 'panelService', _clipboard.clipboardController]).directive('printFrame', ['$timeout', 'AB', 'WMKS', '$window', 'wmksService', 'toastService', _printService.printFrame]).directive('sidebar', _sidebar.sidebarDirective).directive('fileTransferPanel', ['$window', 'panelService', '$timeout', _fileTransferPanel.fileTransferPanel]).directive('fileTransferInput', _fileTransferPanel.fileTransferInput).directive('fileDrop', _fileTransferPanel.fileDrop).directive('fileChange', _fileTransferPanel.fileChange).directive('verticalSlider', ['$window', 'AB', _verticalSlider2.default]).directive('ajaxBusyOverlay', _ajaxBusyOverlay.ajaxBusyOverlay).directive('clipboardInput', _clipboard.clipboardInput).directive('panelNotification', ['translate', _clipboard.panelNotification]).directive('clipboard', ['$window', 'panelService', '$timeout', _clipboard.clipboard]).service('wmksServiceEventHandler', ['$q', 'WMKS', 'AB', _wmksServiceEventHandler2.default]).service("runningItemsModel", ['AB', 'wmksService', 'unityService', '$rootScope', '$timeout', 'translate', 'wmksServiceEventHandler', _runningitemsModel2.default]).service("messageHandlerService", ['AB', '$window', _messagehandlerService2.default]).service('jscdkDesktopInvoker', ['$rootScope', '$location', '$timeout', '$window', 'viewClientModel', 'userGlobalPref', 'dpiService', 'connectionServerModel', 'constants', 'timezone', _jscdkDesktopInvoker2.default]).service('idleSessionService', _idleSessionService2.default).service("entitledItemsService", ['AB', 'safeStorageService', 'entitledItemsModel', 'applicationSessionsModel', 'blastSessionsModel', 'userGlobalPref', '$rootScope', '$q', 'multiSiteService', 'timezone', 'translate', 'constants', 'idleSessionService', 'dpiService', 'jscdkDesktopInvoker', 'ngDialog', 'viewClientModel', 'baseViewService', _entitleditemsService2.default]).service("entitledItemsModel", ["safeStorageService", "RTAVService", _entitleditemsModel2.default]).service("applicationSessionsModel", ["jscdkDesktopInvoker", "viewClientModel", "constants", _applicationsessionsModel2.default]).name; /*********************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *********************************************************/

/***/ }),
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _module = __webpack_require__(27);

var _module2 = _interopRequireDefault(_module);

var _angularRoute = __webpack_require__(11);

var _angularRoute2 = _interopRequireDefault(_angularRoute);

var _ngDialog = __webpack_require__(9);

var _ngDialog2 = _interopRequireDefault(_ngDialog);

var _route = __webpack_require__(247);

var _route2 = _interopRequireDefault(_route);

var _settingDialogController = __webpack_require__(248);

var _settingDialogController2 = _interopRequireDefault(_settingDialogController);

var _itemsctrlService = __webpack_require__(235);

var _itemsctrlService2 = _interopRequireDefault(_itemsctrlService);

var _itemsController = __webpack_require__(234);

var _itemsController2 = _interopRequireDefault(_itemsController);

var _viewctrlService = __webpack_require__(233);

var _viewctrlService2 = _interopRequireDefault(_viewctrlService);

var _viewService = __webpack_require__(232);

var _viewService2 = _interopRequireDefault(_viewService);

var _validateDirective = __webpack_require__(231);

var _utilService = __webpack_require__(230);

var _utilService2 = _interopRequireDefault(_utilService);

var _timeoutService = __webpack_require__(229);

var _timeoutService2 = _interopRequireDefault(_timeoutService);

var _tabsyncService = __webpack_require__(228);

var _tabsyncService2 = _interopRequireDefault(_tabsyncService);

var _mainService = __webpack_require__(227);

var _mainService2 = _interopRequireDefault(_mainService);

var _jscdkLauncherInvoker = __webpack_require__(226);

var _jscdkLauncherInvoker2 = _interopRequireDefault(_jscdkLauncherInvoker);

var _homewarningController = __webpack_require__(225);

var _homewarningController2 = _interopRequireDefault(_homewarningController);

var _headerController = __webpack_require__(224);

var _commonDirective = __webpack_require__(223);

var _blastdesktopController = __webpack_require__(222);

var _blastdesktopController2 = _interopRequireDefault(_blastdesktopController);

var _windowspasswordController = __webpack_require__(246);

var _windowspasswordController2 = _interopRequireDefault(_windowspasswordController);

var _unauthenticatedController = __webpack_require__(245);

var _unauthenticatedController2 = _interopRequireDefault(_unauthenticatedController);

var _securidwaitController = __webpack_require__(244);

var _securidwaitController2 = _interopRequireDefault(_securidwaitController);

var _securidpinchangeController = __webpack_require__(243);

var _securidpinchangeController2 = _interopRequireDefault(_securidpinchangeController);

var _securidpasscodeController = __webpack_require__(242);

var _securidpasscodeController2 = _interopRequireDefault(_securidpasscodeController);

var _securidnexttokencodeController = __webpack_require__(241);

var _securidnexttokencodeController2 = _interopRequireDefault(_securidnexttokencodeController);

var _loginController = __webpack_require__(240);

var _domainSelectMenuDirective = __webpack_require__(239);

var _domainSelectMenuDirective2 = _interopRequireDefault(_domainSelectMenuDirective);

var _disclaimerController = __webpack_require__(238);

var _disclaimerController2 = _interopRequireDefault(_disclaimerController);

var _changepasswordController = __webpack_require__(237);

var _changepasswordController2 = _interopRequireDefault(_changepasswordController);

var _anonymousSelectDirective = __webpack_require__(236);

var _anonymousSelectDirective2 = _interopRequireDefault(_anonymousSelectDirective);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _angular2.default.module('com.vmware.vdi.htmlaccess.launcher', [_angularRoute2.default, _ngDialog2.default, _module2.default]).config(['$routeProvider', _route2.default]).controller('LauncherSettingsWindowController', ['$scope', '$rootScope', 'utilService', 'userGlobalPref', 'translate', 'dialogService', 'mainService', 'viewClientModel', 'prefData', 'timezone', '$timeout', 'jscdkLauncherInvoker', _settingDialogController2.default]).controller('LaunchItemsCtrl', ['$scope', '$rootScope', '$timeout', 'connectionServerModel', 'viewClientModel', 'mainService', 'storageService', 'LaunchItemsCtrlService', 'utilService', 'safeStorageService', 'userGlobalPref', 'translate', 'connectionURIModel', 'dialogService', 'credCleanService', 'timezone', 'jscdkLauncherInvoker', 'brokerSessionStorageService', 'constants', _itemsController2.default]).controller('HomeWarningCtrl', ['$scope', 'utilService', 'mainService', 'viewClientModel', 'storageService', _homewarningController2.default]).controller('HeaderCtrl', ['$rootScope', '$scope', 'connectionServerModel', 'utilService', 'dialogService', _headerController.HeaderCtrl]).controller('BlastDesktopCtrl', ['$window', '$scope', '$rootScope', 'mainService', 'connectionServerModel', 'blastSessionsModel', 'viewClientModel', 'connectionURIModel', 'multiSiteService', 'viewService', 'constants', 'userGlobalPref', 'baseViewService', 'jscdkLauncherInvoker', _blastdesktopController2.default]).controller('WindowsPasswordCtrl', ['$scope', 'connectionServerModel', 'mainService', 'utilService', 'translate', 'dialogService', 'viewClientModel', 'connectionURIModel', 'viewService', 'usernameUtil', 'jscdkLauncherInvoker', _windowspasswordController2.default]).controller('UnauthenticatedCtrl', ['$scope', 'connectionServerModel', 'translate', 'viewService', 'mainService', 'jscdkLauncherInvoker', 'connectionURIModel', 'utilService', 'dialogService', _unauthenticatedController2.default]).controller('SecuridWaitCtrl', ['$scope', '$rootScope', '$timeout', 'connectionServerModel', 'mainService', 'utilService', 'jscdkLauncherInvoker', _securidwaitController2.default]).controller('SecuridPinChangeCtrl', ['$scope', '$rootScope', '$timeout', 'connectionServerModel', 'mainService', 'utilService', 'jscdkLauncherInvoker', 'translate', _securidpinchangeController2.default]).controller('SecuridPasscodeCtrl', ['$scope', '$rootScope', '$timeout', 'connectionServerModel', 'mainService', 'utilService', 'jscdkLauncherInvoker', 'translate', _securidpasscodeController2.default]).controller('SecuridNextTokenCodeCtrl', ['$scope', '$rootScope', '$timeout', 'connectionServerModel', 'mainService', 'utilService', 'jscdkLauncherInvoker', 'translate', _securidnexttokencodeController2.default]).controller('LoginCtrl', ['$scope', '$rootScope', 'mainService', 'utilService', 'storageService', 'jscdkLauncherInvoker', _loginController.LoginCtrl]).controller("WaitingCtrl", ['$scope', '$rootScope', _loginController.WaitingCtrl]).controller('DisclaimerCtrl', ['$scope', '$rootScope', '$timeout', 'mainService', 'utilService', 'jscdkLauncherInvoker', _disclaimerController2.default]).controller('ChangePasswordCtrl', ['$scope', '$timeout', 'mainService', 'utilService', 'connectionServerModel', 'jscdkLauncherInvoker', _changepasswordController2.default]).factory('LaunchItemsCtrlService', ['connectionServerModel', 'mainService', 'utilService', 'dialogService', 'safeStorageService', 'translate', 'connectionURIModel', 'viewService', 'jscdkLauncherInvoker', _itemsctrlService2.default]).service('viewCtrlService', ['$rootScope', '$timeout', _viewctrlService2.default]).service('viewService', ['$location', '$timeout', 'utilService', 'connectionURIModel', 'tabSyncService', 'baseViewService', 'URIParamValidator', 'dialogService', 'jscdkLauncherInvoker', 'translate', 'constants', 'ws1Service', _viewService2.default]).service('utilService', ['connectionURIModel', 'translate', 'dialogService', 'localize', 'brokerSessionStorageService', 'viewClientModel', 'jscdkLauncherInvoker', '$window', _utilService2.default]).service('timeoutService', ['$window', 'connectionServerModel', 'storageService', 'jscdkLauncherInvoker', _timeoutService2.default]).service("tabSyncService", ['$window', 'utilService', _tabsyncService2.default]).service('mainService', ['$rootScope', 'utilService', '$route', 'dialogService', 'viewClientModel', 'connectionURIModel', 'translate', 'viewService', 'timeoutService', 'userGlobalPref', 'brokerSessionStorageService', 'viewCtrlService', 'jscdkLauncherInvoker', 'constants', '$window', 'ws1Service', _mainService2.default]).service('jscdkLauncherInvoker', ['$window', 'viewClientModel', 'connectionURIModel', 'userGlobalPref', 'dpiService', 'storageService', 'connectionServerModel', 'constants', _jscdkLauncherInvoker2.default]).directive('equalTo', _validateDirective.equalToDirective).directive('serverName', _validateDirective.serverNameDirective).directive('scrollTop', _commonDirective.scrollTopDirective).directive('viewAutofocus', ['$timeout', _commonDirective.viewAutofocusDirective]).directive('unstorablePassword', ['$timeout', _commonDirective.unstorablePasswordDirective]).directive('fallbackSrc', _commonDirective.fallbackSrcDirective).directive('progressCircle', _commonDirective.progressCircleDirective).directive('helpLink', ['viewClientModel', 'utilService', 'translate', '$timeout', '$rootScope', 'localize', _commonDirective.helpLinkDirective]).directive('downloadLink', ['translate', '$timeout', '$rootScope', 'viewClientModel', 'localize', _commonDirective.downloadLinkdirective]).directive('highlight', _commonDirective.highlightDirective).directive('domainSelectMenu', ['$timeout', 'viewClientModel', _domainSelectMenuDirective2.default]).directive('anonymousSelect', ['$timeout', _anonymousSelectDirective2.default]).directive('launcherHeader', _headerController.headerDirective).name; /*********************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       *********************************************************/

/***/ }),
/* 71 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 72 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 73 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 74 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 75 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 76 */,
/* 77 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 78 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

__webpack_require__(29);

__webpack_require__(72);

__webpack_require__(71);

__webpack_require__(73);

__webpack_require__(20);

__webpack_require__(78);

__webpack_require__(74);

__webpack_require__(75);

__webpack_require__(77);

__webpack_require__(21);

var _templateModule = __webpack_require__(19);

var _templateModule2 = _interopRequireDefault(_templateModule);

var _module = __webpack_require__(27);

var _module2 = _interopRequireDefault(_module);

var _module3 = __webpack_require__(70);

var _module4 = _interopRequireDefault(_module3);

var _module5 = __webpack_require__(63);

var _module6 = _interopRequireDefault(_module5);

var _appCenterController = __webpack_require__(62);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Define all controllers here for this module


// All css import here. DO NOT change their order.
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * app-htmlaccess.js
 * Entry for the whole html access app.
 * NOTE: this is not the entry for pdfjs and extended monitor page
 */

exports.default = _angular2.default.module('com.vmware.vdi.htmlaccess', [_templateModule2.default, _module2.default, _module4.default, _module6.default]).run(['$window', _appCenterController.config]).controller('AppCenterController', ['$scope', '$rootScope', 'constants', '$window', 'baseViewService', 'connectionURIModel', _appCenterController.AppCenterController]).name;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = AboutDialogCtrl;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function AboutDialogCtrl($scope, viewClientModel, localize) {
   /**
    * When continute the page merge, this part need to be merged with the one
    * for the launcher also.
    */
   var getHelpLink = function getHelpLink() {
      var locale = localize.getLocale(),
          map = viewClientModel.linkModel['helpPages'];

      if (map.hasOwnProperty(locale)) {
         return map[locale];
      }

      return map.en;
   };
   $scope.helpUrl = viewClientModel.rebrandHelpUrl || getHelpLink();
}

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.ngDialogProvider = ngDialogProvider;
exports.dialogService = dialogService;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

var _dialog_service_confirm = __webpack_require__(26);

var _dialog_service_confirm2 = _interopRequireDefault(_dialog_service_confirm);

var _dialog_service_cancel_confirm = __webpack_require__(256);

var _dialog_service_cancel_confirm2 = _interopRequireDefault(_dialog_service_cancel_confirm);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ngDialogProvider(ngDialogProvider) {
   ngDialogProvider.setDefaults({
      name: "DefaultDialog",
      className: "session-ops-dialog",
      showClose: false,
      closeByEscape: true,
      closeByDocument: true
   });
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * dialog-service.js
 *
 * The unified dialog-service for desktop/launcher module.
 * It is a simple wrapper for ngDialog. And ngDialog is pre-configured in
 * 'common/module.js'
 */

function dialogService(ngDialog) {
   var _this = this;

   this._DEFAULT_ERROR_OPTIONS = {
      name: "DefaultErrorDialog",
      templateUrl: _dialog_service_error2.default
   };
   this._DEFAULT_CONFIRM_OPTOINS = {
      name: "DefaultConfirmDialog",
      templateUrl: _dialog_service_confirm2.default
   };

   this.confirm = function (options) {
      if (!options) {
         options = {};
      }
      var defaultOptions = _this._DEFAULT_CONFIRM_OPTOINS;
      _angular2.default.extend(defaultOptions, options);
      return ngDialog.open(defaultOptions);
   };

   this.confirmWithCancelAsDefault = function (options) {
      if (!options) {
         options = {};
      }
      var defaultOptions = {
         name: "ConfirmWithCancelAsDefault",
         templateUrl: _dialog_service_cancel_confirm2.default
      };
      _angular2.default.extend(defaultOptions, options);
      return ngDialog.open(defaultOptions);
   };

   this.error = function (options) {
      if (!options) {
         options = {};
      }
      var defaultOptions = _this._DEFAULT_ERROR_OPTIONS;
      _angular2.default.extend(defaultOptions, options);
      return ngDialog.open(defaultOptions);
   };

   this.predefined = function (options, isConfirmDialog) {
      if (isConfirmDialog) {
         return ngDialog.openConfirm(options);
      }
      return ngDialog.open(options);
   };

   this.isDialogOpen = function (dialogID) {
      return ngDialog.isOpen(dialogID);
   };

   this.hasDialogOpen = function () {
      var dialog = (0, _jquery2.default)('.ngdialog');
      return !(dialog === null || dialog.length === 0);
   };
}

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

var constants = {
   viewclientType: 'htmlaccess',
   CLIENT_MODE: {
      LAUNCHER: 'launcher',
      DESKTOP: 'desktop'
   },
   DPI_100_PERCENT: 96,
   ANONYMOUS_MODE_KEY: 'ANONYMOUS_MODE',
   SP_ID_FOR_WS1_KEY: 'SP_ID_FOR_WS1',
   CLIENT_LOGIN_KEY: 'HTML_ACCESS_LOGIN'
};

exports.default = constants;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.dialogTabindex = dialogTabindex;
exports.dialogPreventKeyUp = dialogPreventKeyUp;
exports.dialogTabScope = dialogTabScope;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function dialogTabindex() {
   /**
    * this derective is serve to fix a bug when using native tabindex, so
    * have the similar interface.
    */
   return {
      require: '^dialogTabScope',
      scope: {},
      restrict: 'A',
      link: function link(scope, element, attrs, scopeCtrl) {
         if (!scopeCtrl.inited) {
            scopeCtrl.init();
         }
         //add this element under control
         scopeCtrl.addChoosableElement(element, attrs.dialogTabindex);
      }
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * dialog-accessibility.js
 *
 */

function dialogPreventKeyUp($rootScope) {
   /**
    * When dialog is closed, the focus could go back to header
    * element. And at this time it is possible that user is still
    * holding the key and then the the key up event is received.
    * That's not what we want.
    */
   return {
      restrict: 'A',
      link: function link(scope, element) {
         element.keydown(function (event) {
            if (event.keyCode === 13) {
               $rootScope.isDialogServiceKeyPress = true;
            }
         });
      }
   };
}

function dialogTabScope($timeout) {
   /**
    * this derective will create a isolated scope and controll the reaction
    * for
    * "tab" key pressing for all registered element in it.
    */
   return {
      restrict: 'A',
      scope: {},
      controller: ['$rootScope', '$scope', '$element', function ($rootScope, $scope, $element) {
         var _this = this;

         this.inited = false;
         this.reseted = true;
         this.choosableArray = [];
         this.currentTabIndex = -1;

         this.reset = function () {
            this.reseted = true;
            this.currentTabIndex = -1;
         };

         this.isInnerElement = function (parent, child) {
            return parent.contains ? parent !== child && parent.contains(child) : !!(parent.compareDocumentPosition(child) & 16);
         };

         /**
          * return a auto assigned index as the default index
          */
         this.getDefaultIndex = function () {
            var i = void 0,
                startIndex = 0,
                indexSlot = startIndex;

            for (i = 0; i < this.choosableArray.length; i++) {
               if (this.choosableArray[i].index >= startIndex) {
                  if (indexSlot === this.choosableArray[i].index) {
                     indexSlot++;
                  } else {
                     break;
                  }
               }
            }
            return indexSlot;
         };

         /**
          * add a choosable element under control
          */
         this.addChoosableElement = function (element, index) {
            var i = void 0,
                indexNumber = void 0,
                item = void 0;

            if (!index) {
               indexNumber = this.getDefaultIndex(index);
            } else {
               indexNumber = Number(index);
            }

            item = {
               index: indexNumber,
               element: element
            };

            if (this.choosableArray.length === 0) {
               this.choosableArray.push(item);
               return;
            }

            if (this.findIndex(index) >= 0) {
               _jscdkLogger2.default.debug('repeat index is not allowed');
               return;
            }

            for (i = 0; i < this.choosableArray.length; i++) {
               if (this.choosableArray[i].index > index) {
                  //insert at index with item
                  this.choosableArray.splice(i, 0, item);
                  return;
               }
            }

            this.choosableArray.push(item);
         };

         this.findIndex = function (targetTabIndex) {
            var i = void 0;
            if (targetTabIndex === -1) {
               return -1;
            }
            for (i = 0; i < this.choosableArray.length; i++) {
               if (this.choosableArray[i].index === targetTabIndex) {
                  return i;
               }
            }
            return -1;
         };

         this.getNextElementIndex = function () {
            return (this.findIndex(this.currentTabIndex) + 1) % this.choosableArray.length;
         };

         this.onTabDown = function () {
            $timeout(function () {
               var nextElementIndex = void 0;

               if (_this.choosableArray.length === 0) {
                  _jscdkLogger2.default.debug('the dialog-tabindex list is empty');
                  return;
               }
               nextElementIndex = _this.getNextElementIndex();
               _this.choosableArray[nextElementIndex].element[0].focus();
               _this.currentTabIndex = _this.choosableArray[nextElementIndex].index;
            });
         };

         this.onKeyDown = function (event) {
            if (event.keyCode === 9) {
               _jscdkLogger2.default.trace('tab key pressed');
               event.preventDefault();
               this.onTabDown();
            }
         };

         this.focusOnDefault = function () {
            var defaultElement = this.choosableArray[0];
            if (!defaultElement) {
               _jscdkLogger2.default.debug('the default element to be focused don\'t exist');
               return;
            }
            defaultElement.element[0].focus();
            this.currentTabIndex = defaultElement.index;
         };

         this.init = function () {
            var _this2 = this;

            var onFocus = void 0,
                onFocusOut = void 0,
                workingDialog = void 0,
                children = $element.children(),
                keyDownFunc = this.onKeyDown.bind(this);

            // valid check
            if (!children || !children[0]) {
               return;
            }
            workingDialog = children[0];

            //callbacks definition, binding "this" is for referring the
            // this.choosableArray and this.currentTabIndex
            onFocus = function (event) {
               if (this.reseted) {
                  // set focus on the default button
                  this.focusOnDefault();
                  _jscdkLogger2.default.debug('dialog focus reseted to default');
                  this.reseted = false;
               }
            }.bind(this);

            onFocusOut = function (event) {
               if (this.isInnerElement($element[0], event.target) && !this.isInnerElement($element[0], event.relatedTarget)) {
                  //dialog loss focus
                  this.reset();
               }
            }.bind(this);

            //callbacks bind
            $element.on('keydown', keyDownFunc);
            $(workingDialog).focus(onFocus);
            $(workingDialog).focusout(onFocusOut);

            //callbacks unbind when destructed
            $element.on('$destroy', function () {
               $element.off('keydown', keyDownFunc);
               $(workingDialog).off('focus', onFocus);
               $(workingDialog).off('focusout', onFocusOut);
               _this2.inited = false;
               _this2.choosableArray = [];
               _this2.currentTabIndex = -1;
            });

            this.inited = true;
         };
      }]
   };
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = fuzzyFree;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function fuzzyFree($rootScope, $timeout) {
   /**
    * This directive is for bug 1512510
    * Some font is fuzzy in Chrome because of Chrome's bug
    * It happens in odd pixel height.
    */
   return {
      restrict: 'A',
      link: function link(scope, element) {
         scope.$watch(function () {
            return element[0].offsetHeight;
         }, function (newHeight, oldHeight) {
            if (newHeight === oldHeight) {
               return;
            }

            $timeout(function () {
               if (newHeight % 2 === 0) {
                  newHeight++;
                  element.css('height', newHeight + 'px');
               }
            });
         });
      }
   };
}

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = scrollableDialog;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scrollableDialog($window) {
   return {
      restrict: 'E',
      replace: false,
      link: function link(scope, element) {
         var defaultHeight = void 0;

         scope.clamp = function (value, minValue, maxValue) {
            return Math.min(maxValue, Math.max(value, minValue));
         };

         scope.windowResizeHandler = function () {
            var newHeight = void 0;
            if (!defaultHeight) {
               defaultHeight = element.find('.dialog-content').outerHeight();
            }
            newHeight = scope.clamp(defaultHeight, 0, $window.innerHeight - element.find('.dialog-title').outerHeight() - element.find('.dialog-button-row').outerHeight());
            element.find('.dialog-content').css('height', newHeight);
         };

         _angular2.default.element($window).bind('resize', scope.windowResizeHandler);

         /*
          * a new directive is instantiated with every dialog open, so we fire a
          * resize event on a small delay so that we adjust the size as soon as
          * the dialog becomes visible.
          */
         setTimeout(scope.windowResizeHandler, 100);

         scope.$on('$destroy', function () {
            _angular2.default.element($window).unbind('resize', scope.windowResizeHandler);
         });
      }
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = model;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function model($rootScope, $timeout, brokerSessionStorageService, constants) {
   function BaseViewClientModel() {
      var _this = this;

      // Name of company that produced this client
      this.vendor = 'VMware';

      // Architecture of client
      this.arch = '';

      // Vendor-specific client-type identifier
      this.product = 'VMware Horizon HTML Access';

      // Product version
      this.version = '';

      // unique client ID
      this.clientID = '';

      this.linkModel = {
         // Help Pages, now Unique ID
         'helpPages': {
            'en': 'https://docs.vmware.com/en/VMware-Horizon-HTML-Access/4.6/' + 'com.vmware.horizon.html-access-46-user-guide/GUID-20F0C9F6-' + '7DE9-4D3D-8095-391C9F795F54.html',
            'de': 'https://docs.vmware.com/de/VMware-Horizon-HTML-Access/4.6/' + 'com.vmware.horizon.html-access-46-user-guide/GUID-20F0C9F6-' + '7DE9-4D3D-8095-391C9F795F54.html',
            'es': 'https://docs.vmware.com/es/VMware-Horizon-HTML-Access/4.6/' + 'com.vmware.horizon.html-access-46-user-guide/GUID-20F0C9F6-' + '7DE9-4D3D-8095-391C9F795F54.html',
            'fr': 'https://docs.vmware.com/fr/VMware-Horizon-HTML-Access/4.6/' + 'com.vmware.horizon.html-access-46-user-guide/GUID-20F0C9F6-' + '7DE9-4D3D-8095-391C9F795F54.html',
            'ja': 'https://docs.vmware.com/jp/VMware-Horizon-HTML-Access/4.6/' + 'com.vmware.horizon.html-access-46-user-guide/GUID-20F0C9F6-' + '7DE9-4D3D-8095-391C9F795F54.html',
            'ko': 'https://docs.vmware.com/kr/VMware-Horizon-HTML-Access/4.6/' + 'com.vmware.horizon.html-access-46-user-guide/GUID-20F0C9F6-' + '7DE9-4D3D-8095-391C9F795F54.html',
            'zh-CN': 'https://docs.vmware.com/cn/VMware-Horizon-HTML-Access/4.6/' + 'com.vmware.horizon.html-access-46-user-guide/GUID-20F0C9F6-' + '7DE9-4D3D-8095-391C9F795F54.html',
            'zh-TW': 'https://docs.vmware.com/tw/VMware-Horizon-HTML-Access/4.6/' + 'com.vmware.horizon.html-access-46-user-guide/GUID-20F0C9F6-' + '7DE9-4D3D-8095-391C9F795F54.html'
         },
         // go to forum Pages
         'gotoForumPages': {
            'en': 'https://communities.vmware.com/community/vmtn/horizon/view'
         },
         /*
          * EULAs of HTML Access are in the installer instead of online web pages.
          * Here are just some dummy IDs. Out-Of-Use
          */
         'eulaPages': {
            'en': 'https://www.vmware.com/info?id=1327'
         }

      };

      this.MIN_VERSION = {
         'IE': 10,
         'Firefox': 36,
         'Gecko': 21,
         'Chrome': 41,
         'Safari': 7,
         'WebKit': 536
      };

      this.acceptLanguage = null;
      this.clientVersion = null;
      this.logLevel = null;
      this.ipAddress = null;
      this.rebrandName = null;
      this.rebrandHelpUrl = '';
      this.rebrandGotoForumUrl = '';
      this.windowsTimezone = null;

      /**
       *  Features in 'client-config' of broker response
       */
      this.clientHideDomainList = !!brokerSessionStorageService.read('clientHideDomainList');
      this.clientHideServerInformation = !!brokerSessionStorageService.read('clientHideServerInformation');
      this.credentialCleanup = !!brokerSessionStorageService.read('credentialCleanup');
      this.isAnonymousMode = !!brokerSessionStorageService.read(constants.ANONYMOUS_MODE_KEY);
      $timeout(function () {
         $rootScope.showPreference = !_this.isAnonymousMode;
      });
   }

   // Return constructor function.
   return BaseViewClientModel;
}

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = blastSessionsModel;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function blastSessionsModel(brokerSessionStorageService) {
   //private:
   var isNotValidString = void 0,
       isInvalidBlastSession = void 0,
       hasBlastInfoIn = void 0,
       getFormatConvertedInfo = void 0,
       getFormatConvertedInfoFromSessionInfo = void 0,
       hasSessionInfoInStorage = void 0,
       readFromStorage = void 0,
       writeToStorage = void 0,
       isInvalidLaunchResponse = void 0;

   isNotValidString = function isNotValidString(data) {
      return typeof data !== 'string' || data.trim() === '';
   };

   isInvalidBlastSession = function isInvalidBlastSession(sessionInfo) {
      if (!sessionInfo || isNotValidString(sessionInfo.sessionId) || sessionInfo.protocolIsBlast === false || typeof sessionInfo.needNewConnectionWithBlast !== 'boolean' || !sessionInfo.content || isNotValidString(sessionInfo.content.originId)) {
         return true;
      }

      return false;
   };

   hasBlastInfoIn = function hasBlastInfoIn(sessionInfo) {
      return sessionInfo.needNewConnectionWithBlast;
   };

   /**
    * other useful but not reported info in sessionInfo.content includes:
    * [userName, domainName, enableUsb, enableMmr, preferences]
    */
   getFormatConvertedInfo = function getFormatConvertedInfo(data) {
      var convertedSessionInfo = {};
      if (!data) {
         return {};
      }
      convertedSessionInfo.originId = data.originId;
      convertedSessionInfo.blastUrl = data.url;
      return convertedSessionInfo;
   };

   getFormatConvertedInfoFromSessionInfo = function getFormatConvertedInfoFromSessionInfo(sessionInfo) {
      return getFormatConvertedInfo(sessionInfo.content);
   };

   hasSessionInfoInStorage = function hasSessionInfoInStorage(originId) {
      return brokerSessionStorageService.exist(originId);
   };

   readFromStorage = function readFromStorage(originId) {
      return brokerSessionStorageService.read(originId);
   };

   writeToStorage = function writeToStorage(convertedSessionInfo) {
      var originId = convertedSessionInfo.originId;

      brokerSessionStorageService.write(originId, convertedSessionInfo);
   };

   isInvalidLaunchResponse = function isInvalidLaunchResponse(responseData) {
      if (!responseData || isNotValidString(responseData.id) || isNotValidString(responseData.url)) {
         return true;
      }
      return false;
   };

   //public:
   /**
    * designed for read out and fill the lacking data of the
    * sessionInfoList side effect!: also write data. implement like this
    * to increase efficiency and provide a simple API.
    */
   this.getFullSessionInfoWith = function (sessionInfoList) {
      var i = void 0,
          sessionInfo = void 0,
          originId = void 0,
          validSessionInfoList = [];

      for (i = 0; i < sessionInfoList.length; i++) {
         sessionInfo = sessionInfoList[i];
         if (isInvalidBlastSession(sessionInfo)) {
            // error
            return [];
         }

         originId = sessionInfo.content.originId;
         if (hasBlastInfoIn(sessionInfo)) {
            validSessionInfoList[i] = getFormatConvertedInfoFromSessionInfo(sessionInfo);
            writeToStorage(validSessionInfoList[i]);
         } else if (hasSessionInfoInStorage(originId)) {
            validSessionInfoList[i] = readFromStorage(originId); //storage
            // service
         } else {
            validSessionInfoList[i] = {};
         }
      }
      return validSessionInfoList;
   };

   /**
    * designed for saving data that contains in the launch
    * app(get-application-connection) XML response
    */
   this.saveFromXmlResponse = function (responseData) {
      var validSessionInfo = void 0;
      if (isInvalidLaunchResponse(responseData)) {
         _jscdkLogger2.default.debug('Error: fail to save, because the saveFromXmlResponse is called with invalid response');
      }
      validSessionInfo = getFormatConvertedInfo(responseData);
      writeToStorage(validSessionInfo);
   };
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * blastsessions-model.js --
 *
 * Model to provide blast application sessions information for reconnection
 * using broker response of reconnect and broerkSessionStorageService.
 */

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = clientIdFactory;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function clientIdFactory($window) {
   var clientUID = null;

   /**
    * Whether the input string is a IP address
    * Try to analysis for both IPv4 and IPv6, and the part for IPv6 is not
    * tested with real IPv6 address.
    *
    * Althrough shorten 1:2:3:4:5:0:7:8 to 1:2:3:4:5::7:8 is not recommened
    * by RFC 5952, but here still treat it as a valid IP address for giving
    * warning info when user don't know this format rule. But do not accept
    * the shorting from 1:2:3:4:5:6:7:0 to 1:2:3:4:5:6:7:: or things like
    * 1:2:3:4:5:6:7:, while accept 1:2::8, 1:2:3::, ::7:8 or ::.
    *
    * @param hostAddress string
    * @return isAnIPAddress bool
    */
   function isAnIP(hostAddress) {
      var segmentArray = void 0,
          segmentLength = void 0,
          i = void 0,
          temp = void 0,
          isIPv4Address = false,
          isIPv6Address = false;

      if (hostAddress.split('.').length !== 4) {
         // not a IPv4
         if ((hostAddress.split('::').length !== 2 || hostAddress.split(':').length > 7) && hostAddress.split(':').length !== 8) {
            // not a IPv6
            return false;
         }
         segmentArray = hostAddress.split(':');
         segmentLength = segmentArray.length;
         isIPv6Address = true;
      } else {
         segmentArray = hostAddress.split('.');
         segmentLength = segmentArray.length;
         isIPv4Address = true;
      }

      if (isIPv4Address) {
         //IPv4
         for (i = 0; i < segmentLength; i++) {
            temp = parseInt(segmentArray[i], 10);
            if (!(temp <= 255 && temp >= 0 && segmentArray[i].length <= 3)) {
               // NaN will be true
               isIPv4Address = false;
               break;
            }
         }
      } else if (isIPv6Address) {
         //IPv6
         if (hostAddress.split('::').length === 2) {
            // have ::
            if (hostAddress === '::') {
               // all-zeros
               return true;
            }
            if (segmentArray[0] === '' && segmentArray[1] === '') {
               //::X:X:X
               for (i = 2; i < segmentLength; i++) {
                  segmentArray[i - 2] = segmentArray[i];
               }
               segmentLength -= 2;
            } else if (segmentArray[segmentLength - 1] === '' && segmentArray[segmentLength - 2] === '') {
               //X:X:X::
               segmentLength -= 2;
            } else {
               // X:X::X:X
               segmentArray = hostAddress.replace('::', ':').split(':');
               segmentLength = segmentArray.length;
            }
         }
         for (i = 0; i < segmentLength; i++) {
            temp = parseInt(segmentArray[i], 16);
            if (!(temp <= 65535 && temp >= 0 && segmentArray[i].length <= 4)) {
               // NaN will be true
               isIPv6Address = false;
               break;
            }
         }
      }
      return isIPv4Address || isIPv6Address;
   }

   /* Whether the input string is a parent-domain(or itself) of current page
    *
    * I use write and read test to test whether current page can access the
    * input 'domain'.
    *
    * the usage of document.domain can also get rootDomain, but the DOM 2
    * HTML standard defined document.domain as readonly while HTML Living
    * Standard updated in 11th/sep/2014 define it as property that can be
    * write, and web sites like q.com seems using this technic. But using
    * it will involve the wired document.domain = document.domain in all
    * other files and browser support them in different ways. So I do not
    * choose this one. Might will be used after the Blast page is moved
    * to Broker.
    *
    * the timestamp is to prevent browser do not rewrite identical cookie,
    * which should never happen, and '=1' is to make it a key-value pair,
    * both are just to make code stronger.
    *
    * @param  domain               string
    * @return isAnAccessableDomain bool
    */
   function isAnAccessableDomain(domain) {
      var testText = 'TCAT4' + domain + new Date().getTime() + '=1';

      try {
         // try write a cookie will expire after 5 seconds, for old browser
         // it will be session cookie
         $window.document.cookie = testText + '; max-age=5; path=/; domain=' + domain + '; secure';

         // try read
         return $window.document.cookie.indexOf(testText) > -1;
      } catch (err) {
         return false;
      }
   }

   /* Whether the input string is a parent-domain(or itself) of current page
    *
    * This function can be rewirte with top-level domain suffix table as
    * broswers do, but it need to be maintained all the time, and might loss
    * support for suffix like '.cn, .jp, .tw' for small contries. So here I
    * use write and read test to get the shortest 'domain' that current page
    * can access. And treat it as the root domain.
    *
    * It also take the domain name without suffix like .com as valid root
    * domain, for this product might be only used in LAN with DNS settings
    * that allows the domain name represented in the short form.
    *
    * @param  hostAddress          string
    * @return rootDomain           string
    */
   function getRootDomain(hostAddress) {
      var segmentArray = hostAddress.split('.'),
          segmentLength = segmentArray.length,
          rootDomain = null;

      // try filter IP address out, and the continuing code can still work
      // with IP not recognized
      if (isAnIP(hostAddress)) {
         _jscdkLogger2.default.warning('launch the html access by IP may generate extra licenses!');
         return hostAddress;
      }

      /* take the domain name without suffix like .com as valid, for this
       * product might be only used in LAN with domain name in short form
       */
      do {
         segmentLength--;
         if (!rootDomain) {
            rootDomain = segmentArray[segmentLength];
         } else {
            rootDomain = segmentArray[segmentLength] + '.' + rootDomain;
         }
         if (isAnAccessableDomain(rootDomain)) {
            return rootDomain;
         }
      } while (segmentLength > 0);

      return hostAddress;
   }

   function setClientUIDFromCookie() {
      var name = 'CID=',
          cookies = $window.document.cookie.split(/;\s*/),
          cookiesLength = cookies.length,
          i = void 0;

      for (i = cookiesLength - 1; i >= 0; i--) {
         if (cookies[i].indexOf(name) === 0) {
            clientUID = cookies[i].replace(name, '');
            return;
         }
      }
      clientUID = null;
   }

   function writeClientUIDToCookie() {
      var rootDomain = getRootDomain($window.location.host),
          d = new Date(),
          expires = void 0;

      // cookie will exist for 10 years (an old way to support old browsers)
      d.setTime(d.getTime() + 10 * 365.25 * 24 * 60 * 60 * 1000);
      expires = '; expires=' + d.toGMTString();
      $window.document.cookie = 'CID=' + clientUID + expires + '; path=/; domain=' + rootDomain + '; secure';
   }

   /* generate a new Client ID by random array
    *
    * the platform ID is generated as MS requested in MSDN.
    *
    * navigator.platform is supported by Chrome, FF, IE, Opera, Safari, and
    * Android, Chrome for Andriod, FF Mobile, IE Mobile, Opera Mobile, Safari
    * Mobile, using UA again is just to make code stronger for old browsers.
    *
    * and the String is matched with capital charactor reserved for reducing
    * the chance of mismatching.
    */
   function generateRandomArray() {
      var platformID = '04-00-00-00'; //default

      if (!!$window.navigator.platform) {
         if ($window.navigator.platform.indexOf('Win') === 0) {
            //'Win32','Windows'
            platformID = '02-00-00-00';
         }
         if ($window.navigator.platform.indexOf('Mac') === 0) {
            // 'Mac68K', 'MacPPC', 'Macintosh', 'MacIntel'
            platformID = '06-00-00-00';
         }
      } else if (!!$window.navigator.userAgent) {
         if ($window.navigator.userAgent.indexOf('Windows') > -1) {
            //Windows NT 5.0, Windows 2000, Windows NT 5.1, Windows XP, Windows NT 5.2,
            // Windows 2003, Windows NT 6.0, Windows Vista, Windows NT 6.1, Windows 7,
            // Windows 8
            platformID = '02-00-00-00';
         }
         if ($window.navigator.userAgent.indexOf('Mac') > -1) {
            platformID = '06-00-00-00';
         }
      }
      /**
       * Generate a random number in [0,1), by using the current time.
       */
      function random() {
         var d = new Date(),
             seed = Math.abs(1000 * d.getSeconds() + d.getMilliseconds()),
             r = seed * Math.random();
         return r - Math.floor(r);
      }

      return (platformID + ' xx-xx-xx-xx xx-xx-xx-xx xx-xx-xx-xx xx-xx-xx-xx').replace(/x/g, function () {
         var r = random() * 16 | 0;
         return r.toString(16);
      }).split(/ |-/);
   }

   function arrayToBase64(uidIntArray) {
      var i = 0,
          arrayLength = uidIntArray.length,
          h1 = void 0,
          h2 = void 0,
          h3 = void 0,
          number = void 0,
          c1 = void 0,
          c2 = void 0,
          c3 = void 0,
          c4 = void 0,
          toBase64Table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          charsArray = [],
          result = void 0,
          indexAc = 0,
          r = void 0;

      do {
         // pack three bytes into four charactors in 64-base
         h1 = parseInt(uidIntArray[i++], 16); //undefine will return NaN
         h2 = parseInt(uidIntArray[i++], 16);
         h3 = parseInt(uidIntArray[i++], 16);

         number = h1 << 16 | h2 << 8 | h3; //NaN will be treated as 0

         c1 = number >> 18 & 0x3f;
         c2 = number >> 12 & 0x3f;
         c3 = number >> 6 & 0x3f;
         c4 = number & 0x3f;

         // Convert decimal into base64, and append to array to avoid
         // realloc spaces too often.
         charsArray[indexAc++] = toBase64Table[c1] + toBase64Table[c2] + toBase64Table[c3] + toBase64Table[c4];
      } while (i < arrayLength);
      result = charsArray.join('');

      //replace the undefined pure-0 charactor(A)s part with '='s
      r = uidIntArray.length % 3;
      return (r ? result.slice(0, r - 3) : result) + '==='.slice(r || 3);
   }

   function generateUID() {
      var uidIntArray = generateRandomArray();
      return arrayToBase64(uidIntArray);
   }

   function getClientID() {
      setClientUIDFromCookie();
      if (!clientUID) {
         clientUID = generateUID();
         writeClientUIDToCookie();
      }
      return clientUID;
   }

   // Return client ID.
   return getClientID();
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * This file is to generate and reuse ClientID, currently, the
 * ClientID will be kept for 10 years, and can corss domains that
 * share a same root domain, so a user can access brokers in the
 * same root-domain with the identical clientID.
 *
 * But access throuth the static IP of broker or the hostName of
 * the static IP will use different Client ID, and will cost more
 * licenses when access RDSH desktop.
 *
 * And after the cookie is cleared by user, the previous client ID
 * will lost.
 *
 * The client ID is not cross browsers or machines but cross server.
 */

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = connectionServerModel;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function connectionServerModel($window) {
   function ServerModel() {
      // Server host address.
      this.host = '';

      // An array of supported protocols.
      this.supportedProtocols = ['BLAST'];

      // Launch an appropriate client for the connection protocol
      this.connectionProtocol = 'BLAST';

      // Username
      this.username = '';

      // Domain
      this.domain = '';

      // Token username
      this.tokenUsername = '';

      /*
       * A HWS session identifier.
       * wiki: https://wiki.eng.vmware.com/View/ViewWorkspaceSessionSynchronization
       */
      this.horizonId = '';

      // Reset server model.
      this.reset = function () {
         this.username = '';
         this.domain = '';
         this.tokenUsername = '';
         this.horizonId = '';
      };

      /*
       * load the data from the URL model, should be trigger when the info in
       * the URL is valid as the current connected info.
       */
      this.loadFromURIModel = function (connectionURIModel) {
         var i = void 0,
             key = void 0,
             srcKey = void 0,
             params = void 0,
             keyList = ['username', 'domain', 'horizonId', 'tokenUsername'],
             specialKeyMap = {
            domain: 'domainName',
            username: 'userName'
         };

         if (!connectionURIModel || !connectionURIModel.params) {
            return;
         }
         params = connectionURIModel.params;
         for (i = 0; i < keyList.length; i++) {
            key = keyList[i];
            srcKey = specialKeyMap[key] || key;
            if (!!params[srcKey]) {
               this[key] = params[srcKey];
            }
         }
      };
   }

   var serverModel = new ServerModel();
   // Server host address.
   serverModel.host = $window.location.host;

   return serverModel;
}

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = connectionURIModel;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function connectionURIModel(storageService, usernameUtil, viewClientModel) {
   // URI parameters
   this.params = null;

   // Whether the current URI connection is the same as the previous one.
   this.reuseSession = false;

   /**
    * This function detects whether it's the same user logins to the
    * broker.
    *
    * @param oldHost    Make function params same with Chrome client.
    *    oldHost is not used here for now.
    * @param callback   Use callback to deal with identical result.
    *                   It will make the funtion action the same with
    *    Chrome client.
    */
   this.isIdenticalUser = function (oldHost, callback) {
      // If connectionURIModel.params is null, return.
      if (!this.params) {
         callback(true);
         return;
      }

      if (this._isSwitchingToAnonymous()) {
         callback(false);
         return;
      }

      var userName = this._getUsername(),
          oldUserName = storageService.cookie.read(storageService.cookie.COOKIE_USER_NAME),
          domainName = this.params.domainName,
          oldDomainName = storageService.cookie.read(storageService.cookie.COOKIE_DOMAIN_NAME),
          tokenUsername = this.params.tokenUserName,
          oldTokenUsername = storageService.cookie.read(storageService.cookie.COOKIE_TOKEN_USER_NAME),
          horizonId = this.params.horizonId,
          oldHorizonId = storageService.cookie.read(storageService.cookie.COOKIE_HORIZON_ID);

      /**
       * NOTE: If userName contains domain, then that domain should
       * always be the same with domainName.
       * We have this check in 'connectToBroker' of view-service.js
       */
      if (!!userName && !!oldUserName && !this.usernameEquals(userName, oldUserName) || !this.domainEquals(userName, domainName, oldUserName, oldDomainName) || !!tokenUsername && !!oldTokenUsername && tokenUsername !== oldTokenUsername || !!horizonId && !!oldHorizonId && horizonId !== oldHorizonId) {
         callback(false);
      } else {
         callback(true);
      }
   };

   this._getUsername = function () {
      // Ignore userName if in anonymous mode
      if (this.isAnonymous()) {
         if (this.params.unauthenticatedAccessAccount) {
            return this.params.unauthenticatedAccessAccount;
         }
         return null;
      }

      if (this.params.userName) {
         return this.params.userName;
      }

      return null;
   };

   this._isSwitchingToAnonymous = function () {
      // If previous session is not anonymous one, but the current is.
      return this.isAnonymous() && !viewClientModel.isAnonymousMode;
   };

   /**
    * isHWSession
    *
    * Use the HWS session identifier to detect whether
    * the url is generated by a Workspace or not.
    */
   this.isHWSession = function () {
      return !!this.params && !!this.params.horizonId;
   };

   /**
    * isF5Session
    *
    * Use the F5 session identifier to detect whether
    * the url is generated by a F5 APM server or not.
    */
   this.isF5Session = function () {
      return !!this.params && !!this.params.mid;
   };

   this.isSamlUsed = function () {
      return !!this.params && !!this.params.samlArt;
   };

   this.isAnonymous = function () {
      return !!this.params && !!this.params.unauthenticatedAccessEnabled && this.params.unauthenticatedAccessEnabled.toLowerCase() === 'true';
   };

   this.getSpID = function () {
      if (!!this.params && !!this.params.spID) {
         return this.params.spID;
      }
      return '';
   };

   /**
    * Refer to this page:
    * https://confluence.eng.vmware.com/display/WOR/Horizon+Client+SP+Init+Flow+a.k.a+Fix+Access+Policy+support+in+Horizon
    *
    * Finally we have agreement with vIDM team that we just send the parameter
    * as it is now and they can send them back
    */
   this.generateRelayInfo = function () {
      if (!this.params) {
         return '';
      }
      var relayInfo = '';

      for (var key in this.params) {
         if ((key === 'path' || key === 'action' || key === 'mid' || key === 'args') && !!this.params[key]) {
            relayInfo += key + '=' + encodeURIComponent(this.params[key]) + '&';
         }
      }
      // Cut the final '&'
      if (relayInfo.length >= 1) {
         relayInfo = relayInfo.substr(0, relayInfo.length - 1);
      }

      return relayInfo;
   };

   /**
    * getF5postFix
    *
    * return the mid=XXX string, currently we still not support ISO
    */
   this.getF5postFix = function () {
      if (!this.isF5Session()) {
         return '';
      }
      return "?mid=" + this.params.mid;
   };

   // Case insensitive string compare.
   this.ignoreCaseEquals = function (str1, str2) {
      if (!str1 || !str2) {
         return false;
      }

      return str1.toLowerCase() === str2.toLowerCase();
   };

   this.usernameEquals = function (username1, username2) {
      if (usernameUtil.domainInUsername(username1)) {
         username1 = usernameUtil.getUsername(username1);
      }
      if (usernameUtil.domainInUsername(username2)) {
         username2 = usernameUtil.getUsername(username2);
      }

      return this.ignoreCaseEquals(username1, username2);
   };

   this.domainEquals = function (userName, domainName, oldUserName, oldDomainName) {
      var domainName1 = domainName,
          domainName2 = oldDomainName;
      /**
       * It is possible there is no domainName param in URI, but the
       * username is UPN or domain\username.
       * So if username contains domain info, use it to compare with the
       * other one. If not, then use the domainName param.
       *
       * NOTE: we have domain check in uri-param-validator.js
       * The domain info in username and domainName param should always
       * be the same.
       */
      if (usernameUtil.domainInUsername(userName)) {
         domainName1 = usernameUtil.getDomain(userName);
      }
      if (usernameUtil.domainInUsername(oldUserName)) {
         domainName2 = usernameUtil.getDomain(oldUserName);
      }

      /**
       * Only compare domain when both of them exist.
       * Otherwise assume they are the same
       */
      if (!!domainName1 && !!domainName2) {
         return this.ignoreCaseEquals(domainName1, domainName2);
      }
      return true;
   };

   // Clear URI data.
   this.clear = function (needReuseSession) {
      this.params = null;
      if (needReuseSession === false) {
         this.reuseSession = false;
      }
   };
}

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = osModel;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function osModel() {
   function detectOS(platform) {
      var prefix = "download_rich_client_",
          os = platform || "unknown",
          getOSLiteral = void 0,
          mIsWin32 = false,
          mIsWin64 = false,
          mIsWinMobile = false,
          mIsLinux32 = false,
          mIsLinux64 = false,
          mIsMacOS = false,
          mIsIOS = false,
          mIsAndroid = false,
          mIsChromeOS = false,

      /*
       * Localization Map
       *   return the local key of the respective OS:
       *
       * win32 - os_win32
       * win64 - os_win64
       * winphone - os_winphone
       * linux32 - os_linux32
       * linux64 - os_linux64
       * mac - os_mac
       * android - os_android
       * ios - os_ios
       * chromeos - os_chromeos
       * unknown - os_unknown
       */
      osNames = {
         win32: 'os_win32',
         win64: 'os_win64',
         winmobile: 'os_winmobile',
         linux32: 'os_linux32',
         linux64: 'os_linux64',
         mac: 'os_mac',
         android: 'os_android',
         ios: 'os_ios',
         chromeos: 'os_chromeos',
         unknown: 'os_unknown'
      };

      switch (os) {
         case 'win32':
            mIsWin32 = true;
            break;
         case 'win64':
            mIsWin64 = true;
            break;
         case 'winmobile':
            mIsWinMobile = true;
            break;
         case 'linux32':
            mIsLinux32 = true;
            break;
         case 'linux64':
            mIsLinux64 = true;
            break;
         case 'mac':
            mIsMacOS = true;
            break;
         case 'android':
            mIsAndroid = true;
            break;
         case 'ios':
            mIsIOS = true;
            break;
         case 'chromeos':
            mIsChromeOS = true;
            break;
         default:
            break;
      }

      getOSLiteral = function getOSLiteral(os) {
         return prefix + (osNames[os] || osNames.unknown);
      };

      /*
       * OS:
       *   win32, win64, linux32, linux64, mac, android, ios, chromeos, unknown
       */
      return {
         os: os,
         osLiteral: getOSLiteral(os),
         mIsWin32: mIsWin32,
         mIsWin64: mIsWin64,
         mIsWinMobile: mIsWinMobile,
         mIsLinux32: mIsLinux32,
         mIsLinux64: mIsLinux64,
         mIsMacOS: mIsMacOS,
         mIsIOS: mIsIOS,
         mIsAndroid: mIsAndroid,
         mIsChromeOS: mIsChromeOS
      };
   }

   return detectOS;
}

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = viewClientModel;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function viewClientModel($window, BaseViewClientModel, osModel, clientID, storageService) {

   var clientInfo = void 0,
       clientModel = new BaseViewClientModel(),
       ua = $window.navigator.userAgent.toLowerCase(),
       vs = $window.navigator.appVersion.toString(),
       inited = false,
       failToInited = false,
       onInitCallback = null;

   // Architecture of client
   clientModel.arch = 'browser';
   // Product version
   clientModel.version = "4.6.0";
   // Client ID
   clientModel.clientID = clientID;

   clientModel.ipAddress = '0.0.0.0';

   clientModel.buildNum = "1";
   // Installer URL of the native client on this specific OS
   clientModel.nativeInstallerLink = 'https://www.vmware.com/go/viewclients';

   clientModel.initClientInfo = function (data) {
      if (!!data.clientIPAddress) {
         this.ipAddress = data.clientIPAddress;
         this.machineName = data.clientIPAddress.replace(/\./g, '-') + '-' + this.browserName;
      }
      if (!!data.logLevel && !isNaN(data.logLevel)) {
         _jscdkLogger2.default.setLogLevel(data.logLevel);
         this.logLevel = data.logLevel;
      }

      if (!!data.rebrandName) {
         this.rebrandName = data.rebrandName;
         this.rebrandEnable = true; // used by BlastDesktopCtrl
      } else {
         this.rebrandEnable = false;
      }

      if (!!data.rebrandHelpUrl) {
         this.rebrandHelpUrl = data.rebrandHelpUrl;
      }

      if (!!data.rebrandGotoForumUrl) {
         this.rebrandGotoForumUrl = data.rebrandGotoForumUrl;
      }

      if (!!data.acceptLanguage) {
         this.acceptLanguage = data.acceptLanguage;
         // Set language for jscdk
         _util2.default.l10N.setLocaleAndLoad(data.acceptLanguage);
      }

      /*
       * Client OS platform, could be:
       * win32, win64, winmobile, linux32, linux64, mac,
       * android, ios, chromeos or unknown
       */
      if (!!data.os) {
         _angular2.default.extend(this, osModel(data.os));
      }

      /*
       * User is able to customize native installers download links
       * in the configuration file.
       *
       * If no download links are customized in the configuration file,
       * use the default download link: https://www.vmware.com/go/viewclients
       */
      if (!!data.installerLink) {
         this.nativeInstallerLink = data.installerLink;
      }

      this.contextPath = data.contextPath;
      inited = true;
      if (typeof onInitCallback === "function") {
         onInitCallback();
      }
   };

   clientModel.onFailReadingClientInfo = function () {
      failToInited = true;
      if (typeof onInitCallback === "function") {
         onInitCallback();
      }
   };

   clientModel.onReady = function (callback) {
      /**
       * Since VADC don't have info.jsp, and BSG is only allow access using
       * specified address for info.jsp, it's possible of failing to get the
       * info.jsp. When that happens, the client will continute for the initing
       * as before.
       */
      if (inited || failToInited) {
         callback();
      } else {
         onInitCallback = callback;
      }
   };

   clientInfo = storageService.cookie.read('clientInfo');
   if (!!clientInfo) {
      clientModel.initClientInfo(JSON.parse(clientInfo));
   } else {
      _jscdkLogger2.default.error('Failed to get locale and product info in cookies.');

      // for grunt server task, in clientModel case, the local
      // http server does not set cookie
      // Request locale and product info from the server.
      _jquery2.default.ajax({
         type: 'GET',
         url: '../info.jsp',
         dataType: 'json',
         async: true,
         cache: false,
         success: function success(data) {
            _jscdkLogger2.default.debug('Request locale and product info ' + 'from the server : ' + JSON.stringify(data));
            clientModel.initClientInfo(data);
         },
         error: function error() {
            _jscdkLogger2.default.error('Request locale and product ' + 'info from the server failed.');
            clientModel.onFailReadingClientInfo();
         }
      });
   }

   // Detect browser version.
   // the browser and version detection copied from original code,
   // but it's better that we can have a browser service to do this job
   clientModel.mIsIE = ua.indexOf('msie') > -1;
   clientModel.mVersionIE = clientModel.mIsIE ? parseInt(vs.slice(vs.indexOf('MSIE ') + 'MSIE '.length).split(';')[0], 10) : null;

   /*
    * The user-agent string for Internet Explorer 11 looks like:
    * 'mozilla/5.0 (windows nt 6.1; wow64; trident/7.0; rv:11.0) like gecko'.
    * It has removed 'MSIE' token. Detect 'trident' instead.
    */
   if (!clientModel.mIsIE) {
      clientModel.mIsIE = ua.indexOf('trident') > -1;
      clientModel.mVersionIE = clientModel.mIsIE ? /rv[:\s]([\w.]+)/.exec(vs) : null;
      clientModel.mVersionIE = clientModel.mVersionIE ? clientModel.mVersionIE[1] : null;
   }

   /*
    * The user-agent string for Internet Explorer 12/Edge looks like:
    * 'Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko)
    * Chrome/39.0.2171.71 Safari/537.36 Edge/12.0'.
    * Detect 'Edge' here.
    */
   if (!clientModel.mIsIE) {
      clientModel.mIsIE = ua.indexOf('edge') > -1;
      clientModel.mVersionIE = clientModel.mIsIE ? parseFloat(ua.slice(ua.indexOf('edge')).split('/')[1].split(' ')[0]) : null;
   }

   // clientModel version is * 100 (e.g. '533' instead of 5.3.3)
   clientModel.mIsWebKit = ua.indexOf('applewebkit') > -1;
   clientModel.mVersionWebKit = clientModel.mIsWebKit ? parseInt(ua.slice(ua.indexOf('applewebkit/') + 'applewebkit/'.length), 10) : null;

   clientModel.mIsOpera = ua.indexOf('opera/') > -1;
   clientModel.mVersionOpera = clientModel.mIsOpera ? parseInt(ua.slice(ua.indexOf('Opera/') + 'Opera/'.length), 10) : null;

   if (!clientModel.mIsIE && !clientModel.mIsOpera && ua.indexOf('applewebkit') !== -1) {
      clientModel.mIsChrome = ua.indexOf('chrome') > -1;
      clientModel.mVersionChrome = clientModel.mIsChrome ? parseFloat(ua.slice(ua.indexOf('chrome')).split('/')[1].split(' ')[0]) : null;
   } else {
      clientModel.mIsChrome = false;
   }

   // See:
   // https://developer.mozilla.org/en/Gecko_user_agent_string_reference
   // Also, Webkit says it's 'like Gecko', so we get a false positive
   // here.
   clientModel.mIsGecko = !clientModel.mIsWebKit && ua.indexOf('gecko') > -1;
   clientModel.mVersionGecko = clientModel.mIsGecko ? parseFloat(ua.slice(ua.indexOf('rv:') + 'rv:'.length)) : null;

   // Detect IE9+ mobile versions.
   clientModel.mIsIEMobile = ua.indexOf('IEMobile') > -1 && clientModel.mVersionIE > 8;

   clientModel.mIsIPhone = ua.indexOf('iphone') > -1;

   if (clientModel.mIsIOS) {
      // even chrome on iOS has 'safari' in user agent,
      // but chrome uses 'crios'.
      clientModel.mIsIOSSafari = ua.indexOf('safari') > -1 && ua.indexOf('crios') === -1;
   } else {
      clientModel.mIsIOSSafari = false;
   }

   if (clientModel.mIsAndroid) {
      clientModel.browserName = 'An';
   } else if (clientModel.mIsIEMobile) {
      clientModel.browserName = 'IEM';
   } else if (clientModel.mIsIOS) {
      clientModel.browserName = 'IOS';
   } else if (clientModel.mIsIE) {
      // mobile browsers should not enter here or after
      clientModel.browserName = 'IE';
   } else if (clientModel.mIsChrome) {
      clientModel.browserName = 'Chr';
   } else if (clientModel.mIsWebKit) {
      clientModel.browserName = 'Saf';
   } else if (clientModel.mIsOpera) {
      clientModel.browserName = 'Op';
   } else if (clientModel.mIsGecko) {
      // webkit will not enter here
      clientModel.browserName = 'FF';
   } else {
      clientModel.browserName = 'UNK';
   }

   return clientModel;
}

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = baseViewService;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function baseViewService($location, $timeout, $window, viewClientModel, credCleanService) {
   this.locationChange = false;

   this.changeLocation = function (value) {
      var _this = this;

      $timeout(function () {
         _this.locationChange = true;
         $location.path(value);
      });
   };

   this.gotoPortal = function () {
      $window.location.href = $location.protocol() + '://' + $location.host() + ':' + $location.port() + viewClientModel.contextPath;
   };

   this.goBackToLauncherFromDesktop = function () {
      // TODO remove it when we don't need to redirect for back to launcher
      credCleanService.setFlagBeforePageJumping();
      $window.location.href = './index.html';
   };

   this.isBackInLauncher = function (next, current) {
      var nextHash = this._getHashFromURL(next),
          currentHash = this._getHashFromURL(current);
      return currentHash === '#/launchitems' && nextHash !== '#/blastdesktop';
   };

   this.isBackFromDesktop = function (next, current) {
      /**
       * If the next hash is not #/desktop, we will treat it as back
       * button click
       */
      var nextHash = this._getHashFromURL(next),
          currentHash = this._getHashFromURL(current);
      return currentHash === '#/desktop' && nextHash !== '#/desktop';
   };

   this.isJumpingToDesktop = function (next, current) {
      var nextHash = this._getHashFromURL(next),
          currentHash = this._getHashFromURL(current);
      return currentHash === '#/blastdesktop' && nextHash === '#/desktop';
   };

   this._getHashFromURL = function (url) {
      if (!url) {
         return '';
      }

      var str = decodeURIComponent(url);
      var loc = str.indexOf('#');
      if (loc < 0) {
         return '';
      }
      return str.substr(loc);
   };

   // in launcher page, in the url tab, delete launchitems and refresh page,
   this.isRefreshingLauncher = function (next, current) {
      return current.indexOf('#/launchitems') > 0 && next.indexOf('#/blastdesktop') <= 0;
   };
}

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = brokerSessionStorageService;
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * brokerSessionStorage-service.js --
 *
 * utility serive to provide API for maintain a storage live as long as the
 * broker session and shared among tabs.
 */

function brokerSessionStorageService($window, storageService) {
   // private:
   var getFullKey = void 0,
       isManagedKey = void 0,
       storage = void 0,
       keyHeader = 'BSS_'; //'broker session storage'

   try {
      /**
       * Try local storage first.
       * We don't have good way to mock local storage right now.
       * So there is no UT for code below.
       */
      storage = $window.localStorage;
      storage.setItem('testKey123', 'foobar');
      storage.removeItem('testKey123');
   } catch (err) {
      storage = storageService.localStorage;
   }

   getFullKey = function getFullKey(key) {
      return keyHeader + key;
   };

   isManagedKey = function isManagedKey(itemKey) {
      // compatible with very short input
      return itemKey.substring(0, keyHeader.length) === keyHeader;
   };

   this.read = function (key) {
      var fullKey = void 0,
          content = void 0;

      fullKey = getFullKey(key);
      content = storage.getItem(fullKey);
      /**
       * If the storage here is referred to storageService.localStorage,
       * then it is actually stored in cookie. And it is possible the
       * return value is ''. See the getItem function in
       * storage-service.js.
       *
       * However JSON.parse('') always throw error. So we should return
       * null in this case
       */
      try {
         return JSON.parse(content);
      } catch (e) {
         return null;
      }
   };

   this.write = function (key, value) {
      var fullKey = void 0,
          content = JSON.stringify(value);

      fullKey = getFullKey(key);
      storage.setItem(fullKey, content);
   };

   this.exist = function (key) {
      var value = this.read(key);
      return value !== null;
   };

   this.clear = function () {
      var i = void 0,
          itemkey = void 0;

      for (i = 0; i < storage.length; i++) {
         itemkey = storage.key(i);
         if (isManagedKey(itemkey)) {
            storage.removeItem(itemkey);
         }
      }
   };
}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = credCleanService;

var _jscdkClient = __webpack_require__(2);

function credCleanService($window, userGlobalPref, viewClientModel) {
   this._isPageJump = false;

   this.init = function () {
      var _this = this;

      if (!viewClientModel.credentialCleanup) {
         return;
      }

      this._isPageJump = false;
      $window.addEventListener('beforeunload', function () {
         _this._actionForPageTearDown();
      });
      $window.addEventListener('unload', function () {
         // Do nothing here yet
      });
   };

   this._actionForPageTearDown = function () {
      if (!this._isPageJump) {
         this._sendLogoutAction();
      }
   };

   this._sendLogoutAction = function () {
      var uiController = _jscdkClient.globalArray['uiController'];
      if (!!uiController) {
         uiController.invokeJSCDK({
            method: 'LogoutFromBroker',
            prefData: userGlobalPref.toFlatFormat(),
            async: false,
            timeout: 2000
         });
      }
   };

   this.setFlagBeforePageJumping = function () {
      // This function can be removed after launcher/desktop page merged
      this._isPageJump = true;
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = dpiService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function dpiService($window, constants, userGlobalPref) {
   var logger = {
      info: function info(msg) {
         _jscdkLogger2.default.info('[dpiService] ' + msg);
      },
      error: function error(msg) {
         _jscdkLogger2.default.error('[dpiService] ' + msg);
      },
      debug: function debug(msg) {
         _jscdkLogger2.default.debug('[dpiService] ' + msg);
      }
   };

   return {
      getDPI: function getDPI() {
         var dpi = void 0;
         if (userGlobalPref.getPrefData().enableDPISync !== 'true') {
            dpi = parseFloat(constants.DPI_100_PERCENT * $window.devicePixelRatio).toString();
         } else {
            logger.info("DPI Sync is disabled.  " + "Ignore the real client DPI");
            dpi = '96';
         }
         logger.info("System DPI is " + dpi);
         return dpi;
      }
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.localize = localize;
exports.i18n = i18n;
exports.translate = translate;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function localize($window, viewClientModel, $rootScope) {

   /**
    * Deals with some of the L10N features like using display text based
    * on user's locale.
    */
   var locale = {

      // Mapping of supported locales to the corresponding JSON file.
      supportedLocale: {
         'en': 'en',
         'es': 'es',
         'de': 'de',
         'fr': 'fr',
         'ja': 'ja',
         'ko': 'ko',
         'zh': 'zh-CN',
         'en-us': 'en',
         'es-es': 'es',
         'de-de': 'de',
         'fr-fr': 'fr',
         'ja-jp': 'ja',
         'ko-kr': 'ko',
         'zh-cn': 'zh-CN',
         'zh-hans': 'zh-CN',
         'zh-hant': 'zh-TW',
         'zh-tw': 'zh-TW',
         'zh-hk': 'en',
         'zh-mo': 'en',
         'zh-hans-hk': 'en',
         'zh-hant-hk': 'en',
         'zh-hans-mo': 'en',
         'zh-hant-mo': 'en'
      },

      // Locale to be used during translation. Default is English.
      locale: 'en',

      // JSON object containing the translated text.
      translatedTable: null,

      // Is localization server already load resource from server?
      localizationReady: false,

      // Get Locale info
      getLocale: function getLocale() {
         return this.locale;
      },

      // Set the locale and load the corresponding JSON translation table.
      setLocaleAndLoad: function setLocaleAndLoad(acceptLanguage) {
         var _this = this;

         var url = void 0,
             selectedLocale = void 0;

         if (!acceptLanguage) {
            // The language version of the platform
            acceptLanguage = $window.navigator.language || $window.navigator.userLanguage;
         }

         if (!!acceptLanguage) {
            // Determine the corresponding JSON translation file.
            selectedLocale = this.getBestLocale(acceptLanguage);
            if (!!selectedLocale) {
               this.locale = selectedLocale;
            }
         }

         _jscdkLogger2.default.debug('Load translation table for locale: ' + this.locale);

         /**
          * Load language JSON file according to browser's locale setting
          * using AJAX synchronous call. TODO: change to server side code
          */
         url = './locale/' + this.locale + '.json?v=' + "1";
         _jquery2.default.ajax({
            type: 'GET',
            url: url,
            dataType: 'json',
            async: false,
            cache: false,
            success: function success(data) {
               if (!!data) {
                  _this.translatedTable = data;
               } else {
                  _jscdkLogger2.default.error('Invalid translation data from url: ' + url);
               }

               _this.localizationReady = true;
               var lang = _this.getHTMLLang(_this.locale);
               (0, _jquery2.default)('html').attr("lang", lang);
               $rootScope.$emit("model:localizationReady");
            },
            error: function error(jqXHR, textStatus, errorThrown) {
               _jscdkLogger2.default.error('Failed to load translation data, url: ' + url + ', status: ' + textStatus + ', errorThrown: ' + errorThrown);
            }
         });
      },

      // set html lang attribute to fix accessibility
      getHTMLLang: function getHTMLLang(locale) {
         //https://www.w3schools.com/tags/ref_language_codes.asp
         if (locale === 'zh-CN') {
            locale = 'zh-Hans';
         }
         if (locale === 'zh-TW') {
            locale = 'zh-Hant';
         }

         return locale;
      },

      translate: function translate(msgid) {
         var translatedStr = void 0,
             i = void 0,
             args = [];

         // Skip the first parameter for it is the key.
         for (i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
         }
         /**
          * If the translated msgid exists, return the translated string,
          * else return the original string.
          */
         if (!!this.translatedTable && !!this.translatedTable[msgid]) {
            /**
             * The tool po2json used for converting po to json puts the
             * translated string to an array and the translated result is
             * in the second element.
             */
            translatedStr = this.translatedTable[msgid];
         } else {
            translatedStr = msgid;
         }

         if (args) {
            // If args, replace placeholders with the args values passed.
            if (_jquery2.default.isArray(args)) {
               // Iterate & replace placeHolders matching number of input args.
               for (i = 0; i < args.length; i++) {
                  translatedStr = translatedStr.replace("{" + i + "}", args[i]);
               }
            } else {
               // Replace the first place holder {0}
               translatedStr = translatedStr.replace("{0}", args);
            }
         }

         return translatedStr;
      },

      /**
       * For a given list of desired locales, determine which language
       * out of our supported languages we should display.
       */
      getBestLocale: function getBestLocale(acceptLanguage) {
         var matchedLocale = null,
             matchedRank = 0,
             accepted = void 0,
             i = void 0,
             kv = void 0,
             parts = void 0,
             thisRank = void 0,
             localeAndRank = void 0;

         if (!acceptLanguage) {
            return null;
         }

         /**
          * For each of the languages in the acceptLanguage param, see
          * if getSupportedLocale likes it. If so, set the currently
          * preferred language and its rank ('q=' value.) Do this for
          * all languages.
          */
         accepted = acceptLanguage.split(',');
         for (i = 0; i < accepted.length; i++) {
            if (accepted[i].indexOf('*') >= 0) {
               // Ignore the wildcard.
               continue;
            }

            /*
             * There may be a 'q=' section with a rank for this language.
             * Set rank value to 1 by default.
             */
            thisRank = 1;
            parts = _jquery2.default.trim(accepted[i]).split(';', 2);
            if (parts.length === 2) {
               kv = parts[1].split('=', 2);
               if (kv[0] === 'q' && kv.length === 2) {
                  thisRank = parseFloat(kv[1]);
               }
            } else if (parts.length < 1) {
               continue;
            }

            /**
             * If this locale entry is supported, compare its rank to the
             * highest matched rank thus far.
             */
            localeAndRank = this.getSupportedLocale(parts[0], thisRank);
            if (!!localeAndRank) {
               if (localeAndRank[1] > matchedRank) {
                  matchedLocale = localeAndRank[0];
                  matchedRank = localeAndRank[1];
               }
            }
         }

         return matchedLocale;
      },

      /**
       * For a given locale, determine the best supported localization
       * fit for that language using the supportedLocale dictionary.
       */
      getSupportedLocale: function getSupportedLocale(locale, returnRank) {
         var langCode = void 0,
             selectedLocale = void 0,
             specifiers = void 0;

         // Convert to lower-case.
         locale = locale.toLowerCase();

         if (this.supportedLocale.hasOwnProperty(locale)) {
            // The full locale is specifically supported.
            selectedLocale = this.supportedLocale[locale];
         } else {
            specifiers = locale.split('-');
            if (specifiers.length > 2) {
               // Locale string like 'zh-hant' or 'zh-hant'.
               langCode = specifiers[0] + '-' + specifiers[1];
               if (this.supportedLocale.hasOwnProperty(langCode)) {
                  // The language is zh-hans or zh-hant
                  selectedLocale = this.supportedLocale[langCode];
               }
            }
            if (!selectedLocale && specifiers.length > 0) {
               // Locale string like 'en-us' or 'zh-tw'.
               langCode = specifiers[0];
               if (this.supportedLocale.hasOwnProperty(langCode)) {
                  /**
                   * The language is supported, but not in the desired
                   * locale, the request is generic (xx instead of xx-YY)
                   */
                  selectedLocale = this.supportedLocale[langCode];
               }
            }
         }

         if (!!selectedLocale) {
            return [selectedLocale, returnRank];
         }

         return null;
      }
   };

   locale.setLocaleAndLoad(viewClientModel.acceptLanguage);

   return locale;
}

function i18n(localize) {
   return function (input) {
      return localize.translate.apply(localize, arguments);
   };
}

function translate(localize) {
   return localize.translate.bind(localize);
}

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = multiSiteService;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function multiSiteService($window) {
   /**
    * In normal case, this function will redirect client to the new server.
    * However, if the params are illegal, the function will return, and
    * client continues the previous action.
    *
    * @param redirectProperties
    */
   this.redirectAndStartSession = function (redirectProperties) {
      var serverAddress = redirectProperties['server-address'],
          desktopName = redirectProperties['desktop-name'],
          SAMLart = redirectProperties['saml-art'],
          desktopProtocol = redirectProperties['desktop-protocol'];

      if (!serverAddress || !desktopName || !SAMLart || desktopProtocol.toLowerCase() !== 'blast') {
         // Shared module doesn't have logger
         throw 'Redirect properties are not working for HTML Access!';
      }

      /**
       * DaaS desktop URL format:
       * https://ip or domain/appblast/webclient/index.html
       * https://ip or domain/appblast/desktop/index.html
       *
       * We don't get desktop ID in this case, so we use desktop name.
       */
      $window.document.location.href = 'https://' + serverAddress + '/appblast/webclient/index.html?' + 'desktopName=' + encodeURIComponent(desktopName) + '&SAMLart=' + encodeURIComponent(SAMLart) + '&action=start-session';
   };
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = prefData;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function prefData() {
   var data = {
      favorites: [], //favorites is an array
      isHighResolution: '',
      useMacOSXKeyMappings: '',
      enableWindowsKey: false,

      reset: function reset() {
         this.favorites = [];
         this.isHighResolution = '';
         this.useMacOSXKeyMappings = '';
         this.enableWindowsKey = false;
         this.timezoneSync = '';
      },

      equals: function equals(data) {
         try {
            if (this.favorites.sort().toString() === data.favorites.sort().toString() && this.isHighResolution === data.isHighResolution && this.useMacOSXKeyMappings === data.useMacOSXKeyMappings && this.enableWindowsKey === data.enableWindowsKey && this.timezoneSync === data.timezoneSync) {
               return true;
            } else {
               return false;
            }
         } catch (e) {
            return false;
         }
      },

      toJSON: function toJSON() {
         var r = {};

         _angular2.default.forEach(this, function (value, index) {
            if (typeof value !== 'function') {
               if (index === 'favorites') {
                  _angular2.default.forEach(value, function (value, index) {
                     this['favorite' + index] = value;
                  }, r);
               } else {
                  this[index] = value;
               }
            }
         }, r);
         return r;
      }
   };

   return data;
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

/**
 * A temp service before the merge of blast into webClient.
 *
 * Only using session storage/storage.local here to improve the security.
 * And for storage.local, I add a clearup when closing the extension.(TODO)
 *
 * usage:
 * 1) include safeStorageService into dependency
 * 2) safeStorageService.setItem(itemName, item, privateKey) to storage info,
 *    item can be any type
 * 3) safeStorageService.getItem(itemName, asyncCallback, privateKey) to get
 *    stored info back, the retirved item will be identical to the one used
 *    to call setItem. and it will be presented in the async way as the
 *    parameter of asyncCallback.
 */

exports.default = safeStorageService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function safeStorageService($window) {
   var itemOperators = {},
       keyHeader = 'SSS_',
       managedKeyPool = {},
       enabled = false;

   // Detect whether the browser supports sessionStorage.
   function isSessionStorageAllowed() {
      try {
         $window.sessionStorage.setItem('testKey', true);
         $window.sessionStorage.removeItem('testKey');
         return true;
      } catch (e) {
         _jscdkLogger2.default.error('This browser does not support sessionStorage. ' + e);
         return false;
      }
   }

   function init() {
      // test typeof for chrome could be never declared
      if (!!$window || !!$window.sessionStorage) {
         if (!isSessionStorageAllowed()) {
            _jscdkLogger2.default.error('the session storage is not valid');
            return;
         }
         itemOperators.setItem = function (key, value) {
            $window.sessionStorage.setItem(key, value);
         }; //do this to avoid illegal invocation
         itemOperators.getItem = function (key, callback) {
            callback($window.sessionStorage.getItem(key));
         };
         itemOperators.removeItem = null; //if needed, can be
         // window.sessionStorage.removeItem;
         enabled = true;
         _jscdkLogger2.default.debug('safeStorageService is configed for webClient');
      } else {
         _jscdkLogger2.default.error('the safe storage can\'t be inited properly');
      }
   }

   init();

   function encode(data, privateKey) {
      return data; // refer the encryptor here
   }

   function decode(encodedData, privateKey) {
      return encodedData; // refer the decryptor here
   }

   /**
    * this function is to encode and store info into proper place
    *
    * @key:              string,
    *     the name of the recorded item
    * @value:            any stringfiable type,
    *     the data that need to be stored
    * #privateKeyString: any unempty string or null
    *    the string that used to encode the data, the longer the better
    *    but slower to decode. it could be token+sessionID.
    */
   this.setItem = function (key, value, privateKeyString) {
      var encodedValue = encode(JSON.stringify(value), privateKeyString),
          extendedkey = keyHeader + key;

      if (!enabled) {
         return false;
      }
      itemOperators.setItem(extendedkey, encodedValue);
      managedKeyPool[extendedkey] = true;
      return true;
   };

   /**
    * this function is to get and decode info from proper place
    *
    * @key:              string,
    *     the name of the target item
    * @callback:         function,
    *     the asyc callback function that use the readed data, the data
    *    is
    *     identical to the one stored in when calling setItem.
    * #privateKeyString: any unempty string or null,
    *     should be the same one used for encoding, and in future it can
    *     specify which type of encoding is used or even pass in a
    *    decoder.
    */
   this.getItem = function (key, callback, privateKeyString, callbackParam) {
      var extendedkey = keyHeader + key,
          callbackWithDecodedData = function callbackWithDecodedData(data) {
         var decodedData = void 0;

         if (typeof data === 'string' || data === null) {
            decodedData = decode(data, privateKeyString);
         } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
            decodedData = decode(data[extendedkey], privateKeyString);
         } else {
            _jscdkLogger2.default.debug('error: the getItem retrive a unknown type of data, will not call back');
            return;
         }

         if (!!decodedData) {
            callback(JSON.parse(decodedData), callbackParam);
         } else {
            callback(null, callbackParam);
         }
      };

      if (!enabled) {
         callback(null, callbackParam);
         return;
      }
      itemOperators.getItem(extendedkey, callbackWithDecodedData);
   };

   /**
    * a function to delete all managed items when closing chromeClient.
    *
    * currently dependen on the header-controller for its calling is in
    * the function 'exitHorizonClient' there.
    */
   this.clearAllManagedItems = function () {
      var key = void 0,
          removeItemCallback = function removeItemCallback() {
         _jscdkLogger2.default.debug('remove ' + key + 'from safe-storage');
      };
      for (key in managedKeyPool) {
         if (managedKeyPool.hasOwnProperty(key) && !!itemOperators.removeItem) {
            itemOperators.removeItem(key, removeItemCallback);
         }
      }
      managedKeyPool = {};
   };
}

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = storageService;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function storageService($window) {
   var _this = this;

   this.cookie = {
      // A delimiter thats not part of the userName / domainName.
      COOKIE_VALUE_DELIMITER: '/',

      // Cookie name to store userName value.
      COOKIE_USER_NAME: 'UID',

      // Cookie name to store tokenName value.
      COOKIE_TOKEN_USER_NAME: 'TID',

      // Cookie name to store domainName value.
      COOKIE_DOMAIN_NAME: 'DID',

      // Cookie name to store idle-timeout value.
      COOKIE_IDLE_TIMEOUT: 'ITO',

      // Cookie name to store user-activity-interval value.
      COOKIE_SEND_TIME_INTERVAL: 'STI',

      // Cookie name to store horizon ID value.
      COOKIE_HORIZON_ID: 'HID',

      /**
       * Create a cookie of name/value pair, which is permanent.
       *
       * @param name    cookie name
       * @param value   cookie value
       * @param days    expiration days, optional
       */
      write: function write(name, value, days) {
         var expires = '',
             date = new Date(),
             data = void 0;

         if (typeof days === 'number') {
            date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
            expires = '; expires=' + date.toGMTString();
         }

         data = encodeURIComponent(_this.base64.encode(value));
         $window.document.cookie = name + '=' + data + expires + '; path=/; domain=' + $window.location.host + '; secure';
      },

      /**
       * Read a cookie of specified name
       *
       * @param name cookie name
       * @return cookie value string
       */
      read: function read(name) {
         var cookies = $window.document.cookie.split(/;\s*/),
             i = void 0;

         name += '=';
         for (i = cookies.length - 1; i >= 0; i--) {
            if (cookies[i].indexOf(name) === 0) {
               return _this.base64.decode(decodeURIComponent(cookies[i].replace(name, '')));
            }
         }

         return '';
      },

      /**
       * Delete a cookie of specified name
       *
       * @param name cookie name
       */
      clear: function clear(name) {
         // Expire and remove the value.
         $window.document.cookie = name + '=; expires=Thu, 01-Jan-70 00:00:01 GMT;' + '; path=/; domain=' + $window.location.host + '; secure';
      },

      /**
       * Clear session cookies set by the client.
       */
      clearSessionCookies: function clearSessionCookies() {
         this.clear(this.COOKIE_USER_NAME);
         this.clear(this.COOKIE_TOKEN_USER_NAME);
         this.clear(this.COOKIE_DOMAIN_NAME);
         this.clear(this.COOKIE_IDLE_TIMEOUT);
         this.clear(this.COOKIE_SEND_TIME_INTERVAL);
         this.clear(this.COOKIE_HORIZON_ID);
      },

      /**
       * isEnabled
       *
       *    Check whether the browser cookie is enabed
       *
       * @return true if the browser cookie is enabled; false otherwise.
       */
      isEnabled: function isEnabled() {
         var cookieEnabled = $window.navigator.cookieEnabled,
             test = void 0;

         if (typeof cookieEnabled === 'undefined') {
            // Try to write a cookie which expires in 10 seconds.
            test = 'test=' + new Date.getTime();
            $window.document.cookie = test + '; max-age=10; domain=' + $window.location.host + '; secure';

            // Check wether the cookie is set successfully.
            if ($window.document.cookie.indexOf(test) > -1) {
               cookieEnabled = true;
            }
         }

         return cookieEnabled;
      }
   };

   this.base64 = {
      /* Convert data (an array of integers) to a Base64 string. */
      toBase64Table: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',

      /**
       * function encode
       *
       *    Take an integer array and return a base64 encoded string.
       *
       * @param data Original string.
       * @return A base64 encoded string.
       */
      encode: function encode(data) {
         var o1 = void 0,
             o2 = void 0,
             o3 = void 0,
             h1 = void 0,
             h2 = void 0,
             h3 = void 0,
             h4 = void 0,
             bits = void 0,
             r = void 0,
             chrTable = _this.base64.toBase64Table.split(''),
             result = '',
             i = 0,
             ac = 0,
             tmpArray = [];

         if (!data) {
            return data;
         }

         if (typeof $window.btoa === 'function') {
            // Encode via browser's native Base64 encode function.
            // Avoid Character Out Of Range exception when dealing with a
            // Unicode string.
            return $window.btoa(unescape(encodeURIComponent(data)));
         }

         data = _this.utf8.encode(data);
         do {
            // pack three octets into four hexets
            o1 = data.charCodeAt(i++);
            o2 = data.charCodeAt(i++);
            o3 = data.charCodeAt(i++);

            bits = o1 << 16 | o2 << 8 | o3;

            h1 = bits >> 18 & 0x3f;
            h2 = bits >> 12 & 0x3f;
            h3 = bits >> 6 & 0x3f;
            h4 = bits & 0x3f;

            // use hexets to index into b64, and append result to encoded
            // string.
            tmpArray[ac++] = chrTable[h1] + chrTable[h2] + chrTable[h3] + chrTable[h4];
         } while (i < data.length);

         result = tmpArray.join('');

         r = data.length % 3;

         return (r ? result.slice(0, r - 3) : result) + '==='.slice(r || 3);
      },

      /**
       * function decode
       *
       *    Decode a base64 encoded string to its original data.
       *
       * @param data A base64 encoded string.
       * @return decoded data.
       */
      decode: function decode(data) {
         var o1 = void 0,
             o2 = void 0,
             o3 = void 0,
             h1 = void 0,
             h2 = void 0,
             h3 = void 0,
             h4 = void 0,
             bits = void 0,
             b64 = _this.base64.toBase64Table,
             i = 0,
             ac = 0,
             result = '',
             tmpArray = [];

         if (!data) {
            return data;
         }

         data += '';

         if (typeof $window.atob === 'function') {
            // Decode via browser's native Base64 decode function.
            // Avoid Character Out Of Range exception when dealing with a
            // Unicode string.
            return decodeURIComponent(escape(window.atob(data)));
         }

         do {
            h1 = b64.indexOf(data.charAt(i++));
            h2 = b64.indexOf(data.charAt(i++));
            h3 = b64.indexOf(data.charAt(i++));
            h4 = b64.indexOf(data.charAt(i++));

            bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

            o1 = bits >> 16 & 0xff;
            o2 = bits >> 8 & 0xff;
            o3 = bits & 0xff;

            if (h3 === 64) {
               tmpArray[ac++] = String.fromCharCode(o1);
            } else if (h4 === 64) {
               tmpArray[ac++] = String.fromCharCode(o1, o2);
            } else {
               tmpArray[ac++] = String.fromCharCode(o1, o2, o3);
            }
         } while (i < data.length);

         result = tmpArray.join('');

         return _this.utf8.decode(result);
      }
   };

   this.utf8 = {
      /*
       * UTF-8 encoding
       *
       * @param string encode string
       */
      encode: function encode(string) {
         var utftext = '',
             i = void 0,
             c = void 0;

         if (!string) {
            return '';
         }

         string = string.replace(/\r\n/g, '\n');
         for (i = 0; i < string.length; i++) {
            c = string.charCodeAt(i);

            if (c < 128) {
               utftext += String.fromCharCode(c);
            } else if (c > 127 && c < 2048) {
               utftext += String.fromCharCode(c >> 6 | 192);
               utftext += String.fromCharCode(c & 63 | 128);
            } else {
               utftext += String.fromCharCode(c >> 12 | 224);
               utftext += String.fromCharCode(c >> 6 & 63 | 128);
               utftext += String.fromCharCode(c & 63 | 128);
            }
         }

         return utftext;
      },

      /*
       * UTF-8 decoding
       *
       * @param utftext decode string
       */
      decode: function decode(utftext) {
         var string = '',
             i = 0,
             c = void 0,
             c2 = void 0,
             c3 = void 0;

         if (!utftext) {
            return '';
         }

         while (i < utftext.length) {
            c = utftext.charCodeAt(i);

            if (c < 128) {
               string += String.fromCharCode(c);
               i++;
            } else if (c > 191 && c < 224) {
               c2 = utftext.charCodeAt(i + 1);
               string += String.fromCharCode((c & 31) << 6 | c2 & 63);
               i += 2;
            } else {
               c2 = utftext.charCodeAt(i + 1);
               c3 = utftext.charCodeAt(i + 2);
               string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
               i += 3;
            }
         }

         return string;
      }
   };

   /**
    * localStorage
    *
    *    Simulate localStorage with cookie fallback.
    */
   this.localStorage = function () {
      // All the keys are stored in the cookie named LOCAL_STORAGE_KEYS.
      var LOCAL_STORAGE_COOKIE = _this.base64.encode('LOCAL_STORAGE_COOKIE');
      // In memory local storage data.
      var storage = {
         data: [],

         // Stringify data delimited by ';'.
         stringify: function stringify() {
            return storage.data.join(';');
         },

         // Add key=value pair into data.
         add: function add(key, value) {
            key = encodeURIComponent(key);
            value = encodeURIComponent(value);

            storage.data.push(key + '=' + value);
         },

         // Remove item at specified index.
         remove: function remove(index) {
            if (index > -1 && index < storage.data.length) {
               storage.data.splice(index, 1);
            }
         },

         // Update key=value pair at specified index.
         set: function set(index, key, value) {
            if (index > -1 && index < storage.data.length) {
               key = encodeURIComponent(key);
               value = encodeURIComponent(value);

               storage.data[index] = key + '=' + value;
            }
         },

         // Find the index of item with named key.
         find: function find(key) {
            var i = void 0,
                item = void 0,
                regexp = void 0;

            regexp = new RegExp('^' + encodeURIComponent(key) + '=');
            for (i = 0; i < storage.data.length; i++) {
               item = storage.data[i];
               if (item.search(regexp) !== -1) {
                  return i;
               }
            }

            return -1;
         },

         // Return the key name of item at specified index.
         getKey: function getKey(index) {
            if (index > -1 && index < storage.data.length) {
               return decodeURIComponent(storage.data[index].split('=')[0]);
            }

            return '';
         },

         // Return the value of item at specified index.
         getValue: function getValue(index) {
            if (index > -1 && index < storage.data.length) {
               return decodeURIComponent(storage.data[index].split('=')[1]);
            }

            return '';
         }
      };

      (function () {
         var value = _this.cookie.read(LOCAL_STORAGE_COOKIE);

         if (value !== '') {
            // Read localStorage from cookie add store it into storage.
            storage.data = value.split(';');
         }
      })();

      return {
         /**
          * identifier
          *
          *    The cookie key name of local storage data.
          */
         identifier: LOCAL_STORAGE_COOKIE,

         /**
          * length
          *
          *    Length of local storage.
          */
         length: storage.data.length,

         /**
          * getItem
          *
          *    Retrieves the data of the key from the cookie.
          *
          * @param key name
          * @return data
          */
         getItem: function getItem(key) {
            var index = storage.find(key);

            if (index > -1) {
               return storage.getValue(index);
            }

            return '';
         },

         /**
          * setItem
          *
          *    Add a key/value pair or update it in the cookie.
          *    The expiration time is 30 days.
          *
          * @param key name
          * @param value data
          */
         setItem: function setItem(key, value) {
            var index = storage.find(key);
            if (index < 0) {
               // Add 'key=value' pair into storage.
               storage.add(key, value);
               _this.localStorage.length++;
            } else {
               // Update 'key=value' pair.
               storage.set(index, key, value);
            }
            // Store updated localStorage data into cookie.
            _this.cookie.write(LOCAL_STORAGE_COOKIE, storage.stringify(), 30);
         },

         /**
          * removeItem
          *
          *    Remove the key from the cookie.
          *
          * @param key name
          */
         removeItem: function removeItem(key) {
            var index = storage.find(key);

            if (index > -1) {
               // Remove item from storage.
               storage.remove(index);
               _this.localStorage.length--;

               if (storage.data.length > 0) {
                  // Write updated localStorage data into cookie.
                  _this.cookie.write(LOCAL_STORAGE_COOKIE, storage.stringify(), 30);
               } else {
                  _this.cookie.clear(LOCAL_STORAGE_COOKIE);
               }
            }
         },

         /**
          * key
          *
          *    Return the name of the nth key.
          *
          * @param key An integer representing the number of the key.
          * @return the name of the nth key.
          */
         key: function key(_key) {
            return storage.getKey(_key);
         },

         /**
          * clear
          *
          *    Empty all keys from the cookie.
          */
         clear: function clear() {
            storage.data = [];
            _this.localStorage.length = 0;
            _this.cookie.clear(LOCAL_STORAGE_COOKIE);
         }
      };
   }();
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = toastService;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _toastr = __webpack_require__(46);

var _toastr2 = _interopRequireDefault(_toastr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function toastService() {

   this.TOAST_TYPE = {
      DEFAULT: 0,
      PREDEFINED: 1,
      FT: 2,
      PRINT: 3
   };

   this.LEVEL = {
      INFO: 'info',
      SUCCESS: 'success',
      WARNING: 'warning',
      ERROR: 'error'
   };

   this.COMMON_OPTIONS = {
      "closeButton": false,
      "debug": false,
      "newestOnTop": false,
      "progressBar": false,
      "positionClass": "toast-top-center",
      "preventDuplicates": false,
      "onclick": null,
      "showDuration": "300",
      "hideDuration": "1000",
      "timeOut": "5000",
      "extendedTimeOut": "1000",
      "showEasing": "swing",
      "hideEasing": "linear",
      "showMethod": "fadeIn",
      "hideMethod": "fadeOut"
   };
   this.DEFAULT_OPTIONS = {};
   this.PRINT_OPTIONS = {};
   this.FT_OPTIONS = {};
   _angular2.default.copy(this.COMMON_OPTIONS, this.DEFAULT_OPTIONS);
   _angular2.default.copy(this.COMMON_OPTIONS, this.PRINT_OPTIONS);
   _angular2.default.copy(this.COMMON_OPTIONS, this.FT_OPTIONS);
   this.PRINT_OPTIONS.timeOut = "0";
   this._currentToast = null;
   this._toastArray = [];

   _toastr2.default.options = this.DEFAULT_OPTIONS;

   this.setOptions = function (options) {
      if (!options) {
         return;
      }
      _toastr2.default.options = options;
   };

   this._showToast = function (level, text, type) {
      if (!text) {
         return;
      }

      if (level !== this.LEVEL.INFO && level !== this.LEVEL.ERROR && level !== this.LEVEL.WARNING && level !== this.LEVEL.SUCCESS) {
         throw 'Error level type is used';
      }

      if (!type) {
         type = this.TOAST_TYPE.DEFAULT;
      }

      var optionCache = _toastr2.default.options;
      switch (type) {
         case this.TOAST_TYPE.DEFAULT:
            {
               _toastr2.default.options = this.DEFAULT_OPTIONS;
               this._currentToast = _toastr2.default[level](text);
               break;
            }
         case this.TOAST_TYPE.PREDEFINED:
            {
               this._currentToast = _toastr2.default[level](text);
               break;
            }
         case this.TOAST_TYPE.FT:
            {
               _toastr2.default.options = this.FT_OPTIONS;
               this._currentToast = _toastr2.default[level](text);
               _toastr2.default.options = optionCache;
               break;
            }
         case this.TOAST_TYPE.PRINT:
            {
               _toastr2.default.options = this.PRINT_OPTIONS;
               this._currentToast = _toastr2.default[level](text);
               _toastr2.default.options = optionCache;
               break;
            }
         default:
            {
               throw 'Error msg type is used.';
            }
      }
      this._toastArray.push({
         toast: this._currentToast,
         type: type
      });
   };

   this.success = function (text, type) {
      this._showToast(this.LEVEL.SUCCESS, text, type);
   };

   this.warning = function (text, type) {
      this._showToast(this.LEVEL.WARNING, text, type);
   };

   this.error = function (text, type) {
      this._showToast(this.LEVEL.ERROR, text, type);
   };

   this.info = function (text, type) {
      this._showToast(this.LEVEL.INFO, text, type);
   };

   this.clearCurrentToast = function () {
      if (!!this._currentToast) {
         _toastr2.default.clear(this._currentToast);
      }
   };

   this.clearEarlyToast = function (type) {
      if (this._toastArray.length < 1) {
         return;
      }

      if (!type) {
         type = this.TOAST_TYPE.DEFAULT;
      }

      var i = 0;
      while (i < this._toastArray.length) {
         if (this._toastArray[i].type === type) {
            _toastr2.default.clear(this._toastArray[i].toast);
            this._toastArray.splice(i, 1);
            continue;
         }
         i++;
      }
   };

   this.clearAll = function () {
      _toastr2.default.clear();
   };
}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = URIParamValidator;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function URIParamValidator(usernameUtil) {

   this.isValid = function (URIParams) {
      if (!URIParams) {
         // If there is no URI params, that is valid as well
         return true;
      }

      // userName=test@domain1&domainName=domain2
      if (usernameUtil.domainInUsername(URIParams.userName) && !!URIParams.domainName) {
         var domain = usernameUtil.getDomain(URIParams.userName);
         if (domain.toLowerCase() !== URIParams.domainName.toLowerCase()) {
            return false;
         }
      }

      // TODO more params check here

      return true;
   };
}

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = userGlobalPref;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _jscdkClient = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function userGlobalPref($log, $rootScope, $window, prefData) {
   var _this = this;

   this.initialized = false;
   this.dirty = false;

   var commandName = 'SetUserGlobalPref';

   if (!!$window.addEventListener) {
      $window.addEventListener('beforeunload', function () {
         _this.postPrefData();
         _this.clearPrefData();
      });
   }

   this.postPrefData = function () {
      if (this.readyToSend()) {
         var uiController = _jscdkClient.globalArray['uiController'];
         if (!!uiController) {
            uiController.invokeJSCDK({
               method: commandName,
               prefData: prefData.toJSON(),
               async: false,
               timeout: 2000
            });
         }
      }
   };

   this.clearPrefData = function () {
      prefData.reset();
      this.dirty = false;
   };

   this.onDataSent = function () {
      this.dirty = false;
   };

   this.readyToSend = function () {
      return this.initialized && this.dirty;
   };

   this.setPrefData = function (data) {
      JSON.parse(JSON.stringify(data));
      $log.info('Received data: ' + JSON.stringify(data));

      prefData.favorites = data.favorites;

      /**
       * High resolution mode is always true
       */
      prefData.enableWindowsKey = data.enableWindowsKey;
      prefData.enableMP4 = data.enableMP4;
      prefData.useMacOSXKeyMappings = data.useMacOSXKeyMappings;
      prefData.timezoneSync = data.timezoneSync;
      /**
       * Refer to getDPI function in dpi-service.
       * When the value is 'true', it doesn't do dpi sync actually...
       */
      prefData.enableDPISync = typeof data.enableDPISync === 'undefined' ? 'false' : data.enableDPISync;
      prefData.isHighResolution = prefData.enableDPISync;

      this.initialized = true;
      // Dispatch event of name 'prefDataInit'.
      $rootScope.$emit('prefDataInit');

      $log.info('Preference data set: ' + JSON.stringify(prefData));
   };

   this.getPrefData = function () {
      return _angular2.default.copy(prefData, {});
   };

   /**
    https://wiki.eng.vmware.com/VDM/ClientBrokerXml#GetUserGlobalPreferences
    data: {name, text, action}
    */
   this.updatePrefData = function (data) {
      var favArray = void 0,
          s = void 0;

      switch (data.action) {
         case 'FavOff':
            favArray = prefData.favorites;
            _angular2.default.forEach(favArray, function (value, index) {
               if (value === data.text) {
                  favArray.splice(index, 1);
               }
            });
            break;
         case 'FavOn':
            prefData.favorites.push(data.text);
            break;
         case 'isHighResolution':
         case 'useMacOSXKeyMappings':
         case 'enableWindowsKey':
         case 'enableMP4':
         case 'timezoneSync':
         case 'enableDPISync':
            prefData[data.action] = data.text;
            break;
         default:
            $log.info('Action \'' + data.action + '\' is not supported yet.');
      }

      this.dirty = true;
      s = JSON.stringify(prefData);
      $log.info('Preference data updated: ' + s);
   };

   this.toFlatFormat = function () {
      return prefData.toJSON();
   };
}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = usernameUtil;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * username-util.js
 *
 * Service for username related code.
 *
 * Three login username formats here:
 * 1. username        (broker supported)
 * 2. username@domain (broker supported)
 * 3. domain\username (broker not supported)
 *
 */

function usernameUtil() {

   this.isDomainUsername = function (username) {
      if (!username) {
         return false;
      }
      return username.indexOf('\\') !== -1 && username.indexOf('@') === -1;
   };

   this.isUPN = function (username) {
      if (!username) {
         return false;
      }
      return username.indexOf('@') !== -1 && username.indexOf('\\') === -1;
   };

   this.domainInUsername = function (username) {
      if (!username) {
         return false;
      }

      return this.isUPN(username) || this.isDomainUsername(username);
   };

   this.getUsernameFromDomainUsername = function (username) {
      if (!this.isDomainUsername(username)) {
         throw 'Not an illegal domain username!';
      }

      var backslash = username.indexOf('\\');
      return username.substr(backslash + 1);
   };

   this.getDomainFromDomainUsername = function (username) {
      if (!this.isDomainUsername(username)) {
         throw 'Not an illegal domain username!';
      }

      var backslash = username.indexOf('\\');
      return username.substr(0, backslash);
   };

   this.getUsernameFromUPN = function (username) {
      if (!this.isUPN(username)) {
         throw 'Not an illegal UPN!';
      }

      var at = username.indexOf('@');
      return username.substr(0, at);
   };

   this.getDomainFromUPN = function (username) {
      if (!this.isUPN(username)) {
         throw 'Not an illegal UPN!';
      }

      var at = username.indexOf('@');
      return username.substr(at + 1);
   };

   this.getUsername = function (username) {
      if (!this.domainInUsername(username)) {
         return username;
      }

      if (this.isUPN(username)) {
         return this.getUsernameFromUPN(username);
      } else if (this.isDomainUsername(username)) {
         return this.getUsernameFromDomainUsername(username);
      }

      throw 'Cannot get legal username!';
   };

   this.getDomain = function (username) {
      if (!this.domainInUsername(username)) {
         return '';
      }

      if (this.isUPN(username)) {
         return this.getDomainFromUPN(username);
      } else if (this.isDomainUsername(username)) {
         return this.getDomainFromDomainUsername(username);
      }

      throw 'Cannot get legal domain!';
   };

   this.isUsernameLegal = function (username) {
      return !(username.indexOf('\\') !== -1 && username.indexOf('@') !== -1);
   };

   this.isDomainLegal = function (domain) {
      // Only check if domain is empty now
      return !!domain;
   };

   this.isDomainInDomainList = function (domain, domains) {
      if (!domain || !domains || domains.length <= 0) {
         throw 'Domain or domain list cannot be null!';
      }

      for (var i = 0; i < domains.length; i++) {
         if (domain.toLowerCase() === domains[i].toLowerCase()) {
            return true;
         }
      }
      return false;
   };
}

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ws1Service;

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ws1Service(constants, brokerSessionStorageService, connectionURIModel) {

   /**
    * Service provider ID.
    * vIDM/WS1 passes the value when it launches client.
    * Refer to
    * https://confluence.eng.vmware.com/display/WOR/Horizon+Client+SP+Init+Flow+a.k.a+Fix+Access+Policy+support+in+Horizon
    */
   this.spID = brokerSessionStorageService.read(constants.SP_ID_FOR_WS1_KEY);

   /**
    *  TODO: This function should replace connectionURIModel.isHWSession()
    *  and messageHandlerService.isFromHWS()
    *  I will do this work in next patch.
    */
   this.isWS1Mode = function () {
      return _util2.default.isWS1Mode();
   };

   this.getWS1Hostname = function () {
      return _util2.default.getWS1Hostname();
   };

   /**
    * Refer to
    * https://confluence.eng.vmware.com/display/WOR/Horizon+Client+SP+Init+Flow+a.k.a+Fix+Access+Policy+support+in+Horizon
    */
   this.redirectToWS1 = function (ws1ServerName, windowObject) {
      ws1ServerName = ws1ServerName.toLowerCase();
      if (ws1ServerName.indexOf('https://') !== 0) {
         ws1ServerName = 'https://' + ws1ServerName;
      }

      var serverAddress = ws1ServerName;

      var appName = void 0;
      if (!!connectionURIModel.params && !!connectionURIModel.params.applicationId) {
         appName = connectionURIModel.params.applicationId;
      } else if (!!connectionURIModel.params && !!connectionURIModel.params.desktopId) {
         appName = connectionURIModel.params.desktopId;
      }

      // If there is no app to launch, just handle off to ws1 server
      if (!appName) {
         windowObject.location.href = serverAddress;
         return;
      }

      var serverAPI = '/SAAS/API/1.0/GET/apps/launch/sp-init/';
      var spURLParam = 'spURL=' + windowObject.location.host;

      // Append app name
      serverAddress += serverAPI + encodeURIComponent(appName);

      // Append spURL
      serverAddress += '?' + spURLParam;

      // Append spID
      if (!!this.spID) {
         serverAddress += '&spID=' + this.spID;
      }

      /**
       * Append relayInfo
       * Server side decode is placed in:
       * com.vmware.vdi.installer.ui.filters.RelayInfoFilter
       */
      var relayInfo = connectionURIModel.generateRelayInfo();
      if (!!relayInfo) {
         serverAddress += '&' + relayInfo;
      }

      // Tell vIDM we need launch html access client rather than native client
      serverAddress += '&clientType=BROWSER';

      windowObject.location.href = serverAddress;
   };

   this.storeSpId = function (spID) {
      if (!spID) {
         return;
      }

      brokerSessionStorageService.write(constants.SP_ID_FOR_WS1_KEY, spID);
      this.spID = spID;
   };

   this.isLaunchedFromWS1 = function () {
      /**
       * If we have SAMLart and horizonId in URI, then we say it is launched
       * from WS1
       */
      return !!connectionURIModel.params && !!connectionURIModel.params.samlArt && !!connectionURIModel.params.horizonId;
   };
} /*********************************************************
   * Copyright (C) 2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * ws1-service.js
 *
 * Service for Workspace one integration
 */

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.timezoneListDirective = timezoneListDirective;
exports.timezone = timezone;

var _timeZoneList = __webpack_require__(258);

var _timeZoneList2 = _interopRequireDefault(_timeZoneList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function timezoneListDirective() {
   return {
      replace: true,
      restrict: 'E',
      templateUrl: _timeZoneList2.default
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

function timezone($window, $log, prefData) {
   return {
      /*
       * https://wiki.eng.vmware.com/VDM/ClientBrokerXml#
       * TimeOffset_GMT : -07:00
       * TZID : Europe/London
       * Windows_Timezone: GMT Standard Time
       */
      timeZoneMap: {
         "-12:00": "Etc/GMT-12",
         "-11:00": "Etc/GMT-11",
         "-10:00": "Pacific/Honolulu",
         "-09:30": "Pacific/Marquesas",
         "-09:00": "America/Anchorage",
         "-08:00": "America/Los_Angeles",
         "-07:00": "America/Denver",
         "-06:00": "America/Chicago",
         "-05:00": "America/New_York",
         "-04:00": "America/Asuncion",
         "-03:30": "America/St_Johns",
         "-03:00": "America/Sao_Paulo",
         "-02:00": "America/Noronha",
         "-01:00": "Atlantic/Azores",
         "-00:00": "Europe/London",
         "+01:00": "Europe/Budapest",
         "+02:00": "Europe/Kiev",
         "+03:00": "Europe/Moscow",
         "+03:30": "Asia/Tehran",
         "+04:00": "Asia/Dubai",
         "+04:30": "Asia/Kabul",
         "+05:00": "Asia/Tashkent",
         "+05:30": "Asia/Calcutta",
         "+05:45": "Asia/Katmandu",
         "+06:00": "Asia/Almaty",
         "+06:30": "Asia/Rangoon",
         "+07:00": "Asia/Bangkok",
         "+08:00": "Asia/Shanghai",
         "+08:30": "Asia/Pyongyang",
         "+08:45": "Australia/Eucla",
         "+09:00": "Asia/Tokyo",
         "+09:30": "Australia/Darwin",
         "+10:00": "Australia/Sydney",
         "+10:30": "Australia/Lord_Howe",
         "+11:00": "Etc/GMT+11",
         "+12:00": "Pacific/Fiji",
         "+12:45": "Pacific/Chatham",
         "+13:00": "Tonga",
         "+14:00": "Pacific/Honolulu"
      },

      isDaylightSaving: function isDaylightSaving() {
         Date.prototype.stdTimezoneOffset = function () {
            var jan = new Date(this.getFullYear(), 0, 1);
            var jul = new Date(this.getFullYear(), 6, 1);
            return Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
         };

         Date.prototype.dst = function () {
            return this.getTimezoneOffset() < this.stdTimezoneOffset();
         };

         var today = new Date();
         return !!today.dst();
      },

      getTimezoneOffsetData: function getTimezoneOffsetData() {
         var offset = void 0,
             r = void 0,
             h = void 0;
         offset = new $window.Date().getTimezoneOffset();

         if (this.isDaylightSaving()) {
            offset = offset + 60;
         }

         r = offset < 0 ? '+' : '-';
         offset = offset < 0 ? 0 - offset : offset;

         offset = String(offset / 60).split('.');
         h = offset[0].length > 1 ? offset[0] : '0' + offset[0];
         r += h;
         r += ":";

         r += offset.length > 1 ? '30' : '00';

         /**
          * As we want to keep remote desktop time the same with local,
          * so  don't consider daylight saving now. Bug 1730455
          */
         $log.info("Timezone offset: " + r);
         return r;
      },

      getWindowsTimezone: function getWindowsTimezone() {
         if (!prefData.timezoneSync) {
            var timezoneOffset = this.getTimezoneOffsetData();
            var WindowsTimezone = this.timeZoneMap[timezoneOffset];
            $log.info("Auto get Timezone data: " + WindowsTimezone);
            return WindowsTimezone;
         } else {
            $log.info("Prefer timezone user preference: " + prefData.timezoneSync);
            return prefData.timezoneSync;
         }
      }

   };
}

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = commonSvcService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _vdpservice = __webpack_require__(22);

var _vdpservice2 = _interopRequireDefault(_vdpservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * commonSvcService.js --
 *
 * The service to communicate with server in main channel
 *
 * Server code: bfg-main
 *    depot/bora/bfg-main/apps/rde/rdeSvc/server/commonSvc.cpp
 *    depot/bora/bfg-main/apps/rde/rdeSvc/server/commonSvc.h
 *    depot/bora/bfg-main/apps/rde/rdeSvc/shared/commonSvc_defines.h
 *
 * Once the connection established, server pushes the DPI message version.
 * After that, the communication protocol would follow
 *   https://wiki.eng.vmware.com/EUCBU/CART/DpiSync#Relationship_between_DPI_Sync_feature_and_.22Enable_display_scaling.22_feature
 *
 *
 */

function commonSvcService(AB, wmksServiceEventHandler, dpiService, userGlobalPref, constants) {
   var comSvcMgrMap = {},
       Mgr = void 0,
       COMMON_SVC = {
      DPI_SYNC_VERSION: 1,

      // bora/apps/rde/rdeSvc/shared/commonSvc_defines.h
      MSG_TYPE: {
         CLIENT_COMMON_PLUGIN_MSG: 0,
         ENVIRONMENT_VAR_INFO_MSG: 1,
         DPI_SYNC_MSG: 2
      },

      DPI_SYNC_COMMAND_TYPE: {
         DPI_SYNC_COMMAND_NONE: 0,
         DPI_SYNC_COMMAND_VERSION: 1,
         DPI_SYNC_COMMAND_DPI: 2
      }
   },
       logger = {
      info: function info(msg) {
         _jscdkLogger2.default.info('[commonSvcService] ' + msg);
      },
      error: function error(msg) {
         _jscdkLogger2.default.error('[commonSvcService] ' + msg);
      },
      debug: function debug(msg) {
         _jscdkLogger2.default.debug('[commonSvcService] ' + msg);
      }
   },
       wmksService = null,

   // object name, see,
   // depot/bora/bfg-main/apps/rde/rdeSvc/shared/commonSvc_defines.h
   commonSvcObject = 'CommonSvcObject';

   Mgr = function Mgr(vdpService, wmksKey, mainChannel) {
      var self = this,
          remoteDPI = null,
          inited = false,
          vdpServiceMainChannel = mainChannel;

      this.wmksKey = wmksKey;
      mainChannel.addMessageHandler(this);

      /**
       * send client dpi to server
       * @param dpi
       * @param {Function} [onDone]
       *    Called when the rpc has completed.
       * @param {Function} [onAbort]
       *    Called if the rpc has aborted.
       * @return {Boolean} success
       *    Returns true on success, false on failure
       */
      function sendRPC(dpi, onDone, onAbort) {
         var packet = WMKS.Packet.createNewPacketLE();

         packet.writeUint32(COMMON_SVC.DPI_SYNC_COMMAND_TYPE.DPI_SYNC_COMMAND_VERSION);
         packet.writeUint32(dpi);

         if (0 === vdpServiceMainChannel.invoke({
            command: COMMON_SVC.MSG_TYPE.DPI_SYNC_MSG,
            type: _vdpservice2.default.RPC_TYPE.REQUEST,
            params: [0, 0, packet.getData()],
            onDone: onDone,
            onAbort: onAbort,
            objName: commonSvcObject
         })) {
            logger.error('Failed to send DPI message.');
            return false;
         }

         return true;
      }

      /**
       * handleRPCFromServer
       *
       * Helper function used to parse the RPC data that we
       * receive from a server.
       *
       * @param rpc      RPC object that was posted by VDPService.
       */
      this.handleRPCFromServer = function (rpc) {
         var packet = void 0,
             commandType = void 0,
             version = void 0;

         if (rpc.command === COMMON_SVC.MSG_TYPE.DPI_SYNC_MSG) {
            packet = WMKS.Packet.createFromBufferLE(rpc.params[2]);
            if (packet != null) {
               commandType = packet.readUint32();
               if (commandType === COMMON_SVC.DPI_SYNC_COMMAND_TYPE.DPI_SYNC_COMMAND_VERSION) {
                  version = packet.readUint32();
                  logger.info('Remote DPI version is: ' + version);
                  sendRPC(dpiService.getDPI());
               } else if (commandType === COMMON_SVC.DPI_SYNC_COMMAND_TYPE.DPI_SYNC_COMMAND_DPI) {
                  remoteDPI = packet.readUint32();
                  inited = true;
                  logger.info('Remote Desktop DPI : ' + remoteDPI);

                  self.displayScale();
               } else {
                  logger.error('Invalid command type: ' + commandType);
               }
            }
            return 0;
         } else {
            return 1;
         }
      };

      /**
       * Compasate for Agent DPI scale
       */
      this.displayScale = function () {
         var scale = void 0,
             wmksSession = void 0,
             enabled = userGlobalPref.getPrefData().enableDPISync === 'true';

         wmksSession = wmksService.getWmksSession(this.wmksKey);
         wmksSession.setRemoteDPI(remoteDPI);
         scale = this.getRemoteDPI();
         wmksSession.wmks('option', 'displayScale', scale);

         /**
          * Workaround for bug 1852996 to avoid agent recieve request in a too
          * short time, 3000ms is a tested value to by pass this bug.
          */
         setTimeout(function () {
            logger.info("adjust display for remote scale as " + scale);
            wmksSession.updateResolution(AB.UTIL.getDesiredResolution(), true);
         }, 3000);
      };

      this.getRemoteDPI = function () {
         if (!remoteDPI) {
            return 1.0;
         }
         return parseFloat(remoteDPI) / parseFloat(constants.DPI_100_PERCENT);
      };

      this.isInited = function () {
         return inited;
      };
   };

   function onWmksSessionConnecting(wmksKey, isApplicationSession, vdpService, mainChannel) {
      var mgr = new Mgr(vdpService, wmksKey, mainChannel);
      comSvcMgrMap[wmksKey] = mgr;
   }

   function onWmksSessionConnected(wmksKey) {
      logger.info('In onWmksSessionConnected');
   }

   function onWmksSessionDisconnected(wmksKey) {
      destroyComSvcMgr(wmksKey);
   }

   function onWmksSessionRemoved(wmksKey) {
      destroyComSvcMgr(wmksKey);
   }

   function destroyComSvcMgr(wmksKey) {
      var mgr = comSvcMgrMap[wmksKey];
      if (!mgr) {
         return;
      }

      delete comSvcMgrMap[wmksKey];
      mgr = null;
      logger.info('CommonSvc Manager Object Destroyed.  wmksKey: ' + wmksKey);
   }

   function init(wmksServiceInstance) {
      wmksService = wmksServiceInstance;
      wmksServiceEventHandler.addEventListener('sessionConnecting', onWmksSessionConnecting);
      wmksServiceEventHandler.addEventListener('sessionConnected', onWmksSessionConnected);
      wmksServiceEventHandler.addEventListener('sessionDisconnected', onWmksSessionDisconnected);
      wmksServiceEventHandler.addEventListener('sessionRemoved', onWmksSessionRemoved);

      wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.COMMON_SVC_SERVICE);
   }

   return {
      getCommonSvcMgr: function getCommonSvcMgr(wmksKey) {
         return comSvcMgrMap[wmksKey];
      },

      init: init,

      /**
       * @return {boolean} This returns whether remote DPI is 100%
       */
      isInitedForSession: function isInitedForSession(wmksKey) {
         if (!comSvcMgrMap || !comSvcMgrMap.hasOwnProperty(wmksKey)) {
            return false;
         }
         return comSvcMgrMap[wmksKey].isInited();
      },
      /**
       * @return {number} This returns the remote DPI in ratio, absent
       *    value as 1.0
       */
      getRemoteDPI: function getRemoteDPI(wmksKey) {
         if (!comSvcMgrMap || !comSvcMgrMap.hasOwnProperty(wmksKey)) {
            return 1.0;
         }
         return comSvcMgrMap[wmksKey].getRemoteDPI();
      },
      COMMON_SVC: COMMON_SVC,
      commonSvcObject: commonSvcObject
   };
}

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = mainChannelService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mainChannelService() {
   var vdpServiceMainChannelNamePrefix = 'RPC#VMwareRde#';

   function ChannelObj(vdpService) {
      // currently, main channel has 2 object names
      this.desiredObjectNames = ['UnitySvcObject', 'CommonSvcObject'];

      this.vdpService = vdpService;

      this.msgHandlers = [];

      this.vdpServiceMainChannel = null;
   }

   ChannelObj.prototype.init = function () {
      var self = this;

      this.vdpService.addChannelCreatedListener(function (channel) {
         if (channel.name.indexOf(vdpServiceMainChannelNamePrefix) === 0) {
            if (self.vdpService.connectChannel(channel, self.desiredObjectNames)) {
               _jscdkLogger2.default.debug('Successfully accepted main channel');
            } else {
               _jscdkLogger2.default.error('Failed to open Unity main channel');
               return;
            }

            self.vdpServiceMainChannel = channel;

            channel.onReady = function () {
               _jscdkLogger2.default.debug('Main channel is ready for traffic.');
            };

            channel.onDisconnect = function () {
               self.vdpServiceMainChannel = null;
               _jscdkLogger2.default.debug('Main channel was closed by the remote desktop.');
            };

            channel.onInvoke = function (rpc) {
               console.error("main!!!!!!!!!!!", rpc);
               self.handleRPCFromServer(rpc);
            };
         }
      });

      ChannelObj.prototype.handleRPCFromServer = function (rpc) {
         var i = void 0,
             ret = void 0;

         for (i = 0; i < this.msgHandlers.length; i++) {
            ret = this.msgHandlers[i].handleRPCFromServer(rpc);
            if (ret === 0) {
               // means the message has been consumed
               break;
            }
         }
      };

      ChannelObj.prototype.addMessageHandler = function (handler) {
         this.msgHandlers.push(handler);
      };

      ChannelObj.prototype.invoke = function (param) {
         return this.vdpServiceMainChannel.invoke(param);
      };
   };

   return {
      getChannel: function getChannel(vdpService) {
         return new ChannelObj(vdpService);
      }
   };
} /*********************************************************
   * Copyright (C) 2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = RdpdrChannelManager;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FOLDER_REDIRECTION_CMD = "FORLDER_REDIRECTION_CMD";
var FOLDER_REDIRECTION_NOTIFICATION = "FOLDER_REDIRECTION_NOTIFICATION";
var RDPDR_POLICY = {
   TSDR_RDPDR_HEADER_SIZE: 4,
   TSDR_POLICY_HEADER_SIZE: 8,
   TSDR_GLOBAL_POLICY_SIZE: 8,
   TSDR_FOLDER_POLICY_SIZE: 8,

   TSDR_DEVID_AC_SHIFT: 24,
   TSDR_DEVID_AC_MASK: 0xFFFFFF,
   // Some defailts in https://wiki.eng.vmware.com/EUCBU/CART/FolderRedirection/Readonly
   TSDR_FOLDER_PERMISSION: {
      TSDR_PERM_UNKNOWN: 0, // Cannot be determined
      TSDR_PERM_OPEN_READ_ONLY: 1, // cannot create/open for write
      TSDR_PERM_READ_ONLY: 2, // cannot write data
      TSDR_PERM_OPEN_WRITE_ONLY: 3, // cannot create/open for read
      TSDR_PERM_WRITE_ONLY: 4, // cannot read data
      TSDR_PERM_NORMAL: 5 // normal permission
   }
};
//https://opengrok.eng.vmware.com/source/xref/bfg-main.perforce.1666/bora/apps/rde/tsdr/common/RdpEfs.h
var RDPDR_TYPE = {
   RDPDR_CTYP_CORE: 0x4472,
   RDPDR_CTYP_PRN: 0x5052,

   /* PacketId [MS-RPDEFS 2.2.1.1] */
   PAKID_CORE_SERVER_ANNOUNCE: 0x496E,
   PAKID_CORE_CLIENTID_CONFIRM: 0x4343,
   PAKID_CORE_CLIENT_NAME: 0x434E,
   PAKID_CORE_DEVICELIST_ANNOUNCE: 0x4441,
   PAKID_CORE_DEVICE_REPLY: 0x6472,
   PAKID_CORE_DEVICE_IOREQUEST: 0x4952,
   PAKID_CORE_DEVICE_IOCOMPLETION: 0x4943,
   PAKID_CORE_SERVER_CAPABILITY: 0x5350,
   PAKID_CORE_CLIENT_CAPABILITY: 0x4350,
   PAKID_CORE_DEVICELIST_REMOVE: 0x444D,
   PAKID_PRN_CACHE_DATA: 0x5043,
   PAKID_CORE_USER_LOGGEDON: 0x554C,
   PAKID_PRN_USING_XPS: 0x5543,

   RDPDR_DEVICE_REMOVE_PDUS: 0x00000001,
   RDPDR_CLIENT_DISPLAY_NAME_PDU: 0x00000002,
   RDPDR_USER_LOGGEDON_PDU: 0x00000004,

   /*CAP_GENERAL_TYPE:                  0x0001,
   CAP_PRINTER_TYPE:                  0x0002,
   CAP_PORT_TYPE:                     0x0003,
   CAP_DRIVE_TYPE:                    0x0004,
   CAP_SMARTCARD_TYPE:                0x0005,
    RDPDR_DTYP_FILESYSTEM:             0x00000008,
   RDPDR_DTYP_SMARTCARD:              0x00000020,
     GENERAL_CAPABILITY_VERSION_02:     0x00000002,
   PRINT_CAPABILITY_VERSION_01:       0x00000001,
   PORT_CAPABILITY_VERSION_01:        0x00000001,
   DRIVE_CAPABILITY_VERSION_02:       0x00000002,
   SMARTCARD_CAPABILITY_VERSION_01:   0x00000001,*/

   //Only support 1-dimension array, not support things like char[2][2]
   BASE_TYPE: {
      "char": 1, //"UINT8",
      "CHAR": 1, //"UINT8",
      "BYTE": 1, //"UINT8",
      "unsigned char": 1, //"UINT8",
      "unsigned short": 2, //"UINT16",
      "UINT32": 4, //"UINT32",
      "WCHAR": 2, //"UINT16",
      "BOOLEAN": 1 },

   IRP_MJ_CREATE: 0,
   IRP_MJ_CLOSE: 2,
   IRP_MJ_READ: 3,
   IRP_MJ_WRITE: 4,

   IRP_MJ_DEVICE_CONTROL: 0x00000000E,
   IRP_MJ_QUERY_VOLUME_INFORMATION: 0xA,
   IRP_MJ_SET_VOLUME_INFORMATION: 0xB,
   IRP_MJ_QUERY_INFORMATION: 0x5,
   IRP_MJ_SET_INFORMATION: 0x6,
   IRP_MJ_DIRECTORY_CONTROL: 0xC,
   IRP_MJ_LOCK_CONTROL: 0x11,

   IRP_MN_QUERY_DIRECTORY: 0x1,
   IRP_MN_NOTIFY_CHANGE_DIRECTORY: 2,

   //[MS-SMB2 2.2.13.1.1]
   FILE_ACCESS_DELETE: 0x10000,
   FILE_ACCESS_GENERIC_ALL: 0x10000000,
   FILE_ACCESS_GENERIC_WRITE: 0x40000000,

   RDP_LOWIO_OP_SHAREDLOCK: 0x00000002,
   RDP_LOWIO_OP_EXCLUSIVELOCK: 0x00000003,
   RDP_LOWIO_OP_UNLOCK: 0x00000004,
   RDP_LOWIO_OP_UNLOCK_MULTIPLE: 0x00000005,

   CAP_TYPES: {
      CAP_GENERAL_TYPE: 1,
      CAP_PRINTER_TYPE: 2,
      CAP_PORT_TYPE: 3,
      CAP_DRIVE_TYPE: 4,
      CAP_SMARTCARD_TYPE: 5
   },
   GENERAL_CAPABILITY_VERSION: {
      GENERAL_CAPABILITY_VERSION_01: 1,
      GENERAL_CAPABILITY_VERSION_02: 2
   },

   /* PAKID_CORE_DEVICELIST_ANNOUNCE */
   RDPDR_DTYP_SMARTCARD: 0x00000020,

   /* The Preferred Dosname length in DEVICE_ANNOUNCE packet. */
   PREFERRED_DOS_NAME_LENGTH: 8,
   /*
    * DeviceData length. Derived from RDPDR_DRIVEDEVICE's
    * szRedirectorLocalName size.
    */
   DEVICE_DATA_LOCAL_NAME_LENGTH: 250,
   DEVICE_TYPE: 8, //defined in RdpdrChannel.cpp

   /*
    *  Allow SmartCard client to have 65K Smartcard readers.  The remainder
    *  of the DWORD will be reserved for FR (and other future purposes).
    */
   SMARTCARD_MAX_DEVICE_ID: 0xffff,

   /* RDP file system device [MS-RDPEFS 2.2.1.3] */
   RDPDR_DTYPE_FILESYSTEM: 0x8,

   /* Shared Protocol Header [MS-RPDEFS 2.2.1.1] */
   FORMAT: {
      RDPDR_HEADER: new Map([["Component", "unsigned short"], ["PacketId", "unsigned short"]]), // RDPDR_HEADER, *PRDPDR_HEADER;

      DR_CORE_SERVER_ANNOUNCE_REQ: new Map([["Header", "RDPDR_HEADER"], ["VersionMajor", "unsigned short"], ["VersionMinor", "unsigned short"], ["ClientId", "UINT32"]]), //DR_CORE_SERVER_ANNOUNCE_REQ, *PDR_CORE_SERVER_ANNOUNCE_REQ;

      DR_CORE_CLIENT_ANNOUNCE_RSP: new Map([["Header", "RDPDR_HEADER"], ["VersionMajor", "unsigned short"], ["VersionMinor", "unsigned short"], ["ClientId", "UINT32"]]), // DR_CORE_CLIENT_ANNOUNCE_RSP, *PDR_CORE_CLIENT_ANNOUNCE_RSP;

      DR_CORE_CLIENT_NAME_REQ: new Map([["Header", "RDPDR_HEADER"], ["UnicodeFlag", "UINT32"], ["CodePage", "UINT32"], ["ComputerNameLen", "UINT32"], ["ComputerName", "WCHAR[Variance]"]]), // DR_CORE_CLIENT_NAME_REQ, *PDR_CORE_CLIENT_NAME_REQ;


      //------------------------------------
      RDP_DR_DEVICE_IOREQUEST: new Map([["DeviceId", "UINT32"],
      /* Id from Client DeviceList Announce Request */
      ["FileId", "UINT32"],
      /* Id from Device Create Response */
      ["CompletionId", "UINT32"],
      /* Unique Id for Each request */
      ["MajorFunction", "UINT32"],
      /* The IRP_MJ_AAA request */
      ["MinorFunction", "UINT32"],
      /* The IRP_MNAAA function (With IRP_MJ_DIRECTORY_CONTROL) */
      ["Parameters", [//TODO
      /* IRP_MJ_CREATE [MS-RPDEFS 2.2.1.4.1] */
      {
         "type": "Create",
         "format": new Map([["DesiredAccess", "UINT32"], // Wanted level of access
         ["AllocationSize", "UINT32"], // Initial allocaiton size for the file
         ["FileAttributes", "UINT32"], // Attributes for the created file
         ["SharedAccess", "UINT32"], // Sharing mode for the opened file
         ["CreateDisposition", "UINT32"], // Action to take of file already exists
         ["CreateOptions", "UINT32"], // Creation options
         ["PathLength", "UINT32"] // Length in bytes of data (Path) following the structure
         //Path", "WCHAR[.PathLength]"
         ])
      },
      /* IRP_MJ_CLOSE [MS-RPDEFS 2.2.1.4.2]
       * No structure, 32 bytes padding
       */

      /* IRP_MJ_READ  [MS-RPDEFS 2.2.1.4.3] */
      {
         "type": "Read",
         "format": new Map([["Length", "UINT32"], // Maximum Number of chars to read
         ["Offset", "LARGE_INTEGER"], // Byte offset where read starts
         ["Padding", "char[20]"] // Padding
         ])
      },

      /* IRP_MJ_WRITE  [MS-RPDEFS 2.2.1.4.4]*/
      {
         "type": "Write",
         "format": new Map([["Length", "UINT32"], // Number of char's to write
         ["Offset", "LARGE_INTEGER"], // Byte offset where write starts
         ["Padding", "char[20]"]])
      },
      /* IRP_MJ_DEVICE_CONTROL  [MS-RPDEFS 2.2.1.4.5]*/
      {
         "type": "DeviceIoControl",
         "format": new Map([["OutputBufferLength", "UINT32"], // Maximum num of bytes in OutputBuffer (See DR_CONTROL_RSP)
         ["InputBufferLength", "UINT32"], // Number of bytes in InputBuffer
         ["IoControlCode", "UINT32"], // IOCTL_AAA
         ["Padding", "char[20]"]])
      }, {
         "type": "QueryDirectory",
         "format": new Map([["FileInformationClass", "UINT32"], ["InitialQuery", "BOOLEAN"], ["PathLength", "UINT32"], ["Padding", "UCHAR[23]"]])
      }, {
         "type": "SetInformation",
         "format": new Map([["FileInformationClass", "UINT32"], ["Length", "UINT32"], ["Padding", "UCHAR[24]"]])
      }, {
         "type": "QueryInformation",
         "format": new Map([["FsInformationClass", "UINT32"], ["Padding", "UCHAR[28]"]])
      },
      /* IRP_MJ_SET_VOLUME_INFORMATION  [MS-RPDEFS 2.2.3.3.7] */
      {
         "type": "SetVolumeInformation",
         "format": new Map([["FsInformationClass", "UINT32"], ["Length", "UINT32"], ["Padding", "UCHAR[24]"]])
      }, {
         "type": "QueryVolumeInformation",
         "format": new Map([["FsInformationClass", "UINT32"], ["Padding", "UCHAR[28]"]])
      }, {
         "type": "NotifyChangeDirectory",
         "format": new Map([["WatchTree", "BOOLEAN"], ["CompletionFilter", "UINT32"], ["Padding", "UCHAR[27]"]])
      },
      /* IRP_MJ_LOCK_CONTROL  [MS-RPDEFS 2.2.3.3.12] */
      {
         "type": "Lock",
         "format": new Map([["Operation", "UINT32"], // Lock type
         ["F", "UINT32"], // Fail immediately
         ["NumLocks", "UINT32"], // Number of locks requested
         ["Padding", "UCHAR[20]"]])
      }]]]),

      /* RDP_LOCK_INFO [MS-RPDEFS 2.2.1.6] */
      RDP_LOCK_INFO: new Map([["Length", "LARGE_INTEGER"], ["Offset", "LARGE_INTEGER"]]),

      /* RDPDR_DEVICE_IOREQUEST [MS-RPDEFS 2.2.1.4] */
      DR_DEVICE_IOREQUEST: new Map([["Header", "RDPDR_HEADER"], ["IoRequest", "RDP_DR_DEVICE_IOREQUEST"]]),

      /*
       * RDP_DR_DEVICE_IOCOMPLETION
       * [MS-RPDEFS 2.2.1.5]
       * Sent by the client to indicate an I/O operation has completed
       * Note: Should contain Protocol Header, I have separated the
       *       Header from the request, it's included in the
       *       DR_DEVICE_IOCOMPLETION below
       */
      RDP_DR_DEVICE_IOCOMPLETION: new Map([//TODO
      // RDP_DR_DEVICE_IOCOMPLETION_HEADER
      ["DeviceId", "UINT32"], // Must match DeviceId used in the RDP_DR_DEVICE_IOREQUEST
      ["CompletionId", "UINT32"], // Must match the CompletionId in the RDP_DR_DEVICE_IOREQUEST
      ["IoStatus", "UINT32"], // NT Status code for the request
      ["Parameters", [
      /* IRP_MJ_CREATE [MS-RPDEFS 2.2.1.5.1] */
      {
         type: "Create",
         formate: new Map([["FileId", "UINT32"], // Unique FileId for the created object
         ["Information", "unsigned char"] // Indicates the success of the Create/Open operation
         ])
      },
      /* IRP_MJ_CLOSE [MS-RPDEFS 2.2.1.5.2] */
      {
         type: "Close",
         formate: new Map([["Padding", "char[5]"]])
      },
      /* IRP_MJ_READ [MS-RPDEFS 2.2.1.5.3] */
      {
         type: "Read",
         formate: new Map([["Length", "UINT32"], // Number of bytes that were read
         ["ReadData", "unsigned char[1]"]])
      },
      /* IRP_MJ_WRITE [MS-RPDEFS 2.2.1.5.4] */
      {
         type: "Write",
         formate: new Map([["Length", "UINT32"], // Number of bytes that were written
         ["Padding", "char[1]"] // Variable Output data from the read request
         ])
      },
      /* IRP_MJ_DEVICE_CONTROL [MS-RPDEFS 2.2.1.5.5] */
      {
         type: "DeviceIoControl",
         formate: new Map([["OutputBufferLength", "UINT32"], // Number of bytes in the OutputBuffer
         ["OutputBuffer", "unsigned char[1]"] // Variable lenght array of bytes
         ])
      }, {
         type: "QueryVolumeInformation",
         formate: new Map([["Length", "UINT32"], ["VolumeInformation", "char[1]"]])
      }, {
         type: "SetVolumeInformation",
         formate: new Map([["Length", "UINT32"], ["Padding", "char[1]"]])
      }, {
         type: "QueryInformation",
         formate: new Map([["Length", "UINT32"], ["FileInformation", "char[1]"]])
      }, {
         type: "QueryDirectory",
         formate: new Map([["Length", "UINT32"], ["FileInformation", "char[1]"]])
      }, {
         type: "NotifyChangeDirectory",
         formate: new Map([["Length", "UINT32"], ["FileNotifyInformation", "char[1]"]])
      },
      /* IRP_MJ_LOCK_CONTROL  [MS-RPDEFS 2.2.3.4.12] */
      {
         type: "Lock",
         formate: new Map([["Padding", "char[5]"]])
      }]]]),
      /* [MS-RPDEFS 2.2.1.5] */
      DR_DEVICE_IOCOMPLETION: new Map([["Header", "RDPDR_HEADER"], ["IoCompletion", "RDP_DR_DEVICE_IOCOMPLETION"]]),
      /* [MS-RDPEFS 2.2.2.2 for server] and [MS-RDPEFS 2.2.2.6 for client] */
      DR_CORE_ANNOUNCE_REQ: new Map([["Header", "RDPDR_HEADER"], ["VersionMajor", "unsigned short"], ["VersionMinor", "unsigned short"], ["ClientId", "UINT32"]]),
      CAPABILITY_HEADER: new Map([["CapabilityType", "unsigned short"], ["CapabilityLength", "unsigned short"], ["Version", "UINT32"]]),
      /* [MS-RDPEFS 2.2.2.7.1] */
      GENERAL_CAPS_SET: new Map([["Header", "CAPABILITY_HEADER"], ["osType", "UINT32"], ["osVersion", "UINT32"], ["protocolMajorVersion", "unsigned short"], ["protocolMinorVersion", "unsigned short"], ["ioCode1", "UINT32"], ["ioCode2", "UINT32"], ["extendedPDU", "UINT32"], ["extraFlags1", "UINT32"], ["extraFlags2", "UINT32"], ["SpecialTypeDeviceCap", "UINT32"]]),
      PRINTER_CAPS_SET: new Map([["Header", "CAPABILITY_HEADER"]]),
      PORT_CAPS_SET: new Map([["Header", "CAPABILITY_HEADER"]]),
      DRIVE_CAPS_SET: new Map([["Header", "CAPABILITY_HEADER"]]),
      SMARTCARD_CAPS_SET: new Map([["Header", "CAPABILITY_HEADER"]]),
      /* [MS-RDPEFS 2.2.2.7 for server] and [MS-RDPEFS 2.2.2.8 for client] */
      DR_CORE_CAPABILITY_REQ: new Map([["Header", "RDPDR_HEADER"], ["numCapabilities", "unsigned short"], ["Padding", "unsigned short"], ["CapabilityMessage", "Variance"]]),
      //------------
      DEVICE_ANNOUNCE_HEADER: new Map([["DeviceType", "UINT32"], ["DeviceId", "UINT32"], ["DosName", "CHAR[..PREFERRED_DOS_NAME_LENGTH]"], ["DeviceDataLength", "UINT32"], ["DeviceData", "BYTE[.DeviceDataLength]"]]),
      DR_CORE_DEVICELIST_ANNOUNCE_REQ: new Map([["Header", "RDPDR_HEADER"], ["DeviceCount", "UINT32"], ["DeviceList", "DEVICE_ANNOUNCE_HEADER[1]"]]),
      DR_CORE_DEVICE_ANNOUNCE_RSP: new Map([["Header", "RDPDR_HEADER"], ["DeviceId", "UINT32"], ["ResultCode", "UINT32"]]),
      DR_DEVICELIST_REMOVE: new Map([["Header", "RDPDR_HEADER"], ["DeviceCount", "UINT32"], ["DeviceIds", "UINT32"]])
   }
};
//https://opengrok.eng.vmware.com/source/xref/bfg-main.perforce.1666/bora/apps/rde/tsdr/common/TsdrDefs.h
var TDSR_TYPE = {
   /*
    * TSDR Version Exchange Component/PacketId defines.
    */
   TSDR_COMPONENT_CAPS: 0xfffe,
   TSDR_PACKID_VERSION_EXCHANGE: 0x0001,
   TSDR_PACKID_AGENT_POLICY: 0x0002,

   TSDR_FOLDER_ENUM_BUF_SIZE: 4096,

   /*
    * Bitmask for peer capbilities
    */
   TSDR_CAPS_MUL_ENTRIES: 0x1,

   /*
    * TSDR Version Exchange Packet structure.
    */
   FORMAT: {
      TSDR_CAPS_VERSION_EXCHANGE_REQ: {
         Header: "RDPDR_HEADER", //4
         Version: "unsigned short", //2
         Caps: "unsigned short" }
   },

   //(sizeof(TSDR_CAPS_VERSION_EXCHANGE_REQ) - sizeof(unsigned short))
   MIN_TSDR_CAPS_VERSION_EXCHANGE_REQ_SIZE: 6,

   /*
    * enum TsdrVersion
    *
    *   Represents the version of the TSDR endpoint.
    *
    *   TSDR_VERSION_UNKNOWN = Unknown version.
    *   TSDR_VERSION_V1 = Initial release.
    *   TSDR_VERSION_V2 = Read/Write only CDR support.
    *
    *   XXX: When adding a version, mention the new features/capabilities here.
    */
   VERSION: {
      TSDR_VERSION_UNKNOWN: 0,
      TSDR_VERSION_V1: 1,
      TSDR_VERSION_V2: 2, // Start to support agent policy
      TSDR_VERSION_V3: 3 // Start to support cache
   }
};

/**
 * Uint8Array data
 */
function StreamHelper(data) {
   var offset = 0;
   var getBytes = function getBytes(bytes) {
      if (data.length < offset + bytes) {
         console.error("too small data to read");
         return 0;
      }
      var number = 0;
      for (var i = 0; i < bytes; i++) {
         number |= data[offset + i] << i * 8;
      }
      offset += bytes;
      return number;
   };
   this.getUint8 = function () {
      return getBytes(1);
   };
   this.getUint16 = function () {
      return getBytes(2);
   };
   this.getUint32 = function () {
      return getBytes(4);
   };
   this.getUint64 = function () {
      return getBytes(8);
   };
   this.getRest = function () {
      return data.subarray(offset, data.length);
   };
   this.getBytes = getBytes;
   this.getOffset = function () {
      return offset;
   };
   this.reset = function () {
      offset = 0;
   };
}
function StreamWriter(type) {
   var temp = [];
   var pushBytes = function pushBytes(number, bytes) {
      for (var i = 0; i < bytes; i++) {
         temp.push(number & 0xFF);
         number >>= 8;
      }
   };
   this.pushUint8 = function (number) {
      pushBytes(number, 1);
   };
   this.pushUint16 = function (number) {
      pushBytes(number, 2);
   };
   this.pushUint32 = function (number) {
      pushBytes(number, 4);
   };
   this.pushUint64 = function (number) {
      pushBytes(number, 8);
   };
   this.getStream = function () {
      return new Uint8Array(temp);
   };
   this.getArray = function () {
      return temp;
   };
   this.hasData = function () {
      return temp.length > 0;
   };
   this.clear = function () {
      temp = [];
   };
   this.pushBytes = pushBytes;
   //UTF-16
   this.pushUnitCode = function (string) {
      for (var i = 0; i < string.length; i++) {
         var charCode = string.charCodeAt(i);
         this.pushUint16(charCode);
      };
      this.pushUint16(0); //add end 2 bytes as /0
   };
   //ascii code
   this.pushString = function (string, length) {
      if (string.length !== length - 1) {
         console.error("error when push string, the length is not matched with the input string length");
      }
      for (var i = 0; i < string.length; i++) {
         var charCode = string.charCodeAt(i);
         this.pushUint8(charCode);
      };
      this.pushUint8(0); //add end 2 bytes as /0
   };
   this.getString = function () {
      var hexNumbers = [];
      temp.forEach(function (number) {
         hexNumbers.push(number.toString(16));
      });
      return hexNumbers;
   };
}
function ProtocolHelper(baseTypes, coodbook) {
   var convertToCaml = function convertToCaml(string) {
      if (!(string.length > 0)) {
         return "";
      }
      return string[0].toLowerCase() + string.substr(1);
   };
   return {
      isInvalidType: function isInvalidType(type) {
         return !coodbook.hasOwnProperty(type);
      },
      parseByStruct: function parseByStruct(streamHelper, struct, result, param) {
         var _this = this;

         if (!struct) {
            return;
         }
         struct.forEach(function (dataType, propertyKey) {
            var propertyName = convertToCaml(propertyKey);
            var logBase = "read " + JSON.stringify(dataType) + " for property " + propertyName;
            result[propertyName] = {}; //default as empty object, will be overwritten if is number
            var propertySlot = result[propertyName];
            if (typeof dataType === 'string') {
               if (baseTypes.hasOwnProperty(dataType)) {
                  console.log(logBase + " as baseTypes of " + baseTypes[dataType] + " bytes");
                  result[propertyName] = streamHelper.getBytes(baseTypes[dataType]);
               } else if (coodbook.hasOwnProperty(dataType)) {
                  //should be another type
                  var _subStruct = coodbook[dataType];
                  _this.parseByStruct(streamHelper, _subStruct, propertySlot, param); //subStruct is of type struct "json"
                  console.log(logBase + " as another sub structure " + _subStruct);
               } else if (dataType === "Variance") {
                  // where the length is not sure, so check param for detail
                  console.error(logBase + " as Variance TODO");
                  //TODO: use param to match which should be used.
               } else if (dataType === "WCHAR[Variance]") {
                  console.error(logBase + " as WCHAR[Variance] TODO");
                  //TODO: use param to match which should be used.
               } else {
                  console.error(logBase + " failed, since the data type is unkonwn: " + dataType);
               }
            } else if ((typeof dataType === "undefined" ? "undefined" : _typeof(dataType)) === 'object') {
               if (Array.isArray(dataType)) {
                  //array is used as union, so need to use param to decide
                  console.error(logBase + " as union");
                  console.error(Array);
                  if (!param.hasOwnProperty(propertyName)) {
                     console.error(logBase + " as union fails, since param is invalid");
                  }
                  var unionType = '';
                  if (typeof param[propertyName] === "string") {
                     unionType = param[propertyName];
                  } else if (typeof param[propertyName] === "function") {
                     // Only support the result.
                     unionType = param[propertyName](result);
                  }
                  var hasMatchedType = false;
                  if (!!unionType) {
                     var _hasMatchedType = dataType.some(function (value, key) {
                        if (value.type === unionType) {
                           console.error(logBase + " as union success as " + unionType);
                           _this.parseByStruct(streamHelper, value.format, propertySlot, param); //subStruct is of type struct "json"
                           return true;
                        }
                        return false;
                     });
                  }
                  if (!hasMatchedType) {
                     console.error(logBase + " as union fails, since can't find the matched union type");
                  }
               } else {
                  // Explicity structure
                  console.log(logBase + " as object of explicity structure: ", dataType);
                  _this.parseByStruct(streamHelper, subStruct, propertySlot, param);
               }
            } else {
               console.error(logBase + " failed, since the type is invalid: ", dataType);
            }
         });
         return result;
      },
      parseByName: function parseByName(streamHelper, type, result, param) {
         if (this.isInvalidType(type)) {
            console.warn("invalid type to parse");
            return;
         }
         if (!result) {
            result = {};
         }
         var struct = coodbook[type];
         this.parseByStruct(streamHelper, struct, result, param);
         return result;
      },
      /**
       * from streamHelper to result
       * @param  {[type]} streamHelper [description]
       * @param  {[type]} type         [description]
       * @return {[type]}              [description]
       */
      parse: function parse(streamHelper, type, param) {
         var result = {};
         return this.parseByName(streamHelper, type, result, param);
         /**
         let component = streamHelper.getUint16();
         let packetId = streamHelper.getUint16();
         return {
            component: component,
            packetId: packetId
         };**/
      },
      streamifyByStruct: function streamifyByStruct(streamWriter, struct, data, param) {
         var _this2 = this;

         if (!struct) {
            return;
         }
         struct.forEach(function (dataType, propertyKey) {
            var propertyName = convertToCaml(propertyKey);
            var logBase = "write " + JSON.stringify(dataType) + " for property " + propertyName;
            var propertyValue = data[propertyName];
            if (typeof dataType === 'string') {
               var arrayMatcher = new RegExp('\\w+\\[.{0,2}\\w+\\]');
               var matchedArray = arrayMatcher.exec(dataType);
               if (baseTypes.hasOwnProperty(dataType)) {
                  console.log(logBase + " as baseTypes of " + baseTypes[dataType] + " bytes");
                  streamWriter.pushBytes(propertyValue, baseTypes[dataType]);
               } else if (coodbook.hasOwnProperty(dataType)) {
                  //should be another type
                  var _subStruct2 = coodbook[dataType];
                  _this2.streamifyByStruct(streamWriter, _subStruct2, propertyValue, param); //subStruct is of type struct "json"
                  console.log(logBase + " as another sub structure " + _subStruct2);
               } else if (dataType === "Variance") {
                  // where the length is not sure, so check param for detail
                  if (!param || !param.hasOwnProperty(propertyName)) {
                     console.error(logBase + " as Variance fail, since find no key " + propertyName + " in the param: ", param);
                     return;
                  }
                  var varientTypes = param[propertyName];
                  console.error(logBase + " as Variance:" + varientTypes);
                  //TODO, currently only accept array of sub type names
                  if (Array.isArray(varientTypes)) {
                     for (var j = 0; j < varientTypes.length; j++) {
                        var varientType = varientTypes[j];
                        var varientName = varientType; //Don't use the caml for this case
                        if (!coodbook.hasOwnProperty(varientType)) {
                           console.error(logBase + " as Variance fail, since we only support array of subtype names for now, but one of sub type is:", varientType);
                           return;
                        }
                        var varientStruct = coodbook[varientType];
                        if (!propertyValue.hasOwnProperty(varientName)) {
                           console.error(logBase + " as Variance fail, since the proterty don't has corresponding data for " + varientType, propertyValue);
                           return;
                        }
                        var varientData = propertyValue[varientName];
                        console.error(logBase + " as Variance for :" + varientName, varientStruct, varientData);
                        _this2.streamifyByStruct(streamWriter, varientStruct, varientData, param /*TODO support nested param*/);
                     }
                  }
                  //TODO: use param to match which should be used.
               } else if (dataType === "WCHAR[Variance]") {
                  console.error(logBase + " as WCHAR[Variance]: " + propertyValue);
                  //TODO: use param to match which should be used.
                  streamWriter.pushUnitCode(propertyValue);
               } else if (!!matchedArray) {
                  var splittedString = matchedArray[0].split(/[\[\]]+/);
                  if (splittedString.length !== 3 && splittedString[2] === '') {
                     console.error(logBase + " failed, since the array indicator is invalid: " + dataType);
                     return;
                  }
                  var arrayType = splittedString[0];
                  var arrayLengthString = splittedString[1];
                  var arrayLength = Number(arrayLengthString);
                  if (!arrayLength) {
                     if (arrayLengthString[0] !== '.') {
                        console.error(logBase + " failed, since the array length is invalid: " + dataType);
                     }
                     if (arrayLengthString[1] === '.') {
                        var macroName = arrayLengthString.slice(2, arrayLengthString.length);
                        if (!RDPDR_TYPE.hasOwnProperty(macroName) || typeof RDPDR_TYPE[macroName] !== 'number') {
                           console.error(logBase + " failed, since the array length is invalid macro: " + dataType);
                        }
                        arrayLength = RDPDR_TYPE[macroName];
                     } else {
                        var lengthPropertyName = convertToCaml(arrayLengthString.slice(1, arrayLengthString.length));
                        if (!data.hasOwnProperty(lengthPropertyName) || typeof data[lengthPropertyName] !== 'number') {
                           console.error(logBase + " failed, since the array length is invalid property: " + dataType);
                        }
                        arrayLength = data[lengthPropertyName];
                     }
                  }
                  if (arrayLength > 0) {
                     if (typeof propertyValue === 'string' && baseTypes[arrayType] === 1) {
                        streamWriter.pushString(propertyValue, arrayLength);
                     } else {
                        //default as number
                        for (var i = 0; i < arrayLength; i++) {
                           var arrayData = propertyValue[i];
                           if (baseTypes.hasOwnProperty(arrayType)) {
                              console.log(logBase + " as baseTypes of " + baseTypes[arrayType] + " bytes");
                              streamWriter.pushBytes(arrayData, baseTypes[arrayType]);
                           } else if (coodbook.hasOwnProperty(arrayType)) {
                              //should be another type
                              var arrayStruct = coodbook[arrayType];
                              _this2.streamifyByStruct(streamWriter, arrayStruct, arrayData, param); //arrayStruct is of type struct "json"
                              console.log(logBase + " as another sub structure in the array" + arrayStruct);
                           } else {
                              console.log(logBase + " failed, since the array data type is invalid" + dataType);
                           }
                        }
                     }
                  } else {
                     console.log(logBase + " failed, since the array length is invalid" + dataType);
                  }
               } else {
                  console.error(logBase + " failed, since the data type is unkonwn: " + dataType);
               }
            } else if ((typeof dataType === "undefined" ? "undefined" : _typeof(dataType)) === 'object') {
               if (Array.isArray(dataType)) {
                  //array is used as union, so need to use param to decide
                  console.error(logBase + " as union TODO");
                  //TODO: use param to match which should be used.
               } else {
                  //explicity structure
                  console.log(logBase + " as object of explicity structure: ", dataType);
                  _this2.streamifyByStruct(streamWriter, subStruct, propertyValue, param);
               }
            } else {
               console.error(logBase + " failed, since the type is invalid: ", dataType);
            }
         });
      },
      streamifyByName: function streamifyByName(streamWriter, type, data, param) {
         if (this.isInvalidType(type)) {
            console.warn("invalid type to parse");
            return;
         }
         var struct = coodbook[type];
         this.streamifyByStruct(streamWriter, struct, data, param);
      },
      /**
       * from data into streamWriter
       * @param  {[type]} streamWriter [description]
       * @param  {[type]} type         [description]
       * @param  {[type]} data         [description]
       * @param  {[type]} param        [description]
       * @return {[type]}              [description]
       */
      streamify: function streamify(streamWriter, type, data, param) {
         streamWriter.clear();
         this.streamifyByName(streamWriter, type, data, param);
         return;
         /*
         //header
         streamWriter.pushUint16(RDPDR_TYPE.RDPDR_CTYP_CORE);
         //corespoding to DR_CORE_CLIENT_ANNOUNCE_RSP https://opengrok.eng.vmware.com/source/xref/bfg-main.perforce.1666/bora/apps/rde/rds/manager/channels.cpp#3619
         streamWriter.pushUint16(RDPDR_TYPE.PAKID_CORE_CLIENTID_CONFIRM);
           //this.streamify(streamWriter,data,type)//DR_CORE_CLIENT_ANNOUNCE_RSP
         streamWriter.pushUint16(data.versionMajor);
         streamWriter.pushUint16(data.versionMinor);
         streamWriter.pushUint32(data.clientId);
         return streamWriter;*/
      }
   };
}
function RdpdrChannelManager(tsdrChannel, tsdrControlObject) {
   var deviceIdCounter = RDPDR_TYPE.SMARTCARD_MAX_DEVICE_ID;
   var selectedFolders = [];
   var userLoggedOn = false;
   var pPolicy = null;
   var serverVersion = TDSR_TYPE.VERSION.TSDR_VERSION_UNKNOWN;

   var protocolHelper = ProtocolHelper(RDPDR_TYPE.BASE_TYPE, RDPDR_TYPE.FORMAT);
   /*let rdpdrChannel = (function(){
      let onDataReceived = null;
      return {
         init: function(onData){
            onDataReceived = onData;
         },
         send: function(stream){
         },
         processData: function(stream){
            if(typeof onDataReceived == 'function'){
               onDataReceived(stream);
            }
         }
      }
   })();*/
   var handleVersionExchange = function handleVersionExchange() {
      console.error("handleVersionExchange");
      return true;
   };
   var handleTsdrPolicy = function handleTsdrPolicy() {
      console.error("handleTsdrPolicy");
      return true;
   };
   /**
    * will make sure the string length is no more than length-1, since last char
    * must be /0
    * @param  {[type]} string [description]
    * @param  {[type]} length [description]
    * @return {[type]}        [description]
    */
   var clipCString = function clipCString(string, length) {
      return string.slice(0, length - 1);
   };
   var deviceListAnnounce = function deviceListAnnounce(folder) {
      var deviceId = deviceIdCounter;
      var deviceType = RDPDR_TYPE.DEVICE_TYPE;
      var folderName = "testFolder"; // from folder propertys
      var folderPermission = RDPDR_POLICY.TSDR_FOLDER_PERMISSION.TSDR_PERM_OPEN_READ_ONLY; //only support this in first version

      //clip folder name
      var dosName = clipCString(folderName, RDPDR_TYPE.PREFERRED_DOS_NAME_LENGTH);
      folderName = clipCString(folderName, RDPDR_TYPE.DEVICE_DATA_LOCAL_NAME_LENGTH);

      // Use 1st Byte in device id for access control
      deviceId |= folderPermission << RDPDR_POLICY.TSDR_DEVID_AC_SHIFT;

      var deviceAnnounce = {
         header: { //RDPDR_HEADER
            component: RDPDR_TYPE.RDPDR_CTYP_CORE,
            packetId: RDPDR_TYPE.PAKID_CORE_DEVICELIST_ANNOUNCE
         },
         deviceCount: 1,
         deviceList: [{ //DEVICE_ANNOUNCE_HEADER, only has one in this version
            deviceType: deviceType,
            deviceId: deviceId,
            dosName: dosName, //char[8]
            deviceDataLength: folderName.length + 1, //strlen(deviceList.DeviceData) + 1;
            deviceData: folderName }]
      };
      var param = {};

      sendResponse("DR_CORE_DEVICELIST_ANNOUNCE_REQ", deviceAnnounce, param);

      deviceIdCounter++;
   };
   var redirectSelectedFolders = function redirectSelectedFolders() {
      //for(let folder in selectedFolders){
      //   deviceListAnnounce();
      //}
      deviceListAnnounce();
   };
   var onUserReady = function onUserReady() {
      console.error("onUserReady");
      redirectSelectedFolders();
   };
   var sendRPC = function sendRPC(streamWriter, onDone, onAbort) {
      if (!tsdrChannel) {
         _jscdkLogger2.default.error('RPC send failed: tsdrChannel not initialized');
         onAbort();
         return;
      }
      var command = 0;
      var result = tsdrChannel.invoke({
         object: tsdrControlObject,
         command: 0, //not sure, just reuse the one in the request
         type: 4, //use POST.  1,//VDPService.RPC_TYPE.REQUEST,
         params: streamWriter.hasData() ? [streamWriter.getStream()] : [],
         onDone: onDone,
         onAbort: onAbort
      });
      console.error('send back', streamWriter.getString());
      return !!result;
   };
   var onAbort = function onAbort() {
      console.error("send rpc aborted");
   };
   var onDone = function onDone() {
      console.error("send rpc done");
   };

   var sendResponse = function sendResponse(type, data, param) {
      console.error("sending response of type " + type + " :", data);
      var streamWriter = new StreamWriter();
      protocolHelper.streamify(streamWriter, type, data, param);
      sendRPC(streamWriter, onDone, onAbort); //commandMap[type] instead of type
   };

   var handleServerAnnounce = function handleServerAnnounce(streamHelper) {
      console.error("handleServerAnnounce");
      var serverVersionInfo = protocolHelper.parse(streamHelper, "DR_CORE_SERVER_ANNOUNCE_REQ");
      serverVersion = serverVersionInfo.versionMajor;

      var clientVersionInfo = serverVersionInfo;

      clientVersionInfo.versionMinor = 12; //for testing and also same as window client
      clientVersionInfo.header.packetId = RDPDR_TYPE.PAKID_CORE_CLIENTID_CONFIRM;

      sendResponse("DR_CORE_CLIENT_ANNOUNCE_RSP", clientVersionInfo);
   };
   var sendClientCapability = function sendClientCapability() {
      var generalCapsSet = { //GENERAL_CAPS_SET
         header: {
            capabilityType: RDPDR_TYPE.CAP_TYPES.CAP_GENERAL_TYPE,
            capabilityLength: 0x2c, //sizeof(GENERAL_CAPS_SET)
            version: RDPDR_TYPE.GENERAL_CAPABILITY_VERSION.GENERAL_CAPABILITY_VERSION_02
         },
         osType: 0x00000002, //unlike 0x0002, 0x0000
         osVersion: 0x00060001, //unlike 0x0001, 0x0006
         protocolMajorVersion: 1,
         protocolMinorVersion: 0x0c,
         ioCode1: 0xffff,
         ioCode2: 0,
         extendedPDU: RDPDR_TYPE.RDPDR_DEVICE_REMOVE_PDUS | RDPDR_TYPE.RDPDR_CLIENT_DISPLAY_NAME_PDU | RDPDR_TYPE.RDPDR_USER_LOGGEDON_PDU,
         extraFlags1: 1, //ENABLE_ASYNCIO = 1
         extraFlags2: 0,
         specialTypeDeviceCap: 0
      };
      var printerCapSet = {
         header: {
            capabilityType: RDPDR_TYPE.CAP_TYPES.CAP_PRINTER_TYPE,
            capabilityLength: 0x08, //sizeof(printerCapSet)
            version: 1
         }
      };
      var portCapSet = {
         header: {
            capabilityType: RDPDR_TYPE.CAP_TYPES.CAP_PORT_TYPE,
            capabilityLength: 0x08, //sizeof(printerCapSet)
            version: 1
         }
      };
      var driveCapSet = {
         header: {
            capabilityType: RDPDR_TYPE.CAP_TYPES.CAP_DRIVE_TYPE,
            capabilityLength: 0x08, //sizeof(printerCapSet)
            /* CAP_DRIVE_TYPE enabled with v2 to
             * support device names longer than 8 bytes.
             */
            version: 2
         }
      };
      var smartcardCapSet = {
         header: {
            capabilityType: RDPDR_TYPE.CAP_TYPES.CAP_SMARTCARD_TYPE,
            capabilityLength: 0x08, //sizeof(printerCapSet)
            version: 1
         }
      };

      var clientCapability = {
         header: {
            component: RDPDR_TYPE.RDPDR_CTYP_CORE,
            packetId: RDPDR_TYPE.PAKID_CORE_CLIENT_CAPABILITY
         },
         numCapabilities: 0x0005,
         padding: 0x0000,
         capabilityMessage: { //array of sub objects
            GENERAL_CAPS_SET: generalCapsSet,
            PRINTER_CAPS_SET: printerCapSet,
            PORT_CAPS_SET: portCapSet,
            DRIVE_CAPS_SET: driveCapSet,
            SMARTCARD_CAPS_SET: smartcardCapSet
         }
      };
      var param = {
         capabilityMessage: ["GENERAL_CAPS_SET", "PRINTER_CAPS_SET", "PORT_CAPS_SET", "DRIVE_CAPS_SET", "SMARTCARD_CAPS_SET"]
      };
      sendResponse("DR_CORE_CAPABILITY_REQ", clientCapability, param);
   };
   var sendClientName = function sendClientName() {
      var machineName = "HorizonClient";
      var clientName = {
         header: {
            component: RDPDR_TYPE.RDPDR_CTYP_CORE,
            packetId: RDPDR_TYPE.PAKID_CORE_CLIENT_NAME
         },
         unicodeFlag: 0x00000001,
         codePage: 0,
         computerNameLen: (machineName.length + 1) * 2, //(cchComputerNameLength + 1) * sizeof(WCHAR),
         computerName: machineName
      };
      sendResponse("DR_CORE_CLIENT_NAME_REQ", clientName);
   };
   /**
    * like Mobile clients webclient also will simplify the capacity to only one.
    * RDSDRQueueClientCapabiltyResponse
    */
   var handleServerCapability = function handleServerCapability(streamHelper) {
      console.error("handleServerCapability");
      /**
      let numCapabilities = streamHelper.getUint16();//force to use only just 1 capacity
      let padding = streamHelper.getUint16();
      let CapabilityMessage = streamHelper.getRest();
         let capacityHelper = new StreamHelper(CapabilityMessage);// of many GENERAL_CAPS_SET
      // CAPABILITY_HEADER;
      let capabilityType = capacityHelper.getUint16();// as CAP_GENERAL_TYPE;
      let capabilityLength = capacityHelper.getUint16(); // as sizeof(GENERAL_CAPS_SET);
      let version = capacityHelper.getUint32(); //as GENERAL_CAPABILITY_VERSION_02;
      //
      let osType = capacityHelper.getUint32();// as 0
      let osVersion = capacityHelper.getUint32();//as 0
      let protocolMajorVersion = capacityHelper.getUint16();//as 1
      let protocolMinorVersion = capacityHelper.getUint16();//as 0xC
      let ioCode1 = capacityHelper.getUint32();//as 0xffff
      let ioCode2 = capacityHelper.getUint32();//as 0
      /**
       * as RDPDR_DEVICE_REMOVE_PDUS |
       * RDPDR_CLIENT_DISPLAY_NAME_PDU |
       * RDPDR_USER_LOGGEDON_PDU;
       *-/
      let extendedPDU = capacityHelper.getUint32();
      let extraFlags1 = capacityHelper.getUint32();//as ENABLE_ASYNCIO;
      let extraFlags2 = capacityHelper.getUint32();// as 0
      let specialTypeDeviceCap = capacityHelper.getUint32();// as 0
       console.warn(capacityHelper.getOffset());
      console.warn(capacityHelper.getRest());
       let serverCapability = {
         capacityHeader:{
            capabilityType: capabilityType,
            capabilityLength: capabilityLength,
            version: version,
         },
         osType:osType,
         osVersion:osVersion,
         protocolMajorVersion:protocolMajorVersion,
         protocolMinorVersion:protocolMinorVersion,
         ioCode1:ioCode1,
         ioCode2:ioCode2,
         extendedPDU:extendedPDU,
         extraFlags1:extraFlags1,
         extraFlags2:extraFlags2,
         specialTypeDeviceCap:specialTypeDeviceCap,
      };
      console.error(serverCapability);
      //sendResponse("PAKID_CORE_CLIENT_CAPABILITY",clientVersion);
      //streamWriter=new StreamWriter();//of struct DR_CORE_CAPABILITY_RSP
      //PAKID_CORE_CLIENT_CAPABILITY;
      */

      sendClientCapability();
      sendClientName();
      return true;
   };
   var handleDeviceReply = function handleDeviceReply() {
      console.error("handleDeviceReply");
      return true;
   };
   var handleIoRequest = function handleIoRequest(streamHelper) {
      console.error("handleIoRequest");
      var param = {
         parameters: function parameters(parsed) {
            var typeMap = {};
            typeMap[RDPDR_TYPE.IRP_MJ_CREATE] = "Create";
            typeMap[RDPDR_TYPE.IRP_MJ_CLOSE] = "Close";
            typeMap[RDPDR_TYPE.IRP_MJ_READ] = "Read";
            typeMap[RDPDR_TYPE.IRP_MJ_WRITE] = "Write";
            typeMap[RDPDR_TYPE.IRP_MJ_DEVICE_CONTROL] = "DeviceControl";
            typeMap[RDPDR_TYPE.IRP_MJ_QUERY_VOLUME_INFORMATION] = "QueryVolumeInformation";
            typeMap[RDPDR_TYPE.IRP_MJ_SET_VOLUME_INFORMATION] = "SetVolumeInformation";
            typeMap[RDPDR_TYPE.IRP_MJ_QUERY_INFORMATION] = "QueryInformation";
            typeMap[RDPDR_TYPE.IRP_MJ_SET_INFORMATION] = "SetInformation";
            typeMap[RDPDR_TYPE.IRP_MJ_DIRECTORY_CONTROL] = function () {
               var minorMap = {};
               minorMap[RDPDR_TYPE.IRP_MN_QUERY_DIRECTORY] = "DirectoryControl";
               minorMap[RDPDR_TYPE.IRP_MN_NOTIFY_CHANGE_DIRECTORY] = "NotifyChangeDirectory";
               if (minorMap.hasOwnProperty(parsed.minorFunction)) {
                  return minorMap[parsed.minorFunction];
               }
               return "NotImplemented";
            }, typeMap[RDPDR_TYPE.IRP_MJ_LOCK_CONTROL] = "LockControl";
            if (!typeMap.hasOwnProperty(parsed.majorFunction)) {
               return null;
            }
            var resultType = typeMap[parsed.majorFunction];
            if (typeof resultType === 'function') {
               return resultType();
            }
            return resultType;
         }
      };
      var serverVersionInfo = protocolHelper.parse(streamHelper, "RDP_DR_DEVICE_IOREQUEST", param);
      return true;
   };

   var handleUserLoggedon = function handleUserLoggedon() {
      console.error("handleUserLoggedon");
      userLoggedOn = true;
      var ret = true;
      if (serverVersion === TDSR_TYPE.VERSION.TSDR_VERSION_V1 || // Backward compatible
      serverVersion !== TDSR_TYPE.VERSION.TSDR_VERSION_UNKNOWN && pPolicy) {
         ret = onUserReady();
      }
      return ret;
   };

   var processData = function processData(stream) {
      console.error("get tsdr message" + stream);
      var type = '';
      var offset = 4;
      var streamHelper = new StreamHelper(stream.params[0]);
      var rdpdrHeader = protocolHelper.parse(streamHelper, "RDPDR_HEADER");
      console.log(rdpdrHeader);
      var ret = true;
      if (rdpdrHeader.component === TDSR_TYPE.TSDR_COMPONENT_CAPS) {
         /*
          * For backward compatibilty and potential race condition,
          * OnUserReady will only be called when
          * User_Login, version and policy are all received.
          */
         //lock policy
         if (rdpdrHeader.packetId === TDSR_TYPE.TSDR_PACKID_VERSION_EXCHANGE) {
            ret = handleVersionExchange();
            if (!!userLoggedOn && (pPolicy || serverVersion === TDSR_TYPE.VERSION.TSDR_VERSION_V1)) {
               onUserReady();
            }
         } else if (rdpdrHeader.packetId === TDSR_TYPE.TSDR_PACKID_AGENT_POLICY) {
            ret = handleTsdrPolicy();
            if (!!userLoggedOn && serverVersion !== TDSR_TYPE.VERSION.TSDR_VERSION_UNKNOWN) {
               onUserReady();
            }
         }
      } else if (rdpdrHeader.component !== RDPDR_TYPE.RDPDR_CTYP_CORE) {
         console.error("Received packet with component != CORE component:" + rdpdrHeader.component + "\n");
         return FALSE;
      }
      /* Handle message */
      switch (rdpdrHeader.packetId) {
         case RDPDR_TYPE.PAKID_CORE_SERVER_ANNOUNCE:
            //DR_CORE_SERVER_ANNOUNCE_REQ
            // exchange tsdr version
            streamHelper.reset();
            ret = handleServerAnnounce(streamHelper);
            break;
         case RDPDR_TYPE.PAKID_CORE_SERVER_CAPABILITY:
            //DR_CORE_CAPABILITY_REQ
            // exchange capability
            ret = handleServerCapability(streamHelper);
            break;
         case RDPDR_TYPE.PAKID_CORE_DEVICE_REPLY:
            ret = handleDeviceReply();
            break;
         case RDPDR_TYPE.PAKID_CORE_USER_LOGGEDON:
            //AutoMutexLock lock(m_policyLock);
            ret = handleUserLoggedon();
            break;
         case RDPDR_TYPE.PAKID_CORE_DEVICE_IOREQUEST:
            ret = handleIoRequest(streamHelper);
            break;
         default:
            ret = true;
      }
      return ret;
   };
   return {
      //onRequestCallback is function([function] onDone), where onDone is function([bool] success, [object]param)
      init: function init(onRequestCallback, onDone) {
         //rdpdrChannel.init(OnData);
         onDone();
      },
      //command, type, param, onDone, onError
      send: function send(request) {
         if (protocolHelper.isInvalidType(request.param.type)) {
            return;
         }
         var dataBuffer = protocolHelper.streamify(request.param);
         //tsdrChannel.invoke();
         /*tsdrChannel.send({
            command: request.command,
            type: request.type,
            param: dataBuffer,
            onDone: request.onDone,
            onAbort: request.onAbort,
            //object/object-name/object-id
         });*/
      },
      handleTSDRFromServer: processData //rdpdrChannel.processData
   };
}

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = tsdrChannelService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _rdpdrChannelManager = __webpack_require__(110);

var _rdpdrChannelManager2 = _interopRequireDefault(_rdpdrChannelManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

function tsdrChannelService() {
   var tsdrChannelNamePrefix = 'RPC#tsdr#';

   function ChannelObj(vdpService) {
      // currently, tsdr channel has ? object names
      this.desiredObjectNames = ['tsdrControlObj', 'tsdrDataObj'];

      this.vdpService = vdpService;

      this.msgHandlers = [];

      this.tsdrChannel = null;
   }

   ChannelObj.prototype.init = function () {
      var self = this;
      this.vdpService.addChannelCreatedListener(function (channel) {
         if (channel.name.indexOf(tsdrChannelNamePrefix) === 0) {
            console.error("connect channel to " + channel.name);
            if (self.vdpService.connectChannel(channel, self.desiredObjectNames)) {
               _jscdkLogger2.default.error('Successfully accepted tsdr channel');
            } else {
               _jscdkLogger2.default.error('Failed to open tsdr channel');
               return;
            }

            self.tsdrChannel = channel;

            channel.onReady = function (object) {
               console.error('tsdr channel is ready for traffic.', object);

               if (object.name === self.desiredObjectNames[0]) {
                  self.tsdrControlObj = object;
                  console.error('tsdr data channel is ready for traffic.');
               } else if (object.name === self.desiredObjectNames[1]) {
                  self.tsdrDataObj = object;
                  console.error('tsdr control channel is ready for traffic.');
               }
               if (self.onReady) {
                  self.onReady(object.name);
               }
            };

            channel.onDisconnect = function () {
               self.tsdrChannel = null;
               _jscdkLogger2.default.error('tsdr channel was closed by the remote desktop.');
            };

            channel.onInvoke = function (tsdr) {
               console.error("!!!!!!!!!!!invoke tsdr", tsdr);
               self.handleTSDRFromServer(tsdr);
            };
         }
      });

      ChannelObj.prototype.onReady = function (objectName) {
         console.error("channel object " + objectName + " ready.");
         if (objectName === self.desiredObjectNames[0]) {
            self.addMessageHandler(new _rdpdrChannelManager2.default(self.tsdrChannel, self.tsdrControlObj));
         }
      };
      ChannelObj.prototype.handleTSDRFromServer = function (tsdr) {
         var i = void 0,
             ret = void 0;
         console.error("!!!!!!!!!!!", tsdr);

         for (i = 0; i < this.msgHandlers.length; i++) {
            ret = this.msgHandlers[i].handleTSDRFromServer(tsdr);
            if (ret === 0) {
               // means the message has been consumed
               break;
            }
         }
      };

      ChannelObj.prototype.addMessageHandler = function (handler) {
         this.msgHandlers.push(handler);
      };

      ChannelObj.prototype.invoke = function (param) {
         console.error("!!!!!!!!!!!", param);
         return this.tsdrChannel.invoke(param);
      };
   };

   return {
      getChannel: function getChannel(vdpService) {
         return new ChannelObj(vdpService);
      }
   };
}

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.clipboard = clipboard;
exports.clipboardController = clipboardController;
exports.clipboardInput = clipboardInput;
exports.panelNotification = panelNotification;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _clip_ft_help_template = __webpack_require__(60);

var _clip_ft_help_template2 = _interopRequireDefault(_clip_ft_help_template);

var _clipboard_template = __webpack_require__(259);

var _clipboard_template2 = _interopRequireDefault(_clipboard_template);

var _mksvchan = __webpack_require__(12);

var _mksvchan2 = _interopRequireDefault(_mksvchan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function clipboard($window, panelService, $timeout) {
   return {
      restrict: 'E',
      replace: true, // Replace with the template below
      templateUrl: _clipboard_template2.default,
      scope: true,
      link: function link(scope, element) {
         var savedClipboardHeight = 0,
             panelServiceInstance = panelService.getService();

         panelServiceInstance.addPanelElement('clipboard', element);

         element.resizable({
            containment: "document"
         }).draggable({
            containment: "window",
            handle: ".clipboard-handle",
            start: function start(event, ui) {
               element.css("z-index", panelServiceInstance.getNewZIndex());
            }
         });

         scope.windowResizeHandler = panelServiceInstance.windowResizeHandler(scope, 'showClipboardPanel', element);

         _angular2.default.element($window).bind('resize', scope.windowResizeHandler);

         // resizes the clipboard contents to fit within the clipboard
         // panel
         scope.resizeClipboardContents = function () {
            if (scope.showClipboardText) {
               /**
                * clipboard contents sit under the label and fills the
                * remaining panel space. Its height is panel height minus
                * label height.
                *
                * 39 is the header height and 19 is the footer height.
                */
               var newHeight = element.outerHeight() - 36 - 19;
               (0, _jquery2.default)('.clipboard-content').css('height', newHeight);
            }
         };

         /*
          * minimizes/restores the clipboard panel. Needs to remember the panel
          * height on minimize and then set the height on restore.
          */
         scope.toggleClipboardText = function () {
            if (scope.showClipboardText) {
               savedClipboardHeight = element.outerHeight();
               element.addClass('minimized');
            } else {
               element.css('height', savedClipboardHeight);
               element.removeClass('minimized');
               scope.resizeClipboardContents();
            }
            scope.showClipboardText = !scope.showClipboardText;
         };

         element.bind('resize', scope.resizeClipboardContents);

         scope.$on('$destroy', function () {
            element.unbind('resize', scope.resizeClipboardContents);
            _angular2.default.element($window).unbind('resize', scope.windowResizeHandler);
         });
         $timeout(function () {
            scope.resizeClipboardContents();
         });
      }
   };
} /********************************************************
   * Copyright 2016 VMware, Inc.  All rights reserved.
   ********************************************************/

function clipboardController(AB, $scope, $rootScope, $timeout, ngDialog, wmksService, _, wmksServiceEventHandler, panelService) {
   var defaultText = '';
   $scope.clipboard = { text: defaultText };
   $scope.clipboardPolicy = { text: '' };
   $scope.clipboardInput = null;
   $scope.focused = false;
   $scope.showNotification = null;
   $scope.showClipboardPanel = false;
   $scope.showClipboardText = true;
   $scope.toggleClipboardText = null;
   $scope.hasClipboardData = false;
   $scope.clipboardReady = false;
   $scope.copyEnabled = true;
   $scope.pasteEnabled = true;
   $scope.isMacOS = WMKS.BROWSER.isMacOS;
   $scope.windowResizeHandler = null;
   $scope.resizeClipboardContents = null;

   $scope.setDefaultPolicyText = function () {
      var policyText = '';
      if (!$scope.clipboardReady) {
         policyText = _('COPY_PASTE_UNAVAILABLE_CONTENT');
      } else if ($scope.clipboardReady && $scope.copyEnabled && $scope.pasteEnabled) {
         policyText = _('COPY_PASTE_ENABLED_CONTENT');
      } else if ($scope.clipboardReady && $scope.copyEnabled && !$scope.pasteEnabled) {
         policyText = _('PASTE_DISABLED_CONTENT');
      } else if ($scope.clipboardReady && !$scope.copyEnabled && $scope.pasteEnabled) {
         policyText = _('COPY_DISABLED_CONTENT');
      } else if ($scope.clipboardReady && !$scope.copyEnabled && !$scope.pasteEnabled) {
         policyText = _('COPY_PASTE_DISABLED_CONTENT');
      }
      $scope.clipboardPolicy.text = policyText;
   };

   // Redirects input to the clipboard's hidden input
   $scope.focusInput = function () {
      if ($scope.clipboardInput) {
         $timeout(function () {
            $scope.clipboardInput.select();
         });
      }
   };

   // Clears clipboard contents
   $scope.clipboardClear = function () {
      $scope.clipboard.text = defaultText;
      wmksService.clearClipboard();
      $scope.showNotification('CLIPBOARD_CLEARED_M');
      $scope.hasClipboardData = false;
   };

   /*
    * Intercepts a copy event and replaces the copied text with the current
    * clipboard contents.
    */
   $scope.clipboardCopy = function (e) {
      AB.LOGGER.log("Copy operation is captured.");
      if (!$scope.hasClipboardData) {
         AB.LOGGER.log("There is no data in the clipboard.");
         return;
      }

      AB.UTIL.setClipboardText(e, $scope.clipboard.text);

      $scope.showNotification('CLIPBOARD_COPIED_M');
      $scope.focusInput();
      e.preventDefault();
   };

   /*
    * Intercept a paste event to get paste data, then update clipboard and send
    * the appropriate call to update the server clipboard.
    */
   $scope.clipboardPaste = function (e) {
      var text = void 0;

      AB.LOGGER.log("Paste operation is captured and data is sent to remote server.");
      text = AB.UTIL.getClipboardText(e);
      wmksService.sendClipboardText(text);

      $scope.focusInput();
      e.preventDefault();
   };

   // Handle clipboard panel focus event
   $scope.clipboardFocus = function () {
      if ($scope.showClipboardPanel) {
         $scope.focused = true;
         panelService.getService().onFocus('clipboard');
      }
   };

   // Handle clipboard panel blur event
   $scope.clipboardBlur = function () {
      $scope.focused = false;
   };

   // shows/hides the clipboard panel
   $scope.toggleClipboardPanel = function ($event) {
      $scope.showClipboardPanel = !$scope.showClipboardPanel;
      if ($scope.showClipboardPanel) {
         $timeout(function () {
            $scope.windowResizeHandler();
            $scope.resizeClipboardContents();
         });
      }

      if ($event) {
         $event.stopPropagation();
         $event.preventDefault();
      }
      $scope.focusInput();
   };

   $scope.openClipboardHelp = function () {

      var modKey = $scope.isMacOS() ? _('CMD_KEY') : _('CTRL_KEY');

      ngDialog.open({
         name: "ClipboardHelpWindow", // dialog name
         templateUrl: _clip_ft_help_template2.default, // dialog template
         className: "clipboard-help-window", // CSS class
         data: {
            title: 'CLIPBOARD_HELP_DIALOG_T',
            msg: 'CLIPBOARD_HELP_DIALOG_M',
            modKey: modKey
         },
         showClose: false, // do not show close button
         closeByEscape: true, // allow escape to close window
         closeByDocument: true // allow clicking on background to close
      });
   };

   // Listen to server clipboard updates and sync panel with remote
   // clipboard data
   wmksServiceEventHandler.addEventListener('clipboardChanged', function (data, error) {
      $timeout(function () {
         AB.LOGGER.log("Clipboard data in the remote server is synced to client.");
         if (data === null) {
            $scope.showNotification('CLIPBOARD_FAILED_M');
            return;
         }

         $scope.clipboard.text = data;
         $scope.hasClipboardData = true;

         if (error === _mksvchan2.default.CLIPBOARD_ERROR.MAX_LIMIT_EXCEEDED) {
            $scope.showNotification('CLIPBOARD_TRUNCATED_M');
         } else {
            $scope.showNotification('CLIPBOARD_SYNCED_M');
         }
      });
   });

   wmksServiceEventHandler.addEventListener("clipboardCapabilitiesChanged", function (clipboardReady, copyEnabled, pasteEnabled) {
      $timeout(function () {
         $scope.clipboardReady = clipboardReady;
         $scope.copyEnabled = copyEnabled;
         $scope.pasteEnabled = pasteEnabled;
         $scope.setDefaultPolicyText();
      });
   });

   wmksServiceEventHandler.addEventListener('clipboardRequestFailed', function (data) {
      $scope.showNotification('CLIPBOARD_FAILED_M');
   });
   wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.CLIPBOARD);

   $rootScope.$on('toggleClipboardPanel', $scope.toggleClipboardPanel);
}

function clipboardInput() {
   return {
      restrict: 'E',
      replace: true, // Replace with the template below
      template: "<input></input>",
      link: function link(scope, element) {
         scope.clipboardInput = element;
         element.val(" ");
      }
   };
}

function panelNotification(_) {
   return {
      restrict: 'E',
      replace: true, // Replace with the template below
      template: "<div></div>",
      link: function link(scope, element) {
         element.addClass("hidden");
         element.addClass('clipboard-notification');
         element.addClass('noselect');

         // Removes notification element from display at end of fade
         // animation
         element.bind('transitionend oTransitionEnd webkitTransitionEnd', function () {
            element.addClass("hidden");
            element.removeClass("hideme");
         });

         // Shows a popup notification with the given text that then fades
         // out
         scope.showNotification = function (msgKey) {
            var temp = void 0;
            element.html(_(msgKey));
            element.removeClass("hidden");
            element.removeClass("hideme");
            /*
             * Accessing offsetHeight forces reflow, which updates classes and
             * styling and restarts the fadeout animation. We don't need to use
             * the value, but we have to assign it to something to prevent lint
             * errors.
             */
            temp = element[0].offsetHeight;
            element.addClass("hideme");
         };
      }
   };
}

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.ajaxBusyOverlay = ajaxBusyOverlay;
exports.ajaxBusyOverlayController = ajaxBusyOverlayController;
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * ajax-busy-overlay.js --
 *
 * Module to implement a busy overlay to indicate server is busy.
 *
 */

function ajaxBusyOverlay() {
   return {
      restrict: 'E',
      scope: {},
      controller: 'ajaxBusyOverlayController',
      template: '<div ng-show="showAjaxBusyOverlay"><div class="ajax-busy-overlay"/><div class="ajax-busy-icon"/><div>'
   };
}

function ajaxBusyOverlayController($scope, $rootScope, $timeout) {
   // Variable that toggles the visibility of ajax busy overlay
   // $scope.showAjaxBusyOverlay = false;
   $scope.showAjaxBusyOverlay = false;

   // Listen on the root scope for the event that tells us to display
   // ajax busy overlay.
   $rootScope.$on('toggleBusyOverlay', function (e, flag) {
      // We need a timeout here for it might be called in the digest or
      // not in digest process.
      $timeout(function () {
         if (typeof flag !== "undefined") {
            $scope.showAjaxBusyOverlay = flag;
         } else {
            $scope.showAjaxBusyOverlay = !$scope.showAjaxBusyOverlay;
         }
      });
   });
}

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = applicationSessionsModel;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function applicationSessionsModel(jscdkDesktopInvoker, viewClientModel, constants) {
   var applicationSessions = null,
       callbackBuff = null;

   /**
    * should be in the commen codes, but put it here now
    */
   function getApplicationSessions(data, targetList) {
      var applicationSessionSet = void 0,
          applicationSessionKey = void 0;
      if (data && data.content) {
         //store the application-sessions localContent
         applicationSessionSet = data.content.applicationSessions;
         for (applicationSessionKey in applicationSessionSet) {
            /* istanbul ignore else */
            if (applicationSessionSet.hasOwnProperty(applicationSessionKey)) {
               targetList.push(applicationSessionSet[applicationSessionKey]);
            }
         }
      }
   }

   /**
    * handle the readed object from safe storage with key(EntitledItems),
    * and construct entitled item.
    */
   function onStorageReaded(localContent) {
      // set the list using localContent
      applicationSessions = [];
      getApplicationSessions(localContent, applicationSessions);
      // clear buff first in case callback will call
      // getApplicationSessions again
      /* istanbul ignore else */
      if (!!callbackBuff) {
         var callbackFunc = callbackBuff;
         callbackBuff = null;
         callbackFunc(applicationSessions);
      }
   }

   /**
    * ApplicationSessionModel.getApplicationSessions
    *
    * Return a array of application session
    *
    */
   this.getApplicationSessions = function (callback, jscdkHandler, useBuffedData) {
      /* istanbul ignore if */
      if (!!callbackBuff) {
         _jscdkLogger2.default.debug("Error: the getApplicationSessions do not support parallal" + " usage");
         return;
      }
      if (typeof callback !== "function") {
         _jscdkLogger2.default.debug("Error: the callback passed to getApplicationSessions is" + " not a function");
         return;
      }
      if (applicationSessions !== null && useBuffedData) {
         _jscdkLogger2.default.debug("applicationSessions is already readed and used");
         callback(applicationSessions);
      } else {
         _jscdkLogger2.default.debug("applicationSessions not fully inited");

         jscdkHandler.handlerGetLaunchItems = function (localContent) {
            onStorageReaded(localContent);
         };
         callbackBuff = callback;
         viewClientModel.onReady(function () {
            /**
             * sync model into jscdk to init environment info for get-launch-item to
             * support: https://jira-hzn.eng.vmware.com/browse/DPM-1211
             * decouple from current _getEnvironmentInfo since they are different,
             * and under current code structure better to be seperated.
             */
            var environmentInfo = {};

            if (!!viewClientModel.ipAddress) {
               environmentInfo['IP_Address'] = viewClientModel.ipAddress;
               environmentInfo['Machine_Name'] = viewClientModel.machineName;
            }
            if (!!viewClientModel.clientID) {
               environmentInfo['Client_ID'] = viewClientModel.clientID;
            }
            environmentInfo['Client_Version'] = viewClientModel.version + '-' + viewClientModel.buildNum;
            environmentInfo['Type'] = constants.viewclientType;
            jscdkDesktopInvoker.setEnvironmentInfo(environmentInfo);
            jscdkDesktopInvoker.sendLaunchItemsXML();
         });
      }
   };
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * applicationsessions-model.js --
 *
 * Module to provide application sessions information to decide session usage
 * when launching from Sidebar, this should be realized in commen folder as the
 * model for manipulate items, but put it here for now.
 *
 * The async API of getApplicationSessions is caused by using the jscdk to get
 * the list from the broker.
 */

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = audioService;
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * audio-service.js --
 *
 * Factory service for playing audio.
 *
 */

function audioService(AB, $window, WMKS) {
   var audioEnabled = false,
       audioUseOpus = false,
       audioUseAac = false,
       audioUseWebAudioAPI = false,
       MAX_CHANNEL_NUMBER = 2,
       MSG_TYPE_CHANNEL_VOLUME_MUTE = 0,
       MSG_TYPE_CHANNEL_VOLUME_CHANGE = 1,
       init = void 0,
       AudioServiceFactory = null,
       globalAudioContext = null;

   /**
    * init
    *
    * Test browser API compatibility and set proper global variables.
    *
    */
   init = function init() {
      var test = void 0;
      try {
         test = new Audio();
         $window.URL = $window.URL || $window.webkitURL;
         audioUseOpus = test.canPlayType('audio/ogg; codecs="opus"') === 'probably';
         audioUseAac = test.canPlayType('audio/mp4; codecs="mp4a.40.2"') === 'probably';
         audioEnabled = true;
         AB.LOGGER.info('HTML5 Audio is available, Opus = ' + audioUseOpus + " AAC: " + audioUseAac);
      } catch (e2) {
         AB.LOGGER.info('HTML5 Audio is unavailable.');
      }

      try {
         $window.AudioContext = $window.AudioContext || $window.webkitAudioContext;
         globalAudioContext = new AudioContext();

         /*
          * This is necessary due to:
          * https://developer.mozilla.org/en-US/docs/Web_Audio_API/Porting_webkitAudioContext_code_to_standards_based_AudioContext
          */
         if (typeof $window.AudioContext.prototype.createGain === 'undefined') {
            $window.AudioContext.prototype.createGain = $window.AudioContext.prototype.createGainNode;
         }

         audioUseWebAudioAPI = true;
         AB.LOGGER.info('Web Audio API support is available.');
      } catch (e) {
         globalAudioContext = null;
         AB.LOGGER.info('Web Audio API support is unavailable.');
      }
   };

   /**
    * AudioServiceFactory
    *
    * Constructor function.
    *
    */
   AudioServiceFactory = function AudioServiceFactory() {
      this.audioNextTime = 0;
      this.volumeInfo = [];
      this.isMuted = false;
      this.lastUpdateChannelId = 0;
      // We support 2 channels at most. The default value is 1.
      for (var i = 0; i < MAX_CHANNEL_NUMBER; i++) {
         this.volumeInfo.push(1.0);
      }
   };

   /**
    * AudioServiceFactory.isAudioEnabled
    *
    * Return whether audio is enabled on the browser.
    *
    */
   AudioServiceFactory.prototype.isAudioEnabled = function () {
      return audioEnabled;
   };

   /**
    * AudioServiceFactory.updateAudioMixer
    *
    * Update the audio mixer for each channel.
    *
    */
   AudioServiceFactory.prototype.updateAudioMixer = function (audioMixerInfo) {
      var volumeNumber = 0;
      var db = void 0;
      if (audioMixerInfo.msgType === MSG_TYPE_CHANNEL_VOLUME_CHANGE) {
         /*
          * Convert from volume level ticks to dB.
          */
         db = audioMixerInfo.data / 0x10000;

         /*
          * Solve for the amplitude of the dB.
          * dB = 10 log_10(A^2) = 20 log_20(A); A = 10^(dB / 20).
          */
         volumeNumber = Math.pow(10.0, db / 20);

         /*
          * Only allow attenuation through sndconvert.
          */
         if (volumeNumber > 1.0) {
            volumeNumber = 1.0;
         }
         this.volumeInfo[audioMixerInfo.channelId] = volumeNumber;
         this.lastUpdateChannelId = audioMixerInfo.channelId;
      } else if (audioMixerInfo.msgType === MSG_TYPE_CHANNEL_VOLUME_MUTE) {
         // Audio muted update.
         this.isMuted = !!audioMixerInfo.data;
      } else {
         return;
      }
   };

   /**
    * AudioServiceFactory.canAudioUseOpus
    *
    * Return whether audio Opus is supported on the browser.
    *
    */
   AudioServiceFactory.prototype.canAudioUseOpus = function () {
      return audioUseOpus;
   };

   /**
    * AudioServiceFactory.canAudioUseAac
    *
    * Return whether audio Aac is supported on the browser.
    *
    */
   AudioServiceFactory.prototype.canAudioUseAac = function () {
      return audioUseAac;
   };

   /**
    * AudioServiceFactory.initializeAudioForTouch
    *
    * Initialize variables for touch device.
    *
    */
   AudioServiceFactory.prototype.initializeAudioForTouch = function () {
      var silentTone = void 0;
      var gainNode = void 0;

      if (!audioUseWebAudioAPI) {
         // We only need to do this for the Web Audio API.
         return true;
      }

      AB.LOGGER.trace('Initializing audio for touch.');

      try {
         silentTone = globalAudioContext.createOscillator();
         gainNode = globalAudioContext.createGain();

         gainNode.gain.value = 0;
         gainNode.connect(globalAudioContext.destination);

         silentTone.type = 'sine';
         silentTone.frequency.value = 200;
         silentTone.connect(gainNode);
         silentTone.noteOn(0);
         silentTone.stop(0);
      } catch (e) {
         AB.LOGGER.info('Fail to Initialize audio for touch.');
      }

      /*
       * Ironically, audio should now be unmuted.
       * Explanation: http://stackoverflow.com/questions/12517000/no-sound-on-ios-6-web-audio-api
       */
      return true;
   };

   /**
    * AudioServiceFactory.playAudio
    *
    * Play a clip of audio information.
    *
    * @params audioInfo audio byte streams.
    */
   AudioServiceFactory.prototype.playAudio = function (audioInfo) {
      var buffer = new ArrayBuffer(audioInfo.data.length);
      var bufferView = new Uint8Array(buffer);

      AB.LOGGER.trace('Received ' + audioInfo.data.length + ' audio bytes.');

      for (var i = 0; i < audioInfo.data.length; i++) {
         bufferView[i] = audioInfo.data[i];
      }

      if (globalAudioContext) {
         // Web Audio API
         this.playAudioWithWebAudioAPI(audioInfo, buffer);
      } else {
         // HTML5 audio object
         this.playAudioWithAudioObject(audioInfo, buffer);
      }
   };

   /**
    *
    * AudioServiceFactory.createBufferSource
    *
    * This is to work around Web Audio API portability issues across
    * browsers. See:
    * https://developer.mozilla.org/en-US/docs/Web_Audio_API/Porting_webkitAudioContext_code_to_standards_based_AudioContext
    *
    */
   AudioServiceFactory.prototype.createBufferSource = function () {
      var source = globalAudioContext.createBufferSource();
      if (typeof source.start === 'undefined') {
         source.start = source.noteOn;
      }
      if (typeof source.stop === 'undefined') {
         source.stop = source.noteOff;
      }
      return source;
   };

   /**
    *
    * playAudioWithWebAudioAPI
    *
    * Play audio using the Web Audio API.
    *
    * @params audioInfo audio byte streams.
    * @params buffer    buffer source.
    */
   AudioServiceFactory.prototype.playAudioWithWebAudioAPI = function (audioInfo, buffer) {
      var self = this;

      globalAudioContext.decodeAudioData(buffer, function (audioBuffer) {
         var source = self.createBufferSource();
         var gainNodeArray = [];
         var curTime = globalAudioContext.currentTime;
         var offset = self.audioNextTime - curTime;
         var delay = Math.max(offset, 0);
         var startTime = curTime + delay;
         var duration = audioInfo.containerSize / 1000.0;
         var overlap = audioInfo.sampleRate / 1000.0;
         var durationDiff = audioBuffer.duration - duration;
         var fadeInBy = startTime + overlap;
         var fadeOutAt = startTime + duration - overlap;
         var endTime = startTime + duration;
         var numberOfChannels = audioInfo.numChannels;
         var channelSplitter = null;
         var channelMerger = null;

         for (var i = 0; i < numberOfChannels; i++) {
            gainNodeArray.push(globalAudioContext.createGain());
         }

         /*
          * "audioBuffer.duration" will always be slightly larger or
          * slightly smaller than the original PCM duration which
          * is sent over as "audioInfo.containerSize". We want to
          * keep the original duration.
          *
          * "overlap" is the amount of time which this clip
          * overlaps with the previous one. We encode redundant
          * data so we can effectively crossfade and minimize
          * any audio glitches at the seams caused by stitching
          * together lossy clips. We want the next track to start
          * at the overlap point and then we crossfade between the
          * two.
          */
         self.audioNextTime = startTime + duration - overlap;

         // Extensive log computation, hence moving it inside a log
         // level check.
         if (AB.LOGGER.LOG_LEVEL === AB.LOGGER.LEVEL_TRACE) {
            AB.LOGGER.trace('Playing audio (Web Audio API)');
            AB.LOGGER.trace('Offset: ' + offset + 's' + ', delay: ' + delay + 's' + ', current time: ' + curTime);
            AB.LOGGER.trace('Sample rate: ' + audioBuffer.sampleRate + ', frames: ' + audioBuffer.length + ', channels: ' + audioBuffer.numberOfChannels);
            AB.LOGGER.trace('Lossy duration: ' + audioBuffer.duration + 's' + ', PCM duration: ' + duration + 's' + ', diff: ' + durationDiff + 's');
            AB.LOGGER.trace('Start: ' + startTime + 's' + ', fade in by: ' + fadeInBy + 's' + ', fade out at: ' + fadeOutAt + 's');
            AB.LOGGER.trace('End: ' + endTime + 's' + ', overlap: ' + overlap + 's');
         }

         source.buffer = audioBuffer;
         if (numberOfChannels === 1) {
            source.connect(gainNodeArray[0]);
            gainNodeArray[0].connect(globalAudioContext.destination);
         } else if (numberOfChannels === 2) {
            /*
             * We need to split audio track to left and right channels. Add a
             * GainNode to control the volume for each channel. Finally, merge
             * the two channel to an audio track. Here is an example from mozilla.
             * See: https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createChannelSplitter
             */
            channelSplitter = globalAudioContext.createChannelSplitter(2);
            channelMerger = globalAudioContext.createChannelMerger(2);
            source.connect(channelSplitter);
            for (var _i = 0; _i < numberOfChannels; _i++) {
               channelSplitter.connect(gainNodeArray[_i], _i);
               gainNodeArray[_i].connect(channelMerger, 0, _i);
            }
            channelMerger.connect(globalAudioContext.destination);
         }

         /*
          * Fade in...
          */
         if (overlap && !self.isMuted) {
            for (var _i2 = 0; _i2 < numberOfChannels; _i2++) {
               gainNodeArray[_i2].gain.linearRampToValueAtTime(0, startTime);
               gainNodeArray[_i2].gain.linearRampToValueAtTime(self.volumeInfo[_i2], fadeInBy);
            }
         }

         for (var _i3 = 0; _i3 < numberOfChannels; _i3++) {
            gainNodeArray[_i3].gain.setValueAtTime(!self.isMuted ? self.volumeInfo[_i3] : 0, startTime);
         }

         source.start(startTime);

         /*
          * Fade out...
          */
         if (overlap && !self.isMuted) {
            for (var _i4 = 0; _i4 < numberOfChannels; _i4++) {
               gainNodeArray[_i4].gain.linearRampToValueAtTime(self.volumeInfo[_i4], fadeOutAt);
               gainNodeArray[_i4].gain.linearRampToValueAtTime(0, endTime);
            }
         }
      }, function () {
         AB.LOGGER.trace('Error decoding audio data.');
      });
   };

   /**
    *
    * playAudioWithAudioObject
    *
    * Play audio using an HTML5 audio object.
    *
    * @params audioInfo audio byte streams.
    * @params buffer    buffer source.
    */
   AudioServiceFactory.prototype.playAudioWithAudioObject = function (audioInfo, buffer) {
      var self = this;
      var audio = new Audio();
      var audioType = (audioInfo.flags & WMKS.VNCDecoder.prototype.audioflagFmtMask) >> WMKS.VNCDecoder.prototype.audioflagFmtShift;
      var mimeType = audioType === WMKS.VNCDecoder.prototype.audioFlagFmtClipsOpus ? 'audio/ogg' : 'audio/mp4';
      var blob = new Blob([buffer], { type: mimeType });

      var playClip = function playClip() {
         var curTime = new Date().getTime();
         // audioInfo.containerSize is really our duration!
         var duration = audioInfo.containerSize;
         // audioInfo.sampleRate is really our overlap!
         var overlap = audioInfo.sampleRate;
         var offset = self.audioNextTime - curTime;
         var delay = Math.max(offset, 0);

         self.audioNextTime = curTime + delay + duration - overlap;

         if (AB.LOGGER.LOG_LEVEL === AB.LOGGER.LEVEL_TRACE) {
            AB.LOGGER.trace('Playing audio (HTML5 Audio object)');
            AB.LOGGER.trace('Offset: ' + offset + 'ms' + ', delay: ' + delay + 'ms' + ', current time: ' + curTime + ', duration: ' + duration + 'ms' + ', overlap: ' + overlap + 'ms');
         }
         setTimeout(function () {
            audio.muted = self.isMuted;
            if (!self.isMuted) {
               audio.volume = self.volumeInfo[self.lastUpdateChannelId];
            }
            audio.play();
            if (overlap) {
               /*
                * The audio object doesn't really support our
                * crossfade trick so start playing after any
                * overlap.
                */
               try {
                  /*
                   * This can throw an exception if the metadata
                   * hasn't been loaded yet.
                   */
                  audio.currentTime = overlap / 1000.0;
               } catch (e) {
                  AB.LOGGER.warn('Error setting currentTime!');
               }
            }
            setTimeout(function () {
               $window.URL.revokeObjectURL(audio.src);
            }, duration + 20);
         }, delay);
      };

      audio.src = $window.URL.createObjectURL(blob);
      audio.addEventListener('loadeddata', playClip, false);
   };

   // Initialize all global browser compatibility variables.
   init();
   return {
      /**
       *
       * getAudioServiceInstance
       *
       * Return an audio service instance.
       *
       */
      getAudioServiceInstance: function getAudioServiceInstance() {
         return new AudioServiceFactory();
      }
   };
}

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = blastWmks;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

var _dialog_service_confirm = __webpack_require__(26);

var _dialog_service_confirm2 = _interopRequireDefault(_dialog_service_confirm);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Todo Remove those two constants.
/******************************************************************************
 * Copyright 2014-2017 VMware, Inc.  All rights reserved.
 *****************************************************************************/

/**
 *------------------------------------------------------------------------------
 *
 * blast-wmks-service.js
 *
 * Blast WMKS client implementation for use with NGP.
 * AB.CONST and WMKS are pre-requisite namespaces.
 *
 *------------------------------------------------------------------------------
 */

_appblastUtil2.default.CONST.BlastWMKS = {
   BSG_TIMEOUT_MS: 2 * 60 * 1000 - 1, // Just under 2 mins.
   INIT_BACKOFF_DELAY_MS: 1000,
   REQUEST_DISCONNECT_TIMEOUT: 5000,
   MAP_META_TO_CTRL_FOR_KEYS: [65, 67, 86, 88], // Map CMD to CTRL when used
   // with A, C, V and X
   IGNORE_RAW_KEY_CODES: [20], // CAPS: VK_CAPITAL = 20
   WIN_KEY_CODES: [91, 92] // WIN: VK_LWIN = 91, VK_RWIN = 92
};

function blastWmks($window, ngDialog, audioService, safeStorageService, VDPService, MKSVchan, RTAVService, multimonRenderingService, $timeout, WMKS, AB, $, _, $rootScope, $q, mainChannelService, tsdrChannelService) {

   var containerId = 0,
       mp4Enabled = false,
       BlastWMKS = function BlastWMKS(wmksService, key, isApplicationSession, isShadow, name) {
      // Private var to denote wmks connected state.
      this.isWmksConnected = false;
      this.isWmksActive = false;
      this.isDestroyed = false;
      this.wasWmksConnectedOnce = false;
      this.isActive = false;
      this.clipboardReady = false;

      this.key = key;
      containerId++;
      this.canvasId = containerId;

      /*
       * Stores clipboard capabilities for this session. Default to enabled
       * since wmks only gives us an update if either is disabled.
       */
      this.copyEnabled = true;
      this.pasteEnabled = true;

      this.multimonServerEnabled = false;

      this.isMP4Enabled = false;

      this.wmksOfflineMessageQueue = [];

      this.backoffDelayMs = AB.CONST.BlastWMKS.INIT_BACKOFF_DELAY_MS;
      // Initialize our various timers to null.
      this.heartbeatTimeout = null;
      this.reconnectTimeout = null;
      this.backoffTimeout = null;
      this.disconnectRequestTimeout = null;

      this.wmksContainer = null;

      this.requestedDisconnect = false;
      this.isApplicationSession = isApplicationSession !== undefined ? isApplicationSession : true;
      this.isShadow = isShadow !== undefined ? isShadow : false;
      this.isEmpty = true;

      this.audioService = audioService.getAudioServiceInstance();
      this.mksVchanClient = null;
      this.url = null;
      this.name = name || "";

      this.closeReasonFromBlast = undefined;
      this.disconnectedDialog = null;
      this.disconnectedDialogOption = null;
      // The delegate object to handle some events.
      this.wmksService = wmksService;
      this.remoteDPI = 0;
      this.mainChannel = null;
      this.tsdrChannel = null;

      /**
       * scale factor is added for bug 1792047
       *
       * When remote agent DPI is more than 100%, displayed cursor is
       * way bigger than host OS cursor.  Client scaling way is taking
       * MAC client as the reference as MAC client is doing cursor
       * scaling.
       *
       * Regarding the factor value which is 105 in this commit,
       * ideally it should be 96 because according to dumped cursor
       * image, it's 2 times larger when DPI is 200% than 100%.
       * However, when doing cursor scaling, we may need to
       * compensate the canvas size.  105 is chosen according the
       * reservation.
       */
      this.cursorFactor = 105;

      this.cursorHandler = function (src, width, height, postResize, hotx, hoty) {
         var _this = this;

         var ratio = void 0;

         if (this.remoteDPI !== 0 && this.remoteDPI !== 96) {
            ratio = parseFloat(this.remoteDPI / this.cursorFactor);
            $q(function (resolve, reject) {
               var img = new Image();

               img.onload = function () {
                  resolve(img);
               };
               img.src = src;
            }).then(function (img) {
               var ctx = void 0;

               if (!_this.canvas) {
                  _this.canvas = document.createElement("canvas");
               }

               _this.canvas.width = Math.round(width / ratio);
               _this.canvas.height = Math.round(_this.canvas.width * parseFloat(height / width));
               ctx = _this.canvas.getContext("2d");
               ctx.drawImage(img, 0, 0, _this.canvas.width, _this.canvas.height);

               return _this.canvas.toDataURL("image/x-icon");
            }).then(function (url) {
               var hx = void 0,
                   hy = void 0;

               // need to scale hotspot as well
               if (!!hotx) {
                  hx = Math.round(hotx / ratio);
               }
               if (!!hoty) {
                  hy = Math.round(hoty / ratio);
               }
               AB.LOGGER.debug("[MKS]ratio=" + ratio + ", hx=" + hx + ", hy=" + hy);
               postResize(url, hx, hy);
            });
         } else {
            postResize(src);
         }
      }.bind(this);
   };

   /**
    * initialize
    *
    * Initialize the WMKS client given a URL.
    * NOTE: #canvas-container is the parent that shows the grey screen
    * and
    * hence WMKS should be added inside this div. It is also the parent
    * div for positioning jquery ui dialogs.
    *
    * @param url target agent uri user is connecting to.
    * @param settings contains prperties enableHighResMode,
    *    useMacOSXKeySettings, enableWindowsKey, enableMP4
    */
   BlastWMKS.prototype.initialize = function (url, settings) {
      var self = this,
          targetUrl = url,
          screenSize = AB.UTIL.getDesiredResolution(),
          ignoredRawKeyCodes = void 0,
          enableHighResMode = !!settings && settings.enableHighResMode,
          useMacOSXKeySettings = !!settings && settings.useMacOSXKeySettings,
          enableWindowsKey = !!settings && settings.enableWindowsKey,
          enableMP4 = !!settings ? settings.enableMP4 : undefined,
          fitGuest = !this.isShadow,
          fitToParent = this.isShadow;

      // Nullify this in case we came here via the reconnect path.
      this.url = targetUrl;

      /*
       * settings object contains properties:
       * {
       *     enableHighResMode,
       *     useMacOSXKeySettings,
       *     enableWindowsKey,
       *     enableMP4
       * }
       */
      this.settings = settings;

      if (this.backoffTimeout) {
         $timeout.cancel(this.backoffTimeout);
         this.backoffTimeout = null;
      }

      // Windows key is diabled in an application session.
      enableWindowsKey = !this.isApplicationSession && enableWindowsKey;
      // If Windows key simulation is disabled, don't process WIN code.
      ignoredRawKeyCodes = enableWindowsKey ? AB.CONST.BlastWMKS.IGNORE_RAW_KEY_CODES : AB.CONST.BlastWMKS.IGNORE_RAW_KEY_CODES.concat(AB.CONST.BlastWMKS.WIN_KEY_CODES);
      this.isMP4Enabled = _angular2.default.isDefined(enableMP4) ? enableMP4 : this.isMP4Enabled;

      mp4Enabled = this.isMP4Enabled;

      /*
       * Setup our wmks widget.
       *
       * 1. Set the preferred screen size to wmks container, so it autofits
       *    upon connection.
       * 2. Blast requests the desired resolution, hence:
       *    if it is a primary session, we set fitToParent = false, fitToGuest = true.
       *    if it is a shadow session, we will set fitToGuest = false.
       * 3. Browser sends unicode and raw keyboard inputs, set flag.
       * 4. Do not process CAPS LOCK keys (send as non-unicode keys).
       *    If Windows key simulation is disabled, don't process WIN code.
       *    VK_LWIN = 91, VK_RWIN = 92, CAPS: VK_CAPITAL = 20 are non-unicode keys.
       *    NOTE: Unicode 91, 92 are [ and \ respectively. (PR 885884)
       */
      this.wmksContainer = $('<div/>', { id: 'wmksContainer' + this.canvasId }).appendTo($(AB.CONST.CANVAS_PARENT_ID)).css({
         position: 'absolute',
         display: 'none',
         border: 0
      });

      this.wmksContainer.hideLoading = false;
      this.updateResolution(screenSize, false);
      this.wmksContainer.wmks({
         useVNCHandshake: false,
         fitToParent: fitToParent,
         fitGuest: fitGuest,
         useUnicodeKeyboardInput: true,
         enableOpusAudioClips: this.audioService.isAudioEnabled() && this.audioService.canAudioUseOpus(),
         enableAacAudioClips: this.audioService.isAudioEnabled() && this.audioService.canAudioUseAac(),
         enableVMWSessionClose: true,
         enableSubRectangleCache: true,
         enableMP4: this.isMP4Enabled,
         enableVMWAudioMixer: true,
         sendProperMouseWheelDeltas: true,
         ignoredRawKeyCodes: ignoredRawKeyCodes,
         retryConnectionInterval: -1,
         useNativePixels: enableHighResMode,
         mapMetaToCtrlForKeys: useMacOSXKeySettings ? AB.CONST.BlastWMKS.MAP_META_TO_CTRL_FOR_KEYS : [],
         enableWindowsKey: enableWindowsKey,
         resolutionHandler: this.resolutionHandler,
         cursorHandler: this.cursorHandler,
         multimonRenderer: multimonRenderingService
      });

      if (WMKS.BROWSER.isTouchDevice()) {
         this.wmksContainer.css({
            overflow: 'hidden'
         });
      }

      // Register our callbacks.
      this.wmksContainer.bind("wmksconnected", function () {
         self.onConnected();
         if (AB.UTIL.isRTAVSupported()) {
            RTAVService.onConnected(self.key); //wmks session ID
         }
      }).bind("wmksconnecting", function (e, info) {
         self.onConnecting(info.vvc, info.vvcSession);
         if (AB.UTIL.isRTAVSupported()) {
            RTAVService.onConnecting(self.key, info.vvcSession); // at
            // the
            // same
            // level
            // of
            // MKS
            // functions,
            // but
            // leave
            // the
            // wmksContainer
            // binding
            // here for
            // now
         }
      }).bind("wmksbeforedisconnected", function (e, closeReason) {
         AB.LOGGER.debug('Closing reason from blast is : ' + closeReason);
         self.closeReasonFromBlast = closeReason;
      }).bind("wmksdisconnected", function (e, info) {
         self.onDisconnected(info.code);
         if (AB.UTIL.isRTAVSupported()) {
            RTAVService.onDisconnected(self.key); //wmks session ID,
            // and RTAV will not
            // care about the
            // reason of
            // disconnection
         }
      }).bind("wmksresolutionchanged", function (e, size) {
         AB.LOGGER.trace('New size: ' + JSON.stringify(size));
         /*
          *  TODO: If there are any resize issues, we can rely on the return
          *  value and verify against the requested desktop size.
          */
      }).bind("wmkserror", function (e, err) {
         AB.LOGGER.error('Error: ', err);
         /*
          *  TODO: Disconnection errors (non-1000 codes) trigger this.
          *  We don't care about those as we handle them in the disconnected
          *  handler but we should figure out what else could trigger this
          *  and consider handling those cases.
          */
      }).bind("wmksheartbeat", function (e, interval) {
         self.onHeartbeat(interval);
      }).bind("wmkscopy", function (e, data) {
         AB.LOGGER.log("wmks copy");
         self.wmksService.onClipboardChange(self);
      }).bind("wmkstoggle", function (e, itemName, toggleState) {
         AB.LOGGER.log("wmks toggle", itemName, toggleState);
         // Todo: It used to be for mobile client.
      }).bind("wmksaudio", function (e, audioInfo) {
         self.audioService.playAudio(audioInfo);
      }).bind("wmksaudiomixer", function (e, audioMixerInfo) {
         self.audioService.updateAudioMixer(audioMixerInfo);
      }).bind("wmksreconnecttoken", function (e, token) {
         self.onReconnectToken(token);
      }).bind("wmksupdatemultimoncapacityui", function (e, data) {
         AB.LOGGER.log("update-multimon-capacity-ui", data);
         self.multimonServerEnabled = data;
      }).bind("wmksupdatecopypasteui", function (e, data) {
         AB.LOGGER.log("update-copy-paste-ui", data);
         self.copyEnabled = !data.noCopyUI;
         self.pasteEnabled = !data.noPasteUI;

         /*
          * Notifies wmksService to update its clipboard capabilities. Note
          * that wmksService always updates with the capabilities of its
          * currently active session. If this session is not currently active
          * then the call is redundant, but harmless.
          */
         self.wmksService.updateClipboardCapabilities();
      }).bind("wmksuseractivity", function () {
         self.wmksService.setUserActivityTime();
      });

      // @Todo: Change it safeStorage if we wanna support Chrome Client.
      var reconnectTokenData = sessionStorage.getItem('ReconnectToken');
      if (reconnectTokenData) {
         reconnectTokenData = _angular2.default.fromJson(reconnectTokenData);
         if (reconnectTokenData[this.key]) {
            targetUrl += targetUrl.indexOf('?') === -1 ? '?' : '&';
            targetUrl += 'session=' + encodeURIComponent(reconnectTokenData[this.key]);
         }
      }
      // Initiate the remote desktop connection.
      this.wmksContainer.wmks('connect', targetUrl);
      return true;
   };

   /**
    * setVisibility
    *
    * Show or hide the canvas itself. Returns true if a change was made.
    *
    * @params isShow if to show the canvas.
    */
   BlastWMKS.prototype.setVisibility = function (isShow) {
      if (this.isActive === isShow) {
         return false;
      }

      this.isActive = isShow;

      if (isShow) {
         if (this.wmksContainer) {
            this.wmksContainer.show();
         }
         if (this.disconnectedDialogOption !== null) {
            this.openDisconnectedDialog(this.disconnectedDialogOption.reconnecting, this.disconnectedDialogOption.reason);
            this.disconnectedDialogOption = null;
         }
      } else {
         if (this.wmksContainer) {
            this.wmksContainer.hide();
         }
      }
      return true;
   };

   /**
    * toggleVisibility
    *
    * Show or hide the active canvas.
    *
    * @params isShow if to show the canvas.
    */
   BlastWMKS.prototype.toggleVisibility = function (isShow) {
      if (this.wmksContainer) {
         if (isShow) {
            this.wmksContainer.hideLoading = false;
            // As there will be many times toggle to show, but one time to hide.
            // so check the status first.
            if (this.wmksContainer.css('display') === 'block') {
               return;
            } else {
               this.wmksContainer.show();
            }
         } else {
            this.wmksContainer.hide();
            this.wmksContainer.hideLoading = true;
         }
      }
   };

   /**
    * setEmpty
    *
    * Change the application session is empty or not.
    * @params isEmpty if there is any unity window active on this session.
    */
   BlastWMKS.prototype.setEmpty = function (isEmpty) {
      if (!this.isApplicationSession) {
         AB.LOGGER.error("We can not set a desktop session " + this.key + " to empty.");
         return;
      }
      this.isEmpty = isEmpty;
   };

   /**
    * onConnected
    *
    * Called upon successful connection.
    */
   BlastWMKS.prototype.onConnected = function () {
      // Note that we're connected with wmks.
      AB.LOGGER.info(this.key + 'Remoting connection successful - wmks.');
      this.isWmksConnected = true;
      this.wasWmksConnectedOnce = true;
      // Clear previous state if any, and start the heartbeats.
      this.resetStateAndInitHeartbeat();

      // Now send the messages from the queue if any.
      this.sendQueueMessages();

      // Show the canvas if we are the active session.
      if (this.isActive && !this.wmksContainer.hideLoading) {
         this.wmksContainer.show();
      }
      this.wmksService.sessionOnConnected(this);
   };

   /**
    * onConnecting
    *
    * Called while the MKS is connecting.  This currently is only used to
    * create an instance of Unity.Mgr and log what it receives. This will
    * also create and initialize an mksVchan client for the session.
    */
   BlastWMKS.prototype.onConnecting = function (vvc, vvcSession) {
      var self = this,
          vdpService = void 0,
          client = void 0;

      this.isWmksActive = true;
      if (!vvc) {
         AB.LOGGER.warn("The agent version this session " + this.key + " is connected to is deprecated.");
         this.copyEnabled = false;
         this.pasteEnabled = false;
         return;
      }

      this.clipboardReady = false;
      this.copyEnabled = true;
      this.pasteEnabled = true;

      vdpService = new VDPService.Service(vvc, vvcSession);
      client = new MKSVchan.Client(vdpService);

      this.mainChannel = mainChannelService.getChannel(vdpService);
      this.mainChannel.init();

      this.tsdrChannel = tsdrChannelService.getChannel(vdpService);
      this.tsdrChannel.init();

      this.mksVchanClient = client;
      client.onReady = function () {
         self.clipboardReady = true;
         self.wmksService.onClipboardReady(self.key);
      };
      client.onDownloadFilesChange = function (downloadList, error) {
         self.wmksService.handleDownloadListChange(downloadList, client, error);
      };
      client.onPrintDownloadFilesChange = function (downloadList, error) {
         self.wmksService.handlePrintDownloadListChange(downloadList, client, error);
      };
      client.onClipboardChanged = function (clipboard, error) {
         self.wmksService.handleClipboardReceived(clipboard, error);
      };
      client.onFileTransferConfigChange = function (error) {
         self.wmksService.handleFileTransferConfigChange(error);
      };
      client.onFileTransferError = function (error) {
         self.wmksService.handleFileTransferError(error);
      };
      client.onPrintError = function (error) {
         self.wmksService.handlePrintError(error);
      };
      client.initialize();

      AB.LOGGER.info(this.key + ' connecting ' + (this.isApplicationSession ? 'application' : 'desktop') + ' session - wmks.');
      this.wmksService.sessionOnConnecting(this, vdpService);
   };

   /**
    * resetStateAndInitHeartbeat
    *
    * Upon successful connection we have to clear some old state if this
    * is from a previous reconnect attempt. Remove old dialogs, reset
    * timeouts, initialize heartbeats, etc. For more details see PR:
    * 1200406
    */
   BlastWMKS.prototype.resetStateAndInitHeartbeat = function () {
      // Close the reconnecting dialog now that we're
      // connected/reconnected.
      AB.LOGGER.info(this.key + " is connected and close all the disconnected dialog");
      this.noReconnectAgain = false;
      this.closeDisconnectedDialog('connected');
      this.disconnectedDialogOption = null;

      // Clear any reconnect timeouts if set.
      if (this.reconnectTimeout !== null) {
         $timeout.cancel(this.reconnectTimeout);
         this.reconnectTimeout = null;
      }
      // Reset the backoffDelayMs used for reconnect.
      this.backoffDelayMs = AB.CONST.BlastWMKS.INIT_BACKOFF_DELAY_MS;

      /*
       * Initialize the heartbeat as soon as we have a successful connection.
       * A successful connection is a valid heartbeat from the server.
       */
      this.onHeartbeat(20);
   };

   /**
    * resolution handler is called in
    * WMKS.widgetProto.updateFitGuestSize to adjust the resolution
    *
    * @param width
    * @param height
    * @returns {[*,*]}
    */
   BlastWMKS.prototype.resolutionHandler = function (width, height) {
      var w = parseInt(width),
          h = parseInt(height);

      // We need to round width to even for RDSH, see PR:1172572
      if (w % 2) {
         w = w - 1;
      }

      // We need to round height to even for H.264
      if (mp4Enabled && h % 2) {
         h = h - 1;
      }

      return [w, h];
   };

   /**
    * For this wmks session, set the remote DPI
    * @param remoteDPI
    */
   BlastWMKS.prototype.setRemoteDPI = function (remoteDPI) {
      this.remoteDPI = remoteDPI;
   };

   /**
    * Set a single canvas dimension, either width or height. Given a
    * desired value, we adjust the value until we get a valid setting for
    * that canvas dimension. Returns the final dimension value after
    * adjustments.
    *
    * @params isWidth: flags whether we are setting width or height
    * @params desiredValue: initial desired value for this dimension
    */
   BlastWMKS.prototype.setDimension = function (isWidth, desiredValue) {
      var value = void 0,
          minReached = false,
          diff = void 0,
          minimum = isWidth ? AB.UTIL.INFO.minScreenWidth : AB.UTIL.INFO.minScreenHeight,
          dimensionName = isWidth ? "width" : "height";

      if (desiredValue < minimum) {
         desiredValue = minimum;
         minReached = true;
      }

      value = desiredValue;
      // call wmksContainer.width() or wmksContainer.height()
      this.wmksContainer[dimensionName](value);

      /**
       * When client DPI is more than 100%, sometimes, the container
       * height would be a float value.  For example, if we set the
       * height to be 720, and browser would make it 720.0000323.
       * In this case, it does not really trigger a scrollbar, and
       * now necessarily to decrease the value.  See VHCH-879
       */
      diff = parseInt(this.wmksContainer[dimensionName]()) / this.wmksContainer[dimensionName]();
      AB.LOGGER.debug("Container " + dimensionName + " is " + this.wmksContainer[dimensionName]());
      AB.LOGGER.debug("Desired value is " + value);

      if (!(diff > 0.999 && diff < 1.001)) {
         /*
          * If the browser is zoomed, the dimensions sometimes will not off by 1
          * because of rounding errors. If this happens, decrease the dimensions
          * until we get a value that doesn't get altered.
          *
          * We adjust downwards first to avoid having a scrollbar show up, but
          * if we hit the minimum we will adjust up instead.
          */

         while (this.wmksContainer[dimensionName]() !== value) {
            if (!minReached) {
               value -= 2;
               if (value < minimum) {
                  value = desiredValue + 2;
                  minReached = true;
               }
            } else {
               value += 2;
            }
            this.wmksContainer[dimensionName](value);
         }
      }

      return value;
   };

   /**
    * updateResolution
    *
    * This function applies the new screen size to the wmks container,
    * and
    * may make adjustments if necessary. If specified we will also make a
    * wmks request to rescale the canvas containing the desktop.
    *
    * @params screenSize: an Array [x,y] containing the new width and
    *    height
    * @params rescale: whether to send wmks rescale
    */
   BlastWMKS.prototype.updateResolution = function (screenSize, rescale) {
      var w = void 0,
          h = void 0;

      AB.LOGGER.info("requested resolution change to " + screenSize[0] + " " + screenSize[1]);

      w = this.setDimension(true, screenSize[0]);
      h = this.setDimension(false, screenSize[1]);

      AB.LOGGER.info("resolution adjusted to " + w + " " + h);
      if (rescale) {
         this.wmksContainer.wmks('rescale');
      }
   };

   /**
    * onDisconnected
    *
    * Called upon disconnection with the WebSocket close code.
    * We may come through here multiple times when trying to reconnect.
    */
   BlastWMKS.prototype.onDisconnected = function (code) {
      var self = this,
          closeReason = this.closeReasonFromBlast;

      // Fix for 1589336
      // When refreshing page, return directly.
      // Mainly for Firefox, but the code does not do harm to Chrome or
      // Safari.
      if ($rootScope.beforeunload === true) {
         return;
      }

      this.clipboardReady = false;
      delete this.mksVchanClient;

      this.isWmksConnected = false;
      this.isWmksActive = false;

      this.closeReasonFromBlast = undefined;
      if (!!this.mainChannel) {
         delete this.mainChannel;
      }
      if (!!this.tsdrChannel) {
         delete this.tsdrChannel;
      }

      AB.LOGGER.warn(this.key + ' disconnected: ' + code);

      /* If the user requests to disconnect this session
       * or an empty app session is closed by some reason,
       * just drop this session.
       */
      if (this.requestedDisconnect || this.isApplicationSession && this.isEmpty && this.wasWmksConnectedOnce) {
         this.destroy();
         return;
      } else {
         this.cleanup(true);
         this.destroyWmks();
      }

      this.wmksService.sessionOnDisconnected(this, code);

      // On idle session disconnect, the sidebar handles this case by
      // taking user back to login
      if (this.isApplicationSession && this.wmksService.isSessionTimedOut()) {
         this.openDisconnectedDialog(false, AB.CONST.DISCONNECT_REASON.IDLE_TIMEOUT);

         // For closeReasonFromBlast, please refer to VDPConnectionResult
         // in cart-main.perforce.1666/bora/public/VMwareVDPPlugin.h
      } else if (closeReason === 10 || // Session expired due to timeout.
      closeReason === 11 || // User initiated disconnect or logout.
      closeReason === 12 || // Admin manually disconnected the session
      // from admin ui.
      closeReason === 13 || // Server initiated disconnect as a
      // precursor to pending reconnect.
      closeReason === 27 || // Generic logout.
      closeReason === 28 || // Generic shutdown.
      closeReason === 29 || // Generic reset.
      code === 1000 || code === 1005) {
         /*
          * 1000 is a normal closure code initiated by remote system shutdown,
          * user logoff or the local disconnect button.
          * 1005 is an empty status code which does not indicate an error state,
          * but merely that a closing frame was received with no status code.
          */
         this.openDisconnectedDialog(false);
      } else if (code === AB.CONST.DISCONNECT_REASON.RECONNECT_FAILED) {
         /*
          * We gave up trying to reconnect (3000).
          */
         this.openDisconnectedDialog(false, code);
      } else {

         /*
          * This is an unexpected closure, attempt reconnection.
          */
         if (!this.isDisconnectedDialogOpen() && this.noReconnectAgain !== true) {
            this.openDisconnectedDialog(true);
         }

         if (!this.reconnectTimeout) {
            this.reconnectTimeout = $timeout(function () {
               AB.LOGGER.warn(self.key + ' giving up on reconnection. sending code: 3000');
               self.reconnectTimeout = null;
               self.onDisconnected(AB.CONST.DISCONNECT_REASON.RECONNECT_FAILED);
               /*
                * Give it two minutes before we give up --
                * The BSG will revoke our route after exactly 2 minutes.
                */
            }, AB.CONST.BlastWMKS.BSG_TIMEOUT_MS);
         }

         // Exponentially backoff our reconnect attempts with a max of
         // 20s.
         this.backoffDelayMs = Math.min(2 * this.backoffDelayMs, 20000);
         AB.LOGGER.info(this.key + ' attempt reconnect in (ms): ' + this.backoffDelayMs);

         if (this.backoffTimeout) {
            AB.LOGGER.debug("Unexpected backoff timeout does exist.");
         }

         this.backoffTimeout = $timeout(function () {
            AB.LOGGER.debug(self.key + ' attempting to reconnect to desktop...');
            // Use storing url and setting params to reconnect.
            self.initialize(self.url, self.settings);
         }, this.backoffDelayMs);
      }
   };

   /**
    * onHeartbeat
    *
    *    Called upon receiving a heartbeat event.
    */
   BlastWMKS.prototype.onHeartbeat = function (interval) {
      var self = this;
      if (this.heartbeatTimeout !== null) {
         $timeout.cancel(this.heartbeatTimeout);
      }

      this.heartbeatTimeout = $timeout(function () {
         AB.LOGGER.warn(self.key + ' timed out waiting for a heartbeat.');
         self.onDisconnected(AB.CONST.DISCONNECT_REASON.HEARTBEAT_TIMEOUT);
         /*
          * "interval" is in seconds --
          * Two intervals without a heartbeat means we're dead.
          */
      }, interval * 1000 * 2);
   };

   /**
    * shadowHeartbeat
    *
    *    This is special handle for bug 1731596
    *
    *    Stop heartbeat watching when print since the print dialog in
    *    Firefox and Safari can block JS code, which prevent client
    * receiving heart beat from server. At last client will disconnect
    * from server itself. Therefore we have to stop heartbeat watching in
    * this case
    */
   BlastWMKS.prototype.shadowHeartbeat = function () {
      if (this.heartbeatTimeout !== null) {
         $timeout.cancel(this.heartbeatTimeout);
      }
   };

   /**
    * recoverHeartbeat
    *
    *    This is special handle for bug 1731596
    *    Recover heartbeat watching after print finish
    */
   BlastWMKS.prototype.recoverHeartbeat = function () {
      this.onHeartbeat(20);
   };

   /**
    * onReconnectToken
    *
    *    Called upon receiving a reconnect token.
    */
   BlastWMKS.prototype.onReconnectToken = function (token) {
      var reconnectTokenData = sessionStorage.getItem("ReconnectToken");
      if (!reconnectTokenData) {
         reconnectTokenData = {};
      } else {
         reconnectTokenData = _angular2.default.fromJson(reconnectTokenData);
      }

      reconnectTokenData[this.key] = token;
      sessionStorage.setItem('ReconnectToken', _angular2.default.toJson(reconnectTokenData));
   };

   /**
    * sendQueueMessages
    *
    * Loop through the list of messages in the queue and send them.
    */
   BlastWMKS.prototype.sendQueueMessages = function () {
      var i = void 0,
          message = void 0,
          length = this.wmksOfflineMessageQueue.length;

      // send all messages, messages may be re-added to list on failure
      for (i = 0; i < length; i++) {
         message = this.wmksOfflineMessageQueue.shift();
         this.wmks.apply(this, message);
      }
   };

   /*
    * wmks
    *
    *Invoke WMKS widget APIs.
    */
   BlastWMKS.prototype.wmks = function () {
      var widget = this.wmksContainer;

      if (widget && this.isWmksConnected) {
         // Send to wmks if its connected.
         widget.wmks.apply(widget, arguments);
         return;
      }
      // Queue these requests for sending upon connection.
      this.wmksOfflineMessageQueue.push(arguments);
   };

   /**
    * requestDisconnect
    *
    * Attempt a graceful disconnect from the server. If the server is
    * already disconnected, triggers a page reflow. If the request takes
    * too long to complete or fails, force the disconnect after a delay.
    */
   BlastWMKS.prototype.requestDisconnect = function () {
      var self = this;
      this.requestedDisconnect = true;

      if (this.isWmksActive) {
         this.wmks('disconnect');

         if (!this.disconnectRequestTimeout) {
            this.disconnectRequestTimeout = $timeout(function () {
               self.disconnectRequestTimeout = null;
               if (self.isWmksActive) {
                  AB.LOGGER.warn(self.key + ' disconnect request timed out');
                  self.onDisconnected(AB.CONST.DISCONNECT_REASON.DISCONNECT_REQUEST_TIMEOUT);
               }
            }, AB.CONST.BlastWMKS.REQUEST_DISCONNECT_TIMEOUT);
         }
      } else {
         this.destroy();
      }
   };

   /**
    * cleanup
    *
    * Clean up the selected timeout task. Default is to
    * clean up all the tasks.
    *
    * @params isIgnoreReconnect if we ignore reconnect timeout
    */
   BlastWMKS.prototype.cleanup = function (isIgnoreReconnect) {
      // Remove all the timeout tasks for it is useless in the shutdown
      // process.
      if (this.heartbeatTimeout) {
         $timeout.cancel(this.heartbeatTimeout);
         this.heartbeatTimeout = null;
      }

      if (this.reconnectTimeout && !isIgnoreReconnect) {
         $timeout.cancel(this.reconnectTimeout);
         this.reconnectTimeout = null;
      }

      if (this.backoffTimeout) {
         $timeout.cancel(this.backoffTimeout);
         this.backoffTimeout = null;
      }

      if (this.disconnectRequestTimeout) {
         $timeout.cancel(this.disconnectRequestTimeout);
         this.disconnectRequestTimeout = null;
      }
   };

   /**
    * removeReconnectToken
    *
    * Remove the reconnect token for this websocket connection.
    */
   BlastWMKS.prototype.removeReconnectToken = function () {
      // @Todo: Change it safeStorage if we wanna support Chrome Client.
      var reconnectTokenData = $window.sessionStorage.getItem("ReconnectToken");
      if (!reconnectTokenData) {
         return;
      }

      reconnectTokenData = _angular2.default.fromJson(reconnectTokenData);
      if (reconnectTokenData[this.key]) {
         delete reconnectTokenData[this.key];
         $window.sessionStorage.setItem("ReconnectToken", _angular2.default.toJson(reconnectTokenData));
      }
   };

   /**
    * isDisconnectedDialogOpen
    *
    * @return return if the disconnected dialog is open.
    */
   BlastWMKS.prototype.isDisconnectedDialogOpen = function () {
      return !!this.disconnectedDialog;
   };

   /**
    * openDisconnectedDialogCallback
    *
    * Callback to displays the dialog indicating the desktop has been
    * disconnected. Or to bring up the SSL CertAccept page for the agent
    * we are trying to connect to if triedSSLVerify is false.
    *
    * @params reconnecting are we trying to reconnect
    * @params reason: a optional DISCONNECT_REASON code
    * @params triedSSLVerify false if we have not tried to load the
    *    certAccept page for this agent.
    */
   BlastWMKS.prototype.openDisconnectedDialogCallback = function (reconnecting, reason, triedSSLVerify) {
      var redirectUrl = void 0,
          self = this,
          match = void 0,
          dialogText = void 0,
          numPages = void 0;

      if (!this.isActive) {
         this.disconnectedDialogOption = {
            'reconnecting': reconnecting,
            'reason': reason
         };
         AB.LOGGER.info('Disconnected dialog is forbidden for session ' + this.key + ' is not active.');
         return;
      }

      if (!this.wasWmksConnectedOnce && this.url && (reconnecting || reason === AB.CONST.DISCONNECT_REASON.RECONNECT_FAILED)) {
         /* matches things of the form:
          * wss://<host>:<port>/<path>/<auth token>
          * We strip out the auth token and replace wss with https
          */
         match = this.url.match(/wss:\/\/(\w.+:\d+\/\S*\/)\S*/);
         if (match && match.length >= 2) {
            numPages = 1;

            /**
             * The Windows 10 Edge browser breaks our untrusted SSL
             * workflow because its untrusted cert warning clobbers
             * the history entry for the client page. This means that
             * moving back one page takes us back to certAccept.html,
             * and moving back 2 pages takes us back to the launcher
             * page.
             *
             * The fix is to use history.pushState() to add a new
             * entry for the client page. This entry is just a
             * duplicate of the URL of the client page. This entry
             * gets clobbered by Edge, but having the extra entry
             * means that the original history entry for the client
             * page is not touched by edge, so moving back two pages
             * takes us back to the client page.
             */
            if (WMKS.BROWSER.isIE()) {
               AB.LOGGER.info('Pushing extra history entry on Edge');
               history.pushState({ state: "certAcceptReturnAddress" }, "", $window.location.href);
               /**
                * Set jump page to 3 after page combined.
                * I'm not sure what happens in Edge. But after page
                * combined, client doesn't jump back to desktop page
                * if numPages is 2. It jumps back to
                * 'https://xxx/webclient/index.html'.
                * Anyway, setting numPages to 3 works here...
                */
               numPages = 3;
            }

            redirectUrl = 'https://' + match[1] + 'certAccept.html?numPages=' + numPages;

            // If we have not tried to verify the cert of the agent
            // then do so.
            triedSSLVerify = triedSSLVerify || {};
            if (!triedSSLVerify[this.url]) {
               triedSSLVerify[this.url] = true;
               safeStorageService.setItem("TriedSSLVerify", triedSSLVerify);
               $window.location.href = redirectUrl;
               return;
            }
         }
      }

      this.closeDisconnectedDialog('old');

      dialogText = _('DESKTOP_DISCONNECTED_M');

      if (reconnecting) {
         dialogText += " " + _('ATTEMPTING_RECONNECT_M');
      } else {
         switch (reason) {
            case AB.CONST.DISCONNECT_REASON.RECONNECT_FAILED:
               dialogText += " " + _('RECONNECT_FAIL_M');
               break;
            default:
            // unrecognized reason, no need to add anything
         }
         self.noReconnectAgain = false;
         // destroy unless we plan to reconnect
         self.destroy();
      }

      if (reconnecting) {
         /*
          ** Here we should use openconfirm,but it can't be closed
          ** by close() method, so that we can't get closePromise.
          ** We use open instead of openconfirm in order we could
          ** close it by codes as before.
          ** It helps us resolve the promise that was returned.
          */
         this.disconnectedDialog = ngDialog.open({
            name: "DisconnectedDialog" + this.key,
            templateUrl: _dialog_service_confirm2.default,
            className: "session-ops-dialog",
            data: {
               errorMessage: dialogText,
               title: _('DESKTOP_DISCONNECTED_T'),
               message: dialogText,
               buttonLabelConfirm: _('YES'),
               buttonLabelCancel: _('NO')
            },
            controller: ['$scope', function ($scope) {
               $scope.confirm = function () {
                  /*
                   ** Button Yes, put the reconnection to background and
                   ** try to reconnect
                   */
                  self.noReconnectAgain = true;
                  self.disconnectedDialog.close('backRun');
               };
            }],
            showClose: false,
            closeByEscape: true,
            closeByDocument: false
         });
      } else {
         this.disconnectedDialog = ngDialog.open({
            name: "DisconnectedDialog" + this.key,
            templateUrl: _dialog_service_error2.default,
            className: "session-ops-dialog",
            data: {
               errorMessage: dialogText,
               title: _('DESKTOP_DISCONNECTED_T'),
               buttonLabel: _('CLOSE')
            },
            showClose: false,
            closeByEscape: true,
            closeByDocument: false
         });
      }

      if (!!this.disconnectedDialog) {
         AB.LOGGER.info("Dialog is created for " + this.key + " with id " + this.disconnectedDialog.id);

         this.disconnectedDialog.closePromise.then(function (data) {
            AB.LOGGER.info("The reason for closing dialog: " + (data.value || "unknown") + " with id " + self.disconnectedDialog.id);
            if (data.value === 'backRun') {
               self.disconnectedDialogOption = null;
               self.disconnectedDialog = null;
               return;
            }
            self.noReconnectAgain = false;
            if (!(data.value === 'old' || data.value === 'hide')) {
               self.disconnectedDialogOption = null;

               // Destroy everything unless the dialog is closed by a
               // connection
               if (data.value !== 'connected') {
                  self.destroy();
               }

               self.disconnectedDialog = null;
            }
         });
      }
   };

   /**
    * openDisconnectedDialog
    *
    * Displays the dialog indicating the desktop has been disconnected.
    *
    * @params reconnecting are we trying to reconnect
    * @params reason: a optional DISCONNECT_REASON code
    */
   BlastWMKS.prototype.openDisconnectedDialog = function (reconnecting, reason) {
      var self = this;
      safeStorageService.getItem("TriedSSLVerify", function (triedSSLVerify) {
         self.openDisconnectedDialogCallback(reconnecting, reason, triedSSLVerify);
      });
   };

   /**
    * closeDisconnectedDialog
    *
    * Close the disconnected dialog.
    */
   BlastWMKS.prototype.closeDisconnectedDialog = function (value) {
      if (this.isDisconnectedDialogOpen()) {
         AB.LOGGER.info("Closing dialog " + this.disconnectedDialog.id + " with value " + value);
         try {
            this.disconnectedDialog.close(value);
         } catch (e) {
            AB.LOGGER.info("Closing dialog " + this.disconnectedDialog.id + " fails");
         }
      }
   };

   /**
    * enableWindowsKey
    *
    * Enable/disable Windows key simulation funcionality
    *
    * @param enabled true means enable, false means disable
    */
   BlastWMKS.prototype.enableWindowsKey = function (enabled) {
      var ignoredRawKeyCodes = void 0;

      // Windows key is always disabled in an application session.
      if (this.isApplicationSession) {
         return;
      }

      // If Windows key simulation is disabled, don't process WIN code.
      ignoredRawKeyCodes = enabled ? AB.CONST.BlastWMKS.IGNORE_RAW_KEY_CODES : AB.CONST.BlastWMKS.IGNORE_RAW_KEY_CODES.concat(AB.CONST.BlastWMKS.WIN_KEY_CODES);
      this.wmks({
         ignoredRawKeyCodes: ignoredRawKeyCodes,
         enableWindowsKey: enabled
      });
   };

   /**
    * destroyWmks
    *
    * Destroys this session's wmks instance and remove the canvas
    */
   BlastWMKS.prototype.destroyWmks = function () {
      if (this.wmksContainer) {
         this.wmksContainer.unbind('wmksdisconnected');
         // here's a issue when update to jquery 1.9.1 call wmks prior to
         // initialization
         this.wmksContainer.wmks().wmks('destroy');
         this.wmksContainer.remove();
      }
   };

   /**
    * destroy
    *
    * Destroys this session after performing the necessary cleanup actions
    */
   BlastWMKS.prototype.destroy = function () {
      if (!this.isDestroyed) {
         this.destroyWmks();
         this.isActive = false;
         this.cleanup();
         this.removeReconnectToken();
         this.wmksService.sessionOnRemoved(this);
         this.isDestroyed = true;
      }
   };

   return {
      getWmksSessionInstance: function getWmksSessionInstance(wmksService, key, isApplicationSession, isShadow, name) {
         return new BlastWMKS(wmksService, key, isApplicationSession, isShadow, name);
      }
   };
}

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DesktopCtrl;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * desktop-controller.js --
 *
 * The center controller for desktop module.
 *
 */

function DesktopCtrl($window, AB, $scope, $location, wmksService, entitledItemsService) {
   // Initialize AB with debug logging level.
   AB.initialize({
      LOG_LEVEL: 1
   });

   /*
    * blastURL is one of the info set by the launcher page before it brings the user
    * to the client page. If blastURL is not set then the user navigated to the
    * launcher page directly. In this case send the user to the launcher as we will
    * not have the information we need to run the client.
    */
   try {
      /* istanbul ignore if */
      if (!$window.sessionStorage.getItem('blastURL')) {
         AB.UTIL.returnToLauncher();
      }
   } catch (e) {
      /* istanbul ignore next */
      AB.UTIL.returnToLauncher();
   }

   // Init for desktop connection
   entitledItemsService.init();
   wmksService.init();

   // Remove query string
   // TODO wait for html5 mode change
   $location.search({});
}

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = entitledItemsModel;

var _signal = __webpack_require__(16);

var _signal2 = _interopRequireDefault(_signal);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function entitledItemsModel(safeStorageService, RTAVService) {
   var entitledItems = [],
       idleTimeout = -1,
       init = void 0,
       reset = void 0,
       onEntitleItemsRead = null,
       self = this;

   init = function init() {
      _signal2.default.makeObservable(self);
      self.addSignal('valueChanged');
      RTAVService.onDeviceStatusChanged(function () {
         self.emit("valueChanged");
      });
      reset();
   };

   reset = function reset() {
      entitledItems = [];
      safeStorageService.getItem("EntitledItems", onEntitleItemsRead, null);
   };

   /**
    * onEntitleItemsRead
    *
    * Read serialized string from local storage with key(EntitledItems).
    * Decode it into JSON format and construct entitled item.
    */
   onEntitleItemsRead = function onEntitleItemsRead(localContent) {
      var // Enumerate desktop information from localStorage.
      desktopKey = void 0,
          desktops = void 0,
          desktop = void 0,

      // Enumerate shadow session information from localStorage.
      shadowSessionKey = void 0,
          shadowSessions = void 0,
          shadowSession = void 0,

      // Enumerate application information from localStorage.
      applicationKey = void 0,
          applications = void 0,
          application = void 0,
          iconIndex = -1;

      if (localContent && localContent.timerInfo && localContent.timerInfo.idleTimeout) {
         idleTimeout = localContent.timerInfo.idleTimeout;
      }

      if (localContent && localContent.content) {
         desktops = localContent.content.desktops;
         for (desktopKey in desktops) {
            /* istanbul ignore else */
            if (desktops.hasOwnProperty(desktopKey)) {
               desktop = desktops[desktopKey];

               if (desktop['protocol-match'] === 'false') {
                  // Don't show this desktop because its display protocol
                  // is not allowed.
                  continue;
               }

               // Desktop icon is always the same. we use the icon in the
               // template html.
               _jquery2.default.extend(desktop, {
                  type: _appblastUtil2.default.CONST.ITEMS_TYPE.DESKTOP,
                  isShadow: false,
                  iconSrc: ""
               });
               entitledItems.push(desktop);
            }
         }

         shadowSessions = localContent.content.shadowSessions;
         for (shadowSessionKey in shadowSessions) {
            /* istanbul ignore else */
            if (shadowSessions.hasOwnProperty(shadowSessionKey)) {
               shadowSession = shadowSessions[shadowSessionKey];

               if (shadowSession['protocol-match'] === 'false' || shadowSession.type !== 'desktop') {
                  continue;
               }
               // Todo: Reuse desktop icon for now. Will replace it once
               // it is available.
               _jquery2.default.extend(shadowSession, {
                  type: _appblastUtil2.default.CONST.ITEMS_TYPE.DESKTOP,
                  isShadow: true,
                  iconSrc: ""
               });
               entitledItems.push(shadowSession);
            }
         }

         applications = localContent.content.applications;
         for (applicationKey in applications) {
            /* istanbul ignore else */
            if (applications.hasOwnProperty(applicationKey)) {
               application = applications[applicationKey];

               if (application['protocol-match'] === 'false') {
                  // Don't show this application because its display
                  // protocol is not allowed.
                  continue;
               }

               _jquery2.default.extend(application, {
                  type: _appblastUtil2.default.CONST.ITEMS_TYPE.APP,
                  iconSrc: ""
               });
               iconIndex = _appblastUtil2.default.UTIL.getAppIconIndex(application.icons, 48);
               if (iconIndex === -1) {
                  application.iconSrc = _appblastUtil2.default.CONST.ICONS.BIG_DEFAULT_ICON;
               } else {
                  application.iconSrc = application.icons[iconIndex].path;
               }
               entitledItems.push(application);
            }
         }

         self.emit("valueChanged");
      }
   };

   /**
    * entitledItemsModel.getEntitledItems
    *
    * Return a array of entitled items.
    */
   this.getEntitledItems = function () {
      return entitledItems;
   };

   /**
    * entitledItemsModel.reset
    *
    * Reset the state of the service and read the entitled items from the
    * safe storage service.
    */
   this.reset = reset;

   this.getIdleTimeout = function () {
      return idleTimeout;
   };

   init();
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * entitleditem-model.js --
 *
 * Module to provide entitled items information for Sidebar.
 *
 */

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = entitledItemsService;

var _dialog_service_reauth = __webpack_require__(264);

var _dialog_service_reauth2 = _interopRequireDefault(_dialog_service_reauth);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jscdkClient = __webpack_require__(2);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function entitledItemsService(AB, safeStorageService, entitledItemsModel, applicationSessionsModel, blastSessionsModel, userGlobalPref, $rootScope, $q, multiSiteService, timezone, _, constants, idleSessionService, dpiService, jscdkDesktopInvoker, ngDialog, viewClientModel, baseViewService) {
   var _this = this;

   //private:
   var _applicationSessions = void 0,
       _desktops = void 0,
       _applications = void 0,
       _callBackfunc = void 0,
       _callBackParam = void 0,
       _itemTypeEnum = {
      desktop: "Desktop",
      application: "Application"
   },
       _canReuseBlastSession = void 0,
       _jscdkHandler = void 0; //this will be defined near the end of the file

   function _fillInDesktopsAndApplicationList(entitledItems) {
      _desktops = [];
      _applications = [];
      for (var i = 0; i < entitledItems.length; i++) {
         if (AB.UTIL.isDesktop(entitledItems[i])) {
            _desktops.push(entitledItems[i]);
         } else {
            _applications.push(entitledItems[i]);
         }
      }
   }

   function _findItemWithPropertyInList(propertyName, targetValue, itemList) {
      for (var i = 0; i < itemList.length; i++) {
         if (itemList[i][propertyName] === targetValue) {
            return itemList[i];
         }
      }
      return null;
   }

   function _findDesktop(desktopId) {
      return _findItemWithPropertyInList('id', desktopId, _desktops);
   }

   function _findApplication(applicationId) {
      return _findItemWithPropertyInList('id', applicationId, _applications);
   }

   /**
    * the application session list might be outdated, so don't check it
    * here, if needed, one can add condition like ||
    * !_findItemWithPropertyInList('origin-id', currentFarmId,
    * _applicationSessions)
    */
   function _sessionExisting(application, currentFarmId) {
      return application['origin-id'] === currentFarmId;
   }

   /**
    * this function is to avoid session reuse error, and should be
    * included in the base sevice it suffer from a defect caused by
    * out-dated data, but I don't fix it now.
    */
   function _getNeedDisconnectedSessionForLaunching(application, applicationSessions) {
      var existingSession = _findItemWithPropertyInList('origin-id', application['origin-id'], applicationSessions);
      if (!!existingSession && existingSession['state'] === "connected") {
         return existingSession;
      }
      return null;
   }

   /**
    * this function is to launch target desktop, and the desktopId can be
    * replaced with desktop object and exclude the entitleditemsModle
    */
   function _launchDesktop(desktopId) {
      var desktop = _findDesktop(desktopId);

      if (!desktop) {
         _jscdkLogger2.default.error("can't find the desktop with ID: " + desktopId + " in the entitledList");
         return;
      }

      // here assume the desktop launching always want to see the result
      // url.
      _canReuseBlastSession = false;
      jscdkDesktopInvoker.launchDesktop(desktop);
   }

   function _launchApplication(applicationId, currentConnectedFarmID) {
      var application = _findApplication(applicationId);

      if (!application) {
         _jscdkLogger2.default.error("can't find the application with ID: " + applicationId + " in the entitledList");
         return;
      }
      if (_sessionExisting(application, currentConnectedFarmID)) {
         _canReuseBlastSession = true;
         jscdkDesktopInvoker.launchApplication({
            application: application
         });
      } else {
         // the blastURL should be returned
         _canReuseBlastSession = false;

         applicationSessionsModel.getApplicationSessions(function (applicationSessions) {
            var badSession = _getNeedDisconnectedSessionForLaunching(application, applicationSessions);
            if (!!badSession) {
               _jscdkLogger2.default.info('Application ID "' + application.id + '" has a ' + 'corresponding connected application session ' + badSession.id + '. Disconnecting it now.');
               // for launching application after disconnect
               _jscdkHandler.applicationCache = application;
               // try disconnect and ignore any error.
               jscdkDesktopInvoker.disconnectApplicationSession(badSession);
            } else {
               jscdkDesktopInvoker.launchApplication({
                  application: application
               });
            }
         }, _jscdkHandler);
      }
   }

   function _setCallbackFunction(callbackFunc, callbackParam) {
      if (typeof callbackFunc !== 'function') {
         _jscdkLogger2.default.debug("Error: the callbackFunc is not a function in entitledItemsService");
         return false;
      }
      _callBackfunc = callbackFunc;

      if (callbackParam !== undefined) {
         _callBackParam = callbackParam;
      } else {
         _callBackParam = null;
      }
   }

   this._initTimer = function (initTimerAction) {
      if (!initTimerAction) {
         throw 'Init timer action cannot be null!';
      }

      // Only work for server return not authenticated error
      // _setCallbackFunction(idleSessionService.handleNotAuthenticate);
      _jscdkHandler.invokeJSCDK(initTimerAction, true);
   };

   this._sendLastUserActiveTime = function (sendLastUserActiveTimeAction) {
      if (!sendLastUserActiveTimeAction) {
         throw 'Last user active time action cannot be null!';
      }

      // Only work for server return not authenticated error
      // _setCallbackFunction(idleSessionService.handleNotAuthenticate);
      _jscdkHandler.invokeJSCDK(sendLastUserActiveTimeAction, true);
   };

   _jscdkHandler = {
      applicationCache: null,
      ajaxBusy: false,
      invokeJSCDK: function invokeJSCDK(action, doNotBlock) {
         var actionString = JSON.stringify(action);

         _jscdkLogger2.default.debug("UI request to JSCDK : " + actionString);

         // Set the ajaxBusy flag here before the JSCDK call is made to
         // prevent race conditions and to deal with the case where
         // action.async === false which means that the operation will
         // complete before UIEventToJSCDK() returns
         if (!doNotBlock) {
            _jscdkHandler.ajaxBusy = true;
         }

         (0, _jscdkClient.UIEventToJSCDK)(actionString);
      },

      invokeCallback: function invokeCallback(response) {
         var callback = _callBackfunc;
         if (!!callback) {
            _callBackfunc = null;
            _jscdkHandler.ajaxBusy = false;
            callback(response);
         }
      },

      invokeCallbackWithCallbackParam: function invokeCallbackWithCallbackParam(response) {
         var callback = _callBackfunc,
             param = _callBackParam;
         if (!!callback) {
            _callBackfunc = null;
            _callBackParam = null;
            _jscdkHandler.ajaxBusy = false;
            callback(response, param);
         }
      },

      handleItemConnect: function handleItemConnect(actionData) {
         var response = {
            success: true,
            blastURL: null,
            sessionLocked: false,
            error: null
         };
         if (actionData.isApplicationSession) {
            blastSessionsModel.saveFromXmlResponse(actionData);
         }
         if (_canReuseBlastSession === false) {
            /**
             * if need further info like id, desktop/application name,
             * isApplicationSession, we can change the blastURL into
             * sessionSwitchNeededInfo as an object, but those infos are
             * available when launching the item, so either way seems ok.
             * but the data for toolbar need to be changed accordingly,
             * and might need to update session storage if page jumping
             * is involved(I guess not).
             */
            if (!!actionData && !!actionData.url) {
               response.blastURL = actionData.url;
            } else {
               _jscdkLogger2.default.debug("Error: actionData.url do not exist when do not reuse blast session");
            }
         }
         _canReuseBlastSession = null;

         this.invokeCallback(response);
      },

      handleDisconnect: function handleDisconnect() {
         jscdkDesktopInvoker.launchApplication({
            application: _jscdkHandler.applicationCache
         });
         _jscdkHandler.applicationCache = null;
      },

      handleError: function handleError(actionData) {
         var response = void 0;

         response = {
            success: false,
            sessionLocked: null,
            error: { // only pass those info to UI, could be changed if needed
               errorType: actionData.errorType,
               userMsg: actionData.errorText,
               errorMsg: actionData.errorMessage,
               errorDetail: actionData.errorDetail
            }
         };
         if (!!_callBackParam) {
            this.invokeCallbackWithCallbackParam(response);
         } else {
            this.invokeCallback(response);
         }
      },

      handleSuccessResponse: function handleSuccessResponse() {
         var response = void 0;
         response = {
            success: true,
            sessionLocked: false,
            error: null
         };

         this.invokeCallback(response);
      },

      handlerReconnectResponse: function handlerReconnectResponse(actionData) {
         var response = void 0;
         response = {
            success: true,
            sessionLocked: false,
            successSessionInfo: blastSessionsModel.getFullSessionInfoWith(actionData),
            error: null
         };
         this.invokeCallbackWithCallbackParam(response);
      },

      handleAuthenticationStatusLocked: function handleAuthenticationStatusLocked(actionData) {
         if ($rootScope.reAuthDialog) {
            return;
         }

         $rootScope.$emit('toggleBusyOverlay', false);
         $rootScope.reAuthDialog = ngDialog.open({
            name: "reAuth",
            templateUrl: _dialog_service_reauth2.default,
            showClose: false,
            className: "re-auth-dialog",
            data: {
               title: 're-authentication',
               actionData: actionData
            },
            closeByEscape: true, // do not allow escape to close window
            closeByDocument: true
         });
         $rootScope.reAuthDialog.closePromise.then(function () {
            $rootScope.reAuthDialog = null;
         });
      },

      handleLastUserActiveTime: function handleLastUserActiveTime(actionName) {
         _jscdkLogger2.default.debug("JSCDK response to blast desktop : " + actionName);
         idleSessionService.requestLastActiveTime(actionName);
      },

      handleAuthenticationStatusReAuth: function handleAuthenticationStatusReAuth(handler) {
         if ($rootScope.reAuthDialog) {
            $rootScope.reAuthDialog.close();
            $rootScope.reAuthDialog = null;
            $rootScope.$emit('toggleBusyOverlay', true);
            handler.appConnectCallBack();
         } else {
            _jscdkLogger2.default.debug("There's no reauth dialog");
         }
      },
      /**
       * JSCDK response handler
       *
       * action will never be null, so don't check here
       * complex as mainservice in web.js and will be deleted after
       * refactory
       */
      responseToJSCDKEvent: function responseToJSCDKEvent(action) {
         var actionObj = _jquery2.default.parseJSON(action),
             actionName = actionObj.name,
             actionData = actionObj.content;

         _jscdkLogger2.default.debug("JSCDK response to UI : " + actionName);
         //If there's a response from jscdk,set the value to true.
         $rootScope.isJSCDKResponse = true;
         switch (actionName) {
            case "ShowError":
               // handlerError
               _jscdkHandler.handleError(actionData);
               break;
            case "DisconnectSession":
            // ignore DisconnectSessionFailed, and just call
            // handleDisconnect connect application
            case "DisconnectSessionFailed":
               _jscdkHandler.handleDisconnect();
               break;
            case "ShowAppBlastApplication":
            case "ShowAppBlastDesktop":
               // Multi-site redirection only works for desktop now
               if (!!actionData.redirectProperties && actionName === 'ShowAppBlastDesktop') {
                  // Multi-site redirection
                  try {
                     multiSiteService.redirectAndStartSession(actionData.redirectProperties);
                     return;
                  } catch (e) {
                     _jscdkLogger2.default.debug('Error: fail to redirect due to: ' + e);
                  }
               }
               /* If we got an ShowAppBlastDesktop or ShowAppBlastApplication message
                * but we think we should reuse an existing session this means that
                * the current session is not completely set up yet (ie Stuck on
                * SSO, etc). In this case the user needs to get a message telling
                * them to complete the login for that session before launching more
                * apps. Report an error and that will let the user launch the
                * apps again.
                */
               if (_canReuseBlastSession) {
                  _jscdkLogger2.default.debug("Error: do not reuse a reusable blast session");
                  _jscdkHandler.handleError({
                     errorType: "CannotReuseSession",
                     errorText: _("CANNOT_REUSE_SESSION_M"),
                     errorMessage: _("CANNOT_REUSE_SESSION_M"),
                     errorDetail: null
                  });
               } else {
                  _jscdkHandler.handleItemConnect(actionData);
               }
               break;
            case "ApplicationAlreadyConnected":
               if (!_canReuseBlastSession) {
                  /* If we got an ApplicationAlreadyConnected message but we think we can't
                   * reuse the session that most likely means that we aborted a reconnect
                   * attempt. In that case the broker thinks we still have a session
                   * and that we should reuse it. However we can't because we have dropped
                   * the info for the session. Report an error to the user and tell them
                   * to try again later. Eventually the broker will drop the session
                   * and the user will be able to launch their app
                   */
                  _jscdkLogger2.default.debug("Error: reuse a un-reusalbe blast session");
                  /* Remove the error dialog to fix bug 1755785
                   * In the CPA environment, when the application is global
                   * entitlement and connected. The origin-id of
                   * application-session is different from the app’s origin-id.
                   * We can't detect whether a session we could reuse or not.
                   */
               } else {
                  _jscdkHandler.handleItemConnect(actionData);
               }
               break;
            case "KillSession":
            case "KillAllApplicationSessions":
            case "ResetDesktop":
            case "RestartDesktop":
            case 'Brokers': // old result type for "LogoutFromBroker"
            // action
            case 'Logout':
               // newer result type for "LogoutFromBroker" action
               /**
                * If client can enter desktop page, localStorage must be
                * supported. No need to check it
                */
               if (actionName === 'Logout') {
                  window.localStorage.removeItem(constants.CLIENT_LOGIN_KEY);
               }
               _jscdkHandler.handleSuccessResponse();
               break;
            case "GetUserGlobalPref":
               userGlobalPref.setPrefData(_jscdkClient.globalArray["get-user-global-preferences"].prefData);
               if (_this.getUserGlobalPrefDeferred) {
                  _this.getUserGlobalPrefDeferred.resolve(userGlobalPref.getPrefData());
                  _this.getUserGlobalPrefDeferred = null;
               }
               $rootScope.$emit('userGlobalPrefsRead');
               break;
            case "SetUserGlobalPref":
            case "RequestAborted":
               break;
            case "GetLaunchItems":
               _jscdkHandler.handlerGetLaunchItems(actionObj);
               break;
            case "ReconnectAppSession":
               _jscdkHandler.handlerReconnectResponse(actionData);
               break;
            case "RequestLastUserActiveTime":
            case "Timeout":
               _jscdkHandler.handleLastUserActiveTime(actionName);
               break;
            case 'AlreadyLock':
               if (viewClientModel.isAnonymousMode) {
                  _setCallbackFunction(function () {
                     baseViewService.gotoPortal();
                  });
                  jscdkDesktopInvoker.logout();
                  return;
               }
               break;
            case "SessionUnlocked":
            case 'LockedNewTab':
               _jscdkHandler.invokeCallback(actionObj);
               break;
            case "AuthenticationStatusUnlocked":
               _this.appConnectCallBack();
               break;
            case "AuthenticationStatusLocked":
               _this.connectToBrokerWithCallback(_this.sendDoUnlock);
               break;
            case "unLock":
               _jscdkHandler.handleAuthenticationStatusReAuth(_this);
               break;
            case "WindowsPassword":
               _jscdkHandler.handleAuthenticationStatusLocked(actionObj);
               $rootScope.reWindowsPasswordExpired = false;
               $rootScope.$emit('changeWindowsPassword', actionObj);
               break;
            case "WindowsPasswordExpired":
               _jscdkHandler.handleAuthenticationStatusLocked(actionObj);
               $rootScope.reWindowsPasswordExpired = true;
               $rootScope.$emit('reAuthWindowsPasswordExpired', actionObj);
               break;
            default:
               _jscdkLogger2.default.error("unknown type of response returned");
         }
         _jscdkHandler.ajaxBusy = false;

         if (actionName === "GetLaunchItems") {
            _this.initDoneDeferred.resolve();
         }
      },

      //will be changed after JSCDK refactory
      initJSCDK: function initJSCDK(responseHandler, brokerUrl, urlParam) {
         _jscdkHandler.ajaxBusy = false;
         _jscdkHandler.invokeJSCDK({
            method: "InitRouter",
            brokerUrl: brokerUrl,
            urlParam: urlParam
         }, true);
         (0, _jscdkClient.jscdkClientSetUIController)(responseHandler);
         jscdkDesktopInvoker.jscdkHandler = this;
      }
   };
   //public:
   this.init = function () {
      _fillInDesktopsAndApplicationList(entitledItemsModel.getEntitledItems()); // it may suffer problem
      // with chromeClient
      _callBackfunc = null;
      _callBackParam = null;
      _canReuseBlastSession = null;

      if (!_this.initDoneDeferred) {
         _this.initDoneDeferred = $q.defer();
      }

      function onBrokerUrlReaded(brokerUrlInfo) {
         if (!brokerUrlInfo) {
            AB.UTIL.returnToLauncher();
         } else {
            _jscdkHandler.initJSCDK(_jscdkHandler, brokerUrlInfo.url, brokerUrlInfo.urlParam);
            // pass in _jscdkHandler as main service for quickly resolve
            // a blocking defect for Q2, after refactorying it could
            // easily changed to look better.
            applicationSessionsModel.getApplicationSessions(function (applicationSessions) {
               _applicationSessions = applicationSessions;
            }, _jscdkHandler);
         }
      }

      safeStorageService.getItem("BrokerUrlInfo", onBrokerUrlReaded, null);
   };

   /**
    * realize the old API to handle the JSCDK response, will be changed
    * after JSCDK refactory the locked status is checked before sending
    * any XML, so not included here.
    */

   this.responseToJSCDKEvent = _jscdkHandler.responseToJSCDKEvent;
   this.itemTypeEnum = _itemTypeEnum;
   this.invokeJSCDK = _jscdkHandler.invokeJSCDK;

   /**
    * try launch a user-entitled item.
    *
    * @itemId: of string,
    *    be the target entitled itemID, do not use object to decompose
    *    the
    *    model of view
    *    (might stored in the sub-controller of view) and the one for
    *    higher level.
    * @type: of itemTypeEnum,
    *    be the type of the item.
    * @currentConnectedFarmID: of string or null,
    *    be the orignal ID(running environment ID of agent?), and used to
    *    check whether the current session can be reused for new
    *    application. when launching a desktop, this param will be
    *    ignored.
    * @callbackFunc: of function,
    *    be the callback function that handle the response like:
    *    {
          *       success: of bool,
          *       sessionLocked: of bool or null(when return error),
          *       blastURL: of string or null,
          *       error​: of object,
          *    }
    * @return: of bool
    *    indicate whether the params used for calling is valid
    */
   this.launch = function (itemId, type, currentConnectedFarmID, callbackFunc) {
      if (_jscdkHandler.ajaxBusy) {
         _jscdkLogger2.default.debug("Error: do not support do multiple actions at the same time in the entitledItemsService");
         return false;
      }
      _setCallbackFunction(callbackFunc);

      if (type === _itemTypeEnum.desktop) {
         _launchDesktop(itemId);
      } else if (type === _itemTypeEnum.application) {
         _launchApplication(itemId, currentConnectedFarmID);
      } else {
         _jscdkLogger2.default.debug("Error: unknown item type in entitledItemsService.launch()");
         return false;
      }
      return true;
   };

   /**
    * This function is different from wmksService.hasApplicationSession
    * This function will return the whether user has exsiting application
    * session, from get-launch-item msg. While
    * wmksService.hasApplicationSession will return whether user has
    * running application session.
    */
   this.hasApplicationSession = function () {
      var deferred = $q.defer();

      applicationSessionsModel.getApplicationSessions(function (applicationSessions) {
         deferred.resolve(applicationSessions);
      }, _jscdkHandler);

      return deferred.promise;
   };

   this.resetAllApplications = function (callbackFunc) {
      if (_jscdkHandler.ajaxBusy) {
         _jscdkLogger2.default.debug("Error: do not support do multiple actions at the same time in the entitledItemsService");
         return false;
      }
      _setCallbackFunction(callbackFunc);
      jscdkDesktopInvoker.resetAllApplicationSessions();
   };

   /**
    * if kill an application, this function will send killSession to the
    * broker, and it would made the current session invalid, so a dialog
    * might be needed.
    *
    * if kill a desktop, this function will send resetDesktop to the
    * broker, and it would make the current session invalid, so might
    * need to disconnect the wmks also.
    */
   this.killItem = function (itemId, type, callbackFunc) {
      var isDesktop = void 0;

      if (_jscdkHandler.ajaxBusy) {
         _jscdkLogger2.default.debug("Error: do not support do multiple actions at the same time in the entitledItemsService");
         return false;
      }

      _setCallbackFunction(callbackFunc);
      if (type === _itemTypeEnum.desktop) {
         isDesktop = true;
      } else if (type === _itemTypeEnum.application) {
         isDesktop = false;
      } else {
         _jscdkLogger2.default.debug("Error: unknown item type in entitledItemsService.launch()");
         return false;
      }
      jscdkDesktopInvoker.resetItem(itemId, isDesktop);
      return true;
   };

   this.resetDesktop = function (desktopId, callbackFunc) {
      if (_jscdkHandler.ajaxBusy) {
         _jscdkLogger2.default.debug("Error: do not support do multiple actions at the same time in the entitledItemsService");
         return false;
      }
      _setCallbackFunction(callbackFunc);

      jscdkDesktopInvoker.resetDesktop(desktopId);
   };

   this.restartDesktop = function (desktopId, callbackFunc) {
      if (_jscdkHandler.ajaxBusy) {
         _jscdkLogger2.default.debug("Error: do not support do multiple actions at the same time in the entitledItemsService");
         return false;
      }
      _setCallbackFunction(callbackFunc);

      jscdkDesktopInvoker.restartDesktop(desktopId);
   };

   /*
    * logout
    *
    * Logout the user from the broker and then invoke the callback
    *
    * @param callbackFunc callback to call once the user is logged out
    */
   this.logout = function (callbackFunc) {
      _setCallbackFunction(callbackFunc);
      jscdkDesktopInvoker.logout();
   };

   this.reconnectApplicationSessions = function (callbackFunc, callbackParam, targetAppSessionIdList, excludedOriginalId) {
      if (_jscdkHandler.ajaxBusy) {
         _jscdkLogger2.default.debug("Error: do not support do multiple actions at the same time in the entitledItemsService");
         return false;
      }
      _setCallbackFunction(callbackFunc, callbackParam);
      jscdkDesktopInvoker.reconnectApplicationSessions(targetAppSessionIdList, excludedOriginalId);
   };

   this.unitTestStatusSetters = {
      setCallback: _setCallbackFunction,
      setCanReuseBlastSession: function setCanReuseBlastSession(canReuse) {
         _canReuseBlastSession = canReuse;
      },
      setApplicationCache: function setApplicationCache(obj) {
         _jscdkHandler.applicationCache = obj;
      }
   };

   this.getUserGlobalPref = function () {
      // the promise we will return
      var deferred = void 0;

      // If there is promise in flight use that promise
      if (this.getUserGlobalPrefDeferred) {
         deferred = this.getUserGlobalPrefDeferred;
      } else {

         deferred = $q.defer();

         // If there is no promise in flight but
         // get-user-global-preferences exists then that means that the
         // preferences where read already and that the process of
         // getting the preferences has completed.
         if (_jscdkClient.globalArray["get-user-global-preferences"]) {
            deferred.resolve(userGlobalPref.getPrefData());
         } else {
            // Otherwise we need to read the preferences because they
            // have not been read yet.
            deferred = $q.defer();
            this.getUserGlobalPrefDeferred = deferred;
            jscdkDesktopInvoker.getUserGlobalPref();
         }
      }

      return deferred.promise;
   };

   this.connectToBrokerWithCallback = function (callback) {
      jscdkDesktopInvoker.connectToBroker();
      _setCallbackFunction(callback);
   };

   this.authenticationStatusCheck = function (callback, ondone) {
      jscdkDesktopInvoker.authenticationStatusCheck();
      _setCallbackFunction(ondone);
      this.appConnectCallBack = callback;
   };

   this.addInitDoneCallback = function (callback) {
      if (!this.initDoneDeferred) {
         this.initDoneDeferred = $q.defer();
      }
      this.initDoneDeferred.promise.then(callback);
   };

   this.abortRequest = function () {
      _jscdkHandler.ajaxBusy = false;
      jscdkDesktopInvoker.cancelCurrentRequest();
   };

   this.sendDoUnlock = function () {
      jscdkDesktopInvoker.sendDoUnlock();
   };

   this.submitWindowsPasswordWithCallback = function (username, password, domain, reAuth, callback) {
      _setCallbackFunction(callback, this.appConnectCallBack);
      jscdkDesktopInvoker.submitWindowsPassword(username, password, domain, reAuth);
   };

   this.startIdleTimer = function (brokerSupportIdleTimeout, idleTimeout, userActivityInterval, brokerUrl, brokerUrlWithTimestamp, handleUserActivityCallback) {
      idleSessionService.initialize(brokerSupportIdleTimeout, idleTimeout, userActivityInterval, brokerUrl, brokerUrlWithTimestamp, _jscdkHandler, handleUserActivityCallback, this._initTimer, this._sendLastUserActiveTime);
   };

   this.stopIdleTimer = function () {
      _jscdkLogger2.default.debug("Stop idle timer for desktop module");
      _jscdkHandler.invokeJSCDK({
         method: 'TimerCtrl',
         type: 'stopTimer'
      }, true);
   };
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * this service do not support multiple calling at the same time, so please
 * make sure the UI is designed to forbidden user to do so.
 *
 * this service is not ready at once it's loaded for chromeClient, and the code
 * changes need to be done for that.
 *
 * currently that's the only service in blast side calling JSCDK, so I think
 * it's ok to mimic the mainService function here before the JSCDK refactory is
 * done. after that, the mainService will be needed no more, and the new
 * callback API of JSCDK is also fit for "many mainService pattern".
 *
 * the safeStorageService is to make the coding easy before the blast-page
 * merged with webClient as a one page app. after that, the IP and ID can be
 * get from clientmodel
 *
 * if the including of entitledItemsModel cause any dependency error(like
 * loop), one can set it as a refer at outside with a extra entitledItemsModel
 * setter API.
 *
 * when try launch the same desktop, this service will return blastURL, and
 * it's not good for the user, so the UI should forbidden user to do so, or pre
 * deal this case for better user experience.
 *
 * the locked status check will be done using a will-check-in patch, that patch
 * can get the locked status without asking broker, thus save time and netwrok
 * traffic.
 *
 * the blastUrl in returned response as the param of callback could be changed
 * to an object that contains all info like item id, name , type, therefor ease
 * the info cache in outside if needed.
 *
 * disconnected-related logic and cache should not be handled here, but put it
 * here for the 1st patch.
 *
 * the null segment are optional once JSCDK is using callback.
 *
 * currently the response of resetAllApplicationSessions is ok only when all of
 * the application-session- killing is ok, and error if any of them fails. This
 * could be changed to return a list of the success info, but currently I see
 * no need, so merge them here.
 */

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = idleSessionService;

var _signal = __webpack_require__(16);

var _signal2 = _interopRequireDefault(_signal);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * idle-session-service.js --
 *
 * This file performs the manage work to init a timerContrller in JSCDK, and
 * is also the middle layer between blast page and JSCDK, thus it will provide
 * an API to let JSCDK send last-user-active time request through post-massage
 * and also handle the response and told back to JSCDK.
 *
 * NOTE: the file is almost copied from slim client
 */

function idleSessionService() {
   var _this = this;

   _signal2.default.makeObservable(this);
   this.addSignal('not-authenticated');

   this.actionTrigger = null;
   this.jscdkHandler = null;
   this.handleUserActivityCallback = null;
   this.initTimer = null;
   this.sendLastUserActiveTime = null;

   /**
    * pass in the last-user-active-time getter function to init the idle
    * timer in JSCDK
    */
   this.initialize = function (brokerSupportIdleTimeout, idleTimeout, userActivityInterval, brokerUrl, brokerUrlWithTimestamp, jscdkHandler, handleUserActivityCallback, initTimer, sendLastUserActiveTime) {
      if (typeof handleUserActivityCallback !== 'function' || typeof initTimer !== 'function' || typeof sendLastUserActiveTime !== 'function') {
         throw 'Wrong parameters for idleSessionService to init!';
      }

      if (!jscdkHandler) {
         throw 'jscdkHandler should not be null!';
      }

      this.jscdkHandler = jscdkHandler;
      this.handleUserActivityCallback = handleUserActivityCallback;
      this.initTimer = initTimer;
      this.sendLastUserActiveTime = sendLastUserActiveTime;

      var initTimerAction = void 0,
          bypassApplicationVersionCheck = void 0;

      if (!brokerSupportIdleTimeout) {
         return;
      }
      bypassApplicationVersionCheck = "true";

      // session storage is no need to be sent, for before enter, it has
      // already been set.
      initTimerAction = {
         method: "TimerCtrl",
         type: "InitTimer",
         initType: "Desktop",
         idleTimeout: idleTimeout,
         userActivityInterval: userActivityInterval,
         bypassApplicationVersionCheck: bypassApplicationVersionCheck,
         brokerUrl: brokerUrl,
         brokerUrlWithTimestamp: brokerUrlWithTimestamp
      };
      this.initTimer(initTimerAction);
   };

   /**
    * the interface to let timerCtrl in JSCDK call to get last user active
    * time
    *
    * through post-message, will get value in the callback bound in listener
    *
    * @param actionTrigger String:
    *    indicates the reason that this function is invovled, null is the
    *    default value, and stands for "RequestLastUserActiveTime", while
    *    this assum that the requests other than
    *    "RequestLastUserActiveTime"(now only "Timeout") should not come too
    *    close to each other. while the best way need to pass extra string
    *    to AB and change codes in it.
    * @return nothing
    */
   this.requestLastActiveTime = function (actionTrigger) {
      if (actionTrigger === "Timeout") {
         _this.actionTrigger = actionTrigger;
      }

      var lastUserActiveTime = _this.handleUserActivityCallback();
      _this.sendLastUserActiveTimeToTimerCtrl(lastUserActiveTime);
   };

   /**
    * the function that send last user active time to JSCDK
    *
    * sending with invokeJSCDK
    *
    * @param lastUserActiveTime long
    * @return nothing
    */
   this.sendLastUserActiveTimeToTimerCtrl = function (lastUserActiveTime) {
      var sendLastUserActiveTimeAction = void 0,
          actionTrigger = _this.actionTrigger,
          actionType = null;

      if (actionTrigger === "Timeout") {
         actionType = "syncWithTimer4Timeout";
         _this.actionTrigger = null;
      } else {
         actionType = "sendLastUserActiveTime";
      }
      _jscdkLogger2.default.debug("handle app-blast response as: " + actionType);

      sendLastUserActiveTimeAction = {
         method: "TimerCtrl",
         type: actionType,
         lastUserActiveTime: lastUserActiveTime
      };
      _this.sendLastUserActiveTime(sendLastUserActiveTimeAction);
   };

   this.handleNotAuthenticate = function () {
      _this.emit('not-authenticated');
   };
}

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = jscdkDesktopInvoker;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function jscdkDesktopInvoker($rootScope, $location, $timeout, $window, viewClientModel, userGlobalPref, dpiService, connectionServerModel, constants, timezone) {
   var _this = this;

   this.jscdkHandler = null;

   this._invokeJSCDK = function (action) {
      // TODO: Move to jscdkUIAdapter later
      _this.jscdkHandler.invokeJSCDK(action);
   };

   this.resetItem = function (itemId, isDesktop) {
      var killItemAction = {};
      killItemAction.method = "KillSession";
      killItemAction.itemInfo = {
         id: itemId,
         isDesktop: isDesktop
      };
      _this.jscdkHandler.invokeJSCDK(killItemAction);
   };

   this.resetDesktop = function (desktopId) {
      var resetDesktopAction = {
         method: "ResetDesktop",
         desktopId: desktopId
      };
      _this.jscdkHandler.invokeJSCDK(resetDesktopAction);
   };

   this.restartDesktop = function (desktopId) {
      var restartDesktopAction = {
         method: "RestartDesktop",
         desktopId: desktopId
      };
      _this.jscdkHandler.invokeJSCDK(restartDesktopAction);
   };

   this.logout = function () {
      var logoutAction = {
         method: 'LogoutFromBroker',
         prefData: userGlobalPref.toFlatFormat()
      };
      _this.jscdkHandler.invokeJSCDK(logoutAction);
   };

   this.submitWindowsPassword = function (username, password, domain, reAuth) {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'WindowsPassword',
         isDesktopReAuth: true,
         username: username,
         secret: password,
         domain: domain
      };
      if (reAuth) {
         submitAuthInfoAction.reAuth = true;
      }

      _this.jscdkHandler.invokeJSCDK(submitAuthInfoAction);
   };

   this.changePassword = function (oldPassword, newPassword1, newPassword2) {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         isDesktopReAuth: true,
         type: 'WindowsPasswordExpired'
      };
      submitAuthInfoAction.oldPassword = oldPassword;
      submitAuthInfoAction.newPassword1 = newPassword1;
      submitAuthInfoAction.newPassword2 = newPassword2;

      _this.jscdkHandler.invokeJSCDK(submitAuthInfoAction);
   };

   this.cancelCurrentRequest = function (doneAction) {
      _this.jscdkHandler.invokeJSCDK({
         method: 'CancelCurrentRequest',
         doneAction: doneAction
      });
   };

   this.sendLaunchItemsXML = function () {
      var getLaunchItemsAction = {
         method: 'GetLaunchItems',
         skipTunnelAndPref: true,
         skipTimer: true
      };
      _this.jscdkHandler.invokeJSCDK(getLaunchItemsAction);
   };

   this.getUserGlobalPref = function () {
      _this.jscdkHandler.invokeJSCDK({
         method: "GetUserGlobalPref"
      });
   };

   this.disconnectApplicationSession = function (applicationsession) {
      _this.jscdkHandler.invokeJSCDK({
         method: "DisconnectSession",
         launchItemId: applicationsession.id
      });
   };

   this.resetAllApplicationSessions = function () {
      var resetApplicationSessionAction = {};
      resetApplicationSessionAction.method = 'KillSession';
      resetApplicationSessionAction.killAllApplicationSessions = true;
      _this.jscdkHandler.invokeJSCDK(resetApplicationSessionAction);
   };

   this.reconnectApplicationSessions = function (targetSessionIds, excludedOriginalId) {
      var reconnectApplicationSessionsAction = {};
      reconnectApplicationSessionsAction.method = "ReconnectSession";
      reconnectApplicationSessionsAction.targetSessionIds = targetSessionIds;
      reconnectApplicationSessionsAction.disconnectAll = false;
      reconnectApplicationSessionsAction.excludedOriginalId = excludedOriginalId;
      reconnectApplicationSessionsAction.environmentInfo = _this._getEnvironmentInfo(false);

      _this.jscdkHandler.invokeJSCDK(reconnectApplicationSessionsAction);
   };

   this.launchApplication = function (appInfo) {
      var application = appInfo.application,
          args = appInfo.args,
          selectApplicationAction = {};

      // connect to application
      selectApplicationAction.method = 'ConnectToApplication';
      /*
       * launch application for the specific protocol
       * currently, only BLAST is allowed.
       */
      selectApplicationAction.protocol = connectionServerModel.connectionProtocol;
      selectApplicationAction.applicationId = application.id;
      selectApplicationAction.originId = application['origin-id'];
      selectApplicationAction.maximized = 'false';
      selectApplicationAction.environmentInfo = _this._getEnvironmentInfo(false);

      selectApplicationAction.preferences = {
         applicationName: application.name,
         resolution: {
            'x': 0,
            'y': 0,
            'w': (0, _jquery2.default)(window).width(),
            'h': (0, _jquery2.default)(window).height()
         }
      };
      if (!!args) {
         selectApplicationAction.launchParam = {
            "args": args
         };
      }

      selectApplicationAction.prefData = userGlobalPref.toFlatFormat();
      _this.jscdkHandler.invokeJSCDK(selectApplicationAction);
   };

   this.launchDesktop = function (desktop) {
      var selectDesktopAction = {},
          ratio = 1;

      selectDesktopAction.method = 'ConnectToDesktop';
      /* launch desktop for the specific protocol
       * currently, only BLAST is allowed.
       */
      selectDesktopAction.protocol = connectionServerModel.connectionProtocol;
      selectDesktopAction.desktopId = desktop.id;
      selectDesktopAction.isShadow = desktop.isShadow;
      if (!desktop.isShadow) {
         selectDesktopAction.environmentInfo = _this._getEnvironmentInfo(true);
      }

      selectDesktopAction.preferences = {
         desktopName: desktop.name,
         resolution: {
            'x': 0,
            'y': 0,
            'w': (0, _jquery2.default)(window).width() * ratio,
            'h': (0, _jquery2.default)(window).height() * ratio
         }
      };

      selectDesktopAction.prefData = userGlobalPref.toFlatFormat();
      _this.jscdkHandler.invokeJSCDK(selectDesktopAction);
   };

   this.connectToBroker = function () {
      var connectBrokerAction = {},
          clientCommonInfo = void 0,
          clientStats = void 0,
          addClientCommonInfo = void 0,
          addClientStats = void 0,
          userAgent = navigator.userAgent,
          isHandheldDevice = !!userAgent.match(/(iPad)|(iPhone)|(iPod)|(android)|(IEMobile)|(webOS)/i),
          matches = void 0,
          browserName = 'unknown',
          browserVersion = void 0,
          browserArch = navigator.platform;

      // Connect To the Broker
      connectBrokerAction.method = 'ConnectToBroker';
      connectBrokerAction.address = connectionServerModel.host;
      connectBrokerAction.supportedProtocols = connectionServerModel.supportedProtocols;

      // //ignore ISO for now
      // if (!!connectionURIModel.isF5Session()) {
      //    connectBrokerAction.mid = connectionURIModel.getF5postFix();
      // }

      if (userAgent.toLowerCase().match(/(iphone|ipod|ipad)/i)) {
         // Apple iOS6 introduced a new xml post bug where the browser
         // would cache response if the request data did not change.
         // Hack to make sure we always request a new url, by adding a
         // timestamp whenever get an iOS browser
         connectBrokerAction.urlParam = '?_ab=' + _jquery2.default.now();
      }

      // Match pattern like 'Chrome/26.0.1410.64' to retrieve browser
      // name and version.
      matches = userAgent.match(/(opera|chrome|safari|firefox|msie|trident)\/?\s*(\.?\d+(\.\d+)*)/i);
      if (!!matches) {
         browserName = matches[1];
         browserVersion = matches[2];
      }

      // For Microsoft Edge, the useragent is like:
      // "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36
      // (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36
      // Edge/12.0". Match pattern Edge, because there's a "chrome"
      // string in it.
      if (userAgent.toLowerCase().indexOf('edge')) {
         matches = userAgent.match(/(edge)\/?\s*(\.?\d+(\.\d+)*)/i);
         if (!!matches) {
            browserName = matches[1];
            browserVersion = matches[2];
         }
      }

      if (browserName === 'Safari') {
         // For Safari, the version is in 'Version/6.0.3'.
         matches = userAgent.match(/version\/([\.\d]+)/i);
         if (!!matches) {
            browserVersion = matches[1];
         }
      } else if (browserName === 'Trident') {
         // For IE 11, the version is in 'rv:11.0'.
         browserName = 'Internet Explorer';
         matches = userAgent.match(/rv[:\s]([\w.]+)/i);
         if (!!matches) {
            browserVersion = matches[1];
         }
      }
      // For Chromebook, detect browser-arch from userAgent text.
      matches = userAgent.match(/cros\s*[a-z0-9_\.]*/i);
      if (!!matches) {
         browserArch = matches[0];
      }

      // Client common info
      clientCommonInfo = {
         // 'VMware'
         'client-vendor': viewClientModel.vendor,
         // 'VMware Horizon HTML Access'
         'client-product': viewClientModel.product,
         // View client version
         'client-version': viewClientModel.version + '-' + viewClientModel.buildNum,
         // 'Chrome Apps'
         'client-arch': viewClientModel.arch
      };
      // Client platform specific info
      clientStats = {
         // Browser info
         'browser-user-agent': userAgent,
         // Browser core
         'browser-core': browserName,
         // Browser version
         'browser-version': browserVersion,
         // System info
         'browser-arch': browserArch,
         // Is mobile device
         'browser-is-handheld': isHandheldDevice ? 'true' : 'false'
      };

      addClientCommonInfo = {
         'entity-type': 'CLIENT',
         'data-type': 'configuration'
      };

      addClientStats = {
         // the same with windows client
         'entity-id': 'singleton'
      };

      connectBrokerAction.clientInfo = {
         'clientCommonInfo': clientCommonInfo,
         'clientStats': clientStats,
         'addClientCommonInfo': addClientCommonInfo,
         'addClientStats': addClientStats
      };

      _this.jscdkHandler.invokeJSCDK(connectBrokerAction);
   };

   this.sendDoUnlock = function () {
      var sendDoUnlockAction = {
         method: 'DoUnlock'
      };
      _this.jscdkHandler.invokeJSCDK(sendDoUnlockAction);
   };

   this.authenticationStatusCheck = function (callback, ondone) {
      var authStatusCheckAction = {
         method: 'GetAuthenticationStatus',
         workForSilentMode: true
      };

      _this.jscdkHandler.invokeJSCDK(authStatusCheckAction);
   };

   this.setEnvironmentInfo = function (environmentInfo) {
      var setEnvironmentInfoAction = {
         "method": "SetEnvironmentInfo",
         "data": environmentInfo
      };
      this.jscdkHandler.invokeJSCDK(setEnvironmentInfoAction);
   };

   this._getEnvironmentInfo = function (isDesktop) {
      var environmentInfo = {};

      if (!!viewClientModel.ipAddress) {
         environmentInfo['IP_Address'] = viewClientModel.ipAddress;
         environmentInfo['Machine_Name'] = viewClientModel.machineName;
      }
      if (!!viewClientModel.clientID) {
         environmentInfo['Client_ID'] = viewClientModel.clientID;
      }
      environmentInfo['Client_Version'] = viewClientModel.version + '-' + viewClientModel.buildNum;
      environmentInfo['TZID'] = timezone.getWindowsTimezone();
      environmentInfo['Type'] = constants.viewclientType;

      environmentInfo['Displays.SystemDpi'] = dpiService.getDPI();

      return environmentInfo;
   };
} /*********************************************************
   * Copyright (C) 2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = messageHandlerService;
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * @fileoverview messagehandler-service.js -- messageHandlerService
 * This service offering the same API to decouple the different design for IE
 *    and non-IE browsers, it will inform the current tab about the launching
 *    info in one way or another with same API.
 *
 * The implement is using API of postMessage for non-IE or Edge browsers to
 *    provide better user exprience, while will use API of storage event for
 *    IE. For we have a different design using storage for IE with version
 *    below or equal to 11, since it suffers from some postMessage Bugs, please
 *    refer below link for details:
 *    http://stackoverflow.com/questions/16226924/is-cross-origin-postmessage-broken-in-ie10
 */

function messageHandlerService(AB, $window) {
   var launchingFunc = null,
       brokerAddress = '',
       horizonId = '',
       userName = '',
       domainName = '',
       inited = false;

   /**
    * check whether the data passed from the HWS is invalid
    * will treat the data for another HWS session as invalid,
    * since HWS should never use postMessage for that case.
    *
    * @param  {object} data
    * @return {boolean} This returns whether the action is acceptable
    * to the WebClient.
    */
   function invalidHWSData(data) {
      if (!data.itemType || !data.itemId || !data.horizonId) {
         return true;
      }
      if (data.horizonId !== horizonId || decodeURIComponent(data.userName) !== userName || data.domainName !== domainName) {
         // message is sent by a invalid horizon session
         return true;
      }
      return false;
   }

   /**
    * deal with the postMessage form the HWS
    * @param  {object} data The structure holds the action related
    *    information
    * @return {boolean} This returns whether the message is accepted
    */
   function dealWithHWSMessage(data) {
      var itemType = data.itemType,
          itemId = decodeURIComponent(data.itemId);

      if (invalidHWSData(data)) {
         return false;
      }

      if (typeof launchingFunc === 'function') {
         launchingFunc(itemType, itemId);
      }
      return true;
   }

   function receiveMessage(event) {
      var message = void 0,
          success = void 0;

      message = JSON.parse(event.data);
      if (message.type === "HWS") {
         success = dealWithHWSMessage(message.data);
         if (success) {
            event.source.postMessage(JSON.stringify({
               type: "WebClient",
               data: 'Ack'
            }), "*");
         } else {
            event.source.postMessage(JSON.stringify({
               type: "WebClient",
               data: 'Nak'
            }), "*");
         }
      }
   }

   function onStorageChange(event) {
      var message = void 0,
          success = void 0,
          eventKey = "HWS_BKA_" + brokerAddress;

      if (event.key === eventKey) {
         message = JSON.parse(event.newValue);
         if (message.origin !== "newTab") {
            return;
         }
         success = dealWithHWSMessage(message.data);
         if (success) {
            // return a success message.
            $window.localStorage.setItem(eventKey, JSON.stringify({
               origin: "oldTab", // this message is from a tab older than
               // the reciever tab.
               data: 'Merged' // message indicate the request content is
               // merged successfully into this tab old
               // tab.
            }));
         }
      }
   }

   return {
      /**
       * Init function to set the current session info, if param are
       * correct, listener will also be registered.
       *
       * @param {object} localInfo The object contains properties of
       *    brokerAddress, horizonId, userName, and domainName
       */
      init: function init(localInfo) {
         if (inited || !localInfo) {
            return;
         }
         brokerAddress = localInfo.brokerAddress;
         horizonId = localInfo.horizonId;
         userName = localInfo.userName;
         domainName = localInfo.domainName;
         if (!!brokerAddress && !!horizonId && !!userName && !!domainName) {
            //only when info are fully given enable the listener
            if (!AB.UTIL.supportPostMessage()) {
               if (!!$window.localStorage) {
                  $window.addEventListener("storage", onStorageChange, false);
               }
            } else {
               $window.addEventListener("message", receiveMessage, false);
            }
         }
         inited = true;
      },

      /**
       * Used to register in the launch callback, which will be called
       * when receive the specified request
       * @param  {function} launchCallback Could be the identical
       *    function used for sidebar launching
       */
      registerLaunchCallback: function registerLaunchCallback(launchCallback) {
         launchingFunc = launchCallback;
      },

      /**
       * @return {Boolean} This returns whether current session is
       *    launched from HWS
       */
      isFromHWS: function isFromHWS() {
         return !!horizonId;
      }
   };
}

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = panelService;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function panelService($window, AB) {
   /**
    * maxYValue
    *
    * returns the maximum Y value for the top of the clipboard window so
    * that all of the window will still be seen
    */
   function maxYValue(element) {
      return Math.max(0, $window.innerHeight - element[0].offsetHeight);
   }

   /**
    * maxXValue
    *
    * returns the maximum X value for the left side of the clipboard
    * window so that all of the window will still be seen or 0 if the
    * window is wider than the browser.
    */
   function maxXValue(element) {
      return Math.max(0, $window.innerWidth - element[0].offsetWidth);
   }

   /**
    * clampY
    *
    * Given a Y value that is to large or two small for the entire
    * clipboard window to be seen on the screen clamp so that the windows
    * would be seen. Or 0 if the window is taller than the browser.
    */
   function clampY(y, element) {
      return AB.UTIL.clamp(y, 0, maxYValue(element));
   }

   /**
    * clampX
    *
    * Given an X value that is to large or two small for the entire
    * clipboard window to be seen on the screen clamp so that the windows
    * would be seen
    */
   function clampX(x, element) {
      return AB.UTIL.clamp(x, 0, maxXValue(element));
   }

   function Service() {
      // Refer to .panel-front in clipboard.css
      this.zIndex = 201;
      this.panelList = [];
   }

   /**
    * windowResizeHandler
    *
    * Callback invoked when the browser window is resized. If the window
    * would fall out view because of the resize this method will
    * reposition it so that it will still be visible
    */
   Service.prototype.windowResizeHandler = function (scope, showPanel, element) {
      if (!scope || !showPanel || !element) {
         return;
      }

      return function () {
         var x = void 0,
             y = void 0;

         // Only move the window if it is visible otherwise we will
         // calculate the wrong x and y
         if (!scope[showPanel]) {
            return;
         }

         /**
          *  The height or width of the panel can never be 0.
          *  If offsetWidth or offsetHeight return 0, the element is not
          *  rendered yet. We need to skip window re-location in this
          *  situation. Otherwise the panel could be placed at left-top
          *  of the window.
          */
         if (element[0].offsetHeight === 0 || element[0].offsetWidth === 0) {
            AB.LOGGER.debug('Element is not ready, do nothing this time.');
            return;
         }

         y = clampY(element[0].offsetTop, element);
         x = clampX(element[0].offsetLeft, element);

         element.css({
            top: y + 'px',
            left: x + 'px'
         });
      };
   };

   Service.prototype.addPanelElement = function (name, element) {
      if (!name || !element) {
         AB.LOGGER.debug('There is no element to add.');
         return;
      }

      this.panelList.push({
         name: name,
         element: element
      });
   };

   Service.prototype.getNewZIndex = function () {
      return this.zIndex++;
   };

   Service.prototype.onFocus = function (name) {
      for (var i = 0; i < this.panelList.length; i++) {
         if (this.panelList[i].name === name) {
            this.panelList[i].element.addClass('panel-front');
            this.panelList[i].element.removeClass('panel-behind');
            this.panelList[i].element.css("z-index", this.getNewZIndex());
         } else {
            this.panelList[i].element.addClass('panel-behind');
            this.panelList[i].element.removeClass('panel-front');
         }
      }
   };

   var service = null;

   return {
      getService: function getService() {
         if (!service) {
            service = new Service();
         }
         return service;
      }
   };
}

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.printFrame = printFrame;
exports.PrintController = PrintController;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _mksvchan = __webpack_require__(12);

var _mksvchan2 = _interopRequireDefault(_mksvchan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function printFrame($timeout, AB, WMKS, $window, wmksService, toastService) {
   var template = void 0,
       linkFn = void 0,
       postPrint = void 0;

   postPrint = function postPrint(scope) {
      scope.isPrinting = false;
      AB.LOGGER.debug('Printing done, print next one');
      wmksService.recoverAllHeartbeatForPrint();
      // The toast is showed for each PDF. Remember to clear it after
      // printing.
      $timeout(function () {
         toastService.clearEarlyToast(toastService.TOAST_TYPE.PRINT);
      }, 500);
      scope.printNextFile();
   };

   if (WMKS.BROWSER.isFirefox()) {
      template = "<iframe id='printPDF' style='height: 0;width: 0;border: none;'" + "src='../pdfjs/web/viewer.html?v='" + "1" + "></iframe>";
      linkFn = function linkFn(scope, element) {
         scope.frame = element[0];
         $window.addEventListener('message', function (event) {
            if (event.origin !== location.origin) {
               AB.LOGGER.debug("Unknown origin");
               return;
            }

            if (_angular2.default.isString(event.data)) {
               if (event.data === 'ready') {
                  scope.viewerReady = true;
               } else if (event.data === 'print done') {
                  postPrint(scope);
               }
            }
         }, false);
      };
   } else if (!WMKS.BROWSER.isIE()) {
      template = "<iframe id='printPDF' " + "style='height: 0;width: 0;border: none;'></iframe>";
      linkFn = function linkFn(scope, element) {
         scope.initialized = false;
         scope.frame = element[0];
         scope.frame.onload = function () {
            AB.LOGGER.debug("Entering frame onload");
            $timeout(function () {
               scope.frame.contentWindow.focus();
               scope.frame.contentWindow.print();
               scope.isPrinting = true;
               /**
                * Bind focus event for iframe window to support print
                * multiple files
                */
               $(scope.frame.contentWindow).on('focus.print', function () {
                  $(scope.frame.contentWindow).off('focus.print');
                  postPrint(scope);
               });
            }, 0);
         };
      };
   }

   return {
      restrict: 'E',
      controller: 'PrintController',
      replace: true,
      template: template,
      link: linkFn
   };
}

function PrintController(AB, $scope, $timeout, WMKS, wmksService, _, TransferHelper, toastService, wmksServiceEventHandler) {
   $scope.transferHelper = TransferHelper.getInstance(_mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT);
   $scope.isPrinting = false;

   $scope.beginDownload = function (mksClient) {
      var downloadFiles = mksClient.FTUtil.downloadList[_mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT],
          downloadService = mksClient.downloadServices[_mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT];
      downloadService.init(downloadFiles, function () {
         AB.LOGGER.debug('Document for print download finished.');
         if (!$scope.isPrinting) {
            $scope.printNextFile(downloadFiles);
         }
      });

      if (!downloadService.downloadReady()) {
         return;
      }

      /**
       * For print download job, PDF could not be 0 size or a folder, and it
       * cannot be stopped. So the error can only be that PDF is exceeding
       * 500MB size.
       *
       * For print download job, server always send new added file one by
       * one. So we just need to verify the last file in the queue.
       *
       * There are 4 situations:
       * 1. No ft task, no error file. Just show the normal toast.
       * 2. No ft task, error file exists. Show toast to warn
       *    user there is error file which cannot be printed.
       * 3. FT task exists, no error file. Show toast print job blocked.
       * 4. FT task exists, error file exists. Show toast to warn
       *    user there is error file which cannot be printed.
       */
      if ($scope.ifLatestFileHasTransferError(downloadFiles)) {
         toastService.warning(_('PRINT_FILE_TOO_LARGE'), toastService.TOAST_TYPE.PRINT);
      } else if (wmksService.isFileDownloadingInCurrentSession()) {
         toastService.warning(_('PRINT_BLOCK_BY_FT'), toastService.TOAST_TYPE.PRINT);
      } else {
         toastService.info(_("PRINT_FILE_DOWNLOAD_BEGIN"), toastService.TOAST_TYPE.PRINT);
      }

      downloadService.beginDownload();
   };

   /**
    * If downloadFiles is past in, use it. Otherwise search for the entire
    * download list.
    * @param downloadFiles
    */
   $scope.printNextFile = function (downloadFiles) {
      var list = void 0;
      if (typeof downloadFiles === 'undefined') {
         // Search for entire download list.
         AB.LOGGER.debug('No download list past in,' + ' search for other mks client.');
         list = $scope.searchForNextDownloadList();
      } else {
         AB.LOGGER.debug('Download list past in.');
         list = downloadFiles;
      }

      // Search for a downloaded file and print it
      if (!list || list.length <= 0) {
         AB.LOGGER.debug('There is not more file to print.');
         return;
      }

      for (var i = 0; i < list.length; i++) {
         if (list[i].progress === 100) {
            $scope.printFile(list[i], list);
            return;
         }
      }
   };

   $scope.searchForNextDownloadList = function () {
      var mksClientList = wmksService.getAllmksClient(),
          downloadFileList = void 0;
      for (var i = 0; i < mksClientList.length; i++) {
         downloadFileList = mksClientList[i].FTUtil.downloadList[_mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT];
         for (var j = 0; j < downloadFileList.length; j++) {
            if (downloadFileList[j].progress === 100) {
               AB.LOGGER.debug('Download list found for print.');
               return downloadFileList;
            }
         }
      }

      AB.LOGGER.debug('No download list is ready for print.');
      return [];
   };

   $scope.ifLatestFileHasTransferError = function (downloadFiles) {
      var length = downloadFiles.length,
          transferError = void 0;
      if (!downloadFiles || length <= 0) {
         return false;
      }

      transferError = downloadFiles[length - 1].transferError;
      // Remove the file if it has transfer error
      if (transferError) {
         downloadFiles.splice(length - 1, 1);
      }
      return transferError;
   };

   $scope.sendMsg = function (file) {
      $scope.isPrinting = true;
      $scope.frame.contentWindow.postMessage(file.contentData, location.origin);
   };

   $scope.printFile = function (file, downloadFiles) {
      wmksService.shadowAllHeartbeatForPrint();
      if (WMKS.BROWSER.isFirefox()) {
         if ($scope.viewerReady) {
            $scope.sendMsg(file);
         }
      } else {
         var data = void 0;
         data = new Blob([file.contentData.buffer], {
            type: 'application/pdf'
         });

         if (!!$scope.frame) {
            $scope.frame.contentWindow.location.replace(window.URL.createObjectURL(data));
         }
      }

      // Delete the file once it is printed.
      $scope.clearFileDataAfterPrint(file, downloadFiles);
   };

   $scope.clearFileDataAfterPrint = function (file, downloadFiles) {
      for (var i = 0; i < downloadFiles.length; i++) {
         if (file === downloadFiles[i]) {
            downloadFiles.splice(i, 1);
            break;
         }
      }
   };

   if (!WMKS.BROWSER.isIE()) {
      // IE is disabled
      wmksServiceEventHandler.addEventListener('downloadPrintFileListChanged', function (fileList, client, error) {
         $timeout(function () {
            if (client.FTUtil.config.printDownloadEnabled === false || !fileList || fileList.length <= 0 || !client.downloadServices[_mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT]) {
               AB.LOGGER.log("Download not enable or list is empty!");
               return;
            }

            if (error === _mksvchan2.default.CLIPBOARD_ERROR.MAX_LIMIT_EXCEEDED) {
               AB.LOGGER.log("File list exceeds the max size!");
            }

            // Store old and new file list
            $scope.transferHelper.updateDownloadFileList(fileList, client);
            $scope.beginDownload(client);
         });
      });

      wmksServiceEventHandler.addEventListener('printError', function (error) {
         switch (error) {
            case _mksvchan2.default.FILE_TRANSFER_ERROR.PRINT_TIMEOUT:
               toastService.warning(_("PRINT_FILE_TIMEOUT"), toastService.TOAST_TYPE.PRINT);
               break;
            default:
               AB.LOGGER.error('Invalid error number: ' + error + ' received from server.');
         }
      });
      wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.PRINT);

      $scope.transferHelper.addStatusListener(function () {
         $scope.transferHelper.initTransferService();
      });
   }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = runningItemsModel;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _signal = __webpack_require__(16);

var _signal2 = _interopRequireDefault(_signal);

var _unity = __webpack_require__(48);

var _unity2 = _interopRequireDefault(_unity);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function runningItemsModel(AB, wmksService, unityService, $rootScope, $timeout, _, wmksServiceEventHandler) {
   var runningItems = [],

   /*
    * Fast query table for visible window, associate windowId with itemObj
    * in application instance array.
    */
   runningVisibleItemsMap = {},

   // Fast query table for apps, associate windowPath+execPath with
   // application array.
   runningApplicationMap = {},

   // Fast query table for all available unity Windows from server.
   runningItemsMap = {},

   // Fast Query table for all running desktops.
   runningDesktopMap = {},


   // Special "Loading" item that contains placeholders for loading
   // sessions
   loadingSessionsItem = null,
       loadingSessionsMap = {},


   // Add/Delete/Update operation for application level array.
   getApplicationItems = null,
       removeApplicationItems = null,
       updateApplicationAttribute = null,
       updateApplicationFocusedItem = null,


   // Add/Delete/Update operation for running item level array.
   addRunningItem = null,
       setCanvasVisibility = null,
       updateRunningItemVisibility = null,
       removeRunningItem = null,
       updateRunningItem = null,
       updateRunningItemAttribute = null,
       updateRunningItemType = null,
       isRunningItemVisibleOnUI = null,
       checkVisibleWindows = null,


   // Remove all the items from the same farm.
   removeAllRunningItemsPerSession = null,


   // Enable disable for running application and desktop.
   changeRunningItemStatus = null,


   // Helper function to generate application and running item id.
   generateApplicationId = null,
       generateRunningItemId = null,
       checkVisibleWindowTimer = null,
       checkVisibleWindowTimeout = 300,
       unityReadyTimer = null,
       unityReadyTimeout = 1000,
       onUnityReady = null,


   /**
    * Fill in current shown desktop item info.
    */
   addDesktopItem = null,
       removeDesktopItem = null,
       addLoadingPlaceholder = null,
       removeLoadingPlaceholder = null,
       addAttentionRequired = null,
       removeAttentionRequired = null,
       changeFocusedSession = null,
       onSessionRemoved = null,
       currentFocusWmksKey = null,

   // Init method to register all the callbacks.
   self = this,
       init = null;

   /**
    * generateApplicationId
    *
    * Generate a unique id based on parameters.
    * @param wmksKey     the key to identify this unique wmksSession.
    * @param windowPath  window path for this application.
    * @param exePath     exec path for this application.
    * return unique application id.
    */
   generateApplicationId = function generateApplicationId(wmksKey, windowPath, execPath) {
      return wmksKey + windowPath + execPath;
   };

   /**
    * generateRunningItemId
    *
    * Generate a unique id based on parameters.
    * @param wmksKey     the key to identify this unique wmksSession.
    * @param windowId    window id for this application.
    * return unique running item id.
    */
   generateRunningItemId = function generateRunningItemId(wmksKey, windowId) {
      return wmksKey + windowId;
   };

   /**
    * getApplicationItems
    *
    * Get an application item instance by windowPath and execPath.
    * If the application doesn't exist and createNew is true, then create
    * a new application and request an attr update from the server.
    *
    * @param wmksKey     the key to identify this unique wmksSession.
    * @param windowPath  window path for this application.
    * @param exePath     exec path for this application.
    * @param windowId    windowId for the unity window calling this
    *    function
    * @param createNew   flags whether we should create a running
    *    application if no application is found
    *
    * return application item if found, else, returns null.
    */
   getApplicationItems = function getApplicationItems(wmksKey, windowPath, execPath, windowId, createNew) {
      var id = generateApplicationId(wmksKey, windowPath, execPath),
          newApplication = void 0;
      if (!runningApplicationMap[id]) {
         if (!createNew) {
            return null;
         }
         newApplication = {
            wmksKey: wmksKey,
            windowPath: windowPath,
            execPath: execPath,
            iconSrc: AB.CONST.ICONS.BIG_DEFAULT_ICON,
            name: _("LOADING_APP"),
            focusedItem: null,
            isCollapsed: true,
            type: AB.CONST.ITEMS_TYPE.LOADING_APP,
            state: AB.CONST.ITEMS_STATE.CONNECTED,
            instances: [],
            orderedInstances: [], // instances ordered from LRU to MRU
            isFocusedItem: function isFocusedItem() {
               return this.wmksKey === currentFocusWmksKey && !!this.focusedItem;
            }
         };
         runningApplicationMap[id] = newApplication;
         runningItems.push(newApplication);
         // This is the first window and we need to retrieve application
         // name and icon.
         unityService.getAppAttr(wmksKey, windowPath, execPath, windowId);
      }
      return runningApplicationMap[id];
   };

   /**
    * removeApplicationItems
    *
    * Remove an application item instance by windowPath and execPath.
    *
    * @param wmksKey     the key to identify this unique wmksSession.
    * @param windowPath  window path for this application.
    * @param exePath     exec path for this application.
    * return true if removing this application.
    */
   removeApplicationItems = function removeApplicationItems(wmksKey, windowPath, execPath) {
      var id = generateApplicationId(wmksKey, windowPath, execPath),
          currentApp = void 0,
          appIndex = void 0;

      if (runningApplicationMap[id]) {
         currentApp = runningApplicationMap[id];
         appIndex = runningItems.indexOf(currentApp);
         if (appIndex !== -1) {
            runningItems.splice(appIndex, 1);
         }

         delete runningApplicationMap[id];
         return true;
      }
      return false;
   };

   /**
    * updateApplicationAttribute
    *
    * Update an application item attributes by windowPath and execPath.
    * It will fire a value changed event.
    *
    * @param wmksKey     the key to identify this unique wmksSession.
    * @param windowPath  window path for this application.
    * @param exePath     exec path for this application.
    * @param params      params value to be updated.
    * return true if value is updated.
    */
   updateApplicationAttribute = function updateApplicationAttribute(wmksKey, windowPath, execPath, params) {
      var id = generateApplicationId(wmksKey, windowPath, execPath),
          currentApp = void 0;

      if (runningApplicationMap[id]) {
         currentApp = runningApplicationMap[id];
         if (_angular2.default.isString(params.iconSrc)) {
            currentApp.iconSrc = params.iconSrc;
         }
         if (_angular2.default.isString(params.windowTitle)) {
            currentApp.name = params.windowTitle;
         }
         currentApp.type = AB.CONST.ITEMS_TYPE.APP;
         self.emit("valueChanged");
         return true;
      }
      return false;
   };

   /**
    * updateApplicationFocusedItem
    *
    * Update an focused item property in its parent application item.
    * It will also reset all others application focused item to null.
    * For we only allow one focused item even if there are multiple farms.
    *
    * @param focusedItem current focused item.
    */
   updateApplicationFocusedItem = function updateApplicationFocusedItem(focusedItem) {
      var currentApp = getApplicationItems(focusedItem.wmksKey, focusedItem.windowPath, focusedItem.execPath, focusedItem.windowId, false),
          applicationIdKey = null,
          index = -1;

      if (currentApp) {
         currentApp.focusedItem = focusedItem;

         // Move the current item to the end of the ordered instance list
         index = currentApp.orderedInstances.indexOf(focusedItem);
         if (index !== -1) {
            currentApp.orderedInstances.splice(index, 1);
         }
         currentApp.orderedInstances.push(focusedItem);

         /*
          * Reset other focused unity Window in same farmer to false.
          */
         for (applicationIdKey in runningApplicationMap) {
            if (runningApplicationMap.hasOwnProperty(applicationIdKey) && runningApplicationMap[applicationIdKey] !== currentApp && runningApplicationMap[applicationIdKey].wmksKey === currentApp.wmksKey && runningApplicationMap[applicationIdKey].focusedItem) {
               runningApplicationMap[applicationIdKey].focusedItem.isFocused = false;
               runningApplicationMap[applicationIdKey].focusedItem = null;
            }
         }
         return true;
      } else {
         AB.LOGGER.warn("updateApplicationFocusedItem: application not found");
         return false;
      }
   };

   /**
    * addRunningItem
    *
    * Add an window item instance by windowId to items map.
    * All the new window is located in items map and it is
    * not visible.
    *
    * @param wmksKey     the key to identify this unique wmksSession.
    * @param windowId    window id for this application.
    * @param windowPath  window path for this application.
    * @param exePath     exec path for this application.
    * return true if a running item is added.
    */
   addRunningItem = function addRunningItem(wmksKey, windowId, windowPath, execPath) {
      var id = generateRunningItemId(wmksKey, windowId),
          newItem = void 0,
          applicationItem = void 0;
      if (!runningVisibleItemsMap[id] && !runningItemsMap[id]) {
         newItem = {
            wmksKey: wmksKey,
            windowId: windowId,
            windowPath: windowPath,
            execPath: execPath,
            iconSrc: AB.CONST.ICONS.SMALL_DEFAULT_ICON,
            isFocused: false,
            name: '',
            /*
             * Todo :Remove all the following three attributes after we
             * have a kind of unity-window-ready notification in unity.js.
             * We should use cached data in unity.js in the end.
             */
            windowType: undefined,
            isTransparent: true,
            isToolWindow: true,
            // Remove this attribute and use cached data in unity.js
            isMinimized: undefined
         };
         runningItemsMap[id] = newItem;
         return true;
      } else {
         return false;
      }
   };

   /*
    * updateRunningItemVisibility
    *
    * Checks a running item's visibility. If the item is visible and in the
    * runningItemsMap, move it to runningVisibleItemsMap. If the item is not
    * visible and in runningVisibleItemsMap, move it to runningItemsMap. This
    * method should be called on a window whenever one of its parameters that
    * may effect visibility is changed.
    *
    * NOTE: If an item's visibility is changed, this method will emit valueChanged
    *
    * @params: item - the running item to check visibility on
    *
    * @return: Returns true if the item visibility has changed (the item has been
    * moved to a different running item map based on visibility)
    */
   updateRunningItemVisibility = function updateRunningItemVisibility(item) {
      var id = generateRunningItemId(item.wmksKey, item.windowId),
          applicationItem = void 0,
          removed = void 0;

      if (runningItemsMap[id] && isRunningItemVisibleOnUI(item)) {
         applicationItem = getApplicationItems(item.wmksKey, item.windowPath, item.execPath, item.windowId, true);
         runningVisibleItemsMap[id] = item;
         delete runningItemsMap[id];
         applicationItem.instances.push(item);
         if (item.isFocused === true) {
            updateApplicationFocusedItem(item);
         }
         self.emit("valueChanged");
         return true;
      } else if (runningVisibleItemsMap[id] && !isRunningItemVisibleOnUI(item)) {
         removed = removeRunningItem(item.wmksKey, item.windowId);
         if (removed) {
            // removeRunningItem already emits valueChanged on success
            runningItemsMap[id] = item;
         }
         return removed;
      } else {
         return false;
      }
   };

   /*
    * setCanvasVisibility
    *
    * Set a running item's visibility.
    *
    * @params: wmksKey - the key to identify this unique wmksSession.
    *
    * @isShow: set visibility to show or hide
    */
   setCanvasVisibility = function setCanvasVisibility(wmksKey, isShow) {
      wmksService.setCanvasVisibility(wmksKey, isShow);
   };

   /**
    * removeRunningItem
    *
    * remove an window item instance by windowId.
    * if this running item is the last instance of its application,
    * application item would be removed, too.
    * It will fire a value changed event if it is visible.
    *
    * @param wmksKey     the key to identify this unique wmksSession.
    * @param windowId    window id for this application.
    * return true if a running item is removed.
    */
   removeRunningItem = function removeRunningItem(wmksKey, windowId) {
      var id = generateRunningItemId(wmksKey, windowId),
          currentItem = void 0,
          currentApp = void 0,
          itemIndex = void 0,
          orderedItemIndex = void 0;

      currentItem = runningItemsMap[id];
      /*
       * It is in the running item maps. It is not visible on the UI yet.
       * We only need to remove it from this temporary cache.
       */
      if (currentItem) {
         delete runningItemsMap[id];
         currentItem = null;
         return true;
      }

      currentItem = runningVisibleItemsMap[id];
      if (currentItem) {
         currentApp = getApplicationItems(currentItem.wmksKey, currentItem.windowPath, currentItem.execPath, windowId, false);
         if (!currentApp) {
            AB.LOGGER.warn("removeRunningItem: application not found");
            return false;
         }
         itemIndex = currentApp.instances.indexOf(currentItem);
         if (itemIndex !== -1) {
            currentApp.instances.splice(itemIndex, 1);
         }

         orderedItemIndex = currentApp.orderedInstances.indexOf(currentItem);
         if (orderedItemIndex !== -1) {
            currentApp.orderedInstances.splice(orderedItemIndex, 1);
         }

         if (currentApp.focusedItem === currentItem) {
            currentApp.focusedItem = null;
         }

         if (currentApp.instances.length === 0) {
            removeApplicationItems(currentItem.wmksKey, currentApp.windowPath, currentApp.execPath);
         } else if (currentApp.instances.length === 1) {
            currentApp.isCollapsed = true;
         }

         delete runningVisibleItemsMap[id];
         currentItem = null;
         self.emit("valueChanged");

         checkVisibleWindows();
         return true;
      } else {
         return false;
      }
   };

   /**
    * updateRunningItem
    *
    * Update an running item attributes by windowId.
    * It will fire a value changed event if the item is visible.
    *
    * @param wmksKey   the key to identify this unique wmksSession.
    * @param windowId  window id for this running item.
    * @param params    params value to be updated.
    * return true if value is updated.
    */
   updateRunningItem = function updateRunningItem(wmksKey, windowId, params) {
      var id = generateRunningItemId(wmksKey, windowId),
          currentItem = void 0,
          visibleChanged = false,
          isFromVisibleMap = true;

      currentItem = runningVisibleItemsMap[id];
      if (!currentItem) {
         currentItem = runningItemsMap[id];
         isFromVisibleMap = false;
      }

      if (currentItem) {
         if (_angular2.default.isString(params.windowTitle)) {
            currentItem.name = params.windowTitle;
         }

         if (_angular2.default.isString(params.iconSrc)) {
            currentItem.iconSrc = params.iconSrc;
         }

         if (_angular2.default.isString(params.windowTitle) || _angular2.default.isString(params.iconSrc)) {
            visibleChanged = updateRunningItemVisibility(currentItem);
         }

         /*
          * Notify UI only if item is visible and visibility has not changed.
          * Note that if visibility changes, updateRunningItemVisibility will
          * handle the valueChanged signal.
          */
         if (isFromVisibleMap && !visibleChanged) {
            self.emit("valueChanged");
         }
         return true;
      } else {
         return false;
      }
   };

   /**
    * updateRunningItemAttribute
    *
    * Update an running item attributes by windowId.
    * It will fire a value changed event if instance value is changed
    * and this item is visible.
    *
    * @param wmksKey   the key to identify this unique wmksSession.
    * @param windowId  window id of unity window.
    * @param type      type of value.
    * @param value     value of this attribute.
    * return true if value is updated.
    */
   updateRunningItemAttribute = function updateRunningItemAttribute(wmksKey, windowId, type, value) {
      var id = generateRunningItemId(wmksKey, windowId),
          currentItem = void 0,
          currentApp = null,
          isChanged = false,
          applicationIdKey = null,
          isFromVisibleMap = true;

      currentItem = runningVisibleItemsMap[id];
      if (!currentItem) {
         currentItem = runningItemsMap[id];
         isFromVisibleMap = false;
      }

      if (currentItem) {
         if (type === _unity2.default.WINDOW_ATTR_FOCUSED && currentItem.isFocused !== value) {
            currentItem.isFocused = value;
            if (value === true) {
               updateApplicationFocusedItem(currentItem);
            } else {
               currentApp = getApplicationItems(currentItem.wmksKey, currentItem.windowPath, currentItem.execPath, currentItem.windowId, false);
               if (currentApp && currentApp.focusedItem === currentItem) {
                  currentApp.focusedItem = null;
               }
            }
            self.emit("valueChanged");
            isChanged = true;
         } else if (type === _unity2.default.WINDOW_ATTR_TRANSPARENT || type === _unity2.default.WINDOW_ATTR_TOOLWINDOW) {
            if (type === _unity2.default.WINDOW_ATTR_TRANSPARENT) {
               currentItem.isTransparent = value;
            } else if (type === _unity2.default.WINDOW_ATTR_TOOLWINDOW) {
               currentItem.isToolWindow = value;
            }
            isChanged = updateRunningItemVisibility(currentItem);
         } else if (type === _unity2.default.WINDOW_ATTR_MINIMIZED) {
            currentItem.isMinimized = value;
            if (value === true) {
               checkVisibleWindows();
               isChanged = false;
            }
         }
      }
      return isChanged;
   };

   /**
    * updateRunningItemType
    *
    * Update an running item type by windowId.
    * The item would become visible if all the conditions are meet.
    * It will fire a value changed event.
    *
    * @param wmksKey   the key to identify this unique wmksSession.
    * @param windowId  window id for this running item.
    * @param type      window type.
    * return true if value is updated.
    */
   updateRunningItemType = function updateRunningItemType(wmksKey, windowId, type) {
      var id = generateRunningItemId(wmksKey, windowId),
          currentItem = void 0,
          isFromVisibleMap = false;

      currentItem = runningItemsMap[id];
      if (!currentItem) {
         currentItem = runningVisibleItemsMap[id];
         isFromVisibleMap = true;
      }

      if (!!currentItem) {
         currentItem.windowType = type;
         return updateRunningItemVisibility(currentItem);
      } else {
         return false;
      }
   };

   /**
    * isRunningItemVisibleOnUI
    *
    * If two attributes are changed from true to false,
    * and its window type is normal,
    * we will consider this running item is visible on UI.
    * Todo: Remove this to Unity-service.js util we have
    * unity-window-ready notification in unity.js.
    *
    * @param runningItem running item
    *
    * Return true if running item is visible on UI.
    */
   isRunningItemVisibleOnUI = function isRunningItemVisibleOnUI(runningItem) {
      if (!runningItem.name && !runningItem.iconSrc) {
         return false;
      }
      return runningItem.windowType === _unity2.default.WINDOW_TYPE_NORMAL && runningItem.isTransparent === false && runningItem.isToolWindow === false;
   };

   /**
    * checkVisibleWindows
    *
    * If unity is running and there is no visible running item on the
    * current active session, we should popup sidebar if sidebar is
    * collapsed. And emit "noVisibleWindow" to notify the sidebar to open
    * if collapsed We don't care about the item which is not visible on
    * the sidebar.
    *
    */
   checkVisibleWindows = function checkVisibleWindows(ignoreUnity) {
      /*
       * If unity has just become ready, we set a timer that blocks visible
       * window checks. We need to wait a bit for us to be notified of all
       * the windows on a pre-existing session, or we may open the sidebar
       * when no windows are visible, but the server has not yet sent us the
       * data on visible items on the desktop.
       */
      if (!!unityReadyTimer) {
         return;
      }

      // Do not open sidebar if unity is paused, we are likely in UAC mode
      if ((typeof ignoreUnity === 'undefined' || !ignoreUnity) && !unityService.isUnityRunning(currentFocusWmksKey)) {
         return;
      }

      if (checkVisibleWindowTimer) {
         $timeout.cancel(checkVisibleWindowTimer);
         checkVisibleWindowTimer = null;
      }
      checkVisibleWindowTimer = $timeout(function () {
         var runningItemKey = void 0;

         checkVisibleWindowTimer = null;
         for (runningItemKey in runningVisibleItemsMap) {
            if (runningVisibleItemsMap.hasOwnProperty(runningItemKey) && runningVisibleItemsMap[runningItemKey].wmksKey === currentFocusWmksKey && !runningVisibleItemsMap[runningItemKey].isMinimized) {
               return;
            }
         }
         self.emit("noVisibleWindow");
      }, checkVisibleWindowTimeout, false);
   };

   /**
    * removeAllRunningItemsPerSession
    *
    * Remove all the running items from the specified farm.
    * It will fire a value changed event if instance value is changed.
    *
    * @param wmksKey   the key to identify this unique wmksSession.
    */
   removeAllRunningItemsPerSession = function removeAllRunningItemsPerSession(wmksKey) {
      var runningItemKey = void 0,
          removed = false;
      for (runningItemKey in runningItemsMap) {
         if (runningItemsMap.hasOwnProperty(runningItemKey) && runningItemsMap[runningItemKey].wmksKey === wmksKey) {
            if (removeRunningItem(wmksKey, runningItemsMap[runningItemKey].windowId)) {
               removed = true;
            }
         }
      }

      for (runningItemKey in runningVisibleItemsMap) {
         if (runningVisibleItemsMap.hasOwnProperty(runningItemKey) && runningVisibleItemsMap[runningItemKey].wmksKey === wmksKey) {
            if (removeRunningItem(wmksKey, runningVisibleItemsMap[runningItemKey].windowId)) {
               removed = true;
            }
         }
      }
      return removed;
   };

   /**
    * addDesktopItem
    *
    * Handle the notification from wmksSevice about the added desktop.
    * Add current desktop item into running section and set the current
    * desktop to be focused. And notify UI if value is changed.
    *
    * @params desktopId unique desktopId.
    * @params isApplicationSession if it is an application session.
    * @params isShadowSession if it is a shadow session.
    * @params desktopName current desktop name
    * Return true if a desktop item is added successfully.
    */
   addDesktopItem = function addDesktopItem(desktopId, isApplicationSession, isShadow, desktopName) {
      var newDesktopItem = void 0;
      if (isApplicationSession) {
         return false;
      }

      if (!runningDesktopMap[desktopId]) {
         newDesktopItem = {
            wmksKey: desktopId,
            name: desktopName,
            type: AB.CONST.ITEMS_TYPE.DESKTOP,
            state: AB.CONST.ITEMS_STATE.CONNECTED,
            isShadow: isShadow,
            instances: [],
            isCollapsed: true,
            isFocusedItem: function isFocusedItem() {
               return desktopId === currentFocusWmksKey;
            }
         };

         runningItems.push(newDesktopItem);
         runningDesktopMap[desktopId] = newDesktopItem;
         self.emit("valueChanged");
         return true;
      } else {
         return false;
      }
   };

   /**
    * onUnityReady
    *
    * Called when a unity session becomes ready. First, search for and
    * remove any session placeholder entries in runningItems. Then, start
    * a timer that blocks checkVisibleWindows in its duration, then calls
    * checkVisibleWindows on completion. This lets us wait a short
    * duration for unity to reload the windows on the session before we
    * do a visible windows check. See bug #1398864
    *
    * @params wmksKey: the key of the wmks session that has become ready
    */
   onUnityReady = function onUnityReady(wmksKey) {
      removeAttentionRequired(wmksKey);

      if (!!unityReadyTimer) {
         return;
      }
      unityReadyTimer = $timeout(function () {
         unityReadyTimer = null;
         checkVisibleWindows();
      }, unityReadyTimeout, false);
   };

   /**
    * changeFocusedSession
    *
    * Handle the notification from wmksSevice about the changed active
    * session. set the current focused session key and notify UI.
    *
    * @params wmksKey unique identifier for session.
    */
   changeFocusedSession = function changeFocusedSession(wmksKey) {
      if (currentFocusWmksKey !== wmksKey) {
         currentFocusWmksKey = wmksKey;
         self.emit("valueChanged");
      }

      // If we are currently focused on a session loading placeholder,
      // unfocus it
      if (loadingSessionsItem.focusedItem) {
         loadingSessionsItem.focusedItem.isFocused = false;
         loadingSessionsItem.focusedItem = null;
      }
      // If focused session has a loading placeholder, set focus on the
      // placeholder
      if (loadingSessionsMap[wmksKey]) {
         loadingSessionsItem.focusedItem = loadingSessionsMap[wmksKey];
         loadingSessionsItem.focusedItem.isFocused = true;
      }
   };

   /**
    * onSessionRemoved
    *
    * Responds to a session removed event, will remove any placeholders
    * and desktop items associated with the given session.
    *
    * @params wmksKey: the key of the calling session
    */
   onSessionRemoved = function onSessionRemoved(wmksKey, isApplicationSession) {
      var removed = false;

      removeLoadingPlaceholder(wmksKey);

      if (isApplicationSession) {
         removed = removeAllRunningItemsPerSession(wmksKey);
      } else {
         removed = removeDesktopItem(wmksKey);
      }
      // If we removed a session, do a visible windows check
      if (removed) {
         checkVisibleWindows(true);
      }
   };

   /**
    * removeDesktopItem
    *
    * Handle the notification from wmksSevice about the removed desktop.
    * Remove specified desktop and notify UI if value is changed.
    *
    * @params desktopId unique desktopId.
    */
   removeDesktopItem = function removeDesktopItem(desktopId) {
      var desktopItemIndex = -1,
          currentDesktopItem = runningDesktopMap[desktopId];
      if (currentDesktopItem) {
         desktopItemIndex = runningItems.indexOf(currentDesktopItem);
         if (desktopItemIndex !== -1) {
            runningItems.splice(desktopItemIndex, 1);
         }
         delete runningDesktopMap[desktopId];
         self.emit("valueChanged");
         return true;
      } else {
         return false;
      }
   };

   /**
    * addLoadingPlaceholder
    *
    * Creates a placeholder for a loading session, to be displayed as an
    * instance under the special "Loading" item. If the "Loading" item is
    * not displayed, add it to the list of displayed items.
    *
    * @param wmksKey: The key of the calling wmks session
    */
   addLoadingPlaceholder = function addLoadingPlaceholder(wmksKey) {
      var newSessionInstance = {
         wmksKey: wmksKey,
         name: _("LOADING_SESSION"),
         iconSrc: AB.CONST.ICONS.LOADING_ICON,
         isFocused: false
      };

      /*
       * if we had no placeholders and we just added one, add the loading item to
       * the runningItems list
       */
      if (loadingSessionsItem.instances.length === 0) {
         runningItems.push(loadingSessionsItem);
      }
      loadingSessionsItem.instances.push(newSessionInstance);
      loadingSessionsMap[wmksKey] = newSessionInstance;

      // If session placeholder is focused, set focus on UI
      if (currentFocusWmksKey === wmksKey) {
         loadingSessionsItem.focusedItem = newSessionInstance;
         loadingSessionsItem.focusedItem.isFocused = true;
      }
   };

   /**
    * removeLoadingPlaceholder
    *
    * Removes a loading items placeholder instance for a given session.
    * If the
    * "Loading" item has no instances, remove it from the sidebar.
    *
    * @param wmksKey: The key of the calling wmks session
    */
   removeLoadingPlaceholder = function removeLoadingPlaceholder(wmksKey) {
      /*
       * If session leaves the connecting state, remove any session
       * placeholder entries that exist.
       */
      var currentSessionInstance = loadingSessionsMap[wmksKey];
      var index = loadingSessionsItem.instances.indexOf(currentSessionInstance);

      if (!currentSessionInstance) {
         return;
      }

      if (loadingSessionsItem.focusedItem === currentSessionInstance) {
         loadingSessionsItem.focusedItem = null;
      }

      if (index !== -1) {
         loadingSessionsItem.instances.splice(index, 1);
      }

      /*
       * if the last placeholder has been removed, remove the loading
       * item from runningItems
       */
      if (loadingSessionsItem.instances.length === 0) {
         index = runningItems.indexOf(loadingSessionsItem);
         if (index !== -1) {
            runningItems.splice(index, 1);
         }
      }

      delete loadingSessionsMap[wmksKey];
      self.emit("valueChanged");
   };

   /**
    * addAttentionRequired
    *
    * Adds an "Attention Required" item for a paused session to the
    * sidebar.
    *
    * @param wmksKey: The key of the calling wmks session
    */
   addAttentionRequired = function addAttentionRequired(wmksKey) {
      var newSessionItem = void 0;

      if (!runningItemsMap[wmksKey]) {
         newSessionItem = {
            wmksKey: wmksKey,
            name: _('ATTENTION_REQUIRED'),
            iconSrc: AB.CONST.ICONS.ATTENTION_ICON,
            type: AB.CONST.ITEMS_TYPE.NEED_ATTENTION,
            instances: [],
            isCollapsed: true,
            isFocusedItem: function isFocusedItem() {
               return wmksKey === currentFocusWmksKey;
            }
         };
         runningItems.push(newSessionItem);
         runningItemsMap[wmksKey] = newSessionItem;

         self.emit("valueChanged");
      } else {
         AB.LOGGER.warn("addAttentionRequired: attempted to add placeholder that already existed");
      }
   };

   /**
    * removeAttentionRequired
    *
    * Removes the "Attention Required" item for a given paused session to
    * the sidebar.
    *
    * @param wmksKey: The key of the calling wmks session
    */

   removeAttentionRequired = function removeAttentionRequired(wmksKey) {
      var sessionItem = void 0,
          index = void 0;
      if (runningItemsMap[wmksKey]) {
         sessionItem = runningItemsMap[wmksKey];
         index = runningItems.indexOf(sessionItem);
         if (index !== -1) {
            runningItems.splice(index, 1);
         }
         delete runningItemsMap[wmksKey];
         self.emit("valueChanged");
      } else {
         AB.LOGGER.warn("removeAttentionRequired: attemped to remove placeholder that did not exist");
      }
   };

   /**
    * changeRunningItemStatus
    *
    * Change item status based on session status.
    *
    * @params wmksKey unique session id.
    * @params isApplicationSession isDesktop or application.
    * @params state: the item state to change to
    * Return true if status is changed.
    */
   changeRunningItemStatus = function changeRunningItemStatus(wmksKey, isApplicationSession, state) {
      var isChanged = false,
          runningApplicationKey = void 0,
          currentItem = void 0,
          hasApps = false;

      if (!isApplicationSession) {
         currentItem = runningDesktopMap[wmksKey];
         if (currentItem && currentItem.state !== state) {
            currentItem.state = state;
            isChanged = true;
         }
      } else {
         for (runningApplicationKey in runningApplicationMap) {
            if (runningApplicationMap.hasOwnProperty(runningApplicationKey) && runningApplicationMap[runningApplicationKey].wmksKey === wmksKey) {
               hasApps = true;
               if (runningApplicationMap[runningApplicationKey].state !== state) {
                  isChanged = true;
                  runningApplicationMap[runningApplicationKey].state = state;
               }
            }
         }

         /*
          * On session connecting, if that session has no associated apps we
          * create a placeholder instance under the "Loading" item.
          */
         if (!hasApps && state === AB.CONST.ITEMS_STATE.CONNECTING && !loadingSessionsMap[wmksKey]) {
            addLoadingPlaceholder(wmksKey);
            isChanged = true;
         } else if (state !== AB.CONST.ITEMS_STATE.CONNECTING && loadingSessionsMap[wmksKey]) {
            removeLoadingPlaceholder(wmksKey);
            isChanged = true;
         }
      }
      if (isChanged) {
         self.emit("valueChanged");
      }
      return isChanged;
   };

   /**
    * init
    *
    * Listen to all the events of wmksService.
    */
   init = function init() {
      // initialize the "Loading" item to hold loading session
      // placeholders
      loadingSessionsItem = {
         name: _('LOADING'),
         iconSrc: AB.CONST.ICONS.LOADING_ICON,
         type: AB.CONST.ITEMS_TYPE.LOADING_ITEM,
         focusedItem: null,
         instances: [],
         isCollapsed: true,
         isFocusedItem: function isFocusedItem() {
            return !!loadingSessionsMap[currentFocusWmksKey];
         }
      };

      wmksServiceEventHandler.addEventListener('sessionAdded', addDesktopItem);
      wmksServiceEventHandler.addEventListener('sessionRemoved', onSessionRemoved);
      wmksServiceEventHandler.addEventListener('sessionConnecting', function (wmksKey, isApplicationSession) {
         changeRunningItemStatus(wmksKey, isApplicationSession, AB.CONST.ITEMS_STATE.CONNECTING);
      });
      wmksServiceEventHandler.addEventListener('sessionConnected', function (wmksKey, isApplicationSession) {
         changeRunningItemStatus(wmksKey, isApplicationSession, AB.CONST.ITEMS_STATE.CONNECTED);
      });
      wmksServiceEventHandler.addEventListener('sessionDisconnected', function (wmksKey, isApplicationSession) {
         changeRunningItemStatus(wmksKey, isApplicationSession, AB.CONST.ITEMS_STATE.DISCONNECTED);
      });
      wmksServiceEventHandler.addEventListener('activeSessionChanged', changeFocusedSession);
      wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.RUNNING_ITEMS);

      unityService.addEventListener('windowAdded', addRunningItem);
      unityService.addEventListener('visibleChanged', function (wmksKey, isShow) {
         setCanvasVisibility(wmksKey, isShow);
      });
      unityService.addEventListener('windowRemoved', removeRunningItem);
      unityService.addEventListener('titleChanged', function (wmksKey, windowId, windowTitle) {
         updateRunningItem(wmksKey, windowId, { windowTitle: windowTitle });
      });
      unityService.addEventListener('iconChanged', function (wmksKey, windowId, iconSrc) {
         updateRunningItem(wmksKey, windowId, { iconSrc: iconSrc });
      });
      unityService.addEventListener('appAttrChanged', function (wmksKey, windowPath, execPath, name, iconSrc) {
         updateApplicationAttribute(wmksKey, windowPath, execPath, { windowTitle: name, iconSrc: iconSrc });
      });
      unityService.addEventListener('attrChanged', updateRunningItemAttribute);
      unityService.addEventListener('typeChanged', updateRunningItemType);
      unityService.addEventListener('unityReady', onUnityReady);
      unityService.addEventListener('unityPaused', addAttentionRequired);
      unityService.addEventListener('unityDestroyed', removeAttentionRequired);

      _signal2.default.makeObservable(self);
      self.addSignal('valueChanged');
      self.addSignal('noVisibleWindow');
   };

   /**
    * runningItemsModel.getRunningItems
    *
    * Return a array of running application and desktop.
    */
   this.getRunningItems = function () {
      return runningItems;
   };

   $rootScope.$on('$destroy', function () {
      if (unityReadyTimer) {
         $timeout.cancel(unityReadyTimer);
         unityReadyTimer = null;
      }
      if (checkVisibleWindowTimer) {
         $timeout.cancel(checkVisibleWindowTimer);
         checkVisibleWindowTimer = null;
      }
   });

   /**
    * runningItemsModel.reset
    *
    * Reset all the internal status.
    */
   this.reset = function () {
      // We want to empty the array but preserve the reference
      runningItems.length = 0;
      runningItemsMap = {};
      runningVisibleItemsMap = {};
      runningApplicationMap = {};
      runningDesktopMap = {};
      if (unityReadyTimer) {
         $timeout.cancel(unityReadyTimer);
         unityReadyTimer = null;
      }
      if (checkVisibleWindowTimer) {
         $timeout.cancel(checkVisibleWindowTimer);
         checkVisibleWindowTimer = null;
      }

      self.emit('valueChanged');
   };

   /**
    * getInternalState - For unit test use only!
    *
    * Returns runningItemModel's internal state variables
    */
   this.getInternalState = function () {
      return {
         runningItems: runningItems,
         runningItemsMap: runningItemsMap,
         runningVisibleItemsMap: runningVisibleItemsMap,
         runningApplicationMap: runningApplicationMap,
         runningDesktopMap: runningDesktopMap,
         loadingSessionsMap: loadingSessionsMap
      };
   };

   init();
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * runningitem-model.js --
 *
 * Module to provide running items information for Sidebar.
 *
 */

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = wmksServiceEventHandler;

var _signal = __webpack_require__(16);

var _signal2 = _interopRequireDefault(_signal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wmksServiceEventHandler($q, WMKS, AB) {
   this.MODULE_NAME = {
      CLIPBOARD: 'clipboard',
      PRINT: 'print',
      RUNNING_ITEMS: 'runningItems',
      SIDEBAR: 'sidebar',
      UNITY_SERVICE: 'unityService',
      FT_CONTROLLER: 'fileTransferController',
      FT_HELPER: 'fileTransferHelper',
      PRINT_HELPER: 'printHelper',
      COMMON_SVC_SERVICE: 'commonSvcService'
   };
   this._initStatus = {
      clipboard: false,
      print: !!WMKS.BROWSER.isIE(),
      runningItems: false,
      sidebar: false,
      unityService: false,
      fileTransferController: false,
      fileTransferHelper: false,
      printHelper: !!WMKS.BROWSER.isIE(),
      commonSvcService: false
   };
   this.defer = $q.defer();

   _signal2.default.makeObservable(this);
   this.addSignal('sessionAdded');
   this.addSignal('activeSessionChanged');
   this.addSignal('sessionConnected');
   this.addSignal('sessionConnecting');
   this.addSignal('sessionDisconnected');
   this.addSignal('sessionRemoved');
   this.addSignal('idleSessionWarning');
   this.addSignal('clipboardChanged');
   this.addSignal('clipboardCapabilitiesChanged');
   this.addSignal('clipboardRequestFailed');
   this.addSignal('fileTransferFailed');
   this.addSignal('update-copy-paste-ui');
   this.addSignal('downloadFileListChanged');
   this.addSignal('downloadPrintFileListChanged');
   this.addSignal('fileTransferConfigChange');
   this.addSignal('fileTransferError');
   this.addSignal('printError');
   this.addSignal('sessionDataReady');
   this.addSignal('dpiSyncMsg');

   this.listenersReady = function () {
      return this.defer.promise;
   };

   this.listenerReadyForModule = function (moduleName) {
      if (!moduleName) {
         throw 'No module name is passed in!';
      }

      if (!this._initStatus.hasOwnProperty(moduleName)) {
         throw 'Wrong module name is passed in!';
      }

      this._initStatus[moduleName] = true;
      AB.LOGGER.debug("Listeners of module " + moduleName + " is ready for event.");
      this._checkInitStatus();
   };

   this._checkInitStatus = function () {
      var key = void 0;
      for (key in this._initStatus) {
         if (this._initStatus.hasOwnProperty(key)) {
            if (this._initStatus[key] === false) {
               return;
            }
         }
      }
      // All listeners are ready! Fire the promise
      AB.LOGGER.debug("All listeners are ready! Going to init wmksService.");
      this.defer.resolve();
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * wmks-service-event-handler.js --
 *
 * The the centralized place to manage all the event listener for wmksService.
 * All the services/controllers which are using wmksService event listener
 * should use this service. On the other handle, only when these
 * servers/controllers finish their listener registry, then wmksService can
 * do the rest of init work.
 *
 */

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = wmksService;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * wmks-service.js --
 *
 * Module for managing multiple webmks adapter instances. Wmks Service is a
 * singleton service.
 *
 */

function wmksService(blastWmks, safeStorageService, entitledItemsModel, entitledItemsService, messageHandlerService, MKSVchan, WMKS, AB, $, $timeout, $window, $rootScope, wmksServiceEventHandler, multimonService, commonSvcService, userGlobalPref) {
   var wmksService = {},
       handleDownloadListChange = void 0,
       handlePrintDownloadListChange = void 0,
       handleClipboardReceived = void 0,
       sendFileDownloadRequest = void 0,
       handleFileTransferConfigChange = void 0,
       readAndSendFileChunks = void 0,
       stopFileDownload = void 0,
       stopFileUpload = void 0,
       isFileTransferringForAllSession = void 0,
       isFileTransferringInSession = null,
       isFileTransferringInCurrentSession = void 0,
       isFileDownloadingInSession = null,
       isFileDownloadingInCurrentSession = void 0,
       isPrintFileTransferringForAllSession = void 0,
       isPrintFileTransferringInSession = null,
       isPrintFileTransferringInCurrentSession = void 0,
       handleClipboardFailure = null,
       handleFileTransferFailure = null,
       handleFileTransferError = void 0,
       handlePrintError = void 0,


   // Handle all the notifications from postMessage.
   readSessionData = null,
       sessionData = void 0,
       handleSessionData = null,
       handleUserActivity = null,
       stopTimer = void 0,


   // Track user activity.
   userActivityTime = $.now(),
       setIdleTimeoutWarning = null,
       setUserActivityTime = null,


   // Variables for tracking logoff behavior.
   closeOnExit = false,


   // Handle logoff request from UI. Ideally, this function should not
   // be here.
   pageFlowAfterDisconnect = null,


   // Handle resize and touchstart event.
   handleResize = null,
       handleTouchResize = null,
       handleTouchStart = null,


   // Sync session between memory and local session storage.
   readRunningSession = null,
       writeRunningSession = null,
       sortRunningSession = null,
       _executeRunningSession = null,


   // Handle external command.
   connectToServer = null,
       requestDisconnect = void 0,
       sendCtrlAltDel = void 0,
       sendEsc = void 0,
       launchKeyboard = void 0,
       sessionIdleTimeout = -1,
       // broker idle timeout setting in
   // milliseconds
   idleWarningTimeBeforeDisconnect = 300,
       // five minutes by default
   idleWarningTimer = null,
       sessionTimedOut = false,
       isHighResModeSupported = void 0,
       toggleHighResMode = void 0,
       getWmksSession = void 0,
       _isHighResModeEnabled = userGlobalPref.getPrefData().enableDPISync === "true",
       isMP4Supported = AB.UTIL.isMP4Supported,
       toggleMP4 = void 0,
       _isMP4Enabled = false,
       toggleUseMacOSXKeyMappings = void 0,
       areMacOSXKeyMappingsSupported = WMKS.BROWSER.isMacOS,
       _areMacOSXKeyMappingsEnabled = false,
       toggleWindowsKey = void 0,
       _isWindowsKeyEnabled = false,
       applyInitialHighResSetting = null,
       applyInitialHighResSettingCallback = null,
       getCurrentMKSVchanClient = null,
       clearClipboard = void 0,
       pushClipboard = null,
       sendClipboardText = void 0,
       onClipboardReady = void 0,
       onClipboardChange = void 0,
       updateClipboardCapabilities = null,
       hasMultimonCapacity = void 0,
       addMonitor = void 0,
       quitMultimon = void 0,
       destroyMultimon = void 0,
       whenNotInMultimon = void 0,
       enterMultimon = void 0,
       disconnectEventConnections = void 0,
       recoveryEventConnections = void 0,
       connectToDesktop = null,
       changeWmksSession = null,
       activateWmksSession = null,
       setCanvasVisibility = void 0,
       connectToApplication = null,
       connectToAllApplications = null,
       allAppsReconnected = false,


   // Variables for handling multiple webmks session.
   wmksSessionMap = {},
       currentWmksSession = null,
       currentActiveSessionKey = null,
       isCurrentSession = null,
       isCurrentSessionApp = void 0,
       isCurrentSessionDesktop = void 0,
       isCurrentSessionHasDPIChannelInited = void 0,
       getCurrentSessionDPI = void 0,


   // Handle all the delegate requests from wmksSession.
   sessionOnConnecting = void 0,
       sessionOnConnected = void 0,
       sessionOnDisconnected = void 0,
       sessionOnRemoved = void 0,


   // Returns true if one of the active sessions is an app session
   hasApplicationSession = null,
       updateEmptySession = void 0,
       prepareForSessionReset = void 0,
       sessionResetDone = void 0,


   // Global clipboard object to be shared between sessions
   globalClipboard = null,
       shadowAllHeartbeatForPrint = void 0,
       recoverAllHeartbeatForPrint = void 0,
       shadowAllHeartbeatWhenSafariHidden = null,
       recoverAllHeartbeatWhenSafariVisible = null,
       getAllmksClient = void 0,
       init = void 0;

   /*
    *init
    *
    * Init all the events we are listening to from postMessage
    * and browser native events.
    */
   init = function init() {
      AB.LOGGER.debug("wmksService is waiting for listeners ready.");
      wmksServiceEventHandler.listenersReady().then(function () {
         AB.LOGGER.debug("Listeners ready, wmksService is doing the rest work.");
         var shouldPassKeyboard = void 0;

         sessionData = readSessionData();
         wmksServiceEventHandler.emit('sessionDataReady', sessionData);
         handleSessionData(sessionData);

         // Listen to all the events for tracking user activity.
         $(document).bind('mousemove.useractivity mousedown.useractivity mouseup.useractivity', setUserActivityTime);
         $(document).bind('keydown.useractivity keyup.useractivity', setUserActivityTime);
         $(document).bind('touchstart.useractivity touchmove.useractivity touchend.useractivity', setUserActivityTime);
         $(document).bind('orientationchange.useractivity', setUserActivityTime);
         $(document).bind('extendedmonitoruse.useractivity', setUserActivityTime);
         $(document).bind('primarymonitoruse.useractivity', setUserActivityTime);

         globalClipboard = new MKSVchan.Clipboard();

         /*
          * Create a check on a DOM element to determine whether the element
          * should pass keyboard events to the canvas rather than consume it.
          * The behaviour is browser specific.
          */
         if (WMKS.BROWSER.isIE() && WMKS.BROWSER.version.major < 12) {
            shouldPassKeyboard = function shouldPassKeyboard(elem) {
               /*
                * In old IE, elements like divs are focusable and we check
                * isContentEditable to filter out elements like inputs from the
                * list of elements that should pass keyboard events.
                *
                * Windows Edge will behave like the other browsers
                */
               return !elem.isContentEditable && elem.nodeName !== "CANVAS";
            };
         } else {
            shouldPassKeyboard = function shouldPassKeyboard(elem) {
               /*
                * In non IE browsers, most elements aren't focusable and the
                * keyboard event gets targeted directly at the body unless it is
                * an input, etc.
                */
               return elem.nodeName === "BODY";
            };
         }

         if (WMKS.BROWSER.isSafari()) {
            $window.document.addEventListener("visibilitychange", function () {
               if ($window.document.hidden) {
                  // Shadow heartbeat for Safari
                  shadowAllHeartbeatWhenSafariHidden();
               } else {
                  // Recover heartbeat for Safari
                  recoverAllHeartbeatWhenSafariVisible();
               }
            }, false);
         }

         /*
          * We currently catch any key events not consumed by an input, canvas,
          * etc and redirects the input to the canvas. This ensures that we
          * don't lose any keystrokes while being focused on a non-interactable
          * part of the sidebar, since there's no UI indication that the sidebar
          * is focused.
          */
         $(window).bind("keypress keydown keyup", function (e) {
            if (currentWmksSession && shouldPassKeyboard(e.target)) {
               var canvas = currentWmksSession.wmksContainer.find("canvas");
               if (canvas.length > 0) {
                  e.target = canvas[0];
                  canvas.trigger(e);
               }
            }
         });

         $rootScope.beforeunload = false;
         $(window).bind('beforeunload', function () {
            $rootScope.beforeunload = true;
         });

         // Listen to onSize to adjust window size.
         if (WMKS.BROWSER.isTouchDevice()) {
            $(window).on('orientationchange', handleResize);
            $(window).on('touchstart', handleTouchStart);
            //change the main div to position fixed, bug 1583810
            $("#main").css({ position: 'fixed' });
         }
         // add resize for touchdevice to solve bug 1916087
         // screen need to resize if open soft keyboard on touchdevice
         $(window).on('resize', handleResize);

         // Gets idle timeout data, and inits the idle warning timer.
         sessionIdleTimeout = entitledItemsModel.getIdleTimeout();
         AB.LOGGER.log("Session idle timeout is " + sessionIdleTimeout);

         if (sessionIdleTimeout !== -1) {
            idleWarningTimeBeforeDisconnect = Math.min(idleWarningTimeBeforeDisconnect, Math.floor(sessionIdleTimeout / 5));
            AB.LOGGER.log("Idle warning time set to " + idleWarningTimeBeforeDisconnect);
            setIdleTimeoutWarning();
         }
      });
   };

   /**
    * iPhone not supported
    */
   isHighResModeSupported = function isHighResModeSupported() {
      return WMKS.UTIL.isHighResolutionSupported() && !AB.UTIL.isIPhone();
   };

   /**
    * handleDownloadListChange
    *
    * handles download file list change notifications from the remote
    * server
    *
    * @params downloadList: formatted file list reference
    */
   handleDownloadListChange = function handleDownloadListChange(downloadList, client, error) {
      wmksServiceEventHandler.emit("downloadFileListChanged", downloadList, client, error);
   };

   /**
    * handlePrintDownloadListChange
    *
    * handles print download file list change notifications from the
    * remote server
    *
    * @params downloadList: formatted file list reference
    */
   handlePrintDownloadListChange = function handlePrintDownloadListChange(downloadList, client, error) {
      wmksServiceEventHandler.emit("downloadPrintFileListChanged", downloadList, client, error);
   };

   /**
    * handleClipboardReceived
    *
    * handles clipboard change notifications from the remote server
    *
    * @params clipboard: A mksVchan clipboard object
    */
   handleClipboardReceived = function handleClipboardReceived(clipboard, error) {
      globalClipboard = clipboard;

      var text = globalClipboard.getText(MKSVchan.CP_FORMAT.TEXT);

      if (text != null) {
         wmksServiceEventHandler.emit("clipboardChanged", text, error);
      }
   };

   /**
    * handleClipboardFailed
    *
    * handles failures to send clipboard RPCs to the remote server
    */
   handleClipboardFailure = function handleClipboardFailure() {
      AB.LOGGER.error("Failed to send clipboard RPC");
      wmksServiceEventHandler.emit("clipboardRequestFailed");
   };

   /**
    * handleClipboardFailed
    *
    * handles failures to send clipboard RPCs to the remote server
    */
   handleFileTransferFailure = function handleFileTransferFailure() {
      AB.LOGGER.error("Failed to send file transfer RPC");
      wmksServiceEventHandler.emit("fileTransferFailed");
   };

   /**
    * handleFileTransferError
    *
    * handles error sent from server for file transfer
    */
   handleFileTransferError = function handleFileTransferError(error) {
      wmksServiceEventHandler.emit("fileTransferError", error);
   };

   /**
    * handlePrintError
    *
    * handles error sent from server for print
    */
   handlePrintError = function handlePrintError(error) {
      wmksServiceEventHandler.emit("printError", error);
   };

   /**
    * handleFileTransferConfigChange
    *
    * handles config received from MKSvchan server
    */
   handleFileTransferConfigChange = function handleFileTransferConfigChange(error) {
      wmksServiceEventHandler.emit("fileTransferConfigChange", error);
   };

   /**
    * readRunningSession
    *
    * Read runningSession item from localStorage. If we never set this
    * item, for desktop, we will use the session data passed from portal
    * page, for application, we will call reconnectApplicationSessions to
    * get all the application sessions for this user. If we have set this
    * item, we will trust the data in localStorage and run the session
    * one by one.
    *
    * @params focusedSession session info passed from portal page.
    */
   readRunningSession = function readRunningSession(focusedSession) {
      // Schedule all of this work for after entitledItemsService.init()
      // is done
      entitledItemsService.addInitDoneCallback(function () {
         if (sessionData['idleTimeout'] !== "-1") {
            entitledItemsService.startIdleTimer(sessionData['brokerSupportIdleTimeout'], sessionData['idleTimeout'], sessionData['userActivityXMLSendingInterval'], sessionData['brokerUrl'], sessionData['brokerUrlWithTimestamp'], handleUserActivity);
         }
         safeStorageService.getItem("RunningSession", function (data) {
            var runningSessions = void 0,
                i = void 0;
            if (data === null) {
               // We launch an item from portal page.
               _executeRunningSession(focusedSession);
            } else {
               // User refreshes browser
               runningSessions = _angular2.default.fromJson(data);
               for (i = 0; i < runningSessions.length; i++) {
                  if (runningSessions[i].isApplicationSession) {
                     allAppsReconnected = true;
                     break;
                  }
               }
               _executeRunningSession(_angular2.default.fromJson(data), true);
            }
         }, null);
      });
   };

   /**
    * writeRunningSession
    *
    * Sync all session data to localStorage.
    *
    */
   writeRunningSession = function writeRunningSession() {
      var tempArray = [],
          wmksKey = null,
          wmksSession = null;

      for (wmksKey in wmksSessionMap) {
         /* istanbul ignore else */
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            wmksSession = wmksSessionMap[wmksKey];
            tempArray.push({
               key: wmksSession.key,
               url: wmksSession.url,
               isActive: wmksSession.isActive,
               isApplicationSession: wmksSession.isApplicationSession,
               isShadow: wmksSession.isShadow,
               name: wmksSession.name
            });
         }
      }
      safeStorageService.setItem("RunningSession", _angular2.default.toJson(tempArray));
   };

   /**
    * sortRunningSession
    *
    * Sort an array of running sessions such that the last element in the
    * array is the active session.
    */
   sortRunningSession = function sortRunningSession(runningSession) {
      var i = void 0;
      if (runningSession.length < 2) {
         return;
      }

      // Move the active session to the end of the list
      for (i = 0; i < runningSession.length; i++) {
         // Assume there is only one active item in the array.
         if (runningSession[i].isActive) {
            runningSession.push(runningSession.splice(i, 1)[0]);
            break;
         }
      }
   };

   /**
    * executeRunningSession
    *
    * Connect to running session one by one.
    * Active status might not be right when resuming the session. Will fix
    * it in next changelist.
    *
    * @params runningSession: a list of running session
    * @params sort: whether or not to sort the list of running sessions so
    *    that the active session is the last session
    * @param onDone: callback to invoke when the last session is resumed
    */
   _executeRunningSession = function executeRunningSession(runningSession, sort, onDone) {
      var currentSession = null,
          session = null,
          i = 0;
      if (!_angular2.default.isArray(runningSession)) {
         runningSession = [runningSession];
      }

      if (sort) {
         sortRunningSession(runningSession);
      }

      // If there is a session left in the array try to resume it
      if (runningSession.length > 0) {
         currentSession = runningSession.shift();

         AB.LOGGER.debug("Starting to load" + (currentSession.isActive ? " active" : " inactive") + " key " + currentSession.key + (!currentSession.isShadow ? " primary" : " shadow") + (currentSession.isApplicationSession ? " application" : " desktop") + " session with url " + currentSession.url);

         // Try to resume the current session. If this is the last
         // session
         // in the array then schedule onDone as the callback for when
         // that session resumes (or fails to resume). If there are more
         // than one remaining sessions then schedule the handling of
         // these sessions as a callback. This is necessary becasuse
         // connectToApplication/connectToADesktop make an async call so
         // the callback is needed to force the calls to follow a
         // sequence.
         if (currentSession.isApplicationSession) {
            connectToApplication(undefined, currentSession.key, currentSession.url, runningSession.length === 0 ? onDone : function () {
               _executeRunningSession(runningSession, false, onDone);
            });
         } else {
            connectToDesktop(currentSession.key, currentSession.name, currentSession.url, currentSession.isShadow, runningSession.length === 0 ? onDone : function () {
               _executeRunningSession(runningSession, false, onDone);
            });
         }
      }
   };

   /**
    * Read data from session storage. This function is implemented by
    * kwikclient previously. Now we need to do it ourselves.
    */
   readSessionData = function readSessionData() {
      var sessionParams = {
         desktopName: null,
         desktopId: null,
         user: null,
         domainName: null,
         closeOnExit: null,
         referer: null,
         rebrand: null,
         idleTimeout: null,
         userActivityXMLSendingInterval: null,
         brokerSupportIdleTimeout: null,
         brokerUrl: null,
         brokerUrlWithTimestamp: null,
         blastURL: null,
         isApplicationSession: true,
         isShadow: false,
         horizonId: null,
         logLevel: null
      };

      // Load optional params. One of these can tell us about logout.
      var key = void 0,
          value = void 0;
      for (key in sessionParams) {
         value = window.sessionStorage.getItem(key);
         AB.LOGGER.log("Read session data " + key + " : " + value);
         if (!!value && value !== 'null' && value !== 'undefined') {
            sessionParams[key] = value;
         }
      }

      return sessionParams;
   };

   /**
    * handleSessionData
    *
    * pmManager callback for the handleSessionData.
    * We will start the bootstrap session.
    */
   handleSessionData = function handleSessionData(args) {
      // Append relevant text from parent window.
      var desktopInfo = args.desktopName || '',
          userInfo = args.userName || '',
          blastURL = args.blastURL,
          horizonId = args.horizonId || '',
          webSocketUrl = void 0,
          isApplicationSession = args.isApplicationSession && args.isApplicationSession === "true",
          isShadow = args.isShadow && args.isShadow === "true";

      // Set the flag to true only if the flag exists and has a true
      // string value.
      closeOnExit = args.closeOnExit && args.closeOnExit === "true";

      // Init the messageHandlerService with current user info, currently,
      // only use the horizonId
      messageHandlerService.init({
         horizonId: horizonId,
         userName: userInfo,
         domainName: args.domainName || '',
         brokerAddress: location.host
      });

      if (!blastURL) {
         return;
      }

      if (!!args.logLevel) {
         AB.LOGGER.setLevel(Number(args.logLevel));
         _jscdkLogger2.default.setLogLevel(Number(args.logLevel));
      }

      if (!isApplicationSession) {
         safeStorageService.getItem("OriginDesktop", function (data) {
            if (!data || !data.id || !data.name) {
               AB.LOGGER.log("There is no desktop information during bootstrap process.");
               return;
            }
            readRunningSession({
               key: data.id,
               name: data.name,
               url: blastURL,
               isActive: true,
               isApplicationSession: false,
               isShadow: isShadow
            });
         }, null);
      } else {
         // Connect to apps.
         safeStorageService.getItem("OriginAppID", function (originId) {
            if (!originId) {
               AB.LOGGER.log("There is no application id information during bootstrap process.");
               return;
            }
            readRunningSession({
               key: originId,
               url: blastURL,
               isActive: true,
               isApplicationSession: true
            });
         }, null);
      }
   };

   /**
    * connectToAllApplications
    *
    * Connect to all the running app session.
    *
    * @params focusedSessionKey focused session key.
    */
   connectToAllApplications = function connectToAllApplications(focusedSessionKey) {
      AB.LOGGER.log("Start to reload all the applications which is triggered by " + focusedSessionKey);
      entitledItemsService.reconnectApplicationSessions(function (response) {
         var sessionList = [],
             i = 0;
         AB.LOGGER.log(response);
         if (response.success && response.successSessionInfo && response.successSessionInfo.length > 0) {
            for (i = 0; i < response.successSessionInfo.length; i++) {
               // Do not try to reconnect to a session with the same
               // origin ID as the already running focused session
               if (response.successSessionInfo[i].originId === focusedSessionKey) {
                  AB.LOGGER.error("should not reload a loaded session");
                  continue;
               }
               sessionList.push({
                  key: response.successSessionInfo[i].originId,
                  url: response.successSessionInfo[i].blastUrl,
                  isActive: response.successSessionInfo[i].originId === focusedSessionKey,
                  isApplicationSession: true
               });
            }
            // Launch the other sessions and schedule changing the
            // the focus to focusedSession as a callback
            _executeRunningSession(sessionList, true, function () {
               changeWmksSession(focusedSessionKey, false);
            });
         } else {
            // No sessions to reconnect just bring the focused session
            // to the front
            changeWmksSession(focusedSessionKey, false);
         }
      }, null, [], focusedSessionKey);
   };

   /**
    * connectToApplication
    *
    * Connect to a specified application. If it is the bootstrap time,
    * we will connect the specified url. If it is launched by sidebar,
    * we try to reuse the session from the same farm and launch an app
    * from it. Otherwise, launch a new app session.
    *
    * @params applicationId unique applicationId.
    * @params originId the original farm identifier .
    * @params targetUrl target url for connecting.
    * @params onDone the callback when completing the request.
    */
   connectToApplication = function connectToApplication(applicationId, originId, targetUrl, onDone, timeoutHandler) {
      var callback = function callback(response) {
         // start timer
         if (!!timeoutHandler) {
            timeoutHandler();
         }
         entitledItemsService.getUserGlobalPref().then(function (prefData) {
            var canReuseSession = void 0;
            _isHighResModeEnabled = prefData.enableDPISync === "true";
            _areMacOSXKeyMappingsEnabled = areMacOSXKeyMappingsSupported() && prefData.useMacOSXKeyMappings !== 'false';
            _isWindowsKeyEnabled = prefData.enableWindowsKey === "true";
            _isMP4Enabled = prefData.enableMP4 === "true";

            if (targetUrl) {
               // Bootstrap process for application.
               connectToServer(targetUrl, true, false, // We don't support shadow session for applications.
               originId);
               changeWmksSession(originId, true);
               if (!allAppsReconnected) {
                  allAppsReconnected = true;
                  connectToAllApplications(originId);
               }
               /* istanbul ignore else */
               if (onDone) {
                  onDone(true);
               }
            } else {
               canReuseSession = wmksSessionMap[originId] ? true : false;
               entitledItemsService.launch(applicationId, entitledItemsService.itemTypeEnum.application, canReuseSession ? originId : null, function (response) {
                  AB.LOGGER.log(response);
                  if (response.success) {
                     if (!canReuseSession) {
                        connectToServer(response.blastURL, true, false, // We don't support shadow session for applications.
                        originId);
                     }
                     changeWmksSession(originId, !canReuseSession);
                     if (!allAppsReconnected) {
                        allAppsReconnected = true;
                        $timeout(function () {
                           connectToAllApplications(originId);
                        }, 0, false);
                     }
                  }
                  /* istanbul ignore else */
                  if (onDone) {
                     onDone(response);
                  }
               });
            }
         });
      };
      entitledItemsService.authenticationStatusCheck(callback, onDone);
   };

   /**
    * connectToDesktop
    *
    * Connect to a specified desktop. If it is the bootstrap time,
    * we will connect the specified url. If it is launched by sidebar,
    * we will get a new session. Otherwise, we will display the hidden
    * desktop.
    *
    * @params desktopId unique desktopId.
    * @params desktopName desktop name .
    * @params targetUrl target url for connecting.
    * @params isShadow a shadow desktop
    * @params onDone the callback when completing the request.
    */
   connectToDesktop = function connectToDesktop(desktopId, desktopName, targetUrl, isShadow, onDone) {
      entitledItemsService.getUserGlobalPref().then(function (prefData) {
         var addSession = function addSession() {
            $timeout(function () {
               wmksServiceEventHandler.emit('sessionAdded', desktopId, false, isShadow, desktopName);
            }, 0, false);
         };

         _isHighResModeEnabled = prefData.enableDPISync === "true";
         _areMacOSXKeyMappingsEnabled = areMacOSXKeyMappingsSupported() && prefData.useMacOSXKeyMappings !== 'false';
         _isWindowsKeyEnabled = prefData.enableWindowsKey === "true";
         _isMP4Enabled = prefData.enableMP4 === "true";

         if (!wmksSessionMap[desktopId]) {
            if (!targetUrl) {
               // From sidebar.
               entitledItemsService.launch(desktopId, entitledItemsService.itemTypeEnum.desktop, null, function (response) {
                  AB.LOGGER.log(response);
                  if (response.success && response.blastURL) {
                     addSession();
                     connectToServer(response.blastURL, false, isShadow, desktopId, desktopName);
                     changeWmksSession(desktopId, true);
                  }

                  /* istanbul ignore else */
                  if (onDone) {
                     onDone(response);
                  }
               });
            } else {
               // For bootstrap process.
               addSession();
               connectToServer(targetUrl, false, isShadow, desktopId, desktopName);
               changeWmksSession(desktopId, true);

               /* istanbul ignore else */
               if (onDone) {
                  onDone(true);
               }
            }
         } else {
            // Show the hidden canvas of this desktop when clicking
            // on entitle item section.
            changeWmksSession(desktopId);
            /* istanbul ignore else */
            if (onDone) {
               onDone(true);
            }
         }
      });
   };

   /**
    * activateWmksSession
    *
    * Activate specified wmksSession .
    *
    * @params activeSessionKey unique identifier for this wmks session.
    *
    * Return true if active session is changed.
    */
   activateWmksSession = function activateWmksSession(activeSessionKey) {
      currentActiveSessionKey = activeSessionKey;
      var wmksKey = void 0;

      if (!wmksSessionMap[activeSessionKey]) {
         AB.LOGGER.warn('Tried to activate unknown session: ' + activeSessionKey);
         return false;
      }

      if (!currentWmksSession) {
         wmksSessionMap[activeSessionKey].setVisibility(true);
         currentWmksSession = wmksSessionMap[activeSessionKey];
         updateClipboardCapabilities();
         return true;
      } else if (currentWmksSession.key === activeSessionKey) {
         return false;
      } else {
         for (wmksKey in wmksSessionMap) {
            /* istanbul ignore else */
            if (wmksSessionMap.hasOwnProperty(wmksKey)) {
               wmksSessionMap[wmksKey].setVisibility(activeSessionKey === wmksKey);
            }
         }
         currentWmksSession = wmksSessionMap[activeSessionKey];
         updateClipboardCapabilities();
         return true;
      }
   };

   /**
    * setCanvasVisibility
    *
    * Display specified wmksSession .
    *
    * @params wmksKey unique identifier for this wmks session.
    *
    */
   setCanvasVisibility = function setCanvasVisibility(wmksKey, isShow) {
      if (!wmksSessionMap[wmksKey]) {
         AB.LOGGER.warn('Tried to set unknown session: ' + wmksKey);
         return;
      }

      wmksSessionMap[wmksKey].toggleVisibility(isShow && currentActiveSessionKey === wmksKey);
   };

   /**
    * changeWmksSession
    *
    * Activate specified session and notify UI.
    *
    * @params wmksKey unique desktopId.
    * @params isNewSession: indicates that the wmks session is newly
    *    created
    */
   changeWmksSession = function changeWmksSession(wmksKey, isNewSession) {
      if (activateWmksSession(wmksKey)) {
         writeRunningSession();
         $timeout(function () {
            if (!isNewSession) {
               pushClipboard();
            }
            wmksServiceEventHandler.emit('activeSessionChanged', wmksKey);
         }, 0, false);
      }
   };

   /**
    * handleUserActivity
    *
    * Callback for the handleRequestUserActivity.
    */
   handleUserActivity = function handleUserActivity() {
      var sessionIdleTimeoutMS = sessionIdleTimeout * 1000;
      setIdleTimeoutWarning();

      if (sessionIdleTimeout === -1) {
         sessionTimedOut = false;
         return;
      } else {
         sessionTimedOut = $.now() - userActivityTime >= sessionIdleTimeoutMS;
      }

      return userActivityTime;
   };

   stopTimer = function stopTimer() {
      entitledItemsService.stopIdleTimer();
   };

   /**
    * setIdleTimeoutWarning
    *
    * When called, calculates the time until we need to show a idle
    * session warning, then sets a timer to issue the warning if
    * necessary. If the timer is already set, then its duration is
    * updated. The warning is only issued if we are connected to an
    * application session.
    *
    */
   setIdleTimeoutWarning = function setIdleTimeoutWarning() {
      var timeElapsedMS = void 0,
          warningTimeMS = void 0;

      // Cancel old timer
      $timeout.cancel(idleWarningTimer);
      idleWarningTimer = null;

      // proceed if idle timeout is set and longer than the warning time
      if (sessionIdleTimeout !== -1 && sessionIdleTimeout > idleWarningTimeBeforeDisconnect) {
         // Calculate time to warning in milliseconds
         warningTimeMS = 1000 * (sessionIdleTimeout - idleWarningTimeBeforeDisconnect);
         timeElapsedMS = $.now() - userActivityTime;
         AB.LOGGER.info("Time since last activity (ms): " + timeElapsedMS);

         // if warning time is in the future, set a timer for it
         if (timeElapsedMS < warningTimeMS) {
            idleWarningTimer = $timeout(function () {
               if (hasApplicationSession()) {
                  wmksServiceEventHandler.emit('idleSessionWarning');
               }
            }, warningTimeMS - timeElapsedMS);
         }
      }
   };

   /**
    * setUserActivityTime
    *
    * Record the activity time when user is using the web client.
    */
   setUserActivityTime = function setUserActivityTime() {
      userActivityTime = $.now();
   };

   /**
    * handleResize
    *
    * We need to resize the remote desktop for onSize.
    * Todo: We need to resize the desktop for all the sessions?
    */
   handleResize = function handleResize(e) {
      if (WMKS.BROWSER.isAndroid()) {
         handleTouchResize();
      } else {
         var screenSize = AB.UTIL.getDesiredResolution(),
             wmksKey = void 0,
             wmksInstance = void 0;

         // Send a rescale request to resize based on the parent container
         // size.
         for (wmksKey in wmksSessionMap) {
            /* istanbul ignore else */
            if (wmksSessionMap.hasOwnProperty(wmksKey)) {
               wmksInstance = wmksSessionMap[wmksKey];
               if (wmksInstance !== multimonService.getMultimonSession()) {
                  wmksInstance.updateResolution(screenSize, true);
               } else {
                  _jscdkLogger2.default.debug("skip resize for session wmksKey: " + wmksKey);
               }
            }
         }
      }
   };

   /**
    * handleTouchResize
    *
    * We need to resize the remote desktop for onSize.
    * Todo: We need to resize the desktop for all the sessions?
    */
   handleTouchResize = function handleTouchResize(e) {
      var callback = function callback(screenSize) {
         var wmksKey = void 0;

         // Send a rescale request to resize based on the parent container
         // size.
         for (wmksKey in wmksSessionMap) {
            /* istanbul ignore else */
            if (wmksSessionMap.hasOwnProperty(wmksKey)) {
               if (wmksSessionMap[wmksKey] !== multimonService.getMultimonSession()) {
                  wmksSessionMap[wmksKey].updateResolution(screenSize, true);
               } else {
                  _jscdkLogger2.default.debug("skip resize for session wmksKey");
               }
            }
         }
      };
      AB.UTIL.getTouchDeviceDesiredResolution(callback);
   };

   /**
    * hasMultimonCapacity
    *
    * Return whether the current session supporting multimon
    */
   hasMultimonCapacity = function hasMultimonCapacity() {
      if (!currentWmksSession) {
         return false;
      }

      return currentWmksSession.multimonServerEnabled;
   };

   /**
    * addMonitor
    */
   addMonitor = function addMonitor(uiCallback, closeSidebar) {
      if (!!currentWmksSession && currentWmksSession.hasOwnProperty("wmksContainer") && currentWmksSession.wmksContainer.length >= 1) {
         AB.LOGGER.log("add a monitor for session " + currentWmksSession.key);
         var options = {
            enableH264: isMP4Supported() && _isMP4Enabled
         };
         multimonService.addMonitor(currentWmksSession, currentWmksSession.wmksContainer[0], uiCallback, closeSidebar, handleResize, options);
      }
   };

   /**
    * quitMultimon
    */
   quitMultimon = function quitMultimon() {
      if (!!currentWmksSession) {
         AB.LOGGER.log("add a monitor for session " + currentWmksSession.key);
         multimonService.switchToSingleMon(currentWmksSession);
      }
   };

   /**
    * destroyMultimon
    */
   destroyMultimon = function destroyMultimon() {
      multimonService.destroyMultimon();
   };

   /**
    * Will processing only when the current session is not in the multimon
    *     mode
    * @param  {function} processingFunction The processing function
    */
   whenNotInMultimon = function whenNotInMultimon(processingFunction) {
      if (!!currentWmksSession) {
         multimonService.whenNotInMultimon(processingFunction);
      } else {
         processingFunction();
      }
   };

   /**
    * enterMultimon
    */
   enterMultimon = function enterMultimon() {
      if (!!currentWmksSession) {
         AB.LOGGER.log("enter multimon for session " + currentWmksSession.key);
         multimonService.enterMultimonMode();
      }
   };

   /**
    * recoveryEventConnections
    */
   recoveryEventConnections = function recoveryEventConnections() {
      for (var wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            try {
               wmksSessionMap[wmksKey].wmks("connectEvents");
            } catch (e) {
               _jscdkLogger2.default.debug("fail to reconnect wmks events, please check the network");
            }
         }
      }
   };

   /**
    * disconnectEventConnections
    */
   disconnectEventConnections = function disconnectEventConnections() {
      for (var wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            wmksSessionMap[wmksKey].wmks("disconnectEvents");
         }
      }
      /**
       * Adding some extra lines since wmks is not symatrix so we can't remove
       * all the events by calling disconnectEvents, which seems can't be done
       * easily.
       */
      $(window).unbind('mousedown.wmks');
      $(window).unbind('mousewheel.wmks');
      $(window).unbind('mousemove.wmks');
      $(window).unbind('mouseup.wmks');
   };

   /**
    * handleTouchStart
    *
    * We need to initialize the audio context for onTouchStart.
    * Todo: We need to initialize audio service for all the sessions?
    */
   handleTouchStart = function handleTouchStart(e) {
      if (currentWmksSession) {
         currentWmksSession.audioService.initializeAudioForTouch();
      }
   };

   /**
    * pageFlowAfterDisconnect
    *
    * Page flow behavior after user logoff.
    *
    */
   pageFlowAfterDisconnect = function pageFlowAfterDisconnect() {
      if (closeOnExit) {
         // Horizon workspace will launch us into a separate tab, so we
         // want to close on exit in this case.

         // NOTE: This won't work in any modern browser when the window
         // is not opened via script / ahref.
         $window.open('', '_self', '');
         $window.close();
      } else {
         AB.UTIL.returnToLauncher();
      }
   };

   /**
    * connectToServer
    *
    * Connect to server with server agent url.
    *
    * @params targetUrl the server url which is connecting to.
    * @params key unique identifier for this wmks session.
    * @params isApplicationSession if this is a desktop or an application
    *    session.
    * @params isShadow if there is a shadow session.
    * @params key unique identifer for a session.
    * @params name session name.
    */
   connectToServer = function connectToServer(targetUrl, isApplicationSession, isShadow, key, name) {
      var wmksSession = blastWmks.getWmksSessionInstance(wmksService, key, isApplicationSession, isShadow, name),
          webSocketUrl = targetUrl.replace('http', 'ws');
      wmksSession.initialize(webSocketUrl, {
         enableHighResMode: _isHighResModeEnabled,
         useMacOSXKeySettings: areMacOSXKeyMappingsSupported() && _areMacOSXKeyMappingsEnabled,
         enableWindowsKey: _isWindowsKeyEnabled,
         enableMP4: isMP4Supported() && _isMP4Enabled
      });
      wmksSessionMap[key] = wmksSession;
   };

   /**
    * requestDisconnect
    *
    * Attempt a graceful disconnect from the server. If the server is
    * already disconnected, triggers a page reflow.
    */
   requestDisconnect = function requestDisconnect(id) {
      var wmksKey = void 0;
      if (id && wmksSessionMap[id]) {
         wmksSessionMap[id].requestDisconnect();
      } else {
         for (wmksKey in wmksSessionMap) {
            /* istanbul ignore else */
            if (wmksSessionMap.hasOwnProperty(wmksKey)) {
               wmksSessionMap[wmksKey].requestDisconnect();
            }
         }

         // Trigger page navigation after we logout from broker.
         entitledItemsService.logout(pageFlowAfterDisconnect);
      }
   };

   /**
    * sendCtrlAltDel
    *
    * Send Ctrl-Alt-Del to the guest.
    */
   sendCtrlAltDel = function sendCtrlAltDel() {
      if (currentWmksSession) {
         currentWmksSession.wmks('sendKeyCodes', [17, 18, 46]);
      }
   };

   /**
    * sendEsc
    *
    * Send Esc to the guest.
    */
   sendEsc = function sendEsc() {
      if (currentWmksSession) {
         currentWmksSession.wmks('sendKeyCodes', [27]);
      }
   };

   /**
    * toggleKeyBoard
    *
    */
   launchKeyboard = function launchKeyboard() {
      if (currentWmksSession) {
         currentWmksSession.wmks('toggleKeyboard');
      }
   };

   /**
    * Get the wmks session according to the key
    * @param key the key passed in
    * @returns {*} the session if the session exists, otherwise null
    */
   getWmksSession = function getWmksSession(key) {
      if (wmksSessionMap.hasOwnProperty(key)) {
         return wmksSessionMap[key];
      } else {
         return null;
      }
   };

   /**
    * toggleHighResMode
    *
    * Function to toggle high resolution mode to a new value on all
    * wmksSessions.
    *
    * @return the new value for high resolution mode
    */
   toggleHighResMode = function toggleHighResMode() {
      if (isHighResModeSupported()) {
         _isHighResModeEnabled = !_isHighResModeEnabled;
         var wmksKey = void 0;
         for (wmksKey in wmksSessionMap) {
            /* istanbul ignore else */
            if (wmksSessionMap.hasOwnProperty(wmksKey)) {
               wmksSessionMap[wmksKey].wmks('option', 'useNativePixels', _isHighResModeEnabled);
            }
         }
      }
      return _isHighResModeEnabled;
   };

   /**
    * toggleMP4
    *
    * Function to toggle MP4 Enablement to a new value on all
    * wmksSessions.
    *
    * @return the new value for MP4 Enablement
    */
   toggleMP4 = function toggleMP4() {
      if (isMP4Supported()) {
         _isMP4Enabled = !_isMP4Enabled;
      }
      return _isMP4Enabled;
   };

   /**
    * toggleUseMacOSXKeyMappings
    *
    * Function to toggle key mappings for this session.
    *
    * @return the new value for high resolution mode
    */
   toggleUseMacOSXKeyMappings = function toggleUseMacOSXKeyMappings() {
      if (areMacOSXKeyMappingsSupported()) {
         _areMacOSXKeyMappingsEnabled = !_areMacOSXKeyMappingsEnabled;
         var wmksKey = void 0;
         for (wmksKey in wmksSessionMap) {
            /* istanbul ignore else */
            if (wmksSessionMap.hasOwnProperty(wmksKey)) {
               wmksSessionMap[wmksKey].wmks('option', 'mapMetaToCtrlForKeys', _areMacOSXKeyMappingsEnabled ? AB.CONST.BlastWMKS.MAP_META_TO_CTRL_FOR_KEYS : []);
            }
         }
      }
      return _areMacOSXKeyMappingsEnabled;
   };

   /**
    * toggleWindowsKey
    *
    * Function to toggle Windows key simulation functionality.
    *
    * @return true or false
    */
   toggleWindowsKey = function toggleWindowsKey() {
      var wmksKey = void 0;

      _isWindowsKeyEnabled = !_isWindowsKeyEnabled;
      for (wmksKey in wmksSessionMap) {
         /* istanbul ignore else */
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            // Enable/disable Windows key in the desktop session.
            wmksSessionMap[wmksKey].enableWindowsKey(_isWindowsKeyEnabled);
         }
      }

      return _isWindowsKeyEnabled;
   };

   /**
    * getCurrentMKSVchanClient
    *
    * Utility function that returns the MKSVchan client of the current
    * wmks session, if available. If the current session or its mksVchan
    * client does not exist, this function returns null.
    */
   getCurrentMKSVchanClient = function getCurrentMKSVchanClient() {
      if (!!currentWmksSession && !!currentWmksSession.mksVchanClient) {
         return currentWmksSession.mksVchanClient;
      }
      return null;
   };

   /**
    * isFileTransferringForAllSession
    *
    * Whether user has transferring file in all sessions.
    */
   isFileTransferringForAllSession = function isFileTransferringForAllSession() {
      var wmksKey = void 0,
          mksVchanClient = void 0,
          uploadService = void 0,
          downloadService = void 0;
      for (wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            mksVchanClient = wmksSessionMap[wmksKey].mksVchanClient;
            if (!!mksVchanClient) {
               uploadService = mksVchanClient.uploadService;
               if (!!mksVchanClient.downloadServices) {
                  downloadService = mksVchanClient.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.FT];
               }
            }
            if (!!uploadService && uploadService.isTransferringFileWithNoDialog() || !!downloadService && downloadService.isTransferringFileWithNoDialog()) {
               return true;
            }
         }
      }
      return false;
   };

   /**
    * isFileTransferringInSession
    *
    * Whether user has transferring file in specific sessions.
    */
   isFileTransferringInSession = function isFileTransferringInSession(wmksKey) {
      if (!wmksKey || !wmksSessionMap.hasOwnProperty(wmksKey)) {
         return false;
      }

      var mksVchanClient = wmksSessionMap[wmksKey].mksVchanClient,
          uploadService = void 0,
          downloadService = void 0;

      if (!!mksVchanClient) {
         uploadService = mksVchanClient.uploadService;
         if (!!mksVchanClient.downloadServices) {
            downloadService = mksVchanClient.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.FT];
         }
      }
      return !!uploadService && uploadService.isTransferringFileWithNoDialog() || !!downloadService && downloadService.isTransferringFileWithNoDialog();
   };

   isFileTransferringInCurrentSession = function isFileTransferringInCurrentSession() {
      if (!currentWmksSession || !currentWmksSession.key) {
         return false;
      }
      return isFileTransferringInSession(currentWmksSession.key);
   };

   isFileDownloadingInSession = function isFileDownloadingInSession(wmksKey) {
      if (!wmksKey || !wmksSessionMap.hasOwnProperty(wmksKey)) {
         return false;
      }

      var mksVchanClient = wmksSessionMap[wmksKey].mksVchanClient,
          downloadService = void 0;

      if (!!mksVchanClient && !!mksVchanClient.downloadServices) {
         downloadService = mksVchanClient.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.FT];
      }
      return !!downloadService && downloadService.isTransferringFileWithNoDialog();
   };

   isFileDownloadingInCurrentSession = function isFileDownloadingInCurrentSession() {
      if (!currentWmksSession || !currentWmksSession.key) {
         return false;
      }
      return isFileDownloadingInSession(currentWmksSession.key);
   };

   isPrintFileTransferringForAllSession = function isPrintFileTransferringForAllSession() {
      var wmksKey = void 0,
          mksVchanClient = void 0,
          downloadService = void 0;
      for (wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            mksVchanClient = wmksSessionMap[wmksKey].mksVchanClient;
            if (!!mksVchanClient && !!mksVchanClient.downloadServices) {
               downloadService = mksVchanClient.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.PRINT];
            }
            if (!!downloadService && downloadService.isTransferringFileWithNoDialog()) {
               return true;
            }
         }
      }
      return false;
   };

   isPrintFileTransferringInSession = function isPrintFileTransferringInSession(wmksKey) {
      if (!wmksKey || !wmksSessionMap.hasOwnProperty(wmksKey)) {
         return false;
      }

      var mksVchanClient = wmksSessionMap[wmksKey].mksVchanClient,
          downloadService = void 0;

      if (!!mksVchanClient && !!mksVchanClient.downloadServices) {
         downloadService = mksVchanClient.downloadServices[MKSVchan.FILE_TRANSFER_CONSUMER.PRINT];
      }
      return !!downloadService && downloadService.isTransferringFileWithNoDialog();
   };

   isPrintFileTransferringInCurrentSession = function isPrintFileTransferringInCurrentSession() {
      if (!currentWmksSession || !currentWmksSession.key) {
         return false;
      }
      return isPrintFileTransferringInSession(currentWmksSession.key);
   };

   /**
    * clearClipboard
    *
    * clears the contents of our global clipboard.
    */
   clearClipboard = function clearClipboard() {
      globalClipboard.clear();
   };

   /*
    * pushClipboard
    *
    * Pushes the local clipboard to the remote guest.
    */
   pushClipboard = function pushClipboard() {
      var client = getCurrentMKSVchanClient();
      if (!client) {
         handleClipboardFailure();
         return;
      }
      client.sendClipboard(globalClipboard, function () {
         AB.LOGGER.info("Clipboard synced with focused session");
      }, handleClipboardFailure);
   };

   /**
    * sendClipboardText
    *
    * Sends a local clipboard text change to the remote guest.
    *
    * @params text: A string that we will update the remote clipboard with
    */
   sendClipboardText = function sendClipboardText(text) {
      var client = getCurrentMKSVchanClient();

      if (!currentWmksSession || !currentWmksSession.pasteEnabled) {
         return;
      }

      if (!client) {
         handleClipboardFailure();
         return;
      }
      client.sendClipboardText(text, function (text, error) {
         AB.LOGGER.info("Clipboard update successfully sent");
         globalClipboard.setText(text, MKSVchan.CP_FORMAT.TEXT);
         wmksServiceEventHandler.emit("clipboardChanged", text, error);
      }, handleClipboardFailure);
   };

   /**
    * onClipboardReady
    *
    * Called by a wmks session when its clipboard is ready. If the
    * session is the current session, sync the remote clipboard with the
    * local clipboard
    *
    * @param session: the calling session
    */
   onClipboardReady = function onClipboardReady(wmksKey) {
      if (!!currentWmksSession && wmksKey === currentWmksSession.key) {
         updateClipboardCapabilities();
         pushClipboard();
      }
   };

   /**
    * updateClipboardCapabilities
    *
    * Updates the clipboard capabilities, always with the capabilities of
    * the current wmks session.
    */
   updateClipboardCapabilities = function updateClipboardCapabilities() {
      if (currentWmksSession) {
         wmksServiceEventHandler.emit("clipboardCapabilitiesChanged", currentWmksSession.clipboardReady, currentWmksSession.copyEnabled, currentWmksSession.pasteEnabled);
      }
   };

   /**
    * onClipboardChange
    *
    * handles the notification from the remote guest that clipboard has
    * changed, sends a request RPC for clipboard contents.
    *
    * @params session: the wmks session that sent the request
    */
   onClipboardChange = function onClipboardChange(session) {
      // Get session mksVchan client and sent a clipboard request RPC
      var client = session.mksVchanClient;
      if (!currentWmksSession || !currentWmksSession.copyEnabled) {
         return;
      }
      if (!!client) {
         client.sendClipboardRequest(function () {
            AB.LOGGER.info("Clipboard request successfully sent");
         }, handleClipboardFailure);
      } else {
         handleClipboardFailure();
      }
   };

   /**
    * sendFileDownloadRequest
    *
    * Send request to MKSVchan server to ask for files.
    *
    */
   sendFileDownloadRequest = function sendFileDownloadRequest(mksClient, type) {
      // Get session mksVchan client and sent a file download request RPC
      if (!mksClient || !mksClient.FTUtil) {
         handleFileTransferFailure();
         return;
      }

      var enabled = false;

      if (type === MKSVchan.FILE_TRANSFER_CONSUMER.FT) {
         enabled = mksClient.FTUtil.config.downloadEnabled;
      } else if (type === MKSVchan.FILE_TRANSFER_CONSUMER.PRINT) {
         enabled = mksClient.FTUtil.config.printDownloadEnabled;
      }

      if (!enabled) {
         return;
      }

      mksClient.sendFileTransferRequest(type, function () {
         AB.LOGGER.info("File download request successfully sent");
      }, handleFileTransferFailure);
   };

   /**
    * readAndSendFileChunks
    *
    * Upload file chunks to MKSVchan server.
    *
    * @params fileChunk: file chunk object
    * @params onDone: onDone event
    * @params onAbort: onAbort event
    */
   readAndSendFileChunks = function readAndSendFileChunks(mksClient, fileChunks, onDone, onAbort) {
      if (!fileChunks || !Array.isArray(fileChunks)) {
         AB.LOGGER.error("File chunks is not a array object!");
         return;
      }

      if (fileChunks.length === 0) {
         return;
      }

      var fileReader = new FileReader(),
          chunkBlob = void 0,
          readerOnload = void 0,
          readerOnerror = void 0,
          fileChunk = fileChunks.shift(),
          self = this;

      if (!!mksClient) {
         chunkBlob = fileChunk.fileRef.slice(fileChunk.chunkNum * fileChunk.chunkSize, fileChunk.chunkNum * fileChunk.chunkSize + fileChunk.currentChunkSize);

         readerOnload = function readerOnload(evt) {
            var uint8Array = new Uint8Array(evt.target.result);

            mksClient.sendFileChunk(fileChunk.chunkNum, fileChunk.totalChunkNum, fileChunk.currentChunkSize, fileChunk.fileRef.name, uint8Array, fileChunk.fileRef.size, function () {
               $timeout(function () {
                  onDone();
                  fileChunk.fileRef.progress = (fileChunk.chunkNum + 1) / fileChunk.totalChunkNum * 100;
               });
            }, function () {
               if (onAbort) {
                  onAbort();
               }
               handleFileTransferFailure();
            });

            self.readAndSendFileChunks(mksClient, fileChunks, onDone, onAbort);
         };

         readerOnerror = function readerOnerror() {
            $timeout(function () {
               fileChunk.fileRef.transferError = true;
               onAbort();
            });
         };

         fileReader.onload = readerOnload;
         fileReader.onerror = readerOnerror;
         fileReader.readAsArrayBuffer(chunkBlob);
      } else {
         handleFileTransferFailure();
      }
   };

   /**
    * stopFileUpload
    *
    * Stop upload specific file.
    *
    * @params fileChunk: file chunk object
    */
   stopFileUpload = function stopFileUpload(mksClient, fileName, onDone) {
      if (!!mksClient) {
         mksClient.sendStopUploadRequest(fileName, onDone, function () {
            handleFileTransferFailure();
         });
      } else {
         handleFileTransferFailure();
      }
   };

   /**
    * stopFileDownload
    *
    * Stop download specific file.
    *
    * @params fileChunk: file chunk object
    */
   stopFileDownload = function stopFileDownload(mksClient, file, onDone) {
      if (!!mksClient && !!file && !!file.fullPath && !!file.uuid) {
         mksClient.sendStopDownloadRequest(file.uuid + '|' + file.fullPath, onDone, function () {
            handleFileTransferFailure();
         });
      } else {
         handleFileTransferFailure();
      }
   };

   /**
    * hasApplicationSession
    *
    * Returns true if any of the sessions in the session map are an
    * application session.
    */
   hasApplicationSession = function hasApplicationSession() {
      var wmksKey = void 0;
      for (wmksKey in wmksSessionMap) {
         /* istanbul ignore else */
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            if (wmksSessionMap[wmksKey].isApplicationSession) {
               return true;
            }
         }
      }
      return false;
   };

   /**
    * updateEmptySession
    *
    * update emtpy status for an app session.
    * @param wmksKey key to identify app session.
    * @param isEmpty empty status for this app session.
    */
   updateEmptySession = function updateEmptySession(wmksKey, isEmpty) {
      var appSession = wmksSessionMap[wmksKey];
      if (appSession && appSession.isApplicationSession) {
         appSession.setEmpty(isEmpty);
      } else {
         AB.LOGGER.error("Session " + wmksKey + " is not found.");
      }
   };

   /**
    * prepareForSessionReset
    *
    * Informs the wmksService that an application reset will be performed.
    * The service sets the requestedDisconnect flag to true for all of its
    * application sessions to prevent them from displaying a disconnected
    * dialog
    */
   prepareForSessionReset = function prepareForSessionReset(resetWmksKey) {
      var wmksKey = void 0,
          wmksSession = void 0;

      if (resetWmksKey) {
         wmksSession = wmksSessionMap[resetWmksKey];
         if (wmksSession) {
            AB.LOGGER.info("Setting requestedDisconnect to true for session: " + resetWmksKey);
            wmksSession.requestedDisconnect = true;
         }
      } else {
         for (wmksKey in wmksSessionMap) {
            /* istanbul ignore else */
            if (wmksSessionMap.hasOwnProperty(wmksKey)) {
               wmksSession = wmksSessionMap[wmksKey];
               if (wmksSession && wmksSession.isApplicationSession) {
                  AB.LOGGER.info("Setting requestedDisconnect to true for session: " + wmksKey);
                  wmksSession.requestedDisconnect = true;
               }
            }
         }
      }
   };

   /**
    * sessionResetDone
    *
    * Tells the wmksService that the application session reset has done,
    * and that the requestedDisconnect flag should be reset for the
    * sessions for which the reset failed.
    *
    * @param wmksKeys an array of wmks session keys for which the reset
    *    failed. requestedDisconnect will be set to false for these
    *    sessions.
    */
   sessionResetDone = function sessionResetDone(wmksKeys) {
      var wmksSession = void 0,
          i = void 0;

      if (!wmksKeys) {
         return;
      }

      for (i = 0; i < wmksKeys.length; i++) {
         AB.LOGGER.error("Failed to reset session: " + wmksKeys[i]);
         wmksSession = wmksSessionMap[wmksKeys[i]];
         if (wmksSession) {
            wmksSession.requestedDisconnect = false;
         }
      }
   };

   /**
    * isCurrentSession
    *
    * Utility function to check if a wmksKey matches the key of the
    * current session
    */
   isCurrentSession = function isCurrentSession(wmksKey) {
      return currentWmksSession ? wmksKey === currentWmksSession.key : false;
   };

   /**
    * isCurrentSessionAPP
    *
    * Utility function to check if current wmks session is remote
    * application
    */
   isCurrentSessionApp = function isCurrentSessionApp() {
      return !!currentWmksSession && currentWmksSession.isApplicationSession;
   };

   /**
    * isCurrentSessionDesktop
    *
    * Utility function to check if current wmks session is remote
    * desktop
    */
   isCurrentSessionDesktop = function isCurrentSessionDesktop() {
      return !!currentWmksSession && !currentWmksSession.isApplicationSession;
   };

   /**
    * isCurrentSessionHasDPIChannelInited
    *
    * Utility function to check if current wmks session has establish a
    * DPI sub connection
    */
   isCurrentSessionHasDPIChannelInited = function isCurrentSessionHasDPIChannelInited() {
      return !!currentWmksSession && commonSvcService.isInitedForSession(currentWmksSession.key);
   };

   /**
    * getCurrentSessionDPI
    *
    * Utility function to getCurrentSessinoDPI
    */
   getCurrentSessionDPI = function getCurrentSessionDPI() {
      if (!currentWmksSession) {
         return 1.0;
      }
      return commonSvcService.getRemoteDPI(currentWmksSession.key);
   };

   /**
    * sessionOnConnecting
    *
    * Handle the onConnecting delegate request from wmksSession.
    */
   sessionOnConnecting = function sessionOnConnecting(wmksSession, vdpService) {
      wmksServiceEventHandler.emit("sessionConnecting", wmksSession.key, wmksSession.isApplicationSession, vdpService, wmksSession.mainChannel);
   };

   /**
    * sessionOnConnected
    *
    * Handle the onConnected delegate request from wmksSession.
    */
   sessionOnConnected = function sessionOnConnected(wmksSession) {
      $timeout(function () {
         wmksServiceEventHandler.emit("sessionConnected", wmksSession.key, wmksSession.isApplicationSession);
      }, 0, false);
   };

   /**
    * sessionOnDisconnected
    *
    * Handle the onDisconnected delegate request from wmksSession.
    */
   sessionOnDisconnected = function sessionOnDisconnected(wmksSession) {
      var wasCurrentSession = isCurrentSession(wmksSession.key);
      $timeout(function () {
         wmksServiceEventHandler.emit("sessionDisconnected", wmksSession.key, wmksSession.isApplicationSession, wasCurrentSession);
      }, 0, false);
   };

   /**
    * sessionOnRemoved
    *
    * Handle the onRemoved delegate request from wmksSession.
    */
   sessionOnRemoved = function sessionOnRemoved(wmksSession) {
      var wmksKey = void 0,
          deletedWmksKey = wmksSession.key,
          isEmpty = wmksSession.isEmpty,
          deletedItemIsApplication = wmksSession.isApplicationSession;

      if (!wmksSessionMap[deletedWmksKey]) {
         AB.LOGGER.warn('Tried to remove unknown session: ' + deletedWmksKey);
         return;
      }

      $timeout(function () {
         wmksServiceEventHandler.emit("sessionRemoved", deletedWmksKey, deletedItemIsApplication);
      }, 0, false);

      delete wmksSessionMap[deletedWmksKey];

      // Switch to another session if possible. Todo: Choose the most
      // recent used session.
      if (currentWmksSession && deletedWmksKey === currentWmksSession.key) {
         currentWmksSession = null;
         // If this is not an empty application session, we will switch to
         // another session.
         if (!(deletedItemIsApplication && isEmpty)) {
            for (wmksKey in wmksSessionMap) {
               /* istanbul ignore else */
               if (wmksSessionMap.hasOwnProperty(wmksKey)) {
                  changeWmksSession(wmksKey);
                  break;
               }
            }
         }
      }

      writeRunningSession();
   };

   getAllmksClient = function getAllmksClient() {
      var wmksKey = void 0,
          wmksSession = void 0,
          mksClient = void 0,
          mksClientList = [];
      for (wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            wmksSession = wmksSessionMap[wmksKey];
            mksClient = wmksSession.mksVchanClient;
            if (!!mksClient) {
               mksClientList.push(mksClient);
            }
         }
      }

      return mksClientList;
   };

   shadowAllHeartbeatForPrint = function shadowAllHeartbeatForPrint() {
      if (!WMKS.BROWSER.isFirefox() && !WMKS.BROWSER.isSafari()) {
         // Only work for Firefox and Safari
         return;
      }

      AB.LOGGER.debug('Stop heartbeat for print.');
      var wmksKey = void 0;
      for (wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            wmksSessionMap[wmksKey].shadowHeartbeat();
         }
      }
   };

   recoverAllHeartbeatForPrint = function recoverAllHeartbeatForPrint() {
      if (!WMKS.BROWSER.isFirefox() && !WMKS.BROWSER.isSafari()) {
         // Only work for Firefox and Safari
         return;
      }

      AB.LOGGER.debug('Recover heartbeat for print.');
      var wmksKey = void 0;
      for (wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            wmksSessionMap[wmksKey].recoverHeartbeat();
         }
      }
   };

   shadowAllHeartbeatWhenSafariHidden = function shadowAllHeartbeatWhenSafariHidden() {
      if (!WMKS.BROWSER.isSafari()) {
         // Only work for Safari
         return;
      }

      AB.LOGGER.debug('Stop heartbeat when Safari is hidden.');
      var wmksKey = void 0;
      for (wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            wmksSessionMap[wmksKey].shadowHeartbeat();
         }
      }
   };

   recoverAllHeartbeatWhenSafariVisible = function recoverAllHeartbeatWhenSafariVisible() {
      if (!WMKS.BROWSER.isSafari()) {
         // Only work for Safari
         return;
      }

      AB.LOGGER.debug('Recover heartbeat when Safari is visible.');
      var wmksKey = void 0;
      for (wmksKey in wmksSessionMap) {
         if (wmksSessionMap.hasOwnProperty(wmksKey)) {
            wmksSessionMap[wmksKey].recoverHeartbeat();
         }
      }
   };

   $.extend(wmksService, {
      init: init,
      connectToDesktop: connectToDesktop,
      connectToApplication: connectToApplication,
      requestDisconnect: requestDisconnect,
      pageFlowAfterDisconnect: pageFlowAfterDisconnect,
      sendCtrlAltDel: sendCtrlAltDel,
      sendEsc: sendEsc,
      launchKeyboard: launchKeyboard,
      isHighResModeEnabled: function isHighResModeEnabled() {
         return _isHighResModeEnabled;
      },
      isHighResModeSupported: isHighResModeSupported,
      toggleHighResMode: toggleHighResMode,
      isMP4Enabled: function isMP4Enabled() {
         return _isMP4Enabled;
      },
      isMP4Supported: isMP4Supported,
      toggleMP4: toggleMP4,
      areMacOSXKeyMappingsEnabled: function areMacOSXKeyMappingsEnabled() {
         return _areMacOSXKeyMappingsEnabled;
      },
      areMacOSXKeyMappingsSupported: areMacOSXKeyMappingsSupported,
      toggleUseMacOSXKeyMappings: toggleUseMacOSXKeyMappings,
      isWindowsKeyEnabled: function isWindowsKeyEnabled() {
         return _isWindowsKeyEnabled;
      },
      toggleWindowsKey: toggleWindowsKey,
      applyInitialHighResSetting: applyInitialHighResSetting,
      applyInitialHighResSettingCallback: applyInitialHighResSettingCallback,
      changeWmksSession: changeWmksSession,
      onClipboardReady: onClipboardReady,
      clearClipboard: clearClipboard,
      updateClipboardCapabilities: updateClipboardCapabilities,
      sendClipboardText: sendClipboardText,
      onClipboardChange: onClipboardChange,
      handleDownloadListChange: handleDownloadListChange,
      handlePrintDownloadListChange: handlePrintDownloadListChange,
      sendFileDownloadRequest: sendFileDownloadRequest,
      handleClipboardReceived: handleClipboardReceived,
      handleFileTransferError: handleFileTransferError,
      handlePrintError: handlePrintError,
      handleFileTransferConfigChange: handleFileTransferConfigChange,
      isFileTransferringForAllSession: isFileTransferringForAllSession,
      isFileTransferringInSession: isFileTransferringInSession,
      isFileTransferringInCurrentSession: isFileTransferringInCurrentSession,
      isFileDownloadingInSession: isFileDownloadingInSession,
      isFileDownloadingInCurrentSession: isFileDownloadingInCurrentSession,
      isPrintFileTransferringForAllSession: isPrintFileTransferringForAllSession,
      isPrintFileTransferringInSession: isPrintFileTransferringInSession,
      isPrintFileTransferringInCurrentSession: isPrintFileTransferringInCurrentSession,
      readAndSendFileChunks: readAndSendFileChunks,
      stopFileUpload: stopFileUpload,
      stopFileDownload: stopFileDownload,
      isCurrentSession: isCurrentSession,
      isCurrentSessionApp: isCurrentSessionApp,
      isCurrentSessionDesktop: isCurrentSessionDesktop,
      isCurrentSessionHasDPIChannelInited: isCurrentSessionHasDPIChannelInited,
      getCurrentSessionDPI: getCurrentSessionDPI,
      sessionOnConnecting: sessionOnConnecting,
      hasApplicationSession: hasApplicationSession,
      sessionOnConnected: sessionOnConnected,
      sessionOnDisconnected: sessionOnDisconnected,
      sessionOnRemoved: sessionOnRemoved,
      updateEmptySession: updateEmptySession,
      prepareForSessionReset: prepareForSessionReset,
      getCurrentMKSVchanClient: getCurrentMKSVchanClient,
      sessionResetDone: sessionResetDone,
      isMacOS: WMKS.BROWSER.isMacOS,
      setUserActivityTime: setUserActivityTime,
      shadowAllHeartbeatForPrint: shadowAllHeartbeatForPrint,
      recoverAllHeartbeatForPrint: recoverAllHeartbeatForPrint,
      getAllmksClient: getAllmksClient,
      isSessionTimedOut: function isSessionTimedOut() {
         return sessionTimedOut;
      },
      handleUserActivity: handleUserActivity,
      stopTimer: stopTimer,
      hasMultimonCapacity: hasMultimonCapacity,
      addMonitor: addMonitor,
      quitMultimon: quitMultimon,
      destroyMultimon: destroyMultimon,
      whenNotInMultimon: whenNotInMultimon,
      enterMultimon: enterMultimon,
      disconnectEventConnections: disconnectEventConnections,
      recoveryEventConnections: recoveryEventConnections,
      getWmksSession: getWmksSession,
      setCanvasVisibility: setCanvasVisibility,
      activateWmksSession: activateWmksSession
   });
   return wmksService;
}

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = FTDownloadService;

var _mksvchan = __webpack_require__(12);

var _mksvchan2 = _interopRequireDefault(_mksvchan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FTDownloadService(AB, wmksService, $timeout, fileTransferService, _) {
   function Service(mksClient, type) {
      this.mksClient = mksClient;
      this.downloadFileNum = 0;
      this.totalFileSize = 0;
      this.unusedFileList = [];
      this.type = type || _mksvchan2.default.FILE_TRANSFER_CONSUMER.FT;
      if (this.type !== _mksvchan2.default.FILE_TRANSFER_CONSUMER.FT && this.type !== _mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT) {
         throw 'Error file transfer consumer type!';
      }
   }

   Service.prototype = fileTransferService.baseService;

   Service.prototype.downloadReady = function () {
      var enabled = false;
      if (this.type === _mksvchan2.default.FILE_TRANSFER_CONSUMER.FT) {
         enabled = this.mksClient.FTUtil.config.downloadEnabled;
      } else if (this.type === _mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT) {
         enabled = this.mksClient.FTUtil.config.printDownloadEnabled;
      }
      if (!enabled) {
         // If download not allowed, just return
         AB.LOGGER.debug('File download is not allowed.');
         return false;
      }

      if (!this.fileList || this.fileList.length < 1) {
         this.openErrorDialog('NoFileWarningDialog', _('FT_NO_FILE_WARNING_M'));
         return false;
      }

      return true;
   };

   Service.prototype.verifyTotalSize = function (newSize) {
      this.totalFileSize = this.getTotalFileSizeForList(this.fileList);
      var size = this.totalFileSize + newSize,
          readableSize = void 0;
      if (size > _mksvchan2.default.FILE_TRANSFER_MAX_TOTAL_SIZE) {
         readableSize = this.mksClient.FTUtil.getReadableSize(size);
         this.openErrorDialog('TotalSizeTooLargeWarningDialog', _('FT_TOTAL_SIZE_TOO_LARGE_WARNING_M', [readableSize]));
         return false;
      }

      return true;
   };

   Service.prototype.beginDownload = function () {
      // Calculate how many file need to be download
      this.downloadFileNum = this.getDownloadFileNum();
      this.downloadedFileNum = this.getAlreadyDownloadedFileNum();
      this.totalFileSize = this.getTotalFileSizeForList(this.fileList);

      if (this.downloadFileNum === this.downloadedFileNum) {
         return;
      }

      if (this.downloadFileNum !== 0) {
         this.isTransferring = true;
         wmksService.sendFileDownloadRequest(this.mksClient, this.type);
      }
   };

   Service.prototype.getTotalFileSizeForList = function (fileList) {
      if (!fileList || fileList.length < 1) {
         return 0;
      }

      var size = 0;
      for (var i = 0; i < fileList.length; i++) {
         if (fileList[i].transferError !== true && fileList[i].stopTransfer !== true) {
            size += fileList[i].size;
         }
      }
      return size;
   };

   Service.prototype.getDownloadFileNum = function () {
      if (!this.fileList || !this.fileList.length) {
         return 0;
      }

      var count = 0;
      // Count every valid download file, including downloaded ones
      for (var i = 0; i < this.fileList.length; i++) {
         if (this.fileList[i].stopTransfer !== true && this.fileList[i].transferError !== true) {
            count++;
         }
      }
      AB.LOGGER.debug("There are: " + count + " files to download.");
      return count;
   };

   Service.prototype.getAlreadyDownloadedFileNum = function () {
      if (!this.fileList || !this.fileList.length) {
         return 0;
      }

      var count = 0;
      // Count every downloaded file
      for (var i = 0; i < this.fileList.length; i++) {
         if (this.fileList[i].progress === 100) {
            count++;
         }
      }
      AB.LOGGER.debug("There are: " + count + " files already downloaded.");
      return count;
   };

   Service.prototype.stopFileDownload = function (file) {
      file.stopTransfer = true;
      this.downloadFileNum--;
      if (this.transferProgess === this.downloadFileNum) {
         this.isTransferring = false;
         this.downloadFileNum = 0;
         if (this.onTransferFinish) {
            this.onTransferFinish();
         }
      }
      wmksService.stopFileDownload(this.mksClient, file, function () {
         AB.LOGGER.debug("Successfully send cancel download request.");
      });
   };

   Service.prototype.getPathAndUUIDFromIdentifier = function (chunkIdentifier) {
      if (!chunkIdentifier) {
         return null;
      }

      var index = chunkIdentifier.indexOf("|");
      if (index < 0 || index > chunkIdentifier.length) {
         AB.LOGGER.error("Invalid identifier.");
         return null;
      }

      return {
         uuid: chunkIdentifier.substr(0, index),
         fullPath: chunkIdentifier.substr(index + 1)
      };
   };

   Service.prototype.searchReceiveFile = function (chunkIdentifier) {
      var info = this.getPathAndUUIDFromIdentifier(chunkIdentifier);

      if (info === null) {
         return null;
      }

      for (var i = 0; i < this.fileList.length; i++) {
         if (info.fullPath === this.fileList[i].fullPath && info.uuid === this.fileList[i].uuid) {
            return this.fileList[i];
         }
      }
      return null;
   };

   Service.prototype.tryStopUnusedFileDownload = function (chunkIdentifier) {
      var info = this.getPathAndUUIDFromIdentifier(chunkIdentifier);

      if (info === null) {
         return false;
      }

      for (var i = 0; i < this.unusedFileList.length; i++) {
         if (info.fullPath === this.unusedFileList[i].fullPath && info.uuid === this.unusedFileList[i].uuid) {
            wmksService.stopFileDownload(this.mksClient, {
               uuid: info.uuid,
               fullPath: info.fullPath
            });
            this.unusedFileList.splice(i, 1);
            return true;
         }
      }
      return false;
   };

   Service.prototype.tryAddUnknownFileToList = function (chunkIdentifier, fileSize) {
      if (!chunkIdentifier || !fileSize) {
         return null;
      }

      var info = this.getPathAndUUIDFromIdentifier(chunkIdentifier),
          relPath = '';

      if (info === null) {
         return null;
      }

      // Find file name from file full path
      for (var i = info.fullPath.length - 1; i >= 0; i--) {
         // Take care for windows '\\' and linux '/'
         if (info.fullPath[i] === '\\' || info.fullPath[i] === '/') {
            relPath = info.fullPath.substr(i + 1);
            break;
         }
      }

      this.fileList.push({
         fullPath: info.fullPath,
         relPath: relPath,
         uuid: info.uuid,
         size: fileSize,
         readableSize: this.mksClient.FTUtil.getReadableSize(fileSize),
         fileType: _mksvchan2.default.FILE_TRANSFER_FILE_TYPE.FILE,
         contentData: null,
         progress: 0,
         transferError: false,
         stopTransfer: false
      });
      return this.fileList[this.fileList.length - 1];
   };

   Service.prototype.reassembleChunks = function (chunkNum, totalChunkNum, chunkIdentifier, chunkData, fileSize) {
      if (typeof chunkNum !== "number" || typeof totalChunkNum !== "number" || typeof fileSize !== "number" || chunkIdentifier == null || chunkData == null) {
         AB.LOGGER.error("Cannot reassemble with wrong parameters!");
         // TODO May need stop the download process
         this.isTransferring = false;
         return;
      }
      var uint8Array = void 0,
          self = this,
          file = void 0,
          stopUnusedFile = void 0;

      $timeout(function () {
         file = self.searchReceiveFile(chunkIdentifier);

         // First search if the file chunk belongs to some file in
         // the file list
         if (file === null) {
            /**
             *  If the chunk doesn't belong to any file in file
             * list, and it is not the first chunk, do nothing
             * here.
             */
            if (chunkNum !== 0) {
               AB.LOGGER.info("Cannot reassemble wrong file chunks!");
               return;
            }

            /**
             * If it is the first chunk, try to find it belongs to
             * the unused file list. If so, ask server to stop
             * transferring.
             */
            stopUnusedFile = self.tryStopUnusedFileDownload(chunkIdentifier);

            // If find in unused file list, return.
            if (stopUnusedFile === true) {
               return;
            }

            /**
             * If not find in unused file list, it should be a
             * 'bug' file. See bug 1645572. We need to add it into
             * file list here.
             */
            file = self.tryAddUnknownFileToList(chunkIdentifier, fileSize);
            if (file === null) {
               return;
            }
         }
         uint8Array = new Uint8Array(chunkData);
         if (chunkNum === 0) {
            file.contentData = new Uint8Array(fileSize);
         }
         file.contentData.set(uint8Array, self.mksClient.FTUtil.config.chunkSize * chunkNum);
         file.progress = (chunkNum + 1) / totalChunkNum * 100;

         if (file.progress === 100) {
            self.transferProgess++;
         }

         if (self.transferProgess === self.downloadFileNum) {
            self.isTransferring = false;
            self.downloadFileNum = 0;
            if (self.onTransferFinish) {
               self.onTransferFinish();
            }
         }
      });
   };

   return {
      getService: function getService(mksClient, type) {
         if (!mksClient) {
            AB.LOGGER.error("Invalid mksvchan client.");
            return null;
         }
         return new Service(mksClient, type);
      }
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * file-transfer-service.js --
 *
 * Module for read file and reassemble file service.
 *
 */

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = TransferHelper;

var _mksvchan = __webpack_require__(12);

var _mksvchan2 = _interopRequireDefault(_mksvchan);

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * file-transfer-helper.js --
 *
 * Common helper for both ft and print service.
 *
 */

function TransferHelper(wmksService, FTDownloadService, FTUploadService, wmksServiceEventHandler) {

   function Service(consumer) {
      if (consumer !== _mksvchan2.default.FILE_TRANSFER_CONSUMER.FT && consumer !== _mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT) {
         throw 'Wrong type of consumer is used!';
      }

      _appblastUtil2.default.LOGGER.debug("Init transfer helper");
      this.consumer = consumer;
   }

   /**
    * Update the download file list.
    * Since it is possible that some file in the coming list has
    * already been added, we need to be careful and verify if it is
    * added. See bug 1645572.
    */

   Service.prototype.updateDownloadFileList = function (fileList, client) {
      /**
       * $scope.downloadFiles is referred to
       * mksClient.FTUtil.downloadList[FT/PRINT]. We need to use the
       * later one, in case some bugs while desktop switch.
       * See bug 1755174, 1755201, 1756222.
       */
      if (!client || !client.FTUtil) {
         _appblastUtil2.default.LOGGER.error("Cannot find FTUtil for this desktop!");
         return;
      }

      var isAdded = void 0,
          downloadList = client.FTUtil.downloadList[this.consumer];
      for (var i = 0; i < fileList.length; i++) {
         isAdded = false;
         for (var j = 0; j < downloadList.length; j++) {
            if (fileList[i].fullPath === downloadList[j].fullPath && fileList[i].uuid === downloadList[j].uuid) {
               isAdded = true;
               break;
            }
         }

         if (isAdded === false) {
            downloadList.push(fileList[i]);
         }
      }
   };

   /**
    * Used to get current mks client with transfer service.
    * @param consumer
    * @returns {*}
    */
   Service.prototype.initTransferService = function () {
      var mksClient = wmksService.getCurrentMKSVchanClient();
      if (mksClient == null) {
         return null;
      }

      // Only file transfer has upload service now
      if (!mksClient.uploadService && this.consumer === _mksvchan2.default.FILE_TRANSFER_CONSUMER.FT) {
         mksClient.uploadService = FTUploadService.getService(mksClient);
      }
      if (!mksClient.downloadServices[this.consumer]) {
         mksClient.downloadServices[this.consumer] = FTDownloadService.getService(mksClient, this.consumer);
      }

      return mksClient;
   };

   Service.prototype.addStatusListener = function (func) {
      if (typeof func !== "function") {
         _appblastUtil2.default.LOGGER.info("Invalid parameter");
         return;
      }

      wmksServiceEventHandler.addEventListener("fileTransferConfigChange", function (error) {
         func();
      });

      // Listen to session change
      wmksServiceEventHandler.addEventListener('activeSessionChanged', func);
      // Listen to new session
      wmksServiceEventHandler.addEventListener('sessionConnected', func);

      if (this.consumer === _mksvchan2.default.FILE_TRANSFER_CONSUMER.FT) {
         wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.FT_HELPER);
      } else if (this.consumer === _mksvchan2.default.FILE_TRANSFER_CONSUMER.PRINT) {
         wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.PRINT_HELPER);
      }
   };

   return {
      getInstance: function getInstance(consumer) {
         return new Service(consumer);
      }
   };
}

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.fileTransferPanel = fileTransferPanel;
exports.fileTransferController = fileTransferController;
exports.fileTransferInput = fileTransferInput;
exports.fileDrop = fileDrop;
exports.fileChange = fileChange;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _file_transfer_template = __webpack_require__(261);

var _file_transfer_template2 = _interopRequireDefault(_file_transfer_template);

var _mksvchan = __webpack_require__(12);

var _mksvchan2 = _interopRequireDefault(_mksvchan);

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _clip_ft_help_template = __webpack_require__(60);

var _clip_ft_help_template2 = _interopRequireDefault(_clip_ft_help_template);

var _fileSaver = __webpack_require__(45);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fileTransferPanel($window, panelService, $timeout) {
   return {
      restrict: 'E',
      replace: true, // Replace with the template below
      templateUrl: _file_transfer_template2.default,
      scope: true,
      link: function link(scope, element) {
         var panelServiceInstance = panelService.getService();

         panelServiceInstance.addPanelElement('ft', element);

         element.resizable({
            containment: "document",
            /**
             * The min height and min width are the same with the
             * style '.file-transfer-panel' in style.css
             * List them here to prevent bug 1788445. Otherwise
             * Edge could set the height much smaller
             */
            minHeight: 350,
            minWidth: 500
         }).draggable({
            containment: "window",
            handle: ".file-transfer-handle",
            start: function start(event, ui) {
               element.css("z-index", panelServiceInstance.getNewZIndex());
            }
         });

         scope.windowResizeHandler = panelServiceInstance.windowResizeHandler(scope, 'showFileTransferPanel', element);

         _angular2.default.element($window).bind('resize', scope.windowResizeHandler);

         /**
          * resizes the clipboard contents to fit within the
          * clipboard panel
          *
          * 39 is the header height and 19 is the footer height.
          */
         scope.resizeFileContent = function () {
            var newHeight = element.outerHeight() - 36 - 19;
            (0, _jquery2.default)('.file-content').css('height', newHeight);
            (0, _jquery2.default)('.file-content-list').css('height', newHeight - (0, _jquery2.default)('.file-area-header').outerHeight());
         };

         element.bind('resize', scope.resizeFileContent);

         scope.$on('$destroy', function () {
            element.unbind('resize', scope.resizeFileContent);
            _angular2.default.element($window).unbind('resize', scope.windowResizeHandler);
         });
         $timeout(function () {
            scope.resizeFileContent();
         });
      }
   };
} /******************************************************************************
   * Copyright 2016-2017 VMware, Inc.  All rights reserved.
   *****************************************************************************/

function fileTransferController($window, $scope, $rootScope, $timeout, ngDialog, wmksService, WMKS, TransferHelper, _, toastService, wmksServiceEventHandler, panelService) {
   $rootScope.disableFTPanel = false;
   $scope.transferHelper = TransferHelper.getInstance(_mksvchan2.default.FILE_TRANSFER_CONSUMER.FT);
   $scope.showFileTransferPanel = false;
   $scope.focused = false;
   // Used for focus/blur event
   $scope.fileTransferInput = null;
   $scope.showFileDownload = true;
   $scope.showFileUpload = false;
   $scope.showNotification = null;
   $scope.downloadFiles = [];
   $scope.uploadFiles = [];
   $scope.uploadEnabled = true;
   $scope.downloadEnabled = true;
   $scope.clipboardToServer = false;
   $scope.clipboardToClient = false;
   $scope.modKey = WMKS.BROWSER.isMacOS() ? _('CMD_KEY') : _('CTRL_KEY');
   $scope.windowResizeHandler = null;
   $scope.resizeFileContent = null;
   $scope.selectFile = null;
   $scope.uploadHandler = null;
   $scope.beginDownload = null;
   $scope.beginUpload = null;
   $scope.uploadService = null;
   $scope.downloadService = null;
   $scope.PANEL_TAB = {
      DOWNLOAD: 0,
      UPLOAD: 1
   };
   $scope.errorDialog = null;

   $scope.switchFileTab = function (type) {
      switch (type) {
         case $scope.PANEL_TAB.DOWNLOAD:
            $scope.showFileDownload = true;
            $scope.showFileUpload = false;
            break;
         case $scope.PANEL_TAB.UPLOAD:
            $scope.showFileDownload = false;
            $scope.showFileUpload = true;
            break;
      }
   };

   // shows/hides the clipboard panel
   $scope.toggleFileTransferPanel = function ($event, closePanel) {
      if (closePanel === true) {
         $scope.showFileTransferPanel = false;
      } else if (closePanel === false) {
         $scope.showFileTransferPanel = true;
      } else {
         $scope.showFileTransferPanel = !$scope.showFileTransferPanel;
      }

      if ($scope.showFileTransferPanel) {
         $timeout(function () {
            $scope.windowResizeHandler();
            $scope.resizeFileContent();
         });
      }

      if ($event) {
         $event.stopPropagation();
         $event.preventDefault();
      }
      $scope.focusInput();
   };

   $scope.focusInput = function () {
      if ($scope.fileTransferInput) {
         $timeout(function () {
            $scope.fileTransferInput.select();
         });
      }
   };

   $scope.ftPanelFocus = function () {
      if ($scope.showFileTransferPanel) {
         $scope.focused = true;
         panelService.getService().onFocus('ft');
      }
   };

   $scope.ftPanelBlur = function () {
      $scope.focused = false;
   };

   $scope.openFileTransferHelp = function () {
      ngDialog.open({
         name: "FileTransferHelpWindow", // dialog name
         templateUrl: _clip_ft_help_template2.default, // template
         className: "file-transfer-help-window", // CSS class
         data: {
            title: 'FILE_TRANSFER_HELP_DIALOG_T',
            msg: 'FILE_TRANSFER_HELP_DIALOG_M',
            modKey: $scope.modKey
         },
         showClose: false, // do not show close button
         closeByEscape: true, // allow escape to close window
         closeByDocument: true // allow clicking on background to close
      });
   };

   $scope.clearDownloadList = function () {
      if ($scope.downloadService.isTransferringFile()) {
         _appblastUtil2.default.LOGGER.debug("Another task is in process.");
         return;
      }

      for (var i = 0; i < $scope.downloadFiles.length; i++) {
         if (!!$scope.downloadFiles[i].contentData) {
            // Delete the file content first to trigger gc
            delete $scope.downloadFiles[i].contentData;
         }
      }
      // Be careful, this is referenced array
      $scope.downloadFiles.splice(0, $scope.downloadFiles.length);
   };

   $scope.stopFileDownload = function (file) {
      $scope.downloadService.stopFileDownload(file);
   };

   $scope.removeDownloadFile = function (file) {
      for (var i = 0; i < $scope.downloadFiles.length; i++) {
         if (file === $scope.downloadFiles[i]) {
            $scope.downloadFiles.splice(i, 1);
            break;
         }
      }
   };

   $scope.clearUploadList = function () {
      if ($scope.uploadService.isTransferringFile()) {
         _appblastUtil2.default.LOGGER.debug("Another task is in process.");
         return;
      }

      $scope.uploadFiles.splice(0, $scope.uploadFiles.length);
      clearFileInput();
   };

   $scope.stopFileUpload = function (file) {
      $scope.uploadService.stopFileUpload(file);

      clearFileInput();
   };

   $scope.uploadHandler = function (event) {
      if (!$scope.uploadEnabled) {
         return;
      }

      $scope.switchFileTab($scope.PANEL_TAB.UPLOAD);

      var mksClient = void 0,
          files = void 0,
          i = void 0;

      mksClient = wmksService.getCurrentMKSVchanClient();
      if (mksClient == null) {
         return;
      }

      files = event.target.files || event.originalEvent.dataTransfer.files;
      for (i = 0; i < files.length; i++) {
         files[i].fullPath = files[i].name;
         files[i].relPath = files[i].name;
         files[i].readableSize = mksClient.FTUtil.getReadableSize(files[i].size);
         files[i].progress = 0;
         files[i].stopTransfer = false;
         // Is the file put into upload queue
         files[i].queued = false;

         if (checkFileNameLength(files[i].name) && checkIllegalCharater(files[i].name)) {
            files[i].transferError = false;
         } else {
            files[i].transferError = true;
         }

         $scope.uploadFiles.push(files[i]);
      }

      $scope.$apply();
      $scope.beginUpload();
   };

   /**
    * Defined this function into window instead of scope to bypass the bug
    * 1793969, where if the $("#upload-file-input").click(); is in the
    * $timeout, no file selection window will be generated when using
    * multimon. And remove the $timeout alone will generate apply error,
    * since we call scope event-firing function inside scope event handing
    * funciton.
    */
   $window.chooseUploadFiles = function () {
      (0, _jquery2.default)('#upload-file-input').click();
   };

   $scope.beginUpload = function () {
      $scope.uploadService.init($scope.uploadFiles, function () {
         _appblastUtil2.default.LOGGER.debug('Upload task finish.');
      });

      if (!$scope.uploadService.uploadReady()) {
         return;
      }

      $scope.uploadService.beginUpload();
      clearFileInput();
   };

   $scope.beginDownload = function () {
      $scope.downloadService.init($scope.downloadFiles, function () {
         _appblastUtil2.default.LOGGER.debug('Download task finish.');
      });

      if (!$scope.downloadService.downloadReady()) {
         return;
      }

      // Show toast if print service is downloading file
      if (wmksService.isPrintFileTransferringInCurrentSession()) {
         // Treat it as a print toast since it is blocked by print
         toastService.warning(_('FT_BLOCK_BY_PRINT'), toastService.TOAST_TYPE.PRINT);
      }

      $scope.downloadService.beginDownload();
   };

   /**
    * save file into the local machine, which will bring side effects when
    * using multimon so need to emit event for multimon module to handle.
    */
   $scope.saveFile = function (file) {
      (0, _jquery2.default)(window).trigger("fileDownloaded");
      (0, _fileSaver.saveAs)(new Blob([file.contentData.buffer]), file.relPath);
   };

   function clearFileInput() {
      var inputEle = (0, _jquery2.default)('#upload-file-input');
      /**
       * Special handle for IE
       * $('#upload-file-input').val('') will trigger new file input
       * change event in IE.
       * See here:
       * http://stackoverflow.com/questions/1043957/clearing-input
       * -type-file-using-jquery/1043969#1043969
       */
      if (WMKS.BROWSER.isIE() && WMKS.BROWSER.version.major <= 11) {
         inputEle.wrap('<form>').closest('form').get(0).reset();
         inputEle.unwrap();
      } else {
         inputEle.val('');
      }
   }

   function adjustFileTransferPolicy(mksClient) {
      /**
       * If copy/paste from server to client is disabled, file
       * download cannot be used
       */
      if ($scope.clipboardToClient === false) {
         mksClient.FTUtil.config.downloadEnabled = false;
         $scope.downloadEnabled = false;
      }

      if (!$scope.downloadEnabled && !$scope.uploadEnabled) {
         $rootScope.disableFTPanel = true;
         $scope.showFileTransferPanel = false;
         return;
      }

      $rootScope.disableFTPanel = false;
      if (!$scope.downloadEnabled && $scope.uploadEnabled) {
         $scope.switchFileTab($scope.PANEL_TAB.UPLOAD);
      }
      if ($scope.downloadEnabled && !$scope.uploadEnabled) {
         $scope.switchFileTab($scope.PANEL_TAB.DOWNLOAD);
      }
   }

   $scope.updateMKSvchanClient = function () {
      $timeout(function () {
         var mksClient = $scope.transferHelper.initTransferService(_mksvchan2.default.FILE_TRANSFER_CONSUMER.FT);
         if (mksClient == null) {
            return;
         }
         $scope.uploadService = mksClient.uploadService;
         $scope.downloadService = mksClient.downloadServices[_mksvchan2.default.FILE_TRANSFER_CONSUMER.FT];
         $scope.downloadFiles = mksClient.FTUtil.downloadList[_mksvchan2.default.FILE_TRANSFER_CONSUMER.FT];
         $scope.uploadFiles = mksClient.FTUtil.uploadList;
         $scope.uploadService.fileChunkQueue = mksClient.FTUtil.fileChunkQueue;

         $scope.downloadEnabled = !!mksClient.FTUtil.config.downloadEnabled && !WMKS.BROWSER.isSafari();
         $scope.uploadEnabled = !!mksClient.FTUtil.config.uploadEnabled;

         adjustFileTransferPolicy(mksClient);

         if ($scope.showFileTransferPanel) {
            $scope.showNotification('FT_SESSION_UPDATE_M');
         }
      });
   };

   function checkFileNameLength(fileName) {
      /**
       * Windows has the max 260 path length restriction
       * Mac has max 255 file name length restriction
       * Since we save uploaded file to C:/Users/userName/Documents/,
       * we need to calculate the length the whole path
       */
      var MAX_LENGTH = 250;

      if (!fileName || fileName === '' || fileName.length > MAX_LENGTH) {
         return false;
      }

      return 21 + fileName.length + $scope.userName.length <= MAX_LENGTH;
   }

   function checkIllegalCharater(fileName) {
      return fileName.indexOf('\\') < 0 && fileName.indexOf('/') < 0 && fileName.indexOf(':') < 0 && fileName.indexOf('*') < 0 && fileName.indexOf('?') < 0 && fileName.indexOf('"') < 0 && fileName.indexOf('<') < 0 && fileName.indexOf('>') < 0 && fileName.indexOf('|') < 0;
   }

   wmksServiceEventHandler.addEventListener('sessionDataReady', function (sessionData) {
      $scope.userName = sessionData.user;
   });
   // Listen to file transfer updates and sync panel with agent
   wmksServiceEventHandler.addEventListener('downloadFileListChanged', function (fileList, client, error) {
      /**
       * TODO reference client here in case some bugs while
       * desktop switch. See bug 1755174, 1755201, 1756222.
       * These bugs have same root cause. Since it is not likely
       * happen in ft, let's fix it later.
       */
      $timeout(function () {
         _appblastUtil2.default.LOGGER.log("File download list from remote server is" + " synced to client.");
         if ($scope.downloadEnabled === false || !fileList || fileList.length <= 0 || !$scope.downloadService) {
            _appblastUtil2.default.LOGGER.log("Download not enable or list is empty!");
            return;
         }

         var i = void 0;
         // If panel not opened, do nothing
         if (!$scope.showFileTransferPanel) {
            _appblastUtil2.default.LOGGER.debug("File control panel is not opened" + " now.");

            for (i = 0; i < fileList.length; i++) {
               $scope.downloadService.unusedFileList.push(fileList[i]);
            }
            return;
         }

         $scope.downloadService.verifyTotalSize($scope.downloadService.getTotalFileSizeForList(fileList));

         if (error === _mksvchan2.default.CLIPBOARD_ERROR.MAX_LIMIT_EXCEEDED) {
            if ($scope.showFileTransferPanel) {
               $scope.showNotification('FT_FILE_LIST_TRUNCATED_M');
            }
         }

         // Store old and new file list
         $scope.transferHelper.updateDownloadFileList(fileList, client);

         // If open panel, begin download right now
         $scope.beginDownload();
      });
   });

   wmksServiceEventHandler.addEventListener('fileTransferFailed', function () {
      if ($scope.showFileTransferPanel) {
         $scope.showNotification('FT_FAILED_M');
      }
   });

   wmksServiceEventHandler.addEventListener('fileTransferError', function (error) {
      if (!!$scope.errorDialog && ngDialog.isOpen($scope.errorDialog.id)) {
         _jscdkLogger2.default.debug('Only open one dialog each time.');
         $scope.errorDialog.close();
      }

      var errorMsg = void 0;

      switch (error) {
         case _mksvchan2.default.FILE_TRANSFER_ERROR.NO_ENOUGH_DISK:
            errorMsg = _('FT_ERROR_NO_ENOUGH_DISK');
            for (var i = 0; i < $scope.uploadFiles.length; i++) {
               if ($scope.uploadFiles[i].progress !== 100 && $scope.uploadFiles[i].stopTransfer !== true && $scope.uploadFiles[i].transferError !== true) {
                  $scope.stopFileUpload($scope.uploadFiles[i]);
               }
            }
            break;
         case _mksvchan2.default.FILE_TRANSFER_ERROR.IS_TRANSFERRING:
            errorMsg = _('FT_ERROR_SERVER_IS_TRANSFERRING_FILES');
            break;
         case _mksvchan2.default.FILE_TRANSFER_ERROR.UNKNOWN_ERROR:
            errorMsg = _('FT_ERROR_UNKNOWN_ERROR');
            break;
         default:
            _jscdkLogger2.default.error('Invalid error number: ' + error + ' received from server.');
      }
      $scope.errorDialog = ngDialog.open({
         name: 'FileTransferServerErrorDialog',
         templateUrl: _dialog_service_error2.default,
         className: "session-ops-dialog",
         data: {
            errorMessage: errorMsg,
            title: _('FT_WARNING_T'),
            buttonLabel: _('OK')
         },
         showClose: false,
         closeByEscape: true,
         closeByDocument: true
      });
   });

   /**
    * Download is associated with copy from agent to client
    * (copyEnabled)
    */
   wmksServiceEventHandler.addEventListener("clipboardCapabilitiesChanged", function (clipboardReady, copyEnabled, pasteEnabled) {
      $timeout(function () {
         $scope.clipboardToServer = pasteEnabled;
         $scope.clipboardToClient = copyEnabled;
         var mksClient = $scope.transferHelper.initTransferService();
         if (mksClient == null) {
            return;
         }

         adjustFileTransferPolicy(mksClient);
      });
   });
   wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.FT_CONTROLLER);

   $scope.transferHelper.addStatusListener($scope.updateMKSvchanClient);
   $rootScope.$on('toggleFileTransferPanel', $scope.toggleFileTransferPanel);
}

function fileTransferInput() {
   return {
      restrict: 'E',
      replace: true, // Replace with the template below
      template: "<input></input>",
      link: function link(scope, element) {
         scope.fileTransferInput = element;
         element.val(" ");
      }
   };
}

function fileDrop() {
   return {
      restrict: 'A',
      scope: {
         fileDrop: '&fileDrop'
      },
      link: function link(scope, element) {
         element.on('dragover', function (e) {
            e.preventDefault();
            e.stopPropagation();
         });
         element.on('dragenter', function (e) {
            e.preventDefault();
            e.stopPropagation();
         });
         element.on('drop', function (e) {
            if (typeof scope.fileDrop === 'function') {
               scope.fileDrop({
                  event: e
               });
            }

            e.preventDefault();
         });
      }
   };
}

function fileChange() {
   return {
      restrict: 'A',
      scope: {
         fileChange: '&'
      },
      link: function link(scope, element) {
         element.on('change', function (e) {
            if (typeof scope.fileChange === 'function') {
               scope.fileChange({
                  event: e
               });
            }
         });
      }
   };
}

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = fileTransferService;

var _mksvchan = __webpack_require__(12);

var _mksvchan2 = _interopRequireDefault(_mksvchan);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * file-transfer-service.js --
 *
 * Base class for upload & download service.
 *
 */

function fileTransferService(AB, ngDialog, wmksService, $timeout, _) {
   function Service() {
      this.fileList = [];
      this.isTransferring = false;
      this.onTransferFinish = null;
      this.transferProgess = 0;
      this.dialog = null;
   }

   Service.prototype.openErrorDialog = function (errorDgName, errorMsg) {
      if (!!this.dialog && ngDialog.isOpen(this.dialog.id)) {
         AB.LOGGER.debug('Only open one dialog each time.');
         this.dialog.close();
      }

      this.dialog = ngDialog.open({
         name: errorDgName,
         templateUrl: _dialog_service_error2.default,
         className: "session-ops-dialog",
         data: {
            errorMessage: errorMsg,
            title: _('FT_WARNING_T'),
            buttonLabel: _('OK')
         },
         showClose: false,
         closeByEscape: true,
         closeByDocument: true
      });
   };

   Service.prototype.init = function (fileList, onTransferFinish) {
      if (!fileList || typeof onTransferFinish !== 'function') {
         AB.LOGGER.error('Cannot init file transfer service due to param error!');
         return;
      }

      this.transferProgess = 0;
      for (var i = 0; i < fileList.length; i++) {
         if (fileList[i].progress === 100) {
            this.transferProgess++;
         }
      }
      this.fileList = fileList;
      this.onTransferFinish = onTransferFinish;
   };

   Service.prototype.isTransferringFile = function () {
      if (this.isTransferring) {
         this.openErrorDialog('BeingTransferWarningDialog', _('FT_BEING_TRANSFER_WARNING_M'));
         return true;
      }
      return false;
   };

   Service.prototype.isTransferringFileWithNoDialog = function () {
      return this.isTransferring;
   };

   Service.prototype.checkFileSize = function () {
      var res = false;

      for (var i = 0; i < this.fileList.length; i++) {
         if (this.fileList[i].size >= _mksvchan2.default.FILE_TRANSFER_MAX_FILE_SIZE || this.fileList[i].size === 0) {
            this.fileList[i].transferError = true;
            res = true;
         }
      }
      return res;
   };

   Service.prototype.checkFolderExist = function () {
      var res = false;

      for (var i = 0; i < this.fileList.length; i++) {
         if (this.fileList[i].fileType === _mksvchan2.default.FILE_TRANSFER_FILE_TYPE.DIRECTORY) {
            this.fileList[i].transferError = true;
            res = true;
         }
      }
      return res;
   };

   Service.prototype.checkSymlinkExist = function () {
      var res = false;

      for (var i = 0; i < this.fileList.length; i++) {
         if (this.fileList[i].fileType === _mksvchan2.default.FILE_TRANSFER_FILE_TYPE.SYMLINK) {
            this.fileList[i].transferError = true;
            res = true;
         }
      }
      return res;
   };

   return {
      baseService: new Service()
   };
}

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = FTUploadService;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * file-transfer-upload-service.js --
 *
 * Module for upload file service.
 *
 */

function FTUploadService(AB, wmksService, $timeout, _, fileTransferService) {
   function Service(mksClient) {
      this.mksClient = mksClient;
      // Store reference for mksvchan.ftutil.fileChunkQueue
      this.fileChunkQueue = null;
      this.NUMBER_OF_CHUNK_SEND_ONE_TIME = 10;
      this.currentNumChunkSendOneTime = 0;
      this.chunkSendNum = 0;
   }

   Service.prototype = fileTransferService.baseService;

   Service.prototype.uploadReady = function () {
      if (!this.mksClient.FTUtil.config.uploadEnabled) {
         // If upload not allowed, just return
         AB.LOGGER.debug('File upload is not allowed.');
         return false;
      }

      if (!this.fileList || this.fileList.length < 1) {
         this.openErrorDialog('NoFileWarningDialog', _('FT_NO_FILE_WARNING_M'));
         return false;
      }

      return true;
   };

   Service.prototype.queueFileChunks = function (file) {
      if (file.transferError === true || file.progress > 0 || file.stopTransfer === true || file.queued === true) {
         return;
      }

      var fileChunkNum = void 0,
          configChunkSize = void 0,
          currentChunkSize = void 0,
          i = void 0;

      if (this.mksClient == null) {
         return;
      }

      file.queued = true;
      configChunkSize = this.mksClient.FTUtil.config.chunkSize;
      currentChunkSize = configChunkSize;
      fileChunkNum = file.size % configChunkSize === 0 ? Math.floor(file.size / configChunkSize) : Math.floor(file.size / configChunkSize + 1);

      for (i = 0; i < fileChunkNum; i++) {
         if (i === fileChunkNum - 1) {
            currentChunkSize = file.size - (fileChunkNum - 1) * configChunkSize;
         }
         this.fileChunkQueue.push({
            fileRef: file,
            chunkNum: i,
            totalChunkNum: fileChunkNum,
            currentChunkSize: currentChunkSize,
            chunkSize: configChunkSize
         });
      }
   };

   Service.prototype.removeFileChunksFromQueue = function (file) {
      for (var i = this.fileChunkQueue.length - 1; i >= 0; i--) {
         if (file === this.fileChunkQueue[i].fileRef) {
            this.fileChunkQueue.splice(i, 1);
         }
      }
   };

   Service.prototype.sendNextFileChunks = function () {
      var _this = this;

      if (this.fileChunkQueue.length === 0) {
         AB.LOGGER.debug("File upload finished.");
         this.isTransferring = false;
         return;
      }

      var onDone = void 0,
          onAbort = void 0;

      onDone = function onDone() {
         _this.chunkSendNum++;

         if (_this.chunkSendNum === _this.currentNumChunkSendOneTime) {
            _this.chunkSendNum = 0;
            _this.sendNextFileChunks();
         }
      };

      onAbort = function onAbort() {
         _this.isTransferring = false;
         _this.fileChunkQueue.splice(0, _this.fileChunkQueue.length);
      };

      this.currentNumChunkSendOneTime = Math.min(this.NUMBER_OF_CHUNK_SEND_ONE_TIME, this.fileChunkQueue.length);

      var chunks = [],
          chunk = void 0;
      for (var i = 0; i < this.currentNumChunkSendOneTime; i++) {
         chunk = this.fileChunkQueue.shift();
         chunks.push(chunk);
      }
      wmksService.readAndSendFileChunks(this.mksClient, chunks, onDone, onAbort);
   };

   Service.prototype.checkFileValid = function (fileList, onValidDone) {
      var _this2 = this;

      if (!fileList || typeof onValidDone !== 'function') {
         AB.LOGGER.error("Error file list or onValidDone function!");
         return;
      }

      // Read each item for 1 byte to verify if it is a valid file
      var fileTester = function fileTester(fileIndex) {
         if (fileIndex > fileList.length - 1) {
            onValidDone();
            return;
         }

         var currentFile = fileList[fileIndex],
             reader = void 0,
             oneByteBlob = void 0;

         if (currentFile.transferError === true || currentFile.queued === true) {
            fileTester(fileIndex + 1);
            return;
         }

         if (currentFile.size === 0 || currentFile.size > _this2.mksClient.FTUtil.config.maxChunkNum * _this2.mksClient.FTUtil.config.chunkSize) {
            $timeout(function () {
               currentFile.transferError = true;
               fileTester(fileIndex + 1);
            });
            return;
         }

         reader = new FileReader();
         oneByteBlob = currentFile.slice(0, 1);

         reader.onload = function (evt) {
            fileTester(fileIndex + 1);
         };

         reader.onerror = function () {
            $timeout(function () {
               currentFile.transferError = true;
               fileTester(fileIndex + 1);
            });
         };
         reader.readAsArrayBuffer(oneByteBlob);
      };

      fileTester(0);
   };

   Service.prototype.beginUpload = function () {
      var _this3 = this;

      // Remember call ready before this function
      var onValidDone = function onValidDone() {
         for (var i = 0; i < _this3.fileList.length; i++) {
            _this3.queueFileChunks(_this3.fileList[i]);
         }

         if (_this3.isTransferring === false) {
            _this3.isTransferring = true;
            _this3.sendNextFileChunks();
         }
      };

      this.checkFileValid(this.fileList, onValidDone);
   };

   Service.prototype.checkUploadStatus = function () {
      for (var i = 0; i < this.fileList.length; i++) {
         if (this.fileList[i].transferError === true) {
            return false;
         }
      }
      return true;
   };

   Service.prototype.stopFileUpload = function (file) {
      file.stopTransfer = true;
      this.removeFileChunksFromQueue(file);

      // If already begin upload, tell mksvchan server to release file
      if (file.progress !== 0 && file.progress !== 100) {
         wmksService.stopFileUpload(this.mksClient, file.name, function () {
            AB.LOGGER.debug("Successfully send cancel upload request.");
         });
      }
   };

   return {
      getService: function getService(mksClient) {
         if (!mksClient) {
            AB.LOGGER.error("Invalid mksvchan client.");
            return null;
         }
         return new Service(mksClient);
      }
   };
}

/***/ }),
/* 133 */,
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = extendedMonitorService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function extendedMonitorService($window, $, _) {
   var getTranslateMap = function getTranslateMap() {
      var keys = ["MM_WAIT_OTHER_MONITOR_READY", "MM_HINT_MOVE", "MM_SELECT_MONITOR", "MM_QUIT_MULTIMON_T", "MM_QUIT_MULTIMON_M", "OK", "CANCEL", "MM_MONITOR_DETECTOR"],
          translationMap = {};

      //user promise if translationService allow.
      for (var i = 0; i < keys.length; i++) {
         translationMap[keys[i]] = _(keys[i]);
      }
      return translationMap;
   };

   this.statusMap = {
      opened: 0,
      inited: 1,
      readyToDisplay: 2,
      displaying: 3,
      close: -1,
      confirmedQuit: -2
   };

   this.wmksSession = null; //TODO: should be set outside
   this.translationMap = getTranslateMap();
   this.onMouseButton = function (data) {
      this.wmksSession.wmksContainer.wmks('sendMouseButtonMessage', data.position, data.isDownEvent, data.bmask);
      $(document).trigger("extendedmonitoruse");
   };
   this.onMouseMove = function (data) {
      this.wmksSession.wmksContainer.wmks('sendMouseMoveMessage', data.position);
      $(document).trigger("extendedmonitoruse");
   };
   this.onMouseWheel = function (data) {
      this.wmksSession.wmksContainer.wmks('sendScrollMessage', data.position, data.dx, data.dy);
      $(document).trigger("extendedmonitoruse");
   };
   this.onKeyEvent = function (data) {
      this.wmksSession.wmksContainer.wmks('sendKeyMessage', data);
      $(document).trigger("extendedmonitoruse");
   };
   this.onBlur = function (data) {
      _jscdkLogger2.default.debug("focus leave extended monitor");
      this.wmksSession.wmksContainer.wmks('onBlur');
      $(document).trigger("extendedmonitoruse");
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * extended-monitor-service.js -- extendedMonitorService
 *
 * provide data
 * extendedMonitorService
 */

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ExtendedMonitor;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ExtendedMonitor($window, extendedMonitorService, vncDecoder, $timeout) {
   return function () {
      var _this2 = this;

      /**
       * @private
       * @type {boolean}
       */
      this.inited = false;
      this.canRender = false;

      this.origin = "https://" + $window.location.hostname;

      this.sendMessage = function (message) {
         if (!this.inited) {
            return;
         }
         message.uid = this.uid;
         this.extendedWindow.postMessage(message, this.origin);
      };
      this.setStatus = function (status) {
         this.status = status;
         this.onStatusChanged(this.id, status);
      };

      this.initPage = function (data) {
         this.uid = data.uid;
         this.sendMessage({
            type: "init",
            data: {
               id: this.id,
               translationMap: extendedMonitorService.translationMap
            }
         });
      };

      this.sendUnmaximizableRegion = function () {
         this.sendMessage({
            type: "updateUnmaxableRegions",
            data: {
               regions: this.unmaximizableRegions
            }
         });
      };

      this.onPostMessage = function (event) {
         var _this = this;

         var responseData = event.data,
             origin = event.origin || event.originalEvent.origin,
             source = event.source || event.originalEvent.source;

         if (origin !== this.origin || source !== this.extendedWindow) {
            return;
         }
         if (this.uid !== "" && responseData.uid !== this.uid) {
            return;
         }

         switch (responseData.type) {
            case "ready":
               this.initPage(responseData);
               break;
            case "initDone":
               this.setStatus(extendedMonitorService.statusMap["inited"]);
               break;
            case "setUnmaxableRegion":
               this.onRegionUpdated(this.id, responseData.data.region);
               break;
            case "readyToDisplay":
               this.onRegionUpdated(this.id, responseData.data.region);
               this.setStatus(extendedMonitorService.statusMap["readyToDisplay"]);
               break;
            case "close":
               this.onRegionUpdated(this.id, null);
               this.onStatusChanged(this.id, extendedMonitorService.statusMap["closed"]);
               break;
            case "confirmedClose":
               this.onStatusChanged(this.id, extendedMonitorService.statusMap["confirmedQuit"]);
               break;
            case "onBlur":
               extendedMonitorService.onBlur();
               break;
            case "keyEvent":
               extendedMonitorService.onKeyEvent(responseData.data);
               break;
            case "mouseButton":
               extendedMonitorService.onMouseButton(responseData.data);
               break;
            case "mouseWheel":
               extendedMonitorService.onMouseWheel(responseData.data);
               break;
            case "mouseMove":
               extendedMonitorService.onMouseMove(responseData.data);
               break;
            case "renderingDone":
               responseData.renderingIndeces.forEach(function (item) {
                  _this.onRenderingDone(_this.id, item);
               });
               break;
            default:
               _jscdkLogger2.default.debug("unknown message type", responseData);
         }
      }.bind(this);
      /**
       * init this instance
       * @param  {[type]} id              The extended monitor id
       * @param  {[type]} unmaximizableRegions The regions that don't allow maximize
       * @param  {[type]} onStatusChanged The callback for monitor status change (id , status)
       * @param  {[type]} onRegionUpdated The callback for regions changes (id ,data(could be null))
       */
      this.init = function (id, unmaximizableRegions, onStatusChanged, onRegionUpdated) {
         this.id = id;
         this.unmaximizableRegions = unmaximizableRegions;
         this.onRegionUpdated = onRegionUpdated;
         this.onStatusChanged = onStatusChanged;
         this.status = extendedMonitorService.statusMap["opened"];
         this.containingMonitor = null;
         this.uid = "";
         this.extendedWindow = $window.open("./app-extended-monitor.html?v=" + "1", "extended_monitor" + this.id, "height=300, width=300, status=yes, toolbar=no, menubar=no, location=no");
         if (!this.extendedWindow) {
            console.error("failed to open pop up window");
            $timeout(function () {
               this.onStatusChanged(this.id, extendedMonitorService.statusMap["closed"]);
            }.bind(this));
            return;
         }
         this.extendedWindow.addEventListener("message", this.onPostMessage, false);
         this.inited = true;
      };

      /**
       * This function should be called when other monitor detector found any changes
       * It will set regions to the all used regions except itself
       * @param  {object} allUsedRegions The object contains the regeion
       */
      this.updateUnmaxizableRegions = function (allUsedRegions) {
         this.unmaximizableRegions = Object.assign({}, allUsedRegions);
         delete this.unmaximizableRegions[this.id];
         this.sendUnmaximizableRegion();
      };

      /**
       * should be called when user want to use all monitors
       * @param  {object} screenBase
       * @param  {object} screenModel
       * @param  {function} onRenderingDone
       */
      this.startDisplay = function (screenBase, onRenderingDone, screenModel, sizeFactor) {
         if (this.status !== extendedMonitorService.statusMap["readyToDisplay"]) {
            _jscdkLogger2.default.debug("skip startDisplay since not ready on" + this.id);
            return;
         }
         this.onRenderingDone = onRenderingDone;
         this.sendMessage({
            type: "startDisplay",
            data: {
               screenBase: screenBase,
               screenModel: screenModel,
               sizeFactor: sizeFactor
            }
         });
         this.status = extendedMonitorService.statusMap["working"];
         this.canRender = true;
         this.vncRects = [];
         this.currentFrameId = 0;
         this.frameWaitTimer = null;
         this.frameWaitTime = 50;
      };

      this.appendChange = function (data) {
         var frameId = data.rect.frameId;
         if (this.currentFrameId !== frameId) {
            this.sendDisplayChange();
            this.currentFrameId = frameId;
         }
         this.vncRects.push(data);
         if (!this.frameWaitTimer) {
            this.frameWaitTimer = $timeout(this.sendDisplayChange, this.frameWaitTime);
         }
      };

      this.sendDisplayChange = function () {
         if (this.vncRects.length > 0) {
            if (!!this.extendedWindow) {
               this.extendedWindow.postMessage({
                  type: "display",
                  uid: this.uid,
                  data: this.vncRects
               }, this.origin);
            }

            this.vncRects.forEach(function (item) {
               vncDecoder.releaseRectData(item);
            });
            this.vncRects = [];
         }
         if (!!this.frameWaitTimer) {
            clearTimeout(this.frameWaitTimer);
            this.frameWaitTimer = null;
         }
      }.bind(this);

      /**
       * [onDisplayChanged description]
       * @param  {[type]} regionData [description]
       * @return {[type]}            [description]
       */
      this.onDisplayChanged = function (rect, renderingIndex) {
         if (this.status !== extendedMonitorService.statusMap["working"]) {
            _jscdkLogger2.default.debug("skip display since not working on " + this.id);
            return;
         }
         if (!this.canRender) {
            _jscdkLogger2.default.trace("skip display since extended monitor is busy on " + this.id);
            return;
         }

         this.appendChange({
            rect: rect,
            renderingIndex: renderingIndex
         });
         rect.skipRelease = true;
      };

      /**
       * [onCursorChanged description]
       * @param  {[type]} cursorAddress [description]
       * @return {[type]}               [description]
       */
      this.onCursorChanged = function (cursorAddress) {
         if (this.status !== extendedMonitorService.statusMap["working"]) {
            _jscdkLogger2.default.debug("skip changeCursor since not working on " + this.id);
            return;
         }
         this.sendMessage({
            type: "setCursor",
            data: {
               url: cursorAddress
            }
         });
      };

      // double ensurance to close extended window, since chrome has bug sometime
      this.close = function () {
         _this2.canRender = false;
         _this2.status = extendedMonitorService.statusMap["opened"];
         _this2.extendedWindow.removeEventListener("message", _this2.onPostMessage, false);
         $timeout(function () {
            this.sendMessage({
               type: "forcibleClose"
            });
            this.extendedWindow = null;
            this.inited = false;
         }.bind(_this2));
      };

      this.showDisplay = function () {
         this.sendMessage({
            type: "showDisplay"
         });
      };

      this.hideDisplay = function () {
         this.sendMessage({
            type: "hideDisplay"
         });
      };
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * extended-monitor.js -- ExtendedMonitor
 *
 * Class to control the extended monitor.
 * contained by the model
 *
 * mainly maintain the inner status and response to message and inner data for communication
 *
 * user JSCDKLogger for now later will change when the new logservice is ready
 */

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _module = __webpack_require__(28);

var _module2 = _interopRequireDefault(_module);

var _primaryMonitorService = __webpack_require__(141);

var _primaryMonitorService2 = _interopRequireDefault(_primaryMonitorService);

var _multimonService = __webpack_require__(140);

var _multimonService2 = _interopRequireDefault(_multimonService);

var _multimonModel = __webpack_require__(138);

var _multimonModel2 = _interopRequireDefault(_multimonModel);

var _monitorManageService = __webpack_require__(137);

var _monitorManageService2 = _interopRequireDefault(_monitorManageService);

var _extendedMonitorService = __webpack_require__(134);

var _extendedMonitorService2 = _interopRequireDefault(_extendedMonitorService);

var _extendedMonitor = __webpack_require__(135);

var _extendedMonitor2 = _interopRequireDefault(_extendedMonitor);

var _multimonRenderingService = __webpack_require__(139);

var _multimonRenderingService2 = _interopRequireDefault(_multimonRenderingService);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

exports.default = angular.module('com.vmware.vdi.htmlaccess.desktop.multimon', [_module2.default]).service("primaryMonitorService", ["jQuery", "$window", "$timeout", "fullscreenService", "wmksBaseService", "vncDecoder", "normalizationService", _primaryMonitorService2.default]).service("multimonService", ["monitorManageService", "multimonModel", "dialogService", "$timeout", "translate", _multimonService2.default]).service("multimonModel", ["ExtendedMonitor", "primaryMonitorService", _multimonModel2.default]).service("monitorManageService", ["$timeout", "$window", "$rootScope", "multimonModel", "extendedMonitorService", "normalizationService", "dialogService", "vncDecoder", "renderCacheService", "translate", _monitorManageService2.default]).service("multimonRenderingService", ["monitorManageService", _multimonRenderingService2.default]).service("extendedMonitorService", ["$window", "jQuery", "translate", _extendedMonitorService2.default]).service("ExtendedMonitor", ["$window", "extendedMonitorService", "vncDecoder", "$timeout", _extendedMonitor2.default]).name;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); /*********************************************************
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          *********************************************************/

/**
 * monitor-manage-service.js -- monitorManageService
 *
 * service to control all monitors for multimon.
 * service to bound events to update the model
 *
 * entermultimon, will always call addMonitor, PrimaryMonitor.enable, bound
 * events
 */
// step: switchToMultiMonitor, addMonitor

exports.default = monitorManageService;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function monitorManageService($timeout, $window, $rootScope, multimonModel, extendedMonitorService, normalizationService, dialogService, vncDecoder, renderCacheService, _) {
   var _this2 = this;

   this.canvasBuffer = null;
   this.canvasContainer = document.getElementById('canvas-container');
   this.quitConfirmDialog = null;
   this.renderingList = {
      0: {}
   };
   this.renderingCallback = {};
   this.renderingIndex = 0;
   this.monitorBounds = null;
   this.caches = [];
   this._cacheInited = false;
   this._isDisplaying = false;
   this._isH264Enabled = false;
   this._activeBackground = null;
   /**
    * MutationObserver is defined as in
    * https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver
    */
   this.cursorObserver = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutationRecord) {
         $timeout(function () {
            (0, _jquery2.default)(window).trigger("CursorChanged");
         });
      });
   });

   this.setMonitorBounds = function () {
      var baseX = multimonModel.monitorSettings.baseX,
          baseY = multimonModel.monitorSettings.baseY;

      this.monitorBounds = {};
      multimonModel.forEachSettings(function (key, setting) {
         this.monitorBounds[key] = {
            x: baseX + setting.x,
            y: baseY + setting.y,
            width: setting.width,
            height: setting.height
         };
      }.bind(this));
   };

   this.clearRenderStatus = function () {
      var key = void 0;
      for (key in this.renderingList) {
         if (this.renderingList.hasOwnProperty(key) && JSON.stringify(this.renderingList[key]) !== "{}") {
            this.renderingCallback[key].onDone();
         }
      }
      this.renderingList = {
         0: {}
      };
      this.renderingCallback = {};
      this.renderingIndex = 0;
   };

   /**
    * Uses the overall decoding delay, which might bring down the fps, but
    *    should be more stable
    * @param  {number} monitorIndex The index of monitor
    * @param  {number} frameIndex   The index of rendered frame
    * @param  {number} decodeStart  The start time of rendering
    */
   this.onRenderingDone = function (monitorIndex, frameIndex) {
      if (!this.renderingList[frameIndex] || !this.renderingCallback[frameIndex]) {
         _jscdkLogger2.default.debug("can't finish rendering twice for index: " + frameIndex);
         return;
      }
      delete this.renderingList[frameIndex][monitorIndex];
      if (JSON.stringify(this.renderingList[frameIndex]) === "{}") {
         this.renderingCallback[frameIndex].onDone();
         delete this.renderingList[frameIndex];
         delete this.renderingCallback[frameIndex];
      }
   }.bind(this);

   this.onCursorChanged = function () {
      var cursorAddress = (0, _jquery2.default)(this._activeBackground).css("cursor"),
          key = void 0;

      // dispatch to all monitors.
      for (key in multimonModel.monitors) {
         if (multimonModel.monitors.hasOwnProperty(key)) {
            multimonModel.monitors[key].onCursorChanged(cursorAddress);
         }
      }
   }.bind(this);

   this.isOutsideBound = function (x, y, width, height, bound) {
      return x < bound.x || x + width > bound.x + bound.width || y < bound.y || y + height > bound.y + bound.height;
   };

   /**
    * Return whether a package should be dispatch to monitor with key as index
    * dispatching EOF to all monitors to ensure all monitors are responding
    * and able to deal with comming frames
    *
    * extra logic for frame buffer cache
    */
   this.shouldDispatch = function (rect, key) {
      var rectWidth = rect.width || !!rect.image && rect.image.width,
          rectHeight = rect.height || !!rect.image && rect.image.height;

      // dispatch message to all monitors when init cache
      if (rect.encoding === vncDecoder.encodingTypes["encUpdateCache"] && rect.opcode === renderCacheService.cacheOperationType["updateCacheOpInit"]) {
         return true;
      }
      if (!this.monitorBounds || !this.monitorBounds.hasOwnProperty(key)) {
         _jscdkLogger2.default.error("wrong status in the monitorBounds");
         return false;
      }
      if (this.isOutsideBound(rect.x, rect.y, rectWidth, rectHeight, this.monitorBounds[key])) {
         return false;
      }
      if (!!rect.srcX && !!rect.srcY && this.isOutsideBound(rect.srcX, rect.srcY, rectWidth, rectHeight, this.monitorBounds[key])) {
         _jscdkLogger2.default.debug("cross monitor move detected");
         return false;
      }
      return true;
   };

   this.initImageBuffer = function () {
      this.canvasContainer.style.height = "1px"; //TODO
      this.canvasContainer.style.width = "1px";

      this.sessionContainer = multimonModel.sessionContainer;
      this.sessionContainer.style.display = "none";
      var backgroundCanvas = (0, _jquery2.default)(this.sessionContainer).children("#mainCanvas")[0];
      var backgroundVideo = (0, _jquery2.default)(this.sessionContainer).children("video")[0];
      /**
       * Don't use this._isH264Enabled for now, since current wmks design allows
       * inconsistent between settings and real working mode, but still keep the
       * mode info for feature usage.
       */
      if (!!backgroundVideo) {
         this._activeBackground = backgroundVideo;
      } else {
         this._activeBackground = backgroundCanvas;
      }
      this.canvasBuffer = backgroundCanvas.getContext('2d');
      (0, _jquery2.default)(window).off("CursorChanged");
      (0, _jquery2.default)(window).on("CursorChanged", this.onCursorChanged);
   };

   this.clearImageBuffer = function () {
      var _this = this;

      this.canvasContainer.style.height = "100%";
      this.canvasContainer.style.width = "100%";
      if (!!this._activeBackground) {
         this._activeBackground.style.display = "none";
         var switchDelay = 2000;
         $timeout(function () {
            _this._activeBackground.style.display = "";
            _this._activeBackground = null;
         }, switchDelay);
      }
      if (!!this.sessionContainer) {
         this.sessionContainer.style.display = "";
         this.sessionContainer = null;
      }
      this.canvasBuffer = null;
      (0, _jquery2.default)(window).off("CursorChanged", this.onCursorChanged);
   };

   /**
    * This release will always fire onSingleMonitor and onQuitMultimon at the
    * same time, but later will be different, user will be allow to adjust the
    * displayers
    * @param  {object} wmksSession     The wmks session object
    * @param  {object} sessionContainer The DOM that contains the blast session
    * @param  {function} onQuitMultimon The callback when quit multimon mode, but still in the config phase
    * @param  {function} onEnterMultimon The callback when leave config phase and enter multimon
    * @param  {function} onSingleMonitor The callback when switch back to single monitor mode
    */
   this.switchToMultiMonitor = function (wmksSession, sessionContainer, onQuitMultimon, onEnterMultimon, onSingleMonitor, onMultiMonitor, onTopologyChanged, onMonitorChanged, options) {
      multimonModel.init(wmksSession, sessionContainer);
      extendedMonitorService.wmksSession = wmksSession;
      this.onSingleMonitor = onSingleMonitor;
      this.onEnterMultimon = onEnterMultimon;
      this.onMultiMonitor = onMultiMonitor;
      this.onQuitMultimon = onQuitMultimon;
      this.onTopologyChanged = onTopologyChanged;
      this.onMonitorChanged = onMonitorChanged;
      multimonModel.primaryMonitor.init(this.onRegionUpdated);
      // pop out first detector
      this.addMonitor();
      $window.addEventListener("beforeunload", this.switchToSingleMonitor);
      $rootScope.$on('$locationChangeStart', this.onLocationChanged);
      this.renderingList = {
         0: {}
      };
      this.renderingIndex = 0;
      this.caches = [];
      if (!!options) {
         this._isH264Enabled = options.enableH264;
      }
   };

   this.onLocationChanged = function (event, next, current) {
      if (current.indexOf('#/desktop') !== -1 && next.indexOf('#/desktop') === -1) {
         this.switchToSingleMonitor();
      }
   }.bind(this);

   this.switchToSingleMonitor = function () {
      var key = void 0;
      //close all extended
      for (key in multimonModel.monitors) {
         if (multimonModel.monitors.hasOwnProperty(key) && typeof multimonModel.monitors[key].close === "function") {
            multimonModel.monitors[key].close();
         }
      }
      //then quitMultimonMode should be called
      this.quitMultimonMode();
      $window.removeEventListener("beforeunload", this.switchToSingleMonitor);
      if (!!$rootScope && typeof $rootScope.$off === 'function') {
         $rootScope.$off('$locationChangeStart', this.onLocationChanged);
      }
      if (!!this.quitConfirmDialog) {
         this.quitConfirmDialog.close();
         this.quitConfirmDialog = null;
      }
   }.bind(this);

   this.startSpyCursor = function () {
      this.cursorObserver.observe(this._activeBackground, {
         attributes: true,
         attributeFilter: ['style']
      });
   };
   this.stopSpyCursor = function () {
      this.cursorObserver.disconnect();
   };
   /**
    * @private
    * @return {[type]} [description]
    */
   this.quitMultimonMode = function () {
      multimonModel.usingMultimon = false;
      this._cacheInited = false;
      this.monitorBounds = null;
      _jscdkLogger2.default.log("quit multimon mode");
      this.stopSpyCursor();
      multimonModel.primaryMonitor.disable();
      this.clearImageBuffer();
      this.clearRenderStatus();
      multimonModel.clear();
      normalizationService.clear();
      this.onQuitMultimon();
      this.onSingleMonitor();
   };

   /**
    * @return {[type]} [description]
    */
   this.addMonitor = function () {
      multimonModel.addMonitor(this.onStatusChanged, this.onRegionUpdated);
   };

   this.keepInMultimon = function () {
      multimonModel.usingMultimon = true;
      multimonModel.updateSettings();
      multimonModel.primaryMonitor.enterFullscreen();
      this.onEnterMultimon();
   };

   /**
    * Don't allow to close dialog by esc since this dialog can be triggered
    *    by it.
    */
   this.onPrimaryMonitorQuit = function (cancelAsDefault) {
      if (!!_this2.quitConfirmDialog) {
         return;
      }
      $timeout(function () {
         var setting = {
            data: {
               title: _('MM_QUIT_MULTIMON_T'),
               message: _('MM_QUIT_MULTIMON_M'),
               buttonLabelConfirm: _('YES'),
               buttonLabelCancel: _('CANCEL')
            },
            showClose: false,
            closeByEscape: false,
            closeByDocument: false,
            controller: ['$scope', function ($scope) {
               $scope.confirm = function () {
                  _this2.switchToSingleMonitor();
                  if (!_this2.quitConfirmDialog) {
                     return;
                  }
                  _this2.quitConfirmDialog.close();
                  _this2.quitConfirmDialog = null;
               };
               $scope.close = function () {
                  _this2.keepInMultimon();
                  if (!_this2.quitConfirmDialog) {
                     return;
                  }
                  _this2.quitConfirmDialog.close();
                  _this2.quitConfirmDialog = null;
               };
            }]
         };
         if (cancelAsDefault) {
            _this2.quitConfirmDialog = dialogService.confirmWithCancelAsDefault(setting);
         } else {
            _this2.quitConfirmDialog = dialogService.confirm(setting);
         }
      });
   };

   /**
    * @private
    * @return {[type]} [description]
    */
   this.enterMultimonMode = function () {
      var key = void 0,
          sizeFactor = void 0,
          alreadyEnter = false;

      multimonModel.usingMultimon = true;
      _jscdkLogger2.default.log("enter multimon mode");
      multimonModel.primaryMonitor.enable(multimonModel.wmksSession, function () {
         var screenBase = void 0,
             screenModels = void 0;

         multimonModel.monitorSettings[0] = multimonModel.primaryMonitor.getSetting();
         normalizationService.setRawSetting('0', multimonModel.monitorSettings[0]);
         if (!alreadyEnter && normalizationService.isScaleMismatched()) {
            $timeout(function () {
               dialogService.error({
                  data: {
                     title: _('WARNING'),
                     errorMessage: _('MM_MOUSE_MISMATCH_WARN_M')
                  }
               });
            });
         }
         alreadyEnter = true;
         normalizationService.calculate();
         multimonModel.monitorSettings = normalizationService.getNormalizedSettings();
         multimonModel.updateSettings();
         screenBase = {
            x: multimonModel.monitorSettings.baseX,
            y: multimonModel.monitorSettings.baseY
         };
         screenModels = normalizationService.getNormalizationModel();
         sizeFactor = normalizationService.getSizeFactor(0);
         multimonModel.primaryMonitor.setScreenBase(screenBase);
         multimonModel.primaryMonitor.setScreenModel(screenModels[0]);
         multimonModel.primaryMonitor.onDPISettingChanged(sizeFactor);
         multimonModel.primaryMonitor.initScreen();
         this.onTopologyChanged();
         this.setMonitorBounds();
         this._isDisplaying = true;
         $timeout(function () {
            this.onMultiMonitor();
            this.initImageBuffer();
            this.startSpyCursor();
            for (key in multimonModel.monitors) {
               if (multimonModel.monitors.hasOwnProperty(key) && key !== "0") {
                  sizeFactor = normalizationService.getSizeFactor(key);
                  multimonModel.monitors[key].startDisplay(screenBase, this.onRenderingDone, screenModels[key], sizeFactor);
               }
            }
         }.bind(this));
      }.bind(this), this.onPrimaryMonitorQuit, this.onRenderingDone);
      this.onEnterMultimon();
   };

   this.readyToEnterMultimon = function () {
      var key = void 0,
          isNotEmpty = false;

      for (key in multimonModel.monitors) {
         if (multimonModel.monitors.hasOwnProperty(key) && key !== "0") {
            isNotEmpty = true;
            if (multimonModel.monitors[key].status !== extendedMonitorService.statusMap["readyToDisplay"] && multimonModel.monitors[key].status !== extendedMonitorService.statusMap["working"]) {
               return false;
            }
         }
      }
      return isNotEmpty;
   };

   this.getMonitorInfo = function () {
      var key = void 0,
          monitorInfo = {};

      for (key in multimonModel.monitors) {
         if (multimonModel.monitors.hasOwnProperty(key)) {
            monitorInfo[key] = {
               settings: multimonModel.monitorSettings[key],
               ready: multimonModel.monitors[key].status === extendedMonitorService.statusMap["readyToDisplay"]
            };
         }
      }
      return monitorInfo;
   };

   this.onStatusChanged = function (id, status) {
      switch (status) {
         case extendedMonitorService.statusMap["inited"]:
            multimonModel.monitors[id].updateUnmaxizableRegions(multimonModel.monitorSettings);
            //TODO: if back from fullsreen mode need to do more action here to
            // support hot switch after Q1
            break;
         case extendedMonitorService.statusMap["readyToDisplay"]:
            this.onMonitorChanged(this.getMonitorInfo(), this.readyToEnterMultimon());
            break;
         case extendedMonitorService.statusMap["closed"]:
            this.onRegionUpdated(id, null);
            multimonModel.updateSettings();
            if (multimonModel.usingMultimon) {
               if (multimonModel.monitorCount === 1) {
                  this.switchToSingleMonitor();
               } else {
                  this.onTopologyChanged();
               }
            }
            break;
         case extendedMonitorService.statusMap["confirmedQuit"]:
            this.switchToSingleMonitor();
            break;
      }
   }.bind(this);

   this.onRegionUpdated = function (id, value, stillUpdating) {
      var monitorCount = 0,
          key = void 0,
          monitorSettings = multimonModel.monitorSettings;

      if (!value) {
         delete monitorSettings[id];
         delete multimonModel.monitors[id];
         normalizationService.removeRawSetting(id);
      } else {
         //update/add
         monitorSettings[id] = value;
         normalizationService.setRawSetting(id, value);
      }
      for (key in multimonModel.monitors) {
         if (multimonModel.monitors.hasOwnProperty(key)) {
            monitorCount++;
            if (key !== id.toString()) {
               multimonModel.monitors[key].updateUnmaxizableRegions(monitorSettings);
            }
         }
      }
      multimonModel.monitorCount = monitorCount;
      this.onMonitorChanged(this.getMonitorInfo(), this.readyToEnterMultimon(), stillUpdating);
   }.bind(this);

   this.renderingNext = function () {
      this.renderingIndex++;
      if (this.renderingIndex === Number.MAX_SAFE_INTEGER) {
         this.renderingIndex = 0;
      }
   };

   this._hideDisplay = function () {
      if (this._isDisplaying) {
         Object.entries(multimonModel.monitors).forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                key = _ref2[0],
                item = _ref2[1];

            item.hideDisplay();
         });
         this._isDisplaying = false;
      }
   };

   /**
    * During prepare of renderring, we better hide the screen
    */
   this._showDisplay = function () {
      var prepareTimeEstimation = 500;
      if (!this._isDisplaying) {
         $timeout(function () {
            Object.entries(multimonModel.monitors).forEach(function (_ref3) {
               var _ref4 = _slicedToArray(_ref3, 2),
                   key = _ref4[0],
                   item = _ref4[1];

               item.showDisplay();
            });
         }, prepareTimeEstimation);
         this._isDisplaying = true;
      }
   };

   this.rectStream = {
      appendData: function (data, onDone, onError) {
         var rect = data.data,
             key = 0,
             monitorSettings = multimonModel.monitorSettings,
             dispatchCount = 0,
             i = void 0;

         if (rect.encoding === vncDecoder.encodingTypes["encUpdateCache"]) {
            if (rect.opcode === renderCacheService.cacheOperationType["updateCacheOpInit"]) {
               this._cacheInited = true;
               this._showDisplay();
            }
            if (!this._cacheInited) {
               _jscdkLogger2.default.trace("receive a cache rect during switching");
               this._hideDisplay();
               onDone();
               return;
            }
         }
         rect.frameId = data.frameId;
         this.renderingList[this.renderingIndex] = {};
         this.renderingCallback[this.renderingIndex] = {
            onDone: onDone,
            onError: onError
         };

         if (rect.opcode === renderCacheService.cacheOperationType["updateCacheOpBegin"]) {
            if (this.caches.length !== 0) {
               _jscdkLogger2.default.debug("cache begin from a wrong place");
               onError();
            }
            this.caches[0] = {
               rect: rect,
               renderingIndex: this.renderingIndex
            };
            this.renderingNext();
            return;
         } else if (this.caches.length > 0 && rect.opcode !== renderCacheService.cacheOperationType["updateCacheOpEnd"]) {
            this.caches.push({
               rect: rect,
               renderingIndex: this.renderingIndex
            });
            this.renderingNext();
            return;
         }
         // dispatch to all valid monitors.
         for (key in multimonModel.monitors) {
            if (multimonModel.monitors.hasOwnProperty(key)) {
               if (this.shouldDispatch(rect, key)) {
                  this.renderingList[this.renderingIndex][key] = true;
                  if (rect.opcode === renderCacheService.cacheOperationType["updateCacheOpEnd"]) {
                     if (this.caches.length === 0) {
                        _jscdkLogger2.default.debug("cache end to a wrong place");
                        onError();
                     }
                     for (i = 0; i < this.caches.length; i++) {
                        multimonModel.monitors[key].onDisplayChanged(this.caches[i].rect, this.caches[i].renderingIndex);
                     }
                     this.caches = [];
                  }
                  multimonModel.monitors[key].onDisplayChanged(rect, this.renderingIndex);
                  dispatchCount++;
               }
            }
         }
         if (rect.opcode !== renderCacheService.cacheOperationType["updateCacheOpEnd"] && !rect.skipRelease) {
            vncDecoder.releaseRectData(rect);
         }
         if (dispatchCount === 0) {
            _jscdkLogger2.default.debug("A rectangle is not dispatched to any monitor!");
            onError();
            delete this.renderingList[this.renderingIndex];
            delete this.renderingCallback[this.renderingIndex];
         }
         this.renderingNext();
      }.bind(this)
   };

   this.h264Stream = {
      //TODO: dispach enable H264/disable H264 to show/hide elements
      init: function init(key, onDecodeComplete, onDecodeMP4Error) {
         // do nothing right now.
      },
      appendData: function appendData(key, data, onDecodeComplete, onDecodeMP4Error) {
         // do nothing right now.
      }
   };

   this.reset = function () {
      // do nothing right now.
   };
}

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = multimonModel;
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * multimon-model.js -- multimonModel
 *
 * module to hold all multimon related informations, mainly for sync them before
 * working
 */

function multimonModel(ExtendedMonitor, primaryMonitorService) {
   var idCounter = void 0;

   this.init = function (wmksSession, sessionContainer) {
      this.primaryMonitor = primaryMonitorService;
      idCounter = 1;
      this.monitors = {};
      this.monitors[0] = this.primaryMonitor;
      this.monitorCount = 1; //TODO
      this.monitorSettings = {};
      this.usingMultimon = false;
      this.wmksSession = wmksSession;
      this.sessionContainer = sessionContainer;
   };

   this.clear = function () {
      idCounter = 0;
      this.monitors = {};
      this.monitorCount = 0; //TODO
      this.monitorSettings = {};
      this.usingMultimon = false;
      this.wmksSession = null;
      this.sessionContainer = null;
   };

   this.addMonitor = function (onStatusChanged, onRegionUpdated) {
      var id = idCounter.toString(),
          extendedMonitor = new ExtendedMonitor();

      extendedMonitor.init(id, this.monitorSettings, onStatusChanged, onRegionUpdated);
      this.monitors[id] = extendedMonitor;
      this.monitorCount++;
      idCounter++;
   };

   /**
    * Set the baseX and baseY based on the current settings, which are both
    * defined as -min(.) corresponding to the agent buffer settings.
    *
    * p.s. the agent buffer setting will not contains the positive offset
    * also, so change max(0, -min(.)) to -min(.), and default as 0
    */
   this.updateSettings = function () {
      var minX = NaN,
          minY = NaN;

      this.forEachSettings(function (key, setting) {
         if (isNaN(minX) && isNaN(minY)) {
            minX = setting.x;
            minY = setting.y;
         } else {
            minX = Math.min(minX, setting.x);
            minY = Math.min(minY, setting.y);
         }
      });
      if (isNaN(minX)) {
         minX = 0;
      }
      if (isNaN(minY)) {
         minY = 0;
      }
      this.monitorSettings.baseX = -minX;
      this.monitorSettings.baseY = -minY;
   };

   /**
    * forEachSettings
    * @param  {function} processFunction The function will be called for
    *    each key setting pair
    */
   this.forEachSettings = function (processFunction) {
      var key = void 0;

      for (key in this.monitorSettings) {
         if (this.monitorSettings.hasOwnProperty(key) && _typeof(this.monitorSettings[key]) === 'object') {
            processFunction(key, this.monitorSettings[key]);
         }
      }
   };
}

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = multimonRenderingService;
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * multimon-rendering-service.js -- multimonRenderingService
 *
 * The API service of multimon to pass into the wmks.
 */

function multimonRenderingService(monitorManageService) {
   this.reset = monitorManageService.reset;
   this.onInit = function (type, param, onSuccess, onError) {
      monitorManageService.h264Stream.init(param.streamId, onSuccess, onError);
   };
   this.onData = function (type, param, onSuccess, onError) {
      if (type === "mp4") {
         monitorManageService.h264Stream.appendData(param.streamId, param.data, onSuccess, onError);
      } else {
         this.onRectData = monitorManageService.rectStream.appendData(param, onSuccess, onError);
      }
   };
}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = multimonService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function multimonService(monitorManageService, multimonModel, dialogService, $timeout, _) {
   var _this = this;

   var onQuitUICallback = null;
   this.onTopologyChanged = function () {
      /*if(!settings valid) {
       return;
       }*/
      //TODO, to support ad hoc monitor modify, need to add code here
      _this.sendTopologyRequest();
   };

   this.onQuitMultimon = function () {
      _jscdkLogger2.default.info("quit multimon");
      // clear hint here if PM want to
      _this.uiCallback("onQuitMultimon");
   };

   this.onEnterMultimon = function () {
      _jscdkLogger2.default.info("enter multimon");
      // pop out hint here if PM want to
      _this.closeSidebar();
      _this.uiCallback("onEnterMultimon");
   };

   this.onSingleMonitor = function () {
      _this.handleResize();
      _this.uiCallback("onSingleMonitor");
      if (!!onQuitUICallback) {
         onQuitUICallback();
         onQuitUICallback = null;
      }
   };

   this.onMultiMonitor = function () {
      _this.uiCallback("onMultiMonitor");
   };

   this.onMonitorChanged = function (settings, allReady, stillUpdating) {
      _jscdkLogger2.default.debug("monitor status changed");
      _this.uiCallback("onMonitorChanged", {
         settings: settings,
         allReady: allReady,
         stillUpdating: !!stillUpdating
      });
   };

   this.switchToMultimon = function (wmksSession, sessionContainer, uiCallback, closeSidebar, handleResize, options) {
      if (!!multimonModel.wmksSession) {
         return;
      }
      this.closeSidebar = closeSidebar;
      this.uiCallback = uiCallback;
      this.handleResize = handleResize;
      monitorManageService.switchToMultiMonitor(wmksSession, sessionContainer, this.onQuitMultimon, this.onEnterMultimon, this.onSingleMonitor, this.onMultiMonitor, this.onTopologyChanged, this.onMonitorChanged, options);
      onQuitUICallback = null;
   };

   this.sendTopologyRequest = function () {
      var monitorSettings = multimonModel.monitorSettings,
          topologySettings = [],
          session = multimonModel.wmksSession;

      if (!session) {
         return;
      }

      // we can round the settings here.
      _jscdkLogger2.default.info("set displayer settings to " + JSON.stringify(monitorSettings));

      multimonModel.forEachSettings(function (key, setting) {
         topologySettings.push({
            requestedWidth: setting.width,
            requestedHeight: setting.height,
            left: setting.x,
            top: setting.y
         });
      });
      session.wmksContainer.wmks('updateTopology', topologySettings, true);
   };

   this.switchToSingleMon = function (wmksSession) {
      if (!multimonModel.wmksSession || wmksSession !== multimonModel.wmksSession) {
         return;
      }
      monitorManageService.switchToSingleMonitor();
   };

   this.destroyMultimon = function () {
      if (!multimonModel.wmksSession) {
         return;
      }
      monitorManageService.switchToSingleMonitor();
   };

   this.addMonitor = function (wmksSession, sessionContainer, uiCallback, closeSidebar, handleResize, options) {
      if (!multimonModel.wmksSession) {
         this.switchToMultimon(wmksSession, sessionContainer, uiCallback, closeSidebar, handleResize, options);
      } else if (wmksSession === multimonModel.wmksSession) {
         monitorManageService.addMonitor();
      }
   };

   this.whenNotInMultimon = function (processingFunction) {
      if (!multimonModel.wmksSession) {
         processingFunction();
         return;
      }
      var dialog = dialogService.confirm({
         data: {
            title: _('MM_QUIT_MULTIMON_T'),
            message: _('MM_QUIT_MULTIMON_M')
         },
         controller: ['$scope', function ($scope) {
            $scope.confirm = function () {
               onQuitUICallback = function onQuitUICallback() {
                  $timeout(processingFunction);
               };
               monitorManageService.switchToSingleMonitor();
               dialog.close();
            };
            $scope.close = function () {
               _jscdkLogger2.default.debug("cancel action to continue use multimon");
               dialog.close();
            };
         }]
      });
   };

   /**
    * Return the multimon using session
    * @return {string} return null if no session is using multimon
    */
   this.getMultimonSession = function () {
      if (!multimonModel.usingMultimon) {
         return null;
      }
      return multimonModel.wmksSession;
   };

   /**
    * Enter the multimon mode
    */
   this.enterMultimonMode = function () {
      if (!multimonModel.usingMultimon) {
         monitorManageService.enterMultimonMode();
      }
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * multimon-service.js -- multimonService
 *
 * The top level service of multimon which provide 2 APIs:
 *  - addMonitor
 *  - switchToSingleMon
 */

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = primaryMonitorService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function primaryMonitorService($, $window, $timeout, fullscreenService, wmksBaseService, vncDecoder, normalizationService) {
   this.enabled = false;
   this.primaryCanvas = null;
   this.canvasContent = null;
   this.offset = null;
   this.conflictEventTime = 0;
   this.browserSizeFactor = 1;
   /**
    * @private
    * A number indicate the button status, and 0 represent no
    * button is being pressed.
    */
   this.buttonStatus = 0;

   /**
    * factor might be dpi_b or dpi_a*dpi_b
    * @param  {[type]} factor [description]
    * @return {[type]}        [description]
    */
   this.onDPISettingChanged = function (factor) {
      this.browserSizeFactor = factor;
      if (this.primaryCanvas.width !== screen.width * this.browserSizeFactor || this.primaryCanvas.height !== screen.height * this.browserSizeFactor) {
         this.primaryCanvas.width = screen.width * this.browserSizeFactor;
         this.primaryCanvas.height = screen.height * this.browserSizeFactor;
         vncDecoder.onDPIChanged(this.primaryCanvas);
      }
   };

   /**
    * @private
    * @param  {[type]} wmksSession [description]
    * @return {[type]}             [description]
    */
   this.createPrimaryCanvas = function (wmksSession) {
      var primaryCanvas = void 0,
          canvasContainner = void 0;

      canvasContainner = document.getElementById("canvas-container");
      primaryCanvas = document.createElement('canvas');
      primaryCanvas.id = 'primary-monitor';
      primaryCanvas.width = screen.width * this.browserSizeFactor;
      primaryCanvas.height = screen.height * this.browserSizeFactor;
      primaryCanvas.style.width = screen.width + "px";
      primaryCanvas.style.height = screen.height + "px";
      primaryCanvas.style.zIndex = 8;
      canvasContainner.appendChild(primaryCanvas);
      primaryCanvas.oncontextmenu = function (e) {
         e.preventDefault();
      };
      /**
       * Detect on document instead of canvas to resolve drag outside the
       * browser issue for mousemove and mouseup;
       * Since only bind part of event on to document looks wired, bound all
       * onto it, and disable the default wmks handling to avoid bugs caused
       * by conflicts.
       */
      this.wmksSession = wmksSession;
      $(document).on("mousemove", this.onMouseMove);
      $(document).on("mousedown", this.onMouseDown);
      $(document).on("mouseup", this.onMouseUp);
      $(document).on("mousewheel", this.onMouseWheel);
      $(canvasContainner).on("keyup", this.onKeyUp);
      $(canvasContainner).on("keydown", this.onKeyDown);
      $(canvasContainner).on("keypress", this.onKeyPress);
      $(window).on("blur", this.onBlur);
      this.primaryCanvas = primaryCanvas;
      this.buttonStatus = 0;
      vncDecoder.setCanvas(primaryCanvas);
   };

   /**
    * @private
    * @param  {object} event
    */
   this.isPrimaryCanvasEvent = function (event) {
      var evt = event || window.event;
      var element = evt.target || evt.srcElement;
      // Allow drag through the sidebar or panels.
      if (this.buttonStatus !== 0) {
         return true;
      } else {
         return element === this.primaryCanvas;
      }
   };

   /**
    * @private
    * @param  {object} event
    */
   this.onBlur = function (event) {
      _jscdkLogger2.default.debug("focus leave primary monitor");
      this.buttonStatus = 0;
      this.wmksSession.wmksContainer.wmks("onBlur");
      $(document).trigger("primarymonitoruse");
   }.bind(this);

   /**
    * @private
    * @param  {object} event
    */
   this.onMouseMove = function (event) {
      var position = void 0;

      if (this.isPrimaryCanvasEvent()) {
         position = wmksBaseService.getEventPosition(event, this.offset);
         this.wmksSession.wmksContainer.wmks('sendMouseMoveMessage', position);
      }
      $(document).trigger("primarymonitoruse");
   }.bind(this);

   /**
    * @private
    * @param  {object} event
    */
   this.onMouseDown = function (event) {
      var position = void 0;

      if (this.isPrimaryCanvasEvent()) {
         position = wmksBaseService.getEventPosition(event, this.offset);
         this.wmksSession.wmksContainer.wmks('sendMouseButtonMessage', position, 1, 1 << event.button);
         this.buttonStatus |= 1 << event.button;
      }
      $(document).trigger("primarymonitoruse");
   }.bind(this);

   /**
    * @private
    * @param  {object} event
    */
   this.onMouseUp = function (event) {
      var position = void 0;

      if (this.isPrimaryCanvasEvent()) {
         position = wmksBaseService.getEventPosition(event, this.offset);
         this.wmksSession.wmksContainer.wmks('sendMouseButtonMessage', position, 0, 1 << event.button);
         this.buttonStatus &= ~(1 << event.button);
      }
      $(document).trigger("primarymonitoruse");
   }.bind(this);

   /**
    * @private
    * @param  {object} event
    */
   this.onMouseWheel = function (event) {
      var position = void 0,
          dx = void 0,
          dy = void 0;

      if (this.isPrimaryCanvasEvent()) {
         position = wmksBaseService.getEventPosition(event, this.offset);
         dx = Math.max(Math.min(event.wheelDeltaX, 1), -1);
         dy = Math.max(Math.min(event.wheelDeltaY, 1), -1);
         this.wmksSession.wmksContainer.wmks('sendScrollMessage', position, dx, dy);
      }
      $(document).trigger("primarymonitoruse");
   }.bind(this);

   /**
    * @private
    * @param  {object} event
    */
   this.onKeyUp = function (event) {
      this.onKeyEvent("KeyUp", event);
   }.bind(this);

   /**
    * @private
    * @param  {object} event
    */
   this.onKeyDown = function (event) {
      this.onKeyEvent("KeyDown", event);
   }.bind(this);

   /**
    * @private
    * @param  {object} event
    */
   this.onKeyPress = function (event) {
      this.onKeyEvent("KeyPress", event);
   }.bind(this);

   /**
    * @private
    * @param  {string} type
    * @param  {object} event
    */
   this.onKeyEvent = function (type, event) {
      this.wmksSession.wmksContainer.wmks('sendKeyMessage', {
         type: type,
         event: event
      });
      if (wmksBaseService.shouldPreventDefault(event)) {
         event.preventDefault();
      }
      event.stopPropagation();
      $(document).trigger("primarymonitoruse");
   }.bind(this);

   /**
    * @private
    * Destroy the primary canvas with the mks event for it and reconnect
    * default events back.
    *
    * Add a try catch block since the wmksSession might fail.
    */
   this.destroyPrimaryCanvas = function () {
      var canvasContainner = document.getElementById("canvas-container");
      canvasContainner.removeChild(this.primaryCanvas);
      $(document).off("mousemove", this.onMouseMove);
      $(document).off("mousedown", this.onMouseDown);
      $(document).off("mouseup", this.onMouseUp);
      $(document).off("mousewheel", this.onMouseWheel);
      $(canvasContainner).off("keyup", this.onKeyUp);
      $(canvasContainner).off("keydown", this.onKeyDown);
      $(canvasContainner).off("keypress", this.onKeyPress);
      $(window).off("blur", this.onBlur);
   };

   /**
    * @private
    * @return {[type]} [description]
    */
   this.startRegionDetector = function (onRegionUpdated) {
      var lastRegion = null,
          detectRegionChange = function detectRegionChange(stillUpdate) {
         //TODO, seems the API is not consistent, need to clip in the
         // comming patch
         var currentRegion = {
            x: screen.availLeft,
            y: screen.availTop,
            height: screen.availHeight,
            width: screen.availWidth,
            devicePixelRatio: devicePixelRatio
         };
         if (!lastRegion || JSON.stringify(lastRegion) !== JSON.stringify(currentRegion)) {
            onRegionUpdated(0, currentRegion, stillUpdate);
            lastRegion = currentRegion;
         }
      };
      detectRegionChange(true);
      this.detectTimer = setInterval(detectRegionChange, 1000);
   };
   /**
    * @private
    * @return {[type]} [description]
    */
   this.stopRegionDetector = function () {
      if (!!this.detectTimer) {
         clearInterval(this.detectTimer);
      }
   };

   /**
    * Although very very corner, this function also be implemented to avoid
    * primary monitor move after extended monitor connected for 3+ display case.
    */
   this.updateUnmaxizableRegions = function (allRegions) {
      _jscdkLogger2.default.log("the setting is updated as" + JSON.stringify(allRegions));
   };

   this.onCursorChanged = function (cursorAddress) {
      if (!this.enabled) {
         return;
      }
      this.primaryCanvas.style.cursor = cursorAddress;
   };

   this.onDisplayChanged = function (rect, renderingIndex) {
      if (!this.enabled) {
         return;
      }
      vncDecoder.render(rect, this.offset, function () {
         this.onRenderingDone(0, renderingIndex);
      }.bind(this));
   };

   /**
    * Init the primary monitor
    * @param  {function} onRegionUpdated The callback should be called when
    *    region changed
    */
   this.init = function (onRegionUpdated) {
      this.startRegionDetector(onRegionUpdated);
   };

   this.enterFullscreen = function () {
      fullscreenService.enterFullscreen(document.body);
   };

   this.exitFullscreen = function () {
      fullscreenService.unbindFullScreen();
      fullscreenService.exitFullscreen();
   };

   this.onConflictEvent = function () {
      this.conflictEventTime = Date.now();
   }.bind(this);

   /**
    * Enable primary monitor
    * @param  {object} wmksSession The session that want to use the primary
    *    monitor
    * @param  {function} onDone The callback after the enable done.
    * @param  {object} screenBase The object that include property x and y for
    *     the screen base offset.
    */
   this.enable = function (wmksSession, onDone, onQuit, onRenderingDone) {
      if (!!this.enabled) {
         return;
      }
      this.stopRegionDetector();
      this.createPrimaryCanvas(wmksSession);

      fullscreenService.onExitFullscreen(function () {
         var mayHasConflict = void 0,
             conflictTime = 100,
             //use 100ms as a workaround in 17Q1 to wait
         // event take effects
         currentTime = Date.now();

         console.log(currentTime, this.conflictEventTime);
         mayHasConflict = currentTime - this.conflictEventTime < conflictTime;
         onQuit(mayHasConflict);
      }.bind(this));
      fullscreenService.onEnterFullscreen(function () {
         $timeout(onDone);
      });
      fullscreenService.bindFullScreen();
      this.enterFullscreen();
      this.canvasContent = this.primaryCanvas.getContext('2d');
      this.enabled = true;
      $(window).on("fileDownloaded", this.onConflictEvent);
      this.onRenderingDone = onRenderingDone;
   };

   /**
    * Disable primary monitor
    */
   this.disable = function () {
      if (!this.enabled) {
         return;
      }
      this.exitFullscreen();
      this.offset = null;
      this.stopRegionDetector();
      this.destroyPrimaryCanvas();
      this.primaryCanvas = null;
      this.canvasContent = null;
      this.enabled = false;
      $(window).off("fileDownloaded", this.onConflictEvent);
   };

   /**
    * return the monitor setting
    */
   this.getSetting = function () {
      return wmksBaseService.getScreenSetting();
   };

   /**
    * set the offset
    * @param {object} screenBase The base offset in the co-ordination
    */
   this.setScreenBase = function (screenBase) {
      this.offset = screenBase;
   };

   this.setScreenModel = function (model) {
      normalizationService.setScreenModel(model);
   };

   this.initScreen = function () {
      vncDecoder.initScreen();
   };

   this.showDisplay = function () {
      this.primaryCanvas.style.display = "";
   };

   this.hideDisplay = function () {
      this.primaryCanvas.style.display = "none";
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * primary-monitor-service.js -- primaryMonitorService
 *
 * service to control the primary monitor.
 * will write data into the model
 *
 *
 * in the detect mode, dispatch all events to other windows using model
 */

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = multimonSettingWindowController;

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * multimon-setting-window-controller.js -- multimonSettingWindowController
 *
 * Module to implement modal dialogs for the Blast UI using Angular JS.
 * The funciton of this window is still not reviewed thus not finalized, so
 *    refactory will not be done for now.
 */

function multimonSettingWindowController($scope, $rootScope, $timeout, wmksService, userGlobalPref, ngDialog, _) {
   $scope.addButtonEnabled = false;
   $scope.allReady = false;
   $scope.hasConflictedDetector = false;

   $scope.startConfiguring = false;
   $scope.hasTooLargeMonitor = false;
   $scope.verticalMonitorNumber = 0;
   $scope.maxMonitorNumber = 2;
   /**
    * Helper function to check whether rectangles coincide
    * @param  {object} rectA
    * @param  {object} rectB
    * @return {boolean}
    */
   this.rectanglesCoincide = function (rectA, rectB) {
      return rectA.x === rectB.x && rectA.y === rectB.y && rectA.width === rectB.width && rectA.height === rectB.height;
   };

   /**
    * Helper function to check whether non-trivial rectangles has non-zero
    *    shared area
    * It's written in the less effective but more readable way
    * @param  {object} rectA
    * @param  {object} rectB
    * @return {boolean}
    */
   this.rectanglesShareArea = function (rectA, rectB) {
      var minAx = rectA.x,
          minAy = rectA.y,
          maxAx = rectA.x + rectA.width,
          maxAy = rectA.y + rectA.height,
          minBx = rectB.x,
          minBy = rectB.y,
          maxBx = rectB.x + rectB.width,
          maxBy = rectB.y + rectB.height,
          aLeftOfB = maxAx <= minBx,
          aRightOfB = minAx >= maxBx,
          aAboveB = minAy >= maxBy,
          aBelowB = maxAy <= minBy;

      return !(aLeftOfB || aRightOfB || aAboveB || aBelowB) || this.rectanglesCoincide(rectA, rectB);
   };

   /**
    * Helper function to check whether targetKey is conflict with others,
    *    and always return false for key "0"
    * @param {string} targetKey The key we check for
    * @param {object} content Contains all the items
    * @return {boolean} This will return result
    */
   this.hasConflict = function (targetKey, content) {
      var key = void 0,
          targetRect = content[targetKey].settings,
          comparedRect = void 0;

      if (targetKey === "0") {
         return false;
      }
      for (key in content) {
         if (content.hasOwnProperty(key) && targetKey !== key) {
            comparedRect = content[key].settings;
            if (this.rectanglesShareArea(targetRect, comparedRect)) {
               return true;
            }
         }
      }
      return false;
   };

   /**
    * Helper function to derive the settings suitable to be previewed
    * @param {object} content The content to be previewed
    * @return {object} This returns a object containing all adjusted rect
    *    and requested canvas size
    */
   this.getPreviewSettings = function (content, maxWidth, maxHeight) {
      var key = void 0,
          baseOffset = void 0,
          currentRect = void 0,
          scale = void 0,
          visibleScaleFactor = void 0,
          canvasSize = void 0,
          setting = void 0,
          overallWidth = void 0,
          overallHeight = void 0,
          scaleFactor = 0.85,
          rects = {},
          overallRect = null;

      for (key in content) {
         if (content.hasOwnProperty(key)) {
            setting = content[key].settings;
            currentRect = {
               minX: setting.x,
               minY: setting.y,
               maxX: setting.x + setting.width,
               maxY: setting.y + setting.height
            };
            if (!overallRect) {
               overallRect = currentRect;
            } else {
               overallRect.minX = Math.min(overallRect.minX, currentRect.minX);
               overallRect.minY = Math.min(overallRect.minY, currentRect.minY);
               overallRect.maxX = Math.max(overallRect.maxX, currentRect.maxX);
               overallRect.maxY = Math.max(overallRect.maxY, currentRect.maxY);
            }
         }
      }

      overallWidth = overallRect.maxX - overallRect.minX;
      overallHeight = overallRect.maxY - overallRect.minY;
      scale = Math.min(maxWidth / overallWidth, maxHeight / overallHeight);
      visibleScaleFactor = scale * scaleFactor;
      canvasSize = {
         width: Math.floor(scale * overallWidth),
         height: Math.floor(scale * overallHeight)
      };
      baseOffset = {
         x: (1 - scaleFactor) * 0.5 * overallWidth * scale,
         y: (1 - scaleFactor) * 0.5 * overallHeight * scale
      };

      for (key in content) {
         if (content.hasOwnProperty(key)) {
            setting = content[key].settings;
            rects[key] = {
               x: Math.round((setting.x - overallRect.minX) * visibleScaleFactor + baseOffset.x),
               y: Math.round((setting.y - overallRect.minY) * visibleScaleFactor + baseOffset.y),
               width: Math.round(setting.width * visibleScaleFactor),
               height: Math.round(setting.height * visibleScaleFactor)
            };
            rects[key].ready = content[key].ready;
            rects[key].conflicted = this.hasConflict(key, content);
         }
      }

      return {
         rects: rects,
         canvasOffset: {
            x: Math.floor(maxWidth - canvasSize.width) / 2,
            y: Math.floor(maxHeight - canvasSize.height) / 2
         }
      };
   };

   /**
    * Helper function to check whether value in (min, max)
    * @param {number} value
    * @param {number} min
    * @param {number} max
    * @return {boolean}
    */
   this.InRange = function (value, min, max) {
      return min < value && value < max;
   };

   /**
    * Helper function to check whether non-trivial rectangles has adjacent
    * Edge. It's written in the less effective but more readable way
    *
    * Since In Q1 we have other functions to implement use a tricky tolerentY
    *    to cope with the problem that browser can't return real monitor
    *    resolution since the up and down system bar area is not allow to
    *    be used by browser, it will make the condition losser than it should
    *    be, but the condition-difference is very trivial and demage
    *    acceptable, and this is disucssed with Jack and get agreement for Q1.
    *    And we should change this after Q1 by adjust workflow if PM is ok
    *    with the drawback of that "good" design which will make the screen
    *    blink once before seeing error message.
    *
    * @param  {object} rectA
    * @param  {object} rectB
    * @return {boolean}
    */
   this.rectanglesAdjacent = function (rectA, rectB) {
      var tolerentY = 100,
          // TODO: remove this after 17Q1 release
      minAx = rectA.x,
          minAy = rectA.y,
          maxAx = rectA.x + rectA.width,
          maxAy = rectA.y + rectA.height,
          minBx = rectB.x,
          minBy = rectB.y,
          maxBx = rectB.x + rectB.width,
          maxBy = rectB.y + rectB.height,
          minAxInBx = this.InRange(minAx, minBx, maxBx),
          maxAxInBx = this.InRange(maxAx, minBx, maxBx),
          minAyInBy = this.InRange(minAy, minBy, maxBy),
          maxAyInBy = this.InRange(maxAy, minBy, maxBy),
          minBxInAx = this.InRange(minBx, minAx, maxAx),
          maxBxInAx = this.InRange(maxBx, minAx, maxAx),
          minByInAy = this.InRange(minBy, minAy, maxAy),
          maxByInAy = this.InRange(maxBy, minAy, maxAy),
          someAxInBx = minAxInBx || maxAxInBx,
          someAyInBy = minAyInBy || maxAyInBy,
          someBxInAx = minBxInAx || maxBxInAx,
          someByInAy = minByInAy || maxByInAy,
          axEqualBx = minAx === minBx && maxAx === maxBx,
          ayEqualBy = minAy === minBy && maxAy === maxBy,
          xShareRange = someAxInBx || someBxInAx || axEqualBx,
          yShareRange = someAyInBy || someByInAy || ayEqualBy,
          aLeftOfB = maxAx === minBx,
          aRightOfB = minAx === maxBx,
          aBelowB = maxBy <= minAy && minAy < maxBy + tolerentY,
          aAboveB = minBy - tolerentY < maxAy && maxAy <= minBy;

      return aLeftOfB && yShareRange || aRightOfB && yShareRange || aAboveB && xShareRange || aBelowB && xShareRange;
   };

   /**
    * slow but easily readable way to detect non adjacent rect
    * don't reuse key to make code more readable
    */
   this.hasNonAdjacentRect = function (content) {
      var k1 = void 0,
          k2 = void 0,
          rect1 = void 0,
          rect2 = void 0,
          hasAdjacent = void 0;

      for (k1 in content) {
         if (content.hasOwnProperty(k1)) {
            rect1 = content[k1].settings;
            hasAdjacent = false;
            for (k2 in content) {
               if (content.hasOwnProperty(k2) && k1 !== k2) {
                  rect2 = content[k2].settings;
                  if (!!rect2 && this.rectanglesAdjacent(rect1, rect2)) {
                     hasAdjacent = true;
                     break;
                  }
               }
            }
            if (!hasAdjacent) {
               return true;
            }
         }
      }
      return false;
   };

   /**
    * Return whether a monitor is abnormal large
    *
    * The max supported resolution is 3840*2160 as in the document:
    * https://www.vmware.com/pdf/horizon-view/horizon-client-windows-44-document.pdf
    * "With the VMware Blast display protocol or the PCoIP display protocol, a
    * remote desktop screen resolution of 4K (3840 x 2160) is supported."
    * Although it's for windows client, the limitation is on the agent side, so
    * commen for all Clients.
    */
   this.isTooLargeMonitor = function (rect, factor) {
      var maxWidth = 3840,
          maxHeight = 2160;

      if (!rect || rect.devicePixelRatio === undefined) {
         return false;
      }

      return rect.width * factor * rect.devicePixelRatio > maxWidth || rect.height * factor * rect.devicePixelRatio > maxHeight;
   };

   /**
    * Detect whether has abnormal large monitor caused by agent status
    */
   this.checkTooLargeMonitor = function (content) {
      var agentScale = wmksService.getCurrentSessionDPI();
      if (agentScale === 1) {
         return false;
      }
      var devideFactor = userGlobalPref.getPrefData().enableDPISync !== 'true' ? devicePixelRatio : 1;
      var factor = agentScale / devideFactor;

      for (var key in content) {
         if (content.hasOwnProperty(key)) {
            if (this.isTooLargeMonitor(content[key].settings, factor)) {
               return true;
            }
         }
      }
      return false;
   };

   /**
    * display the monitor status and position as rect for user to preview
    * @param {object} content The previewed content, it contains all
    * @param {boolean} stillUpdating Whether the update is not finished
    * monitor status and position info
    */
   $scope.updatePreview = function (content, stillUpdating) {
      var key = void 0,
          previewSettings = void 0,
          offset = void 0,
          rects = void 0,
          rect = void 0,
          previewCanvas = document.getElementById("topology-preview-canvas"),
          previewContext = void 0,
          rectNumber = 0;

      if (!previewCanvas || typeof previewCanvas.getContext !== "function") {
         return;
      }
      previewContext = previewCanvas.getContext("2d");
      $scope.hasNonAdjacentMonitors = this.hasNonAdjacentRect(content);
      $scope.hasTooLargeMonitor = this.checkTooLargeMonitor(content);
      previewSettings = this.getPreviewSettings(content, previewCanvas.width, previewCanvas.height);
      rects = previewSettings.rects;

      offset = previewSettings.canvasOffset;
      previewContext.beginPath();
      previewContext.rect(0, 0, previewCanvas.width, previewCanvas.height);
      previewContext.fillStyle = "#cccccc";
      previewContext.fill();
      $scope.hasConflictedDetector = false;
      $scope.verticalMonitorNumber = 0;
      for (key in rects) {
         if (rects.hasOwnProperty(key)) {
            rect = rects[key];
            rectNumber++;
            if (rect.height > rect.width) {
               $scope.verticalMonitorNumber++;
            }
            //TODO: need PM's input for UX details
            if (!rect.conflicted) {
               previewContext.beginPath();
               previewContext.rect(offset.x + rect.x, offset.y + rect.y, rect.width, rect.height);
               if (key === "0" || rect.ready) {
                  previewContext.fillStyle = "#77FF77";
               } else {
                  previewContext.fillStyle = "#777777";
               }
               previewContext.fill();
               previewContext.lineWidth = 2;
               previewContext.strokeStyle = 'black';
               previewContext.stroke();
            } else {
               $scope.hasConflictedDetector = true;
            }
         }
      }
      $scope.startConfiguring = rectNumber > 1;
      if (!stillUpdating) {
         $scope.addButtonEnabled = rectNumber < $scope.maxMonitorNumber;
      }
   }.bind(this);

   $scope.addMonitor = function () {
      _appblastUtil2.default.LOGGER.log("call addMonitor");
      var uiCallback = function uiCallback(type, data) {
         $timeout(function () {
            switch (type) {
               case "onMonitorChanged":
                  $scope.allReady = data.allReady;
                  $scope.updatePreview(data.settings, data.stillUpdating);
                  break;
               case "onMultiMonitor":
                  // to fix bug 1852282
                  wmksService.disconnectEventConnections();
                  break;
               case "onEnterMultimon":
                  $rootScope.setMultimonStarted(true);
                  break;
               case "onSingleMonitor":
                  // to fix bug 1852282
                  wmksService.recoveryEventConnections();
                  break;
               case "onQuitMultimon":
                  $rootScope.setMultimonStarted(false);
                  break;
               default:
                  _appblastUtil2.default.LOGGER.log("unknown message from multimon");
            }
         });
      };
      $timeout(function () {
         // disable before real number calculated to avoid user click too
         // quickly
         $scope.addButtonEnabled = false;
         $scope.startConfiguring = true;
         wmksService.addMonitor(uiCallback, function () {
            $rootScope.collapseSidebar();
         });
      });
   };

   /**
    * In Q1, we use the dialog to show 2 vertial display message since user
    *    is doing valid operations but the result is not a valid horizon
    *    multimon setting.
    * p.s. dialog service is suggested to procide identical API with options as
    *    dialogService.error(contentKey, optimalOptions);
    */
   $scope.showErrorMessage = function (contentKey, options) {
      options = options || {};
      ngDialog.open({
         name: "SessionOpsError", // dialog name
         templateUrl: _dialog_service_error2.default, // dialog template
         showClose: false, // do not show the default close button
         className: "session-ops-dialog", // css class to apply
         data: {
            errorMessage: _(contentKey, options.massageParam)
         }, // data object for $scope.ngDialogData
         closeByEscape: true, // allow escape to close window
         closeByDocument: true // allow clicking on background to
         // close window
      });
   };

   $scope.startMultimon = function () {
      _appblastUtil2.default.LOGGER.log("start multimon");
      $scope.closeThisDialog();
      wmksService.enterMultimon();
   };

   $scope.multimonCancelClicked = function () {
      _appblastUtil2.default.LOGGER.log("close multimon");
      $scope.closeThisDialog();
      wmksService.quitMultimon();
   };

   $scope.multimonOkClicked = function () {
      if (!($scope.startConfiguring && !$scope.hasConflictedDetector && $scope.allReady)) {
         return;
      }

      if ($scope.verticalMonitorNumber > 2) {
         $scope.showErrorMessage("MM_MAX_2_VERTICAL");
      } else if ($scope.hasNonAdjacentMonitors) {
         $scope.showErrorMessage("MM_NONADJACENT_MONITOR");
      } else if ($scope.hasTooLargeMonitor) {
         $scope.showErrorMessage("MM_HAS_TOO_LARGE_MONITOR");
      } else {
         $scope.startMultimon();
      }
   };

   /**
    * When this window is renderred show the preview right away, and the
    *    initial x,y doesn't matters, any data can derive the same UI, so set
    *    to 0 here.
    */
   $scope.initPreview = function () {
      var initialContent = {
         "0": {
            "settings": {
               "x": 0,
               "y": 0,
               "width": screen.availWidth,
               "height": screen.availHeight,
               "devicePixelRatio": devicePixelRatio
            },
            "ready": false
         }
      };
      $scope.updatePreview(initialContent);
   };

   $scope.$watch('$viewContentLoaded', function () {
      $timeout(function () {
         $scope.initPreview();
      });
   });
}

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = reAuthChangePasswordCtrl;
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

function reAuthChangePasswordCtrl($scope, $rootScope, $timeout, connectionServerModel, jscdkDesktopInvoker) {
    $scope.renderData = function (data) {
        if (!!data && !!data.content) {
            if (!!data.content.username) {
                $scope.username = data.content.username;
            }
            if (!!data.content.oldpassword) {
                $scope.credential.oldpassword = data.content.oldpassword;
            }
            // Set error message.
            if (!!data.content.error) {
                $scope.error = data.content.error;
            }
        }
    };

    // Initialize ChangePasswordCtrl controller.
    $scope.init = function (actionData) {
        $scope.loadingAllow = true;
        var data = actionData ? actionData : $scope.ngDialogData.actionData;

        // Name of the controller.
        $scope.name = 'WindowsPasswordExpired';
        // Set host address.
        $scope.host = connectionServerModel.host;
        // Error message.
        $scope.error = '';
        // User credentials.
        $scope.credential = {
            oldpassword: '',
            newpassword: '',
            newpasswordRepeat: ''
        };
        $scope.ajaxBusy = false;
        $scope.renderData(data);
    };

    $scope.changePassword = function (form) {
        if (form.$valid && !$scope.ajaxBusy) {
            jscdkDesktopInvoker.changePassword($scope.credential.oldpassword, $scope.credential.newpassword, $scope.credential.newpasswordRepeat);
            $scope.ajaxBusy = true;
            $scope.loadingAllow = true;
        }
    };

    $scope.cancel = function () {
        $scope.loadingAllow = false;
        if ($scope.ajaxBusy) {
            jscdkDesktopInvoker.cancelCurrentRequest({
                name: 'WindowsPasswordExpired',
                content: {
                    oldpassword: $scope.credential.oldpassword,
                    error: $scope.error
                }
            });
            $scope.ajaxBusy = false;
        } else {
            $rootScope.reAuthDialog.close();
            $rootScope.reAuthDialog = null;
        }
    };

    $scope.keyPress = function (event, form) {
        if (!!event && event.keyCode === 13) {
            // Press enter key.
            $scope.changePassword(form);
        }
    };

    $rootScope.$on('reAuthWindowsPasswordExpired', function (e, data) {
        $timeout(function () {
            $scope.init(data);
        });
    });

    $timeout(function () {
        $scope.init();
    });
}

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

exports.default = reAuthCtrl;

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

var _jscdkBrokerError = __webpack_require__(15);

var _jscdkBrokerError2 = _interopRequireDefault(_jscdkBrokerError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function reAuthCtrl($scope, $rootScope, $timeout, connectionServerModel, jscdkDesktopInvoker, viewClientModel, usernameUtil, entitledItemsService, ngDialog) {
   // Case insensitive string compare.
   var ignoreCaseEquals = function ignoreCaseEquals(str1, str2) {
      if (!str1 || !str2) {
         return false;
      }

      return str1.toLowerCase() === str2.toLowerCase();
   };

   var renderData = function renderData(data) {
      var domain = void 0,
          i = void 0;
      if (!!data && !!data.content) {
         // Initialize credential data binding model.
         $scope.credential.username = data.content.username;
         // Set available domains.
         $scope.domains = data.content.domains;

         // Set current domain.
         if (!!$scope.domains && $scope.domains.length > 0) {
            if (!!data.content.domainName) {
               domain = data.content.domainName;
            }

            for (i = 0; i < $scope.domains.length; i++) {
               if (ignoreCaseEquals($scope.domains[i], domain)) {
                  break;
               }
            }
            if (i >= $scope.domains.length) {
               i = 0;
            }

            $scope.credential.domain = $scope.domains[i];
         }
         // Set error message.
         if (!!data.content.error) {
            $scope.error = data.content.error;
         }
      }
   };

   // Initialize LoginCtrl controller.
   $scope.init = function (actionData) {
      $scope.loadingAllow = true;
      $rootScope.reWindowsPasswordExpired = false;
      var data = actionData ? actionData : $scope.ngDialogData.actionData;
      //check platform to use native select.
      if (viewClientModel.mIsAndroid || viewClientModel.mIsIEMobile || viewClientModel.mIsIOS) {
         $scope.isPhone = true;
      } else {
         $scope.isPhone = false;
      }
      // Error message.
      $scope.error = '';
      // User credentials.
      $scope.credential = {
         username: connectionServerModel.username,
         password: '',
         domain: ''
      };
      // User name input editability.
      $scope.userNameReadOnly = true;
      // Domain select disable
      $scope.domainReadOnly = true;

      if (viewClientModel.clientHideDomainList) {
         $("#domain-button").addClass('ui-hide');
      }

      renderData(data);
      $scope.ajaxBusy = false;
   };

   $scope.loginCallback = function (response, onDone) {
      var MAX_ERROR = "Maximum login attempts exceeded.";
      $scope.ajaxBusy = false;
      if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) === 'object' && !response.success) {
         if (response.error && response.error.errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_AUTHENTICATION_FAILED && response.error.userMsg.indexOf(MAX_ERROR) > -1) {
            $scope.maxLogin = ngDialog.open({
               name: "LoginError",
               templateUrl: _dialog_service_error2.default,
               showClose: false,
               className: "session-ops-dialog",
               data: {
                  errorMessage: response.error.userMsg
               }
            });
            if (!!$scope.maxLogin) {
               $scope.maxLogin.closePromise.then(function () {
                  // take it back to the login page.
                  _appblastUtil2.default.UTIL.returnToLauncher();
               });
            }
         } else if (response.error && response.error.errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_ALREADY_AUTHENTICATED) {
            // already authenticated close dialog
            if (!!$rootScope.reAuthDialog) {
               $rootScope.reAuthDialog.close();
               $rootScope.reAuthDialog = null;
            }
            //launch app
            if (!!onDone) {
               onDone();
            }
         }
      }
   };

   // Login method.
   $scope.login = function (form) {
      var domain = void 0;

      if (form.$valid) {
         if (usernameUtil.domainInUsername($scope.credential.username)) {
            domain = usernameUtil.getDomain($scope.credential.username);
         } else {
            domain = $scope.credential.domain;
         }

         entitledItemsService.submitWindowsPasswordWithCallback($scope.credential.username, $scope.credential.password, domain, true, $scope.loginCallback);
         $scope.loadingAllow = true;
         $scope.ajaxBusy = true;
         $scope.error = '';
      }
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      // wirte in datas that needed when back to login page
      var backContent = {
         username: $scope.credential.username,
         domains: $scope.domains,
         domainName: $scope.credential.domain
      };

      backContent.usernameReadOnly = 'yes';
      backContent.domainReadOnly = 'yes';
      // cancel current request
      if ($scope.ajaxBusy) {
         jscdkDesktopInvoker.cancelCurrentRequest({
            name: 'WindowsPassword',
            content: backContent
         });
      } else {
         $rootScope.reAuthDialog.close();
         $rootScope.reAuthDialog = null;
      }
   };

   $scope.keyPress = function (event, form) {
      if (!!event && event.keyCode === 13) {
         // Press enter key.
         $scope.login(form);
      }
   };

   $rootScope.$on('changeWindowsPassword', function (e, data) {
      $timeout(function () {
         $scope.init(data);
      });
   });

   $timeout(function () {
      $scope.init();
   });
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = unityService;

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _signal = __webpack_require__(16);

var _signal2 = _interopRequireDefault(_signal);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function unityService($window, wmksService, Unity, wmksServiceEventHandler) {
   var init = void 0,
       unityService = {},
       unityMgrMap = {},
       unityFeatures = Unity.SHOW_FLOATING_LANGUAGE_BAR,


   /**
    * Private functions for handling unity notification.
    */
   handleWindowAdded = null,
       handleWindowRemove = null,
       handleTitleChanged = null,
       handleAttrChanged = null,
       handleTypeChanged = null,
       handleIconChanged = null,
       handleActiveChanged = null,
       handleCapsChanged = null,
       handleReadyChanged = null,
       handleVisibilityChanged = null,


   /**
    * Private functions for initializing and handling app event.
    */
   initEventsListener = null,
       removeEventsListener = null,


   /**
    * Handle notification from wmksSession
    */
   onWmksSessionConnecting = null,
       onWmksSessionConnected = null,
       onWmksSessionDisconnected = null,
       onWmksSessionRemoved = null,


   // The help function to retrieve data for a specified windowId.
   getIconDataHelper = null,


   // The help function to update the empty status for an app session.
   updateEmptySession = null,
       destroyUnityMgr = null;

   /**
    * init
    *
    * subscribe to wmksService events
    */
   init = function init() {
      _signal2.default.makeObservable(unityService);
      unityService.addSignal('windowAdded');
      unityService.addSignal('windowRemoved');
      unityService.addSignal('titleChanged');
      unityService.addSignal('iconChanged');
      unityService.addSignal('attrChanged');
      unityService.addSignal('appAttrChanged');
      unityService.addSignal('typeChanged');
      unityService.addSignal('unityReady');
      unityService.addSignal('unityPaused');
      unityService.addSignal('unityDestroyed');
      unityService.addSignal('visibleChanged');

      wmksServiceEventHandler.addEventListener('sessionConnecting', onWmksSessionConnecting);
      wmksServiceEventHandler.addEventListener('sessionConnected', onWmksSessionConnected);
      wmksServiceEventHandler.addEventListener('sessionDisconnected', onWmksSessionDisconnected);
      wmksServiceEventHandler.addEventListener('sessionRemoved', onWmksSessionRemoved);
      wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.UNITY_SERVICE);
   };

   /**
    * destroyUnityMgr
    *
    * Reset the internal status of wmksService.
    *
    * @param wmksKey the wmksSession identifier.
    */
   destroyUnityMgr = function destroyUnityMgr(wmksKey) {
      var unityMgr = unityMgrMap[wmksKey];
      if (!unityMgr) {
         return;
      }
      removeEventsListener(wmksKey);
      delete unityMgrMap[wmksKey];
      unityMgr = null;
      unityService.emit('unityDestroyed', wmksKey);
   };

   /**
    * onWmksSessionConnecting
    *
    * If this is an app session, create an UnityMgr instance.
    * Otherwise, do nothing.
    *
    * @params wmksKey               the key to identify this unique
    *    wmksSession.
    * @params isApplicationSession  if this is an application session.
    * @params vdpService            vdpService associated with
    *    wmksSession.
    */
   onWmksSessionConnecting = function onWmksSessionConnecting(wmksKey, isApplicationSession, vdpService, mainChannel) {
      var unityMgr = void 0;

      if (!isApplicationSession) {
         return;
      }

      unityMgr = new Unity.Mgr(vdpService, mainChannel);

      unityMgrMap[wmksKey] = unityMgr;
      initEventsListener(wmksKey);
      unityMgr.onVisibilityChanged(false);
   };

   /**
    * onWmksSessionConnected
    *
    * On WMKS connection, notify listeners if unity is not yet ready (off
    * or paused).
    *
    * @params wmksKey               the key to identify this unique
    *    wmksSession.
    */
   onWmksSessionConnected = function onWmksSessionConnected(wmksKey) {
      var unityMgr = unityMgrMap[wmksKey];

      if (unityMgr && (!unityMgr.isOn || unityMgr.paused)) {
         unityService.emit('unityPaused', wmksKey);
      }
   };

   /**
    * onWmksSessionDisconnected
    *
    * Cleanup the specific wmksSession.
    *
    * @params wmksKey the key to identify this unique wmksSession.
    */
   onWmksSessionDisconnected = function onWmksSessionDisconnected(wmksKey) {
      destroyUnityMgr(wmksKey);
   };

   /**
    * onWmksSessionRemoved
    *
    * Respond to a session removal by cleaning up the associated unityMgr.
    *
    * @params wmksKey: the key to identify this unique wmksSession
    */
   onWmksSessionRemoved = function onWmksSessionRemoved(wmksKey) {
      destroyUnityMgr(wmksKey);
   };

   /**
    * handleWindowAdded
    *
    * Return a closure that roxy windowAdded event from unityMgr to its
    * consumer.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onWindowAdded.
    */
   handleWindowAdded = function handleWindowAdded(wmksKey) {
      return function (windowId, windowPath, execPath) {
         _appblastUtil2.default.LOGGER.info('Window added with id ' + windowId + ', windowPath ' + windowPath + ', and execPath ' + execPath);
         updateEmptySession(wmksKey, true);

         unityService.emit('windowAdded', wmksKey, windowId, windowPath, execPath);
      };
   };

   /**
    * handleWindowRemove
    *
    * Return a closure that proxy windowRemove event from unityMgr to its
    * consumer.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onWindowRemoved.
    */
   handleWindowRemove = function handleWindowRemove(wmksKey) {
      return function (windowId) {
         _appblastUtil2.default.LOGGER.info('Window removed with id ' + windowId);
         updateEmptySession(wmksKey, false);

         unityService.emit('windowRemoved', wmksKey, windowId);
      };
   };

   /**
    * handleTitleChanged
    *
    * Return a closure that proxy titleChanged event from unityMgr to its
    * consumer.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onTitleChanged.
    */
   handleTitleChanged = function handleTitleChanged(wmksKey) {
      return function (windowId, windowTitle) {
         _appblastUtil2.default.LOGGER.info('Window with id ' + windowId + ' now has title ' + windowTitle);

         unityService.emit('titleChanged', wmksKey, windowId, windowTitle);
      };
   };

   /**
    * handleAttrChanged
    *
    * Return a closure that proxy attrChanged event from unityMgr to its
    * consumer.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onAttrChanged.
    */
   handleAttrChanged = function handleAttrChanged(wmksKey) {
      return function (windowId, type, value) {
         _appblastUtil2.default.LOGGER.info('Window with id ' + windowId + ' has attribute ' + type + ' change to value ' + value);

         unityService.emit('attrChanged', wmksKey, windowId, type, value);
      };
   };

   /**
    * handleTypeChanged
    *
    * Return a closure that proxy typeChanged event from unityMgr to its
    * consumer.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onTypeChanged.
    */
   handleTypeChanged = function handleTypeChanged(wmksKey) {
      return function (windowId, type) {
         _appblastUtil2.default.LOGGER.info('Window with id ' + windowId + ' now is of type ' + type);

         unityService.emit('typeChanged', wmksKey, windowId, type);
      };
   };

   /**
    * handleIconChanged
    *
    * Return a closure that call getIconDataHelper to get proper icon.
    * Send proper notification to its consumer.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onIconChanged.
    */
   handleIconChanged = function handleIconChanged(wmksKey) {
      return function (windowId) {
         getIconDataHelper(wmksKey, windowId, function (data) {
            var iconSrc = !!data ? data : _appblastUtil2.default.CONST.ICONS.SMALL_DEFAULT_ICON;
            unityService.emit('iconChanged', wmksKey, windowId, iconSrc);
         });
      };
   };

   /**
    * getIconDataHelper
    *
    * Send request of getting proper icon information to unityMgr.
    * We will try 32*32 at first and then fallback to 16*16.
    * And call onDone callback if callback is set by user.
    *
    * @param wmksKey     unique identifier of wmksSession.
    * @param windowId    window id of unity window.
    * @param onDone      callback called when requesting is finished.
    */
   getIconDataHelper = function getIconDataHelper(wmksKey, windowId, onDone) {
      var iconSizeSets = [32, 16],
          iconSrc = "",
          iconSize = void 0,
          _getIconData = void 0,
          unityMgr = unityMgrMap[wmksKey];

      _appblastUtil2.default.LOGGER.info('Window with id ' + windowId + ' has a new icon available.');

      _getIconData = function getIconData() {
         if (iconSizeSets.length > 0) {
            iconSize = iconSizeSets.shift();
            unityMgr.getIconData(windowId, iconSize, function (bgra) {
               _appblastUtil2.default.LOGGER.info('Retrieved ' + iconSize + ' icon with length: ' + bgra.length + ' for window ' + windowId);
               iconSrc = 'data:image/png;base64,' + $window.btoa(String.fromCharCode.apply(null, bgra));
               if (onDone) {
                  onDone(iconSrc);
               }
            }, function (error) {
               _appblastUtil2.default.LOGGER.info('Failed to retrieve icon data for window ' + windowId + ' width ' + iconSize + ' with error: ' + error);
               _getIconData();
            });
         } else {
            if (onDone) {
               onDone(iconSrc);
            }
         }
      };

      _getIconData();
   };

   /**
    * updateEmptySession
    *
    * If an app session empty status is changed, we will notify
    * wmksService to update it.
    *
    * @param wmksKey the wmksSession identifier.
    * @param isAdd flags whether we are invoking this on an add or remove
    *    operation
    */
   updateEmptySession = function updateEmptySession(wmksKey, isAdd) {
      var unityMgr = unityMgrMap[wmksKey];
      /* istanbul ignore if */
      if (!unityMgr) {
         return;
      }

      if (unityMgr.windowCount === 1 && isAdd) {
         // Unity window number is changed from 0 to 1. It is not empty.
         wmksService.updateEmptySession(wmksKey, false);
      } else if (unityMgr.windowCount === 0 && !isAdd) {
         // Unity window number is changed from 1 to 0. It is empty now.
         wmksService.updateEmptySession(wmksKey, true);
      }
   };

   /**
    * handleActiveChanged
    *
    * None.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onActiveChanged.
    */
   handleActiveChanged = function handleActiveChanged(wmksKey) {
      return function (active) {
         _appblastUtil2.default.LOGGER.info('Unity is now ' + (active ? 'on' : 'off'));
      };
   };

   /**
    * handleCapsChanged
    *
    * None.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onCapsChanged.
    */
   handleCapsChanged = function handleCapsChanged(wmksKey) {
      return function (caps) {
         _appblastUtil2.default.LOGGER.info('Server advertised capabilities: ' + caps);
      };
   };

   /**
    * handleReadyChanged
    *
    * None.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onReadyChanged.
    */
   handleReadyChanged = function handleReadyChanged(wmksKey) {
      return function (ready) {
         var unityMgr = unityMgrMap[wmksKey];
         _appblastUtil2.default.LOGGER.info('Server is ' + (ready ? 'ready' : 'not ready') + ' for unity.');
         if (ready) {
            if (unityMgr.isOn) {
               if (unityMgr.paused) {
                  _appblastUtil2.default.LOGGER.info('Unpausing Unity now.');
                  unityService.emit('unityReady', wmksKey);
                  unityMgr.unpause();
               } else {
                  _appblastUtil2.default.LOGGER.info('Ignoring duplicate "Unity ready" notification.');
               }
            } else {
               _appblastUtil2.default.LOGGER.info('Entering Unity now.');
               unityService.emit('unityReady', wmksKey);
               unityMgr.on(unityFeatures);
            }
         } else {
            if (unityMgr.isOn) {
               if (unityMgr.paused) {
                  _appblastUtil2.default.LOGGER.info('Ignoring duplicate "Unity not ready" notification.');
               } else {
                  _appblastUtil2.default.LOGGER.info('Pausing Unity now.');
                  unityMgr.pause();
                  unityService.emit('unityPaused', wmksKey);
               }
            } else {
               /*
                * Clients that do actual seamless windows need this notification
                * but we don't.
                */
               _appblastUtil2.default.LOGGER.info('Ignoring "Unity not ready" when not in Unity mode.');
               // Unity not ready, show login desktop directly.
               unityMgr.onVisibilityChanged(true);
            }
         }
      };
   };

   /**
    * handleVisibilityChanged
    *
    * None.
    *
    * @param wmksKey the wmksSession identifier.
    * @return a function to handle onReadyChanged.
    */
   handleVisibilityChanged = function handleVisibilityChanged(wmksKey) {
      return function (isShow) {
         unityService.emit('visibleChanged', wmksKey, isShow);
      };
   };

   /**
    * initEventsListener
    *
    * Bind callback to all the unityMgr events.
    *
    * @param wmksKey the wmksSession identifier.
    */
   initEventsListener = function initEventsListener(wmksKey) {
      var unityMgr = unityMgrMap[wmksKey];
      /* istanbul ignore if */
      if (!unityMgr) {
         return;
      }
      unityMgr.onAdd = handleWindowAdded(wmksKey);
      unityMgr.onRemove = handleWindowRemove(wmksKey);
      unityMgr.onTitleChanged = handleTitleChanged(wmksKey);
      unityMgr.onAttrChanged = handleAttrChanged(wmksKey);
      unityMgr.onTypeChanged = handleTypeChanged(wmksKey);
      unityMgr.onIconChanged = handleIconChanged(wmksKey);
      unityMgr.onActiveChanged = handleActiveChanged(wmksKey);
      unityMgr.onCapsChanged = handleCapsChanged(wmksKey);
      unityMgr.onReadyChanged = handleReadyChanged(wmksKey);
      unityMgr.onVisibilityChanged = handleVisibilityChanged(wmksKey);
   };

   /**
    * removeEventsListener
    *
    * Clear callbacks of Unity instance.
    *
    * @param wmksKey the wmksSession identifier.
    */
   removeEventsListener = function removeEventsListener(wmksKey) {
      var unityMgr = unityMgrMap[wmksKey];
      /* istanbul ignore if */
      if (!unityMgr) {
         return;
      }
      unityMgr.onAdd = null;
      unityMgr.onRemove = null;
      unityMgr.onTitleChanged = null;
      unityMgr.onAttrChanged = null;
      unityMgr.onTypeChanged = null;
      unityMgr.onIconChanged = null;
      unityMgr.onActiveChanged = null;
      unityMgr.onCapsChanged = null;
      unityMgr.onReadyChanged = null;
      unityMgr.onVisibilityChanged = null;
   };

   var helper = {
      /**
       * unityService.closeWindow
       *
       * Send closing window command to unityMgr.
       *
       * @param wmksKey  the wmksSession identifier.
       * @param windowId window to be closed.
       */
      closeWindow: function closeWindow(wmksKey, windowId) {
         this.closeWindows(wmksKey, [windowId]);
      },

      /**
       * unityService.closeWindows
       *
       * Send close commands to unityMgr for a list of windowIds. Windows
       * are closed in reverse order of input, so if the windows failed
       * to close, they are stacked on screen in the order of input
       * (window 1 on top of window 2, etc).
       *
       * @param wmksKey  the wmksSession identifier.
       * @param windowIds an array of windowIds to be closed.
       */
      closeWindows: function closeWindows(wmksKey, windowIds) {
         var unityMgr = unityMgrMap[wmksKey],
             i = void 0;

         if (!unityMgr) {
            return;
         }

         // Bring windows to top first,  so they can open "save content"
         // dialogs
         unityMgr.setTopWindows(windowIds);
         // close in opposite order to setTopWindows
         for (i = windowIds.length - 1; i >= 0; i--) {
            unityMgr.closeWindow(windowIds[i]);
         }
      },

      /**
       * unityService.toggleWindow
       *
       * Toggle unity window's status
       *
       * @param wmksKey the wmksSession identifier.
       * @param windowId windowId to be toggled.
       */
      toggleWindow: function toggleWindow(wmksKey, windowId) {
         var unityMgr = unityMgrMap[wmksKey],
             unityWindow = void 0;

         if (!unityMgr) {
            return;
         }

         unityWindow = unityMgr.windows[windowId];
         if (!!unityWindow) {
            if (unityWindow.attributes[Unity.WINDOW_ATTR_MINIMIZED]) {
               _appblastUtil2.default.LOGGER.info('Restoring minimized Unity window: ' + windowId);
               unityMgr.unminimize(windowId);
            } else {
               _appblastUtil2.default.LOGGER.info('Activating Unity window: ' + windowId);
               unityMgr.setTopWindows([windowId]);
            }
         }
      },

      /**
       * unityService.getAppAttr
       *
       * Send get app name and icons command to unityMgr.
       * Once we get the information, we will fire appAttrChanged event
       * to its consumer.
       *
       * @param wmksKey    the wmksSession identifier.
       * @param windowPath window path for identifying application.
       * @param execPath   exec path for identifying application.
       * @param windowId   window id for the first unity window of this
       *    application.
       */
      getAppAttr: function getAppAttr(wmksKey, windowPath, execPath, windowId) {
         var unityMgr = unityMgrMap[wmksKey];
         if (!unityMgr) {
            return;
         }

         unityMgr.getExecInfoHash(execPath, function (execInfoHash) {
            _appblastUtil2.default.LOGGER.info('ExecPath ' + execPath + ' has exec info hash: ' + execInfoHash);
         }, function (error) {
            _appblastUtil2.default.LOGGER.info('Failed to retrieve exec info hash for ExecPath ' + execPath + ' with error: ' + error);
         });

         unityMgr.getBinaryInfo(windowPath, function (name, images) {
            var iconSrc = "",
                iconIndex = -1;
            _appblastUtil2.default.LOGGER.info('Window path ' + windowPath + ' has name "' + name + '" and ' + images.length + ' icons.');
            if (images.length > 0) {
               iconIndex = _appblastUtil2.default.UTIL.getAppIconIndex(images, 48);
               if (iconIndex !== -1) {
                  iconSrc = _appblastUtil2.default.UTIL.bgraMapToPNG(images[iconIndex].bgra, images[iconIndex].width, images[iconIndex].height);
               }
            }

            if (iconSrc !== "") {
               unityService.emit('appAttrChanged', wmksKey, windowPath, execPath, name, iconSrc);
            } else {
               /*
                * On failure to retrieve or convert the icon to PNG, we use a
                * fallback RPC to try and retrieve it from the running instance.
                * The fallback is susceptible to a race condition if the server
                * application is changing icons when the RPC arrives, giving us
                * an outdated icon. However we should only need to send the RPC
                * rarely, and the race condition should be even rarer, so we can
                * reasonably ignore this case.
                *
                * PNG conversion will fail if canvas is not supported (IE9), so
                * the RPC will let us continue to support IE9.
                */
               getIconDataHelper(wmksKey, windowId, function (data) {
                  var iconSrc = !!data ? data : _appblastUtil2.default.CONST.ICONS.BIG_DEFAULT_ICON;
                  unityService.emit('appAttrChanged', wmksKey, windowPath, execPath, name, iconSrc);
               });
            }
         }, function (error) {
            _appblastUtil2.default.LOGGER.info('Failed to retrieve binary info for window path ' + windowPath + ' with error: ' + error);
         });
      },

      isUnityRunning: function isUnityRunning(key) {
         var unityMgr = unityMgrMap[key];
         if (unityMgr) {
            return unityMgr.isOn && !unityMgr.paused;
         } else {
            return false;
         }
      }
   };

   _jquery2.default.extend(unityService, helper);

   init();
   return unityService;
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * unity-service.js --
 *
 * Module for wrapping unity to angular factory service. Unity Service is a
 * singleton service.
 *
 * Todo: we will go to manage several unityMgr instances in this factory
 * service.
 *
 */

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = routeConfig;

var _desktop = __webpack_require__(260);

var _desktop2 = _interopRequireDefault(_desktop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function routeConfig($routeProvider) {
   $routeProvider.when('/desktop', {
      templateUrl: _desktop2.default,
      reloadOnSearch: false,
      controller: 'DesktopCtrl'
   });
} /*********************************************************
   * Copyright (C) 2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = AudioCapture;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AudioCapture() {
   this.clipBuffer = new this.ClipBuffer(AudioCapture.clipTarget, AudioCapture.clipBufferLen);
   this.previousSampleRate = null;
   this.inited = false;
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/
/**
 * @fileoverview audiocapture.js -- AudioCapture
 * Class to handle audio capturing
 *
 * Support but not recommand to change the default sample rate.
 */

;

// It's one of the API required length, so need to clip before
// compress+translate
AudioCapture.bufferLen = 512;
// Required length at service side
AudioCapture.clipTarget = 160;
// A length enough for buffering the data
AudioCapture.clipBufferLen = 1024;
// browser API sample rate
AudioCapture.machineSampleRate = 44100;

AudioCapture.statusEnum = {
   Uninited: 'Uninited',
   Inited: 'Inited',
   Working: 'Working'
};

/**
 * Get what status this audio src is in, cuurently only Uinited is detected,
 * but keep the API as it for future extension and debugging
 * @return {string} This returns one of the AudioCapture.statusEnum of
 *    'Uninited', 'Inited', 'Working'
 */
AudioCapture.prototype.getStatus = function () {
   var status = void 0;
   if (!this.inited) {
      status = AudioCapture.statusEnum['Uninited'];
   } else {
      if (this.paused) {
         status = AudioCapture.statusEnum['Inited'];
      } else {
         status = AudioCapture.statusEnum['Working'];
      }
   }
   return status;
};

/**
 * Init capturing audio by binding events to the passed in stream, and for each
 * data segment, call the callback with it. Similar to mAudInput.Open for
 * native clients, use prefs and timer, but here also pass in stream and
 * callback which is done differently for native clients. and the caller should
 * be similar to VCamServer::InitAudioInDev, to reset sync timer if needed. It
 * looks like "open" but the real open didn't happen here, it's acctually init
 * the opened source, we do not open it here to avoid anoying hint diaglog
 * which is forced by some browsers like firefox.
 *
 * @param  {object} syncTimer The timer object user to sync audio and video
 * @param  {function} callback The function for dealing with each frame
 */
AudioCapture.prototype.init = function (audioParam, syncTimer, callback) {
   var sampleRate = audioParam.sampleRate;

   if (this.inited) {
      _logservice2.default.logService.error('this audio capture has already been inited, init fail');
      return;
   }
   if (typeof callback !== 'function') {
      return;
   }

   if (!sampleRate || sampleRate <= 0) {
      sampleRate = 8000;
   }
   if (sampleRate >= AudioCapture.machineSampleRate) {
      _logservice2.default.logService.devError('do not support sample rate greater than 44100');
   }

   if (this.previousSampleRate !== sampleRate) {
      if (this.hasOwnProperty('resampler') && !!this.resampler) {
         delete this.resampler;
      }
      this.resampler = new this.Resampler(AudioCapture.machineSampleRate, sampleRate, AudioCapture.bufferLen);
   }

   this.callback = callback;
   this.paused = true;
   this.syncTimer = syncTimer;

   this.inited = true;
};

/**
 * Clear the status and release audio capture related resources which make this
 * srouce to start a new srouce for another stream session(start_A and stop_A).
 * But be aware of that, the stream object which will hold the devices will not
 * be release in this level, but in the mediacapture.clear(). and that should
 * only happen when the wmks session don't want RTAV anymore, like when the
 * wmks session is closed.
 */
AudioCapture.prototype.clear = function () {
   if (!this.inited) {
      _logservice2.default.logService.error('this audio capture is not inited, clear fail');
      return;
   }
   if (!this.paused) {
      _logservice2.default.logService.trace('negative: the audio capture is not stopped yet, stop it before clear it.');
      this.stop();
   }
   this.scriptNode = null;
   this.mediaCtx = null;
   this.mediaStreamSource = null;
   // Edge seems not support close method which is defined in html5 standard
   // for now, so we need the check
   if (!!this.audioContext && typeof this.audioContext.close === 'function') {
      this.audioContext.close();
   }
   this.audioContext = null;
   this.clipBuffer.reset();
   this.resampler.reset();
   this.inited = false;
   this.paused = true;
   this.losingDevice = false;
   this.deviceUnpluged = false;
   this.localStream = null;
};

/**
 * Start capturing data with inited param
 * @param  {object} stream The stream object obtained by the getUserMedia
 */
AudioCapture.prototype.start = function (stream) {
   var numChannelsIn = 1,
       numChannelsOut = 1;

   if (!stream) {
      _logservice2.default.logService.error('the audio stream is not valid, start fail');
      return;
   }
   if (!this.inited) {
      _logservice2.default.logService.error('the audio capture is not being inited, start fail');
      return;
   }
   if (!this.paused) {
      _logservice2.default.logService.error('find existing audio capturing session, start fail');
      return;
   }

   this.lastValidTime = -1;
   this.freezeCount = 0;
   this.losingDevice = false;
   this.deviceUnpluged = false;
   this.audioContext = new window.AudioContext();
   this.localStream = stream;
   this.mediaStreamSource = this.audioContext.createMediaStreamSource(stream);
   this.mediaCtx = this.mediaStreamSource.context;
   this.scriptNode = this.mediaCtx.createScriptProcessor(AudioCapture.bufferLen, numChannelsIn, numChannelsOut);
   this.scriptNode.onaudioprocess = function (event) {
      var clip = void 0,
          capturedData = void 0,
          resampledBuff = void 0;
      if (this.paused) {
         return;
      }

      this.updateActiveStatus();
      // Buffer has length specified in _useStream
      capturedData = event.inputBuffer.getChannelData(0);
      resampledBuff = this.resampler.process(capturedData);
      // Add the samples immediately to the Clip, with correct format(float32
      // to uint16)
      this.clipBuffer.add(resampledBuff, this.syncTimer.getTime());
      clip = this.clipBuffer.getClip();
      if (!!clip) {
         // The callback should compress the clip, and send the compressed data
         // in package on VVC.
         this.callback(clip);
      }
   }.bind(this);

   this.mediaStreamSource.connect(this.scriptNode);
   this.scriptNode.connect(this.mediaCtx.destination);
   this.paused = false;
};

/**
 * Stop capturing data, and enter waiting status.
 */
AudioCapture.prototype.stop = function () {
   if (!this.inited) {
      _logservice2.default.logService.error('the audio capture is not being inited, stop fail');
      return;
   }
   if (this.paused) {
      _logservice2.default.logService.error('find no audio capturing session, stop fail');
      return;
   }
   this.mediaStreamSource.disconnect(this.scriptNode);
   this.scriptNode.disconnect(this.mediaCtx.destination);
   //since its in the single thread, set the puase flag here is early enough
   this.paused = true;
   this.losingDevice = false;
   this.deviceUnpluged = false;
};

/**
 * Update the device active status
 */
AudioCapture.prototype.updateActiveStatus = function () {
   var freezeTolerence = AudioCapture.machineSampleRate / AudioCapture.bufferLen;

   if (!!this.localStream.currentTime) {
      if (this.localStream.currentTime === this.lastValidTime) {
         this.freezeCount = this.freezeCount + 1;
         if (!this.losingDevice && this.freezeCount > freezeTolerence) {
            this.losingDevice = true;
            _logservice2.default.logService.trace('negative: seems the audio device becomes invalid, please check');
            _logservice2.default.resourceManager.emitDeviceStatusChanged();
         }
      } else {
         if (this.localStream.currentTime > 0) {
            this.lastValidTime = this.localStream.currentTime;
         }
         this.freezeCount = 0;
         if (this.losingDevice) {
            this.losingDevice = false;
            _logservice2.default.logService.trace('negative: seems the audio device becomes valid again, which means it might unstable');
            _logservice2.default.resourceManager.emitDeviceStatusChanged();
         }
      }
   }

   if (!!this.localStream && typeof this.localStream.active === 'boolean') {
      if (!this.localStream.active && !this.deviceUnpluged) {
         this.deviceUnpluged = true;
         _logservice2.default.logService.trace('negative: seems the audio device is unpluged');
         _logservice2.default.resourceManager.emitDeviceStatusChanged();
      }
   }
};

/**
 * This returns whether the device can provide valid data
 */
AudioCapture.prototype.isActive = function () {
   return !this.losingDevice && !this.deviceUnpluged;
};

/**
 * FIFO clipper buffer
 * @param {number} segmentLength [description]
 * @param {number} buffsize      [description]
 */
AudioCapture.prototype.ClipBuffer = function (segmentLength, buffsize) {
   /**
    * Init the instance
    */
   this.init = function () {
      this.segmentLength = segmentLength;
      this.buffsize = buffsize;
      this.buff = new Uint16Array(this.buffsize);
      this.reset();
   };

   this.reset = function () {
      this.startIndex = 0;
      this.tailIndex = 0;
      this.length = 0;
      this.lastTimeStamp = {
         value: 0,
         index: 0
      };
      this.newTimeStamp = {
         value: 0,
         index: 0
      };
   };

   /**
    * A simple float to short(int16) converting function
    * @param  {number} floatNum A number in the range [-1,1]
    * @return {number} This returns a short number in the range [-32767, 32767]
    */
   this.convertToShort = function (floatNum) {
      var maxShortValue = 32767;
      return Math.round(maxShortValue * floatNum);
   };

   /**
    * Add data to the ClipBuffer with floating number converted to short
    * @param {Array} data
    * @param {number} timeStamp
    */
   this.add = function (data, timeStamp) {
      var i = void 0,
          k = void 0;
      if (data.length > this.buffsize - this.length) {
         return;
      }

      this.lastTimeStamp.value = this.newTimeStamp.value;
      this.lastTimeStamp.index = this.newTimeStamp.index;
      for (i = 0, k = this.tailIndex; i < data.length; i++, k = (k + 1) % this.buffsize) {
         this.buff[k] = this.convertToShort(data[i]);
      }
      this.length += data.length;
      this.tailIndex = (this.tailIndex + data.length) % this.buffsize;
      this.newTimeStamp.value = timeStamp;
      this.newTimeStamp.index = this.tailIndex;
   };

   /**
    * get the extended index to easy the calculation of accurate timestamp
    * @param  {number} srcIndex The original index, which might get extended if
    *    too small
    * @param  {number} minIndex The lower bound of the index
    * @return {number} This returns the extended index which is larger or equal
    *    to minIndex
    */
   this.getExtendedIndex = function (srcIndex, minIndex) {
      if (srcIndex < minIndex) {
         return srcIndex + this.buffsize;
      } else {
         return srcIndex;
      }
   };

   /**
    * Get a object with ArrayBuffer as data and number as timeStamp if possible
    * @return {object|null}
    */
   this.getClip = function () {
      var i = void 0,
          k = void 0,
          resultLength = void 0,
          result = void 0,
          sampleExtenedIndex = void 0,
          newExtenedIndex = void 0,
          lastIndex = void 0,
          addup = void 0,
          timeStamp = void 0;

      if (this.length < this.segmentLength) {
         return null;
      }

      // shift out the data
      resultLength = this.length - this.length % this.segmentLength;
      result = new Uint16Array(resultLength);
      for (i = 0, k = this.startIndex; i < resultLength; i++, k = (k + 1) % this.buffsize) {
         result[i] = this.buff[k];
      }
      this.length -= result.length;
      this.startIndex = (this.startIndex + result.length) % this.buffsize;

      // calculate the corresponding timeStamp with linear assumsion, which
      // should be acurate enough for the currect use case
      lastIndex = this.lastTimeStamp.index;
      sampleExtenedIndex = this.getExtendedIndex(this.startIndex, lastIndex);
      newExtenedIndex = this.getExtendedIndex(this.newTimeStamp.index, lastIndex);
      // approximate increamental time from the 2nd last newTimeStamp, and that
      // is using linear assumsion with 2nd last and last newTimeStamp to get.
      addup = (this.newTimeStamp.value - this.lastTimeStamp.value) / (newExtenedIndex - lastIndex) * (sampleExtenedIndex - lastIndex);
      // add the increamental time to 2nd last newTimeStamp, and get the result
      // timeStamp
      timeStamp = Math.round(this.lastTimeStamp.value + addup);
      return {
         data: result.buffer,
         timeStamp: timeStamp
      };
   };
   this.init();
};

/**
 * Resampler for converting data in high sample rate to lower.
 * @param {number} originalRate The input sample rate
 * @param {number} targetRate   The target sample rate
 * @param {number} inputSize    The input data length
 */
AudioCapture.prototype.Resampler = function (originalRate, targetRate, inputSize) {
   /**
    * Init the instance
    */
   this.init = function () {
      if (originalRate < targetRate) {
         _logservice2.default.logService.devError('resample can only have less samples');
         return;
      }
      this.sampleIndexInc = originalRate / targetRate;
      // Math.ceil(this.sampleIndexInc) * 2 is large enough extra space for
      // the non-processed and being processed data
      this.buffSize = inputSize + Math.ceil(this.sampleIndexInc) * 2;
      this.buff = new Array(this.buffSize);
      this.inputSize = inputSize;
      this.reset();
   };

   this.reset = function () {
      this.startIndex = 0;
      this.tailIndex = 0;
      this.sampleStartIndex = 0;
   };

   /**
    * Insert data in the inner buffer
    * @private
    */
   this.push = function (data) {
      var i = void 0,
          k = void 0;
      if (data.length > this.buffSize - this.length) {
         return false;
      }
      for (i = 0, k = this.tailIndex; i < data.length; i++, k = (k + 1) % this.buffSize) {
         this.buff[k] = data[i];
      }
      this.tailIndex = (this.tailIndex + data.length) % this.buffSize;
      return true;
   };

   /**
    * @return {float} return the resampled value
    */
   this.getResampledData = function (startIndex, endIndex) {
      var i = void 0,
          is = void 0,
          ie = void 0,
          ws = void 0,
          we = void 0,
          sum = void 0;

      // Start index of included data segment(included)
      is = Math.ceil(startIndex);
      // End index of included data segment(not included)
      ie = Math.floor(endIndex);
      // The persentage of sample that should be count in before the
      // included data segment
      ws = is - startIndex;
      // The persentage of sample that should be count in after the included
      // data segment
      we = endIndex - ie;
      // Count in the data before the included data segment
      sum = ws * this.buff[Math.floor(startIndex)];
      // Count in the data after the included data segment
      if (we > 0) {
         sum += we * this.buff[ie];
      }
      // Count in the included data segment
      if (ie < is) {
         ie += this.buffSize;
         for (i = is; i < ie; i++) {
            sum += this.buff[i % this.buffSize];
         }
      } else {
         for (i = is; i < ie; i++) {
            sum += this.buff[i];
         }
      }
      return sum / this.sampleIndexInc;
   };

   /**
    * @param  {number} index
    * @return {boolean} This returns whether the index is in the valid range
    */
   this.isInRange = function (index) {
      if (this.startIndex < this.tailIndex) {
         return index <= this.tailIndex && index >= this.startIndex;
      }
      return index >= this.startIndex || index <= this.tailIndex;
   };

   /**
    * Using reverting check to tell when both input index are valid, whether
    * the range in between is also valid
    * @param  {number}  sampleIndexStart The valid start index of the range
    * @param  {number}  sampleIndexEnd The valid end index of the range
    * @return {Boolean} This returns whether the range in between valid
    *    index contains invalid data
    */
   this.isInCorrectOrder = function (sampleIndexStart, sampleIndexEnd) {
      if (this.startIndex < this.tailIndex) {
         // with normal order of valid data, sample should also be normal
         // order
         return sampleIndexStart < sampleIndexEnd;
      }
      // with revert order of valid data, sample can't across the bind
      return sampleIndexStart > this.tailIndex || sampleIndexEnd < this.startIndex;
   };

   /**
    * Using isInCorrectOrder and isInRange to check whether the sub-range
    * are valid or not.
    * @return {boolean} This returns whether we can access the elements in
    *    the range.
    */
   this.validSubRange = function (sampleIndexStart, sampleIndexEnd) {
      return this.isInRange(sampleIndexStart) && this.isInRange(sampleIndexEnd) && this.isInCorrectOrder(sampleIndexStart, sampleIndexEnd);
   };

   this.deleteUsed = function () {
      this.startIndex = Math.floor(this.sampleStartIndex);
   };

   /**
    * @return {Array} return the resampled array
    */
   this.getResampledArray = function () {
      var sampleIndexStart = this.sampleStartIndex,
          sampleIndexEnd = (sampleIndexStart + this.sampleIndexInc) % this.buffSize,
          i = 0,
          result = [];

      // while needed data are in the buff.
      while (this.validSubRange(sampleIndexStart, sampleIndexEnd)) {
         // get each resampled data
         result[i] = this.getResampledData(sampleIndexStart, sampleIndexEnd);
         // shift indexes accordingly after get the resampled data
         i++;
         sampleIndexStart = sampleIndexEnd;
         sampleIndexEnd = (sampleIndexStart + this.sampleIndexInc) % this.buffSize;
      }
      this.sampleStartIndex = sampleIndexStart;
      this.deleteUsed();
      return result;
   };

   /**
    * Input data and would return the resampled array
    * @param  {Array} data The array of length inputSize and with sample
    *    rate originalRate
    * @return {Array|null} This returns the array of data with sample rate
    *    targetRate
    */
   this.process = function (data) {
      var resampled = void 0;

      if (data.length !== this.inputSize) {
         return null;
      }
      if (!this.push(data)) {
         return null;
      }
      resampled = this.getResampledArray();
      if (!resampled) {
         return null;
      }
      return resampled;
   };

   this.init();
};

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DeviceMessageManager;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DeviceMessageManager(controller) {
   var unprocessedMessageQueues = void 0,
       actionMap = void 0,
       actionIDMap = void 0,
       permissionDialogPending = void 0,
       localMessageController = void 0,
       nextTargetDeviceInfo = void 0,
       actionNames = void 0,
       messageWaitManager = void 0;

   var init = function init(controller, self) {
      unprocessedMessageQueues = {
         audio: [],
         video: [],
         none: []
      };
      nextTargetDeviceInfo = null;
      actionMap = ["None", "Stop"];
      actionIDMap = {
         "Start": -1,
         "None": 0,
         "Stop": 1
      };
      permissionDialogPending = {
         audio: false,
         video: false
      };
      localMessageController = controller;
      localMessageController.deviceMessageManager = self;
      actionNames = {
         "Start": "Start",
         "None": "None",
         "Stop": "Stop"
      };
      messageWaitManager = new _logservice2.default.MessageWaitManager();
   };

   var getFinalAction = function getFinalAction(type) {
      var i = void 0,
          queue = void 0,
          sum = void 0;
      if (unprocessedMessageQueues[type] === undefined || unprocessedMessageQueues[type].length === 0) {
         return actionNames["None"];
      }
      queue = unprocessedMessageQueues[type];
      sum = 0;
      for (i = 0; i < queue.length; i++) {
         sum = sum + queue[i];
         if (sum < 0 || sum > 1) {
            _logservice2.default.logService.error('unexpected agent messages detected while user not accepting permission, ');
            return actionNames["None"];
         }
      }
      return actionMap[sum];
   };

   var clearQueue = function clearQueue(type) {
      _logservice2.default.logService.trace("queue for " + type + " is cleared");
      unprocessedMessageQueues[type] = [];
   };

   var pushUnprocessedMessage = function pushUnprocessedMessage(type, action) {
      _logservice2.default.logService.trace(action + " is added into " + type + " queue");
      unprocessedMessageQueues[type].push(actionIDMap[action]);
   };

   var processMessage = function processMessage(messageType, self) {
      if (!localMessageController) {
         _logservice2.default.logService.devError("uninited controller");
         return;
      }
      messageWaitManager.process(messageType, function () {
         switch (messageType) {
            case 'PMsgStart_A':
               localMessageController.enableAudioIn(function (success) {
                  if (success) {
                     _logservice2.default.logService.debug('audio device successfully enabled');
                  } else {
                     _logservice2.default.logService.debug('audio device fail to be enabled');
                  }
               }, self);
               break;
            case 'PMsgStop_A':
               localMessageController.disableAudioIn();
               _logservice2.default.logService.debug('audio device is disabled');
               break;
            case 'PMsgStart_V':
               localMessageController.enableVideoIn(function (success) {
                  if (success) {
                     _logservice2.default.logService.debug('video device successfully enabled');
                  } else {
                     _logservice2.default.logService.debug('video device fail to be enabled');
                  }
               }, self);
               break;
            case 'PMsgStop_V':
               localMessageController.disableVideoIn();
               _logservice2.default.logService.debug('video device is disabled');
               break;
         }
      });
   };

   var self = {
      /**
       * process the action of in out type
       * @param {string} messageType The message name
       * @param {string} type Of audio or video to indicate which kind of device
       *     we should operate on
       * @param {string} action Of Start or Stop to indicate which kind of action
       *     we should do
       */
      processAction: function processAction(messageType, type, action) {
         if (this.isPermissionPending(type)) {
            pushUnprocessedMessage(type, action);
         } else {
            if (this.isPermissionPending() && action === actionNames["Start"]) {
               _logservice2.default.logService.debug("hold the permission dialog for " + type + " for now for previous dialog still exist");
               nextTargetDeviceInfo = {
                  messageType: messageType,
                  type: type,
                  action: action
               };
            } else {
               processMessage(messageType, this);
            }
         }
      },

      /**
       * should be called when get device related message
       * @param {string} messageType Message name
       * @param {function} callback Optimal The callback should be called with
       *     bool indicate whether success
       */
      onMessage: function onMessage(messageType, callback) {
         var type = void 0,
             action = void 0;
         switch (messageType) {
            case 'PMsgStop_A':
               type = "audio";
               action = actionNames["Stop"];
               break;
            case 'PMsgStart_A':
               type = "audio";
               action = actionNames["Start"];
               break;
            case 'PMsgStop_V':
               type = "video";
               action = actionNames["Stop"];
               break;
            case 'PMsgStart_V':
               type = "video";
               action = actionNames["Start"];
               break;
            default:
               type = "none";
               action = actionNames["None"];
         }

         // start events need callback
         if (typeof callback === "function") {
            localMessageController.processWhenHaveResources(function (canProcess) {
               callback(canProcess);
               if (canProcess) {
                  this.processAction(messageType, type, action);
               } else {
                  _logservice2.default.logService.log("do nothing for " + messageType + " since session is not allow to be processed");
               }
            }.bind(this));
         } else {
            this.processAction(messageType, type, action);
         }
         return true;
      },

      /**
       * function to perform the hold message of another type than current
       * @param {bool} needReinit Whether to reinit the stream
       */
      precessHoldMessage: function precessHoldMessage(needReinit) {
         var pendingDeviceType = void 0,
             pendingMessageType = void 0,
             finalAction = void 0;

         if (!!nextTargetDeviceInfo) {
            /**
             * since agent might send the start stop message pair, client
             * should to cancel them, and dothing for a better user exprience,
             * meanwhile client has to pretent it did those action to agent
             * since RDSH agent has a almost-unfixable bug that always assume
             * client will known the premission right after
             */
            pendingDeviceType = nextTargetDeviceInfo.type;
            pendingMessageType = nextTargetDeviceInfo.messageType;
            finalAction = getFinalAction(pendingDeviceType);
            clearQueue(pendingDeviceType);
            if (finalAction === actionNames["Stop"]) {
               _logservice2.default.logService.debug("previous premission dialog is dismissed, but do nothing for " + pendingDeviceType + ", since we need to start then stop it");
               nextTargetDeviceInfo = null;
               return;
            }
            /**
             * reset the stream status to started status for resolve bug 1750132,
             * since it will make the status of the client to further mismatch
             * from the status in the agent status, so we need to sync them when
             * possible to avoid other regressions caused by the mismatch.
             */
            if (needReinit) {
               _logservice2.default.logService.debug("previous premission dialog just get dismissed but device released, so restart streaming");
               messageWaitManager.process("restartStream", function () {
                  localMessageController.restartStream();
               });
            }
            _logservice2.default.logService.debug("previous premission dialog is dismissed, now pop out another dialog for " + pendingMessageType);
            processMessage(pendingMessageType, this);
            nextTargetDeviceInfo = null;
         }
      },

      /**
       * function should be called when premission is handled
       * @param {string} type Of audio or video indicate which premission is handled
       */
      onPermissionHandled: function onPermissionHandled(type) {
         _logservice2.default.logService.trace('premission dialog is closed');
         if (!permissionDialogPending[type]) {
            _logservice2.default.logService.devError("the inner logic is wrong, the premission dialog seems get disapper");
            return;
         }
         var action = getFinalAction(type);
         clearQueue(type);
         permissionDialogPending[type] = false;
         _logservice2.default.logService.trace('when ' + type + 'dialog get dismissed, the queued action is ' + action);

         // Stop is the only message we need to handle so far
         if (action === actionNames["Stop"]) {
            if (type === 'audio') {
               processMessage('PMsgStop_A');
               this.precessHoldMessage(true);
            } else if (type === 'video') {
               processMessage('PMsgStop_V');
               this.precessHoldMessage(true);
            }
         } else {
            messageWaitManager.process("restartStream", function () {
               localMessageController.restartStream();
            });
            this.precessHoldMessage(false);
         }
         messageWaitManager.process("onPermissionHandled", function () {
            if (!this.isPermissionPending()) {
               localMessageController.onPermissionHandled();
            }
         }.bind(this));
      },

      /**
       * function should be called when premission is asked
       * @param {string} type Of audio or video indicate which premission is asked
       */
      onPermissionAsked: function onPermissionAsked(type) {
         if (permissionDialogPending[type]) {
            _logservice2.default.logService.devError("the inner logic is wrong, the premission dialog seems get duplicated");
            return;
         }
         permissionDialogPending[type] = true;
         _logservice2.default.resourceManager.emitDeviceStatusChanged();
         _logservice2.default.logService.trace('premission dialog poped out');
      },

      /**
       * function to known whether premission is being asked for specified type
       * @param {string} type Of audio or video indicate which premission is asked
       * @return {boolean} This returns whether premission is being asked for
       *     specified type
       */
      isPermissionPending: function isPermissionPending(type) {
         if (!!nextTargetDeviceInfo && nextTargetDeviceInfo.type === type) {
            _logservice2.default.logService.trace("the premission dialog of type " + type + " is hold so treat as pending");
            return true;
         }
         if (type !== undefined) {
            return permissionDialogPending[type];
         }
         return permissionDialogPending['audio'] || permissionDialogPending['video'] || !!nextTargetDeviceInfo;
      }
   };
   init(controller, self);
   return self;
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/
/**
 * @fileoverview devicemessagemanager.js -- DeviceMessageManager
 * Class contains the logic for device related messages, mainly works
 * as a status converter since we need to mock response to avoid pending
 * agent response for too long when agent ask whether has devices.
 */

/**
 * Class contains the main logic of logic for device related messages
 * @type {function}
 */

;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var dialogService = function () {
   var uiDialogCallback = void 0;
   return {
      setDialogFunction: function setDialogFunction(dialogFunction) {
         uiDialogCallback = dialogFunction;
      },
      showDialog: function showDialog(info, okCallback, cancelCallback) {
         if (typeof uiDialogCallback !== 'function') {
            _logservice2.default.logService.devError('the uiDialogCallback doesn\'t exist');
            return;
         }
         uiDialogCallback(info, okCallback, cancelCallback);
      }
   };
}(); /*********************************************************
      * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
      *********************************************************/

/**
 * @fileoverview dialogservice.js -- dialogService
 * Service to decouple the dialog implementation from UI layer
 */

exports.default = dialogService;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = FrameRateController;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FrameRateController() {
   this.lastCaptureTime = 0;
   this.targetInterval = 0;
   this.fpsLogTime = 60;
   this.fpsInfo = {
      count: -1,
      startTime: 0
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/
/**
 * @fileoverview frameratecontroller.js -- FrameRateController
 * Class to help calculate the wait time in ms with target fps,
 * when fps is 0, always return the suggested wait time as 0 ms.
 */

;

/**
 * set the fps info for calculating the target interval in ms.
 * @param {number} fps The target frame rate.
 */
FrameRateController.prototype.setFPS = function (fps) {
   // fps lies here
   if (fps < 0) {
      _logservice2.default.logService.devError('fps can never be a negative number');
      return;
   }
   if (fps === 0) {
      this.targetInterval = 0; // no rate limitation
   } else {
      this.targetInterval = 1000 / fps;
   }
   this.lastCaptureTime = 0;
   this.fpsInfo = {
      count: -1,
      startTime: 0
   };
};

/**
 * Get current time in ms
 * @priavte
 */
FrameRateController.prototype.getNow = function () {
   return new Date().getTime();
};

/**
 * Get the suggested wait time to capture the next frame
 * @return {number} This returns the suggested wait time to capture the next frame
 */
FrameRateController.prototype.getWaitTime = function () {
   var passedTime = this.getNow() - this.lastCaptureTime;
   return Math.max(0, this.targetInterval - passedTime);
};

/**
 * Used to calculate the real-time fps, should be called when starting a frame sending
 * Currently It returns nothing and will print a log each %this.fpsLogTime% seconds
 * @param  {number} currentTime The currentTime in ms
 */
FrameRateController.prototype.updateRealFPS = function (currentTime) {
   var difftime = void 0;

   if (this.fpsInfo.count === -1) {
      this.fpsInfo.count = 0;
      this.fpsInfo.startTime = currentTime;
   } else {
      difftime = (currentTime - this.fpsInfo.startTime) / 1000;
      if (this.fpsLogTime > 0 && difftime >= this.fpsLogTime) {
         _logservice2.default.logService.trace("fps = " + (this.fpsInfo.count + 1) / difftime);
         this.fpsInfo.count = 0;
         this.fpsInfo.startTime = currentTime;
      } else {
         this.fpsInfo.count++;
      }
   }
};

/**
 * The function to update the knowledge of when the last frame is captured
 */
FrameRateController.prototype.onFrameCaptured = function () {
   this.lastCaptureTime = this.getNow();
   this.updateRealFPS(this.lastCaptureTime);
};

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = MediaCapture;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MediaCapture() {
   var supportHTML5Audio = void 0,
       MediaStream = void 0;

   window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext;
   navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.mediaDevices.getUserMedia;

   supportHTML5Audio = !!window.AudioContext && !!navigator.getUserMedia;
   if (!supportHTML5Audio) {
      _logservice2.default.logService.error('browser does not support HTML5 media in, creating media source fails');
      return null;
   }
   _logservice2.default.logService.log('browser supports HTML5 media in');
   /**
    * MediaStream is an experimental technology, so add this compatible codes
    * to provide the same API for the new and old browsers
    */
   MediaStream = window.MediaStream || window.webkitMediaStream;
   if (MediaStream !== undefined) {
      if (!MediaStream.prototype.hasOwnProperty('stop')) {
         MediaStream.prototype.stop = function () {
            this.getAudioTracks().forEach(function (track) {
               track.stop();
            });
            this.getVideoTracks().forEach(function (track) {
               track.stop();
            });
         };
      }
   }

   this.syncTimer = new _logservice2.default.SyncTimer();
   this.audioCapture = new _logservice2.default.AudioCapture();
   this.videoCapture = new _logservice2.default.VideoCapture();
   if (!this.audioCapture || !this.videoCapture || !this.syncTimer) {
      _logservice2.default.logService.error('capture instance is not created, creating media source fails');
      return null;
   }
   this.streamStarted = false;
   this.isEnabled = {
      audio: false,
      video: false
   };
   this.resourcesHold = {
      audio: false,
      video: false
   };
   this.localStream = {
      audio: null,
      video: null
   };
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/
/**
 * @fileoverview mediacapture.js -- MediaCapture
 * Class based on AudioCaptuer & VideoCapture to handle media capturing
 * depend on AudioCapture, VideoCapture, and SyncTimer
 *
 * the callback is used to pull the next video frame, while audio need no such
 *    an property since it push the data out.
 *
 * API:
 * No init API, after new or clear, the instance should be in the started
 *    status
 * We need to detect stopstream instead of dealing with that message is caused
 *    by the fact that the agent doesn't implement that message.
 *
 * open: get device
 * close: release device, Close the instance with all hardware resources
 *    released. startStream: get device and ready to capture any data
 *    stopCapturing: reset and return to the original status(started) after
 *    created enable(type): enable the capturing of data of specified type
 *    disable(type): disable the capturing of data of specified type
 */

;

/**
 * Stop both video and audio if possible.
 * @private
 */
MediaCapture.prototype.disableAll = function () {
   if (this.isEnabled.audio) {
      this.disable('audio');
   }
   if (this.isEnabled.video) {
      this.disable('video');
   }
};

/**
 * Close the instance with all hardware resources released.
 * @param  {string} type The type name of device of the request
 */
MediaCapture.prototype.close = function (type) {
   if (!this.resourcesHold[type]) {
      _logservice2.default.logService.debug('no need to close ' + type + ' device');
      this.localStream[type] = null;
      return;
   }
   if (!!this.localStream[type] && typeof this.localStream[type].stop === 'function') {
      this.localStream[type].stop();
      _logservice2.default.logService.log('rtav source is closed, ' + type + ' hardware get released');
   } else {
      _logservice2.default.logService.log('rtav source is closed, but ' + type + ' hardware might fail to be released');
   }
   this.localStream[type] = null;
   this.resourcesHold[type] = false;
};

/**
 * Stop capture audio and video, and release the devices
 * after clear this instance should look like a new object
 */
MediaCapture.prototype.stopCapturing = function () {
   // ensure stop
   if (this.streamStarted) {
      _logservice2.default.logService.debug('negative: there is at least one of stream capture session, so disable them before stopping capture');
      this.disableAll();
   }

   // clear audio/video capture
   this.syncTimer.clear();
   if (this.audioCapture.getStatus() !== _logservice2.default.AudioCapture.statusEnum['Uninited']) {
      this.audioCapture.clear();
   }
   if (this.videoCapture.getStatus() !== _logservice2.default.VideoCapture.statusEnum['Uninited']) {
      this.videoCapture.clear();
   }
   this.streamStarted = false;
   this.isEnabled.audio = false;
   this.isEnabled.video = false;
};

/**
 * Async process to get control of audio & video devices
 * @param {string} type The device tpye name of open request
 * @param {function} openDone The callback with a bool as open succcess or not
 * @param {object} deviceMessageController This param is used to emit
 *    premission dialog related events
 */
MediaCapture.prototype.open = function (type, openDone, deviceMessageController) {
   var deviceRequest = {
      audio: false,
      video: false
   },
       successCallback = void 0,
       errorCallback = void 0;

   successCallback = function (stream) {
      this.localStream[type] = stream;
      this.resourcesHold[type] = true;
      openDone(true);
      deviceMessageController.onPermissionHandled(type);
   }.bind(this);
   errorCallback = function errorCallback(e) {
      _logservice2.default.logService.debug('negative: can\'t get the rtav device, so rtav will not working' + e);
      openDone(false);
      deviceMessageController.onPermissionHandled(type);
   };
   deviceRequest[type] = true;
   if (!this.resourcesHold[type]) {
      navigator.getUserMedia(deviceRequest, successCallback, errorCallback);
      deviceMessageController.onPermissionAsked(type);
   }
};

/**
 * Start capture audio and video
 * This function fit for the message startstream, and will ensure both the
 * audio and video source inited
 * @param  {function} audioCallback The callback funciton used to deal with
 *    cauptured audio
 * @param  {function} videoCallback The callback funciton used to deal with
 *    cauptured video
 */
MediaCapture.prototype.startStream = function (deviceParam, audioCallback, videoCallback) {
   if (this.streamStarted) {
      _logservice2.default.logService.log('the media capture has already being "streamStarted" status, skip start');
      return;
   }
   if (!this.isEnabled.audio && !this.isEnabled.video) {
      _logservice2.default.logService.log('the media capture try to start with none of the video nor audio enabled, please check whether video device exist');
   }

   if (!this.resourcesHold.audio && !this.resourcesHold.video) {
      _logservice2.default.logService.log('no stream hold before trying to start capturing, please check whether video device exist ');
   }

   _logservice2.default.logService.debug('starting the source stream');

   this.syncTimer.reset();
   this.audioCapture.init(deviceParam.audio, this.syncTimer, function (sample) {
      audioCallback(sample);
   }.bind(this));
   this.videoCapture.init(deviceParam.video, this.syncTimer, function (sample) {
      videoCallback(sample);
   }.bind(this));

   // we need to start start the audio/video capturing if that is enabled
   if (this.isEnabled.audio) {
      this.audioCapture.start(this.localStream['audio']);
   }
   if (this.isEnabled.video) {
      this.videoCapture.start(this.localStream['video']);
   }
   this.streamStarted = true;
};

/**
 * Disable the capturing of data of specified type
 * @param  {string} type This param is one of the 'audio' and 'video'.
 */
MediaCapture.prototype.disable = function (type) {
   if (!this.resourcesHold[type]) {
      _logservice2.default.logService.log('call disable when no device hold, video device might be missing');
   }
   if (this.streamStarted) {
      if (type === 'audio') {
         this.audioCapture.stop();
      } else if (type === 'video') {
         this.videoCapture.stop();
      }
      this.close(type);
   }
   this.isEnabled[type] = false;
   /**
    * this code is to detect stopStream
    * The agent implement the stopstream this way, so client need to do work
    * accordingly. if detected, the source will stop working but that can be
    * recoveried by enable audio/video and startstream again.
    */
   if (!this.isEnabled.audio && !this.isEnabled.video) {
      this.streamStarted = false;
      this.stopCapturing();
   }
};

/**
 * Enable the capturing of data of specified type
 * @param  {string} type This param is one of the 'audio' and 'video'.
 * @param  {function} openDone This param is the callback will be called with a
 *    bool to indicate success or not
 * @param  {object} deviceMessageController This param is used to emit
 *    premission dialog related events
 */
MediaCapture.prototype.enable = function (type, openDone, deviceMessageController) {
   if (this.isEnabled[type]) {
      _logservice2.default.logService.error('try to re-enable a media source of type ' + type);
      openDone(false);
      return;
   }

   this.open(type, function (success) {
      if (type === 'video' && !success) {
         openDone(true, true);
      } else {
         openDone(success);
      }
      if (success) {
         if (this.streamStarted) {
            if (type === 'audio') {
               this.audioCapture.start(this.localStream[type]);
            } else if (type === 'video') {
               this.videoCapture.start(this.localStream[type]);
            }
         }
         this.isEnabled[type] = true;
      }
   }.bind(this), deviceMessageController);
};

/**
 * return whether the device of given type is active
 * @param  {string} type This param is one of the 'audio' and 'video'.
 */
MediaCapture.prototype.isActive = function (type) {
   if (type === 'audio') {
      return this.audioCapture.isActive();
   } else if (type === 'video') {
      return this.videoCapture.isActive();
   }
   return false;
};

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = MediaEncoder;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MediaEncoder() {
   // private Class
   var LimitedSet = void 0,

   // priavte properties:
   workers = void 0,
       headers = void 0,
       callbacks = void 0,
       resourcesCount = void 0,
       enabled = void 0,
       encodingEnvs = void 0,
       encoderStatus = void 0,
       messageManager = void 0,

   // private functions:
   resetEncoder = void 0,
       initInstance = void 0,
       arrayCopy = void 0,
       setMergedHeader = void 0,
       handleMessage = void 0,
       handleAudioMessage = void 0,
       handleVideoMessage = void 0,
       encode = void 0,
       clearWorker = void 0,
       clear = void 0;

   /**
    * We choose to use an extra bool list instead of the special value in the buffer to mark
    * @private
    */
   LimitedSet = function LimitedSet(capacity) {
      this.buff = new Array(capacity);
      this.occupied = Array.apply(null, Array(capacity)).map(Boolean.prototype.valueOf, false);
      this.insert = function (item) {
         var i = void 0;
         for (i = 0; i < this.occupied.length; i++) {
            if (!this.occupied[i]) {
               this.buff[i] = item;
               this.occupied[i] = true;
               return i;
            }
         }
         return -1;
      };
      // single thread, and inner usage, so skip id tests
      this.fetch = function (id) {
         this.occupied[id] = false;
         return this.buff[id];
      };
   };

   resetEncoder = function resetEncoder() {
      headers = {
         audio: null,
         video: null,
         merged: null
      };
      callbacks = {
         video: null,
         audio: null,
         header: null
      };
      /**
       * number used for PV operation avoid taking too much of resources in the event queue,
       * and the values are get by testing on different machines, the bigger the number
       * the less data is dropped, but the more delay might exist.
       * in the release phase, if this object constains like 1, 1, we can change them into boolean,
       * but better to keep it for now without testing with the finalized codes.
       * @type {object}
       */
      resourcesCount = {
         audio: 1,
         video: 1
      };
      encodingEnvs = {
         audio: new LimitedSet(resourcesCount.audio),
         video: new LimitedSet(resourcesCount.video)
      };
      encoderStatus = {
         audio: {
            beingUsed: false
         },
         video: {
            beingUsed: false
         }
      };
      enabled = false;
   };

   initInstance = function initInstance() {
      try {
         workers = {
            audio: new Worker("./audioworker." + "1" + ".js"),
            video: new Worker("./videoworker." + "1" + ".js")
         };
      } catch (e) {
         workers = {
            audio: null,
            video: null
         };
      }
      workers.audio.onmessage = handleAudioMessage;
      workers.video.onmessage = handleVideoMessage;

      resetEncoder();
   };

   arrayCopy = function arrayCopy(src, srcPtr, dst, dstPtr, length) {
      var srcArray = new Uint8Array(src, srcPtr, length),
          dstArray = new Uint8Array(dst, dstPtr, length);

      dstArray.set(srcArray);
   };

   setMergedHeader = function setMergedHeader() {
      var streamHeaderLength = _logservice2.default.constants.streamHeaderLength,
          videoHeaderLength = headers.video.length + streamHeaderLength,
          audioHeaderLength = headers.audio.length,
          mergedLength = videoHeaderLength + audioHeaderLength,
          mergedHeaderBuffer = new ArrayBuffer(mergedLength);

      arrayCopy(headers.video.buffer, 0, mergedHeaderBuffer, 0, videoHeaderLength);
      arrayCopy(headers.audio.buffer, streamHeaderLength, mergedHeaderBuffer, videoHeaderLength, audioHeaderLength);

      headers.merged = {
         buffer: mergedHeaderBuffer,
         length: mergedLength - streamHeaderLength
      };
   };

   handleMessage = function handleMessage(e, dataType) {
      var message = e.data,
          callback = void 0,
          env = void 0;

      if (!enabled) {
         return;
      }
      switch (message.type) {
         case 'InitDone':
            headers[dataType] = message.data;
            if (typeof callbacks.header !== 'function') {
               _logservice2.default.logService.devError('header callback doesn\'t exist');
               return;
            }
            if (!!headers.video && !!headers.audio) {
               setMergedHeader();
               callbacks.header(headers.merged);
            }
            break;
         case 'Encoded':
            env = encodingEnvs[dataType].fetch(message.envId);
            if (!env || !env.metaData) {
               _logservice2.default.logService.debug('negative: bad env readed, might caused by switching devices to other desktop');
               return;
            }
            callback = callbacks[dataType];
            if (typeof callback !== 'function') {
               _logservice2.default.logService.devError('encoding callback doesn\'t exist');
               return;
            }
            callback(message.data, env.metaData, env.others);
            resourcesCount[dataType]++;
            break;
         case 'Cleared':
            _logservice2.default.logService.log(dataType + ' encoder cleared:' + message.success);
            break;
      }
   };

   handleAudioMessage = function handleAudioMessage(e) {
      handleMessage(e, 'audio');
   };

   handleVideoMessage = function handleVideoMessage(e) {
      handleMessage(e, 'video');
   };

   encode = function encode(sample, type) {
      var dataBuffer = void 0,
          envId = void 0;

      if (!workers[type] || !sample || !sample.data) {
         return;
      }
      if (resourcesCount[type] > 0) {
         resourcesCount[type]--;
         dataBuffer = sample.data;
         envId = encodingEnvs[type].insert({
            others: sample.others,
            metaData: sample.timeStamp
         });
         if (envId < 0) {
            _logservice2.default.logService.devError('when encoding media data, environment object can\'t be saved');
            return;
         }
         workers[type].postMessage({
            type: 'Encode',
            data: dataBuffer,
            envId: envId
         }, [dataBuffer]);
      }
   };

   clearWorker = function clearWorker(type) {
      if (!!workers[type]) {
         workers[type].postMessage({
            type: 'Clear'
         });
      }
   };

   /**
    * This function is to release the resources for encoding.
    */
   clear = function clear() {
      _logservice2.default.logService.debug('clear encoders for none of audio and video is used');
      clearWorker('audio');
      clearWorker('video');
      resetEncoder();
   };

   initInstance();

   return {
      /**
       * Init the encoder using params and register the callbacks to handle header and encoded data
       * now we will provide no default value, so caller must prepare the good init param for initialize
       * @param  {object} audioParam      The param used to init audio encoder
       * @param  {object} videoParam      The param used to init video encoder
       * @param  {function} headerCallback  The callback use to handle inited header
       * @param  {function} audioCallback The callback use to handle encoded audio
       * @param  {function} videoCallback The callback use to handle encoded video
       */
      init: function init(audioParam, videoParam, headerCallback, audioCallback, videoCallback) {
         var videoWorker = workers.video,
             audioWorker = workers.audio;

         if (!videoWorker || !audioWorker || enabled) {
            return;
         }
         callbacks = {
            header: headerCallback,
            audio: audioCallback,
            video: videoCallback
         };
         audioParam.logLevel = _logservice2.default.logService.getLevel();
         videoParam.logLevel = audioParam.logLevel;
         // althought js is non-preemptive, put enabled = true to later place will add complex for UT
         enabled = true;
         audioWorker.postMessage({
            type: 'Init',
            data: audioParam
         });
         videoWorker.postMessage({
            type: 'Init',
            data: videoParam
         });
      },

      clear: clear,

      /**
       * @param  {object} sample {data: {Int16Array}, timeStamp: {number}}
       */
      encodeAudio: function encodeAudio(sample) {
         encode(sample, 'audio');
      },

      /**
       * @param  {object} sample {data: {Uint8Array}, timeStamp: {number}}
       */
      encodeVideo: function encodeVideo(sample) {
         encode(sample, 'video');
      },

      /**
       * When we don't need to use the encoder of type, one should call this function to release resources
       * and also set the media encoder to be ready for re-inited. it's related to stop_A and stop_V message
       * @param  {string} type The encoder type name, should be 'audio' or 'video'
       */
      disable: function disable(type) {
         if (!encoderStatus[type].beingUsed) {
            _logservice2.default.logService.debug('negative: no need to disable a disabled encoder: ' + type);
            return;
         }
         encoderStatus[type].beingUsed = false;
         // release all the resources when both encoder are in use no more.
         if (!encoderStatus['audio'].beingUsed && !encoderStatus['video'].beingUsed) {
            if (!messageManager) {
               _logservice2.default.logService.devError("messageManager don't exist when disable " + type);
               return;
            }
            if (messageManager.isPermissionPending()) {
               _logservice2.default.logService.debug("skip clear encoders since the premission dialog is still pending");
            } else {
               clear();
            }
         }
      },

      /**
       * When we need to use the encoder of type, one should call this function to record the use status and
       * ready to release resources after both encoder are useded no more. it's related to start_A and start_V
       * message.
       * @param  {string} type The encoder type name, should be 'audio' or 'video'
       */
      enable: function enable(type) {
         if (encoderStatus[type].beingUsed) {
            _logservice2.default.logService.error('fail to enable a enabled encoder: ' + type);
            return;
         }
         encoderStatus[type].beingUsed = true;
      },

      /**
       * return whether this encoder is inited
       */
      isInited: function isInited() {
         return enabled;
      },

      /**
       * Get previously generated header from the cache, it can faster the whole process and avoid blink in video
       */
      fetchCachedHeader: function fetchCachedHeader() {
         if (!enabled) {
            _logservice2.default.logService.devError("fail to get cached header for enc is not inited yet");
         }
         if (typeof callbacks.header !== 'function') {
            _logservice2.default.logService.devError("fail to get cached header for callback is not set yet");
         }
         callbacks.header(headers.merged, true);
      },

      /**
       * Used for Unit Tests to expose some of inner varibles, NEVER use it in the code.
       * @return {obj} This returns the obj contains UT needed data references
       */
      utTestingAPIs: function utTestingAPIs() {
         return {
            headers: headers,
            callbacks: callbacks
         };
      },

      /**
       * Used for get whether the encoder is working, for bug 1750132.
       * @return {boolean} Whether any of audio or video is being used
       */
      notInUse: function notInUse() {
         return !encoderStatus['audio'].beingUsed && !encoderStatus['video'].beingUsed;
      },

      /**
       * Used to check the mismatch status before clear up.
       * @param {object} manager A DeviceMessageManager instance
       */
      setMessageManager: function setMessageManager(manager) {
         messageManager = manager;
      }
   };
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/
/**
 * @fileoverview audioworker.js -- audioWorker
 * Class to wrap audio and video encoding
 * encoderStatus need to be extended to also constains wmksSessionID and param
 * if we want to support seamless window with RTAV.
 */

;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = MessageWaitManager;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class contains the logic of what message need to wait
 * @type {function}
 */
function MessageWaitManager() {
   var previousActions = void 0,
       actionQueue = void 0,
       actionWaitMap = void 0,
       defaultWaitTime = void 0,
       maxRecordDuration = void 0,
       waitTimer = void 0,

   //functions
   getNow = void 0,
       init = void 0,
       reset = void 0,
       setMaxRecordDuration = void 0,
       updateBufferedActions = void 0,
       getWaitTimeForAction = void 0,
       getWaitTime = void 0,
       getDefaultActionWaitTime = void 0,
       _processQueue = void 0,
       canProcess = void 0,
       onProcess = void 0,
       onWait = void 0;

   getNow = function getNow() {
      return new Date().getTime();
   };

   reset = function reset() {
      previousActions = [];
      actionQueue = [];
      waitTimer = null;
   };

   /**
    * it should be >= max(actionWaitMap[k].time, defaultWaitTime), for all valid k
    */
   setMaxRecordDuration = function setMaxRecordDuration() {
      var key = void 0;

      maxRecordDuration = defaultWaitTime;
      for (key in actionWaitMap) {
         if (actionWaitMap.hasOwnProperty(key)) {
            maxRecordDuration = Math.max(maxRecordDuration, actionWaitMap[key].time);
         }
      }
   };

   init = function init() {
      /**
       * @private
       * @type {Object}
       * The format is as: {
       *    previousActionName: {
       *       name: laterActionName,
       *       time: intervalTime
       *    },
       *    ...
       * }
       * and it means if previously we process the message of previousActionName,
       * we must at least wait intervalTime before processing later action of name
       * laterActionName.
       * Choose the same value as the highDelay in the Agent as 600.
       */
      actionWaitMap = {
         "PMsgStart_V": {
            name: "PMsgStop_V",
            time: 600 //ms
         },
         "PMsgStop_V": {
            name: "PMsgStart_V",
            time: 600 //ms
         },
         "PMsgStart_A": {
            name: "PMsgStop_A",
            time: 600 //ms
         },
         "PMsgStop_A": {
            name: "PMsgStart_A",
            time: 600 //ms
         }
      };
      defaultWaitTime = 0; //ms for any messages
      setMaxRecordDuration();
      reset();
   };
   init();

   /**
    * clear outdated record in previousActions, which is sorted by time order
    */
   updateBufferedActions = function updateBufferedActions() {
      var i = void 0,
          oldestRecoderTime = getNow() - maxRecordDuration,
          clipIndex = -1;

      for (i = 0; i < previousActions.length; i++) {
         if (previousActions[i].time <= oldestRecoderTime) {
            clipIndex = i;
         } else {
            break;
         }
      }
      if (clipIndex >= 0) {
         previousActions.splice(0, clipIndex + 1);
      }
   };

   /**
    * get wait time for a specifyed action
    */
   getWaitTimeForAction = function getWaitTimeForAction(messageType, currentTime, previousAction) {
      var alreadyWaitTime = void 0,
          actionWaitTime = void 0,
          waitInfo = void 0;

      if (!actionWaitMap.hasOwnProperty(previousAction.name)) {
         return 0;
      }
      waitInfo = actionWaitMap[previousAction.name];
      if (waitInfo.name !== messageType) {
         return 0;
      }
      actionWaitTime = waitInfo.time;
      alreadyWaitTime = currentTime - previousAction.time;
      return Math.max(0, actionWaitTime - alreadyWaitTime);
   };

   /**
    * get wait time for default action, which apply to all messages
    */
   getDefaultActionWaitTime = function getDefaultActionWaitTime(currentTime) {
      var alreadyWaitTime = void 0;

      if (previousActions.length === 0) {
         return 0;
      }
      alreadyWaitTime = currentTime - previousActions[previousActions.length - 1].time;

      return Math.max(0, defaultWaitTime - alreadyWaitTime);
   };

   /**
    * get overall wait time
    */
   getWaitTime = function getWaitTime(messageType) {
      var i = void 0,
          currentTime = getNow(),
          waitTime = getDefaultActionWaitTime(currentTime);

      for (i = 0; i < previousActions.length; i++) {
         waitTime = Math.max(waitTime, getWaitTimeForAction(messageType, currentTime, previousActions[i]));
      }
      return waitTime;
   };

   _processQueue = function processQueue() {
      var nextAction = void 0;
      if (actionQueue.length === 0) {
         return;
      }
      nextAction = actionQueue[0];
      if (waitTimer !== null) {
         _logservice2.default.logService.trace("there is a message waiting, wait that to be processed first");
         return;
      }

      _logservice2.default.logService.trace("start timer for " + nextAction.messageType);
      waitTimer = setTimeout(function () {
         actionQueue.shift();
         waitTimer = null;
         onProcess(nextAction.messageType);
         nextAction.processingFunction();
         _processQueue();
      }, getWaitTime(nextAction.messageType));
   };

   canProcess = function canProcess(messageType) {
      return getWaitTime(messageType) === 0 && actionQueue.length === 0;
   };
   onProcess = function onProcess(messageType) {
      _logservice2.default.logService.debug("start executing message " + messageType);
      updateBufferedActions();
      previousActions.push({
         name: messageType,
         time: getNow()
      });
   };
   onWait = function onWait(messageType, processingFunction) {
      actionQueue.push({
         messageType: messageType,
         processingFunction: processingFunction
      });
      _processQueue();
   };
   return {
      /**
       * This function will run the processingFunction as the order they passed
       * in, and will keep them apart from each other to leave enough interval
       * as defined in the actionWaitMap
       * @param {string} messageType The action Name
       * @param {funciton} processingFunction The function for the action
       */
      process: function process(messageType, processingFunction) {
         if (canProcess(messageType)) {
            onProcess(messageType);
            processingFunction();
         } else {
            onWait(messageType, processingFunction);
            _logservice2.default.logService.debug("waiting for message " + messageType);
         }
      },
      /**
       * This is for UT only, and should not be used by program.
       * @type {Object}
       */
      APIforUT: {
         getPreviousActions: function getPreviousActions() {
            return previousActions;
         },
         getActionQueue: function getActionQueue() {
            return actionQueue;
         },
         getMaxRecordDuration: function getMaxRecordDuration() {
            return maxRecordDuration;
         },
         getWaitTimer: function getWaitTimer() {
            return waitTimer;
         }
      }
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/
/**
 * @fileoverview devicemessagemanager.js -- DeviceMessageManager
 * Class contains the logic for device related messages, mainly works
 * as a interval control since device can't be operated too frequently,
 * and no extra cancel logic are added since driver in the agent should
 * do this.
 *
 * And we can't process start right after stop, or stop right after start,
 * since the browser init is async and some will cause unexcepted errors.
 * and the 600ms is exprimential interval value to safely process actions
 *
 * Although adding minial processing interval for all messages are more safer,
 * and easy to implement, it look not needed and will decrease the user
 * experience somehow, so not use that design.
 */

;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var resourceManager = function () {
   var activeSessionID = null,
       resourcePool = null,

   // private function
   initResourcesPool = void 0,
       deviceStatusChangeCallback = void 0;

   initResourcesPool = function initResourcesPool(onDone) {
      var mediaSrc = void 0;
      if (!resourcePool) {
         resourcePool = {
            src: new _logservice2.default.MediaCapture(),
            mediaEnc: new _logservice2.default.MediaEncoder()
         };
      }
      onDone(resourcePool);
   };

   return {
      /**
       * Used to check whether there is any usable devices
       * cuurrently we only allow device to be used by one desktop at a time.
       * @return {Boolean} This returns whether there is any usable devices
       */
      hasUsableResources: function hasUsableResources() {
         return activeSessionID === null;
      },

      /**
       * Used to check whether a session have usable devices, and if not we should not
       * process the RTAV function on that session.
       * currently we only have one session can work, so the condition is very simple.
       * @param {string}  sessionID The ID of the session that will be checked.
       * @return {Boolean} This returns whether the device has already been occupied
       */
      hasOccupiedResources: function hasOccupiedResources(sessionID) {
         return activeSessionID === sessionID;
      },

      /**
       * Used to occupy device for specified session.
       * Should only be call this API when hasOccupiedResources returns false, and hasUsableResources returns true.
       * @param {string} sessionID The ID of session that wants to occupy the devices
       * @param {function} onDone The callback to pass resources out, null means fail to occupy
       */
      occupyResources: function occupyResources(sessionID, onDone) {
         if (this.hasOccupiedResources(sessionID)) {
            _logservice2.default.logService.devError('session "' + sessionID + '" has already occupy a device');
            onDone(null);
            return;
         }
         if (!this.hasUsableResources()) {
            _logservice2.default.logService.devError('there is no rest device for session "' + sessionID + '"');
            onDone(null);
            return;
         }
         activeSessionID = sessionID;

         this.emitDeviceStatusChanged();

         initResourcesPool(onDone);
      },

      /**
       * Used to release device for specified session.
       * Should only be call this API when hasOccupiedResources returns true.
       * @param {string} sessionID The ID of session that wants to release the devices
       * @param {bool} forcibly Whether bypass the owner ship check to release owner's devices
       * @param {function} onDone The callback to pass resources out, null means fail to occupy
       */
      releaseResources: function releaseResources(sessionID, forcibly) {
         if (!forcibly && !this.hasOccupiedResources(sessionID)) {
            _logservice2.default.logService.error('session "' + sessionID + '" hasn\'t occupied a device');
            return;
         }
         activeSessionID = null;
      },

      /**
       * Set the callback function to detect the device status changes
       * @param {function} callback The callback function passed from the UI layer
       */
      onDeviceStatusChanged: function onDeviceStatusChanged(callback) {
         deviceStatusChangeCallback = callback;
      },

      /**
       * Trigger DeviceStatusChanged function from outside
       */
      emitDeviceStatusChanged: function emitDeviceStatusChanged() {
         if (typeof deviceStatusChangeCallback === 'function') {
            deviceStatusChangeCallback();
         }
      },

      /**
       * @return {string} This returns the current device using id, if not in use, return null
       */
      getWorkingSessionId: function getWorkingSessionId() {
         return activeSessionID;
      },

      /**
       * Let a new session steal device from current using session
       * @param  {string} sessionID The new session ID
       * @param  {function} onDone  The callback function once the device hand over is finished
       */
      stealSession: function stealSession(sessionID, onDone) {
         if (!sessionID || typeof onDone !== 'function') {
            return;
         }
         _logservice2.default.wmksAdapter.userStopSession(activeSessionID);
         this.occupyResources(sessionID, onDone);
      },

      /**
       * Close the devices for RTAV, later usage must require another premission
       * @param  {string} sessionID The ID of session from which this function is called
       * since we close device when not using them, there is no need to close them manully anymore
       */
      closeDevices: function closeDevices(sessionID) {
         if (!sessionID || !this.hasOccupiedResources(sessionID)) {
            return;
         }
         _logservice2.default.wmksAdapter.userStopSession(sessionID);
      }
   };
}(); /*********************************************************
      * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
      *********************************************************/
/**
 * @fileoverview resourcemanager.js -- resourceManager
 * Service to handle resources(mainly audio-in and video-in devices) management
 *
 * currently we only allow devices to be used by one of the wmks session, and before it
 * releases the resources, other sesion can not get the resouce.
 */

exports.default = resourceManager;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

__webpack_require__(156);

__webpack_require__(160);

var _devicemessagemanager = __webpack_require__(148);

var _devicemessagemanager2 = _interopRequireDefault(_devicemessagemanager);

var _dialogservice = __webpack_require__(149);

var _dialogservice2 = _interopRequireDefault(_dialogservice);

var _synctimer = __webpack_require__(161);

var _synctimer2 = _interopRequireDefault(_synctimer);

var _frameratecontroller = __webpack_require__(150);

var _frameratecontroller2 = _interopRequireDefault(_frameratecontroller);

var _messagewaitmanager = __webpack_require__(153);

var _messagewaitmanager2 = _interopRequireDefault(_messagewaitmanager);

var _audiocapture = __webpack_require__(147);

var _audiocapture2 = _interopRequireDefault(_audiocapture);

var _videocapture = __webpack_require__(163);

var _videocapture2 = _interopRequireDefault(_videocapture);

var _mediacapture = __webpack_require__(151);

var _mediacapture2 = _interopRequireDefault(_mediacapture);

__webpack_require__(162);

var _mediaencoder = __webpack_require__(152);

var _mediaencoder2 = _interopRequireDefault(_mediaencoder);

var _resourcemanager = __webpack_require__(154);

var _resourcemanager2 = _interopRequireDefault(_resourcemanager);

var _rtavprotocolservice = __webpack_require__(157);

var _rtavprotocolservice2 = _interopRequireDefault(_rtavprotocolservice);

var _rtavsessioncontroller = __webpack_require__(159);

var _rtavsessioncontroller2 = _interopRequireDefault(_rtavsessioncontroller);

var _rtavsession = __webpack_require__(158);

var _rtavsession2 = _interopRequireDefault(_rtavsession);

var _wmksadapter = __webpack_require__(164);

var _wmksadapter2 = _interopRequireDefault(_wmksadapter);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/
/**
 * @fileoverview rtav-service.js -- RTAVService
 * Service implement RTAV feature for WebClient
 */

_logservice2.default.dialogService = _dialogservice2.default;
_logservice2.default.SyncTimer = _synctimer2.default;
_logservice2.default.FrameRateController = _frameratecontroller2.default;
_logservice2.default.MessageWaitManager = _messagewaitmanager2.default;
_logservice2.default.DeviceMessageManager = _devicemessagemanager2.default;
_logservice2.default.AudioCapture = _audiocapture2.default;
_logservice2.default.VideoCapture = _videocapture2.default;
_logservice2.default.MediaCapture = _mediacapture2.default;
_logservice2.default.MediaEncoder = _mediaencoder2.default;
_logservice2.default.resourceManager = _resourcemanager2.default;
_logservice2.default.rtavProtocolService = _rtavprotocolservice2.default;
_logservice2.default.RtavSessionController = _rtavsessioncontroller2.default;
_logservice2.default.RtavSession = _rtavsession2.default;
_logservice2.default.wmksAdapter = _wmksadapter2.default;

var RTAVService = {
   onConnecting: _logservice2.default.wmksAdapter.addSession,
   onConnected: _logservice2.default.wmksAdapter.activeSession,
   onDisconnected: _logservice2.default.wmksAdapter.removeSession,
   onDeviceStatusChanged: _logservice2.default.resourceManager.onDeviceStatusChanged,
   setDialogHandler: _logservice2.default.dialogService.setDialogFunction
};
if (Object.freeze) {
   RTAVService = Object.freeze(RTAVService);
}

exports.default = RTAVService;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var constants = {
   AVPluginState: {
      STChannelClose: 0,
      STChannelOpen: 1,
      STOff: 2,
      STOn: 3,
      STPending_AIn: 4,
      STEnabled_AIn: 5,
      STEnabled_V: 6,
      STEnabled_VAIn: 7,
      STError: 8
   },
   rtavTypes: {
      PMsgGetConfig: 4,
      PMsgSetConfig: 5,
      PMsgGetCliSettings: 6,
      PMsgSetCliSettings: 7,
      PMsgStart_A: 8,
      PMsgStart_A_Ack: 9,
      PMsgStart_A_Ack_Err: 10,
      PMsgStop_A: 11,
      PMsgStop_A_Ack: 12,
      PMsgStop_A_Ack_Err: 13,
      PMsgStart_V: 14,
      PMsgStart_V_Ack: 15,
      PMsgStart_V_Ack_Err: 16,
      PMsgStop_V: 17,
      PMsgStop_V_Ack: 18,
      PMsgStop_V_Ack_Err: 19,
      PMsgStartStream: 21,
      PMsgStopStream: 22,
      PMsgBinData: 24
   },
   streamHeaderLength: 16
}; /*********************************************************
    * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
    *********************************************************/
/**
 * @fileoverview rtavconstants.js -- constants
 * object holds RTAV related constants
 */

_logservice2.default.constants = constants;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

/**
 * @fileoverview rtavprotocolservice.js -- rtavProtocolService
 * Service implement RTAV feature for WebClient, depend on MediaCapture, and MediaEncoder
 */

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var rtavProtocolService = function () {
   var constants = {},
       util = {},
       getSendingBinary = void 0,
       parseRecievedMessage = void 0;

   constants.codecTypes = {
      CodecNone: 0,
      CodecSpeex: 1,
      CodecTheora: 2,
      CodecTheoraSpeex: 3,
      CodecVmwSpeex: 4,
      CodecVmwTheora: 5,
      CodecVmwTheoraSpeex: 6
   };
   constants.rtavTypes = _logservice2.default.constants.rtavTypes;
   constants.streamHeaderLength = _logservice2.default.constants.streamHeaderLength;

   util.convertU32 = function (n) {
      return [(n & 0xFF000000) >>> 24, (n & 0x00FF0000) >>> 8, (n & 0x0000FF00) << 8, (n & 0x000000FF) << 24].reduce(function (a, b) {
         return a + b;
      });
   };

   /**
    * Contains protocol formation information for sending to get streamlized binary data.
    * @type {function}
    */
   getSendingBinary = function () {
      var getNetWork = void 0,
          uint32ToUint8 = void 0,
          getRtavControlPacket32 = void 0,
          extendZeros = void 0,
          getDevPrefsNet = void 0,
          streamlizersMap = void 0;

      getNetWork = function getNetWork(src) {
         var i = void 0,
             dst = [];

         for (i = 0; i < src.length; i++) {
            dst[i] = util.convertU32(src[i]);
         }
         return dst;
      };

      uint32ToUint8 = function uint32ToUint8(array32) {
         var i = void 0,
             length8 = array32.length * 4,
             buff8 = new Uint8Array(new Uint32Array(array32).buffer),
             array8 = new Array(length8);

         for (i = 0; i < length8; i++) {
            array8[i] = buff8[i];
         }
         return array8;
      };

      getRtavControlPacket32 = function getRtavControlPacket32(type, dataArray) {
         var data = void 0,
             networkBytes = void 0,
             headerLength = 8,
             dataLength = dataArray.length * 4 + headerLength,
             typeCode = constants.rtavTypes[type];

         if (typeof typeCode !== 'number') {
            return;
         }
         data = [typeCode, dataLength].concat(dataArray);
         networkBytes = new Uint8Array(new Uint32Array(data).buffer);
         return networkBytes;
      };

      extendZeros = function extendZeros(length) {
         var i = void 0,
             result = new Array(length);
         for (i = 0; i < length; i++) {
            result[i] = 0;
         }
         return result;
      };

      getDevPrefsNet = function getDevPrefsNet(localConfig) {
         var audioSettings = localConfig.audio,
             videoSettings = localConfig.video,
             audioPrefs = void 0,
             videoPrefs = void 0,
             audioInDevPrefsNet = void 0,
             videoCamDevPrefsNet = void 0;

         audioPrefs = {
            audFrameUnitLenMS: 20, // cAInUnitLenMS_Def = 20
            audFrameUnitCount: 50, // cAInCacheUnitCount_Def = 50
            queueLen: 10, // cAInQueueLen_Def = 10, but here set as 10
            bitsPerSample: audioSettings.bitsPerSample,
            channels: audioSettings.channels,
            inputStreams: 1,
            framesPerPacket: 1,
            samplesPerSec: audioSettings.sampleRate
         };
         videoPrefs = {
            fWidth: videoSettings.width,
            fHeight: videoSettings.height,
            frameRate: videoSettings.fps,
            tPauseMS: 0,
            queueLen: 10 // cWCamQueueLen_Def = 10
         };
         audioInDevPrefsNet = getNetWork([audioPrefs.audFrameUnitLenMS, audioPrefs.audFrameUnitCount, audioPrefs.queueLen, audioPrefs.bitsPerSample, audioPrefs.channels, audioPrefs.inputStreams, audioPrefs.framesPerPacket, audioPrefs.samplesPerSec].concat(extendZeros(20)));
         videoCamDevPrefsNet = getNetWork([videoPrefs.fWidth, videoPrefs.fHeight, videoPrefs.frameRate, videoPrefs.tPauseMS, videoPrefs.queueLen].concat(extendZeros(20)));

         return audioInDevPrefsNet.concat(videoCamDevPrefsNet);
      };

      streamlizersMap = {
         sendConfig: function sendConfig(config) {
            var configArray = [8 * 4, _logservice2.default.constants.AVPluginState['STOn'], config.versionNum, config.isEnabled, config.vdoRes.width, config.vdoRes.height, config.vdoFPS, config.reserved],
                networkArray = getNetWork(configArray);

            return getRtavControlPacket32('PMsgSetConfig', networkArray);
         },

         sendStartAudioAck: function sendStartAudioAck() {
            var networkArray = [];
            return getRtavControlPacket32('PMsgStart_A_Ack', networkArray);
         },

         sendStartAudioNak: function sendStartAudioNak() {
            var networkArray = [];
            return getRtavControlPacket32('PMsgStart_A_Ack_Err', networkArray);
         },

         sendStopAudioAck: function sendStopAudioAck() {
            var networkArray = [];
            return getRtavControlPacket32('PMsgStop_A_Ack', networkArray);
         },

         sendStopAudioNak: function sendStopAudioNak() {
            var networkArray = [];
            return getRtavControlPacket32('PMsgStop_A_Ack_Err', networkArray);
         },

         sendStartVideoAck: function sendStartVideoAck(localConfig) {
            var codecPref = constants.codecTypes['CodecVmwTheoraSpeex'];
            return getRtavControlPacket32('PMsgStart_V_Ack', getNetWork([codecPref]).concat(getDevPrefsNet(localConfig)));
         },

         sendStartVideoNak: function sendStartVideoNak() {
            var networkArray = [];
            return getRtavControlPacket32('PMsgStart_V_Ack_Err', networkArray);
         },

         sendStopVideoAck: function sendStopVideoAck() {
            var networkArray = [];
            return getRtavControlPacket32('PMsgStop_V_Ack', networkArray);
         },

         sendStopVideoNak: function sendStopVideoNak() {
            var networkArray = [];
            return getRtavControlPacket32('PMsgStop_V_Ack_Err', networkArray);
         },

         sendStream: function sendStream(messageData) {
            var streamData = void 0,
                streamHeader = void 0;

            if (!messageData || !messageData.streamData) {
               _logservice2.default.logService.devError('trying to send a invalid stream');
               return null;
            }
            streamData = messageData.streamData;
            streamHeader = new Uint32Array(streamData.buffer, 0, 4);

            streamHeader[0] = constants.rtavTypes['PMsgBinData'];
            streamHeader[1] = streamData.length + constants.streamHeaderLength;
            streamHeader[2] = messageData.timeStamp;
            streamHeader[3] = messageData.dataCount;

            return new Uint8Array(streamData.buffer);
         },

         sendClientSettings: function sendClientSettings(localConfig) {
            var codecPref = constants.codecTypes['CodecVmwTheoraSpeex'];
            return getRtavControlPacket32('PMsgSetCliSettings', getNetWork([codecPref]).concat(getDevPrefsNet(localConfig)));
         },

         sendStopStream: function sendStopStream() {
            var networkArray = [];
            return getRtavControlPacket32('PMsgStopStream', networkArray);
         }
      };
      return function (type, data) {
         var getStream = streamlizersMap[type];
         if (typeof getStream !== 'function') {
            _logservice2.default.logService.devError('unknown type to be streamlized');
            return null;
         }
         if (type !== 'sendStream') {
            _logservice2.default.logService.trace("generating response " + type);
         }
         return getStream(data);
      };
   }();

   /**
    * Contains reciever related logic and functions
    * @type {object}
    */
   parseRecievedMessage = function () {
      var getMessageStruct = void 0,
          parseStruct = void 0,
          parseAdminPolicy = void 0;

      getMessageStruct = function getMessageStruct(message) {
         var headerLength = 8,
             header = new Uint32Array(message.data.slice(0, headerLength));
         if (header[1] !== message.data.byteLength) {
            return {
               type: "undefined"
            };
         }
         return {
            type: header[0],
            dataLength: header[1] - headerLength,
            data: message.data.slice(8)
         };
      };

      parseStruct = function parseStruct(data, formats) {
         var i = void 0,
             j = void 0,
             k = void 0,
             format = void 0,
             result = {},
             array = void 0;
         for (i = 0, j = 0, k = 0; i < formats.length; i++) {
            format = formats[i];
            if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {
               array = [];
               for (j = 0; j < format.length; j++, k++) {
                  array[j] = util.convertU32(data[k]);
               }
               result[format.name] = array;
            } else {
               result[format] = util.convertU32(data[k]);
               k++;
            }
         }
         return result;
      };

      parseAdminPolicy = function parseAdminPolicy(rtavMessage) {
         var configArray = new Uint32Array(rtavMessage.data),
             format = ['dataLength', 'status', 'versionNum', 'isEnabled', 'vdoMaxFPS', 'vdoMaxResHeight', 'vdoMaxResWidth', 'vdoDefResHeight', 'vdoDefResWidth', {
            length: 20,
            name: 'reserved'
         }],
             adminPolicy = void 0;
         adminPolicy = parseStruct(configArray, format);
         if (adminPolicy.dataLength !== rtavMessage.dataLength) {
            return null;
         }
         return adminPolicy;
      };

      return function (message) {
         var adminPolicy = void 0,
             rtavMessage = getMessageStruct(message),
             parsedMessage = {
            type: rtavMessage.type,
            data: null
         };

         switch (rtavMessage.type) {
            case constants.rtavTypes['PMsgGetConfig']:
               // set admin policy, and set user config back to the Agent
               adminPolicy = parseAdminPolicy(rtavMessage);
               _logservice2.default.logService.log(adminPolicy);
               parsedMessage.data = adminPolicy;
               break;
            case constants.rtavTypes['PMsgGetCliSettings']:
            case constants.rtavTypes['PMsgStart_A']:
            case constants.rtavTypes['PMsgStop_A']:
            case constants.rtavTypes['PMsgStart_V']:
            case constants.rtavTypes['PMsgStop_V']:
            case constants.rtavTypes['PMsgStartStream']:
            case constants.rtavTypes['PMsgStopStream']:
               break;
            default:
               _logservice2.default.logService.error('unknown msg');
               _logservice2.default.logService.error(rtavMessage);
               return null;
         }
         _logservice2.default.logService.debug('recieve rtav message:' + JSON.stringify(parsedMessage));
         return parsedMessage;
      };
   }();

   return {
      /**
       * use to get rtav protocol message object into binary stream.
       * @param {string} type The message type
       * @param {object} data Optional The data that will be carried by the message
       * @return {object} This will returns the binary message constructed from the inputs
       */
      getSendingBinary: getSendingBinary,
      /**
       * use to parse rtav protocol message into object.
       * @param  {object} message The object contains binary message
       * @return {object} This will returns the parsed Object of input message
       */
      parseRecievedMessage: parseRecievedMessage
   };
}();

exports.default = rtavProtocolService;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = RtavSession;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class that contains functions and logic for using the rtav sub channel
 * @type {function}
 */
var RtavChannel = function RtavChannel(vvcSession) {
   var rtavChannel = null;

   return {
      initialize: function initialize() {
         //halt the sending and recieving if any thing goes wrong
         var onChannelCloseError = void 0;

         if (!vvcSession) {
            return;
         }
         rtavChannel = vvcSession.openChannel('MultimediaRedirChannel', 10);
         rtavChannel.onopen = function () {
            _logservice2.default.logService.log('rtav channel is opened');
         };
         onChannelCloseError = function () {
            this.stop();
         }.bind(this);
         rtavChannel.onclose = onChannelCloseError;

         rtavChannel.onerror = onChannelCloseError;
         this.send = function (networkBytes) {
            if (!networkBytes) {
               return;
            }
            try {
               vvcSession.send(rtavChannel, networkBytes);
            } catch (e) {
               _logservice2.default.logService.log('error when sending rtav message:' + e);
            }
         };
      },

      send: function send() {},

      stop: function stop() {
         if (!rtavChannel) {
            return;
         }
         this.send = function () {
            _logservice2.default.logService.debug('stop one package sending for rtav channel is closed');
         };
         rtavChannel.onmessage = function () {
            _logservice2.default.logService.debug('stop one package recieving for rtav channel is closed');
         };
         rtavChannel = null;
      },

      setRecievedListener: function setRecievedListener(onMessage) {
         if (!rtavChannel) {
            return;
         }
         rtavChannel.onmessage = onMessage;
      }
   };
};

/**
 * Class that contains functions and logic for managing and formating RTAV configurable settings
 * @type {function}
 */
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/
/**
 * @fileoverview rtavsession.js -- RtavSession
 * Service to handle wmks session management
 *
 * Class that holds channel, setting, as well as status. It depends on RtavSessionController, rtavProtocolService,
 * and also depends on local class RtavChannel, RtavSettingManager, RtavStatus
 */

var RtavSettingManager = function RtavSettingManager() {
   var adminPolicy = void 0,
       localConfig = void 0,

   //private function
   setLocalConfig = void 0;

   // setting the local config with admin policy and ingore local settings since we avoid provide user UI for that.
   setLocalConfig = function setLocalConfig(adminPolicy) {
      var localWidth = void 0,
          localHeight = void 0,
          localMaxFPS = void 0;

      if (adminPolicy.vdoDefResWidth !== 0) {
         // client set has no limit, use agent default value
         localWidth = adminPolicy.vdoDefResWidth;
      } else {
         if (adminPolicy.vdoMaxResWidth !== 0) {
            localWidth = Math.min(adminPolicy.vdoMaxResWidth, _logservice2.default.settings.video.defResWidth);
         } else {
            localWidth = _logservice2.default.settings.video.defResWidth;
         }
      }
      if (adminPolicy.vdoDefResHeight !== 0) {
         // client set has no limit, use agent default value
         localHeight = adminPolicy.vdoDefResHeight;
      } else {
         if (adminPolicy.vdoMaxResHeight !== 0) {
            localHeight = Math.min(adminPolicy.vdoMaxResHeight, _logservice2.default.settings.video.defResHeight);
         } else {
            localHeight = _logservice2.default.settings.video.defResHeight;
         }
      }
      if (adminPolicy.vdoMaxFPS !== 0) {
         if (_logservice2.default.settings.video.defMaxFPS !== 0) {
            localMaxFPS = Math.min(_logservice2.default.settings.video.defMaxFPS, adminPolicy.vdoMaxFPS);
         } else {
            localMaxFPS = adminPolicy.vdoMaxFPS;
         }
      } else {
         localMaxFPS = _logservice2.default.settings.video.defMaxFPS;
      }

      // round the resolution since cpmpression lib suggest so.
      if (localWidth % 16 !== 0) {
         localWidth = Math.floor(localWidth / 16) * 16;
      }
      if (localHeight % 16 !== 0) {
         localHeight = Math.floor(localHeight / 16) * 16;
      }

      localConfig = {
         versionNum: adminPolicy.versionNum,
         isEnabled: adminPolicy.isEnabled,
         vdoRes: {
            width: localWidth,
            height: localHeight
         },
         vdoFPS: localMaxFPS,
         reserved: 0
      };
   };
   return {
      setAdminPolicy: function setAdminPolicy(policy) {
         adminPolicy = policy;
         setLocalConfig(adminPolicy);
      },

      getLocalConfig: function getLocalConfig() {
         return localConfig;
      },

      getAudioDeviceSetting: function getAudioDeviceSetting() {
         return _logservice2.default.settings.audio;
      },

      getVideoDeviceSetting: function getVideoDeviceSetting() {
         return {
            width: localConfig.vdoRes.width,
            height: localConfig.vdoRes.height,
            fps: localConfig.vdoFPS
         };
      }
   };
};

/**
 * Class that contains functions and logic for managing and formating RTAV configurable settings
 * @type {function}
 * It hasn't been fully implemented yet
 */
var RtavStatus = function RtavStatus() {
   var currentStatus = void 0,
       setStatus = void 0,
       AVPluginState = _logservice2.default.constants.AVPluginState;

   setStatus = function setStatus(statusName) {
      if (!AVPluginState.hasOwnProperty(statusName)) {
         _logservice2.default.logService.error('bad statusName to be set for rtav session');
      }
      currentStatus = AVPluginState[statusName];
   };
   currentStatus = setStatus('STChannelClose');

   return {
      set: setStatus,

      processAllowed: function processAllowed(actionName) {
         return true;
      }
   };
};

/**
 * The Class that contains all information for a rtav session.
 * @param {string} sessionId  The ID of vvcSession
 * @param {object} vvcSession The vvcSession object passed from wmks, with send and openChannel API.
 */
function RtavSession(sessionId, vvcSession) {
   var channel = void 0,
       settingManager = void 0,
       status = void 0,
       controller = void 0,
       protocol = void 0,
       deviceMessageManager = void 0,

   // private function
   onMessage = void 0,
       sendStopStream = void 0,
       startStream = void 0;

   settingManager = new RtavSettingManager();
   channel = new RtavChannel(vvcSession);
   status = new RtavStatus();
   controller = new _logservice2.default.RtavSessionController(sessionId);
   protocol = _logservice2.default.rtavProtocolService;
   deviceMessageManager = new _logservice2.default.DeviceMessageManager(controller);
   controller.setMessageManager(deviceMessageManager);

   onMessage = function onMessage(message) {
      var parsedMessage = protocol.parseRecievedMessage(message),
          adminPolicy = void 0,
          localConfig = void 0,
          deviceConfig = void 0,
          rtavMessageTypes = _logservice2.default.constants.rtavTypes,
          success = void 0,
          binaryData = void 0;

      if (!parsedMessage) {
         _logservice2.default.logService.warn('skip processing for unknown message');
         return;
      }

      switch (parsedMessage.type) {
         case rtavMessageTypes['PMsgGetConfig']:
            // set admin policy, and set user config back to the Agent
            adminPolicy = parsedMessage.data;
            settingManager.setAdminPolicy(adminPolicy);
            localConfig = settingManager.getLocalConfig();
            binaryData = protocol.getSendingBinary('sendConfig', localConfig);
            channel.send(binaryData);
            break;
         case rtavMessageTypes['PMsgGetCliSettings']:
            deviceConfig = {
               audio: settingManager.getAudioDeviceSetting(),
               video: settingManager.getVideoDeviceSetting()
            };
            binaryData = protocol.getSendingBinary('sendClientSettings', deviceConfig);
            channel.send(binaryData);
            break;
         case rtavMessageTypes['PMsgStart_A']:
            deviceMessageManager.onMessage('PMsgStart_A', function (success) {
               if (success) {
                  binaryData = protocol.getSendingBinary('sendStartAudioAck');
               } else {
                  binaryData = protocol.getSendingBinary('sendStartAudioNak');
               }
               channel.send(binaryData);
            });
            break;
         case rtavMessageTypes['PMsgStop_A']:
            success = deviceMessageManager.onMessage('PMsgStop_A');
            if (success) {
               binaryData = protocol.getSendingBinary('sendStopAudioAck');
            } else {
               binaryData = protocol.getSendingBinary('sendStopAudioNak');
            }
            channel.send(binaryData);
            break;
         case rtavMessageTypes['PMsgStart_V']:
            deviceMessageManager.onMessage('PMsgStart_V', function (success) {
               if (success) {
                  deviceConfig = {
                     audio: settingManager.getAudioDeviceSetting(),
                     video: settingManager.getVideoDeviceSetting()
                  };
                  binaryData = protocol.getSendingBinary('sendStartVideoAck', deviceConfig);
               } else {
                  binaryData = protocol.getSendingBinary('sendStartVideoNak');
               }
               channel.send(binaryData);
            });
            break;
         case rtavMessageTypes['PMsgStop_V']:
            success = deviceMessageManager.onMessage('PMsgStop_V');
            if (success) {
               binaryData = protocol.getSendingBinary('sendStopVideoAck');
            } else {
               binaryData = protocol.getSendingBinary('sendStopVideoNak');
            }
            channel.send(binaryData);
            break;
         case rtavMessageTypes['PMsgStartStream']:
            startStream();
            break;
         case rtavMessageTypes['PMsgStopStream']:
            controller.stopMediaIn();
            break;
         default:
            _logservice2.default.logService.error('unknown msg');
            break;
      }
   };

   startStream = function startStream() {
      // cache the sending function with closure to maintain the correct context
      var deviceConfig = {
         audio: settingManager.getAudioDeviceSetting(),
         video: settingManager.getVideoDeviceSetting()
      };
      // currently controller only has one active session, so one can pass no session info in.
      controller.startMediaIn(deviceConfig, function (data) {
         var binaryStream = protocol.getSendingBinary('sendStream', data);
         channel.send(binaryStream);
      });
   };
   controller.startStream = startStream;

   sendStopStream = function sendStopStream() {
      var binaryData = void 0;
      binaryData = protocol.getSendingBinary('sendStopStream');
      channel.send(binaryData);
   };

   return {
      /**
       * Will always start the rtav session, but might fail to get device and thus session has no data to send.
       */
      start: function start() {
         channel.initialize();
         channel.setRecievedListener(onMessage);
         controller.initialize();
         status.set('STChannelOpen');
      },

      /**
       * Stop the whole rtav, will clear all recources and disconnect from agent.
       */
      stop: function stop() {
         channel.stop();
         controller.stop();
         status.set('STChannelClose');
      },

      /**
       * User want to stop the rtav from working for now, but several resources will be kept for later usage.
       */
      userStop: function userStop() {
         controller.userStop();
         sendStopStream();
         status.set('STOff');
      },

      /**
       * [isUsingDevices description]
       * @param  {string}  type Optional Indicate whether asking for audio or video, when undefined, ask for either
       * @return {boolean} This returns whether the asked type is in usage
       */
      isUsingDevices: function isUsingDevices(type) {
         return controller.isSendingStream(type);
      },

      /**
       * [isUsingDevices description]
       * @param  {string}  type Optional Indicate whether asking for audio or video, when undefined, ask for either
       * @return {boolean} This returns whether the asked type is being asked for premission
       */
      isAskingPremission: function isAskingPremission(type) {
         return deviceMessageManager.isPermissionPending(type);
      }
   };
};

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = RtavSessionController;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Class contains the main logic of rtav session, which will be used
 * by the RTAV session
 * @type {function}
 */
function RtavSessionController(sessionId) {
   var src = void 0,
       mediaEnc = void 0,
       sendingFunc = void 0,
       metaCacheA = void 0,
       metaCacheV = void 0,
       dataChannel = {
      audioEnable: false,
      videoEnable: false,
      // this flag is for fixing bug 1647044, where the device is missing but we should treat the enable as success
      videoMissing: false
   },
       hasResources = false,
       massageManager = null,

   /**
    * need to bind the sending function into a map with wmksId as key if we want to support seamless window,
    * that could be done using a new object named sessionManager, and I will not implement that for now.
    */
   initDoneCallback = void 0,
       audioDataCallback = void 0,
       videoDataCallback = void 0,

   //private functions
   resetProperties = void 0,
       initResources = void 0,
       initEncoder = void 0,
       releaseResources = void 0,
       closeResources = void 0,
       setResources = void 0;

   /**
    * reset for a new stream session
    * @param  {[type]} sendingFunction [description]
    * @return {[type]}                 [description]
    */
   resetProperties = function resetProperties(sendingFunction) {
      sendingFunc = sendingFunction;
      metaCacheA = null;
      metaCacheV = null;
   };

   initEncoder = function initEncoder(deviceParam) {
      var headerCallback = function headerCallback(libHeader, isFackInit) {
         initDoneCallback(libHeader, deviceParam, isFackInit);
      };
      if (!mediaEnc.isInited()) {
         _logservice2.default.logService.log('init encoders');
         mediaEnc.init(deviceParam.audio, deviceParam.video, headerCallback, audioDataCallback, videoDataCallback);
      } else {
         _logservice2.default.logService.log('encoders has already been inited, so fetch the header again');
         mediaEnc.fetchCachedHeader();
      }
   };

   setResources = function setResources(resources, onDone) {
      if (!resources) {
         _logservice2.default.logService.log('find no avaliable audio-in or video-in devices, so RTAV function is not usable');
         onDone(false);
      } else {
         src = resources.src;
         mediaEnc = resources.mediaEnc;
         if (!!massageManager) {
            mediaEnc.setMessageManager(massageManager);
         }
         _logservice2.default.logService.debug('session ' + sessionId + ' successfully get RTAV devices control rights');
         onDone(true);
      }
   };

   initResources = function initResources(onDone) {
      var stolenSessionId = void 0,
          confirmDeviceSteal = void 0,
          cancelDeviceSteal = void 0;

      if (!_logservice2.default.resourceManager.hasOccupiedResources(sessionId)) {
         if (_logservice2.default.resourceManager.hasUsableResources()) {
            _logservice2.default.resourceManager.occupyResources(sessionId, function (resources) {
               setResources(resources, onDone);
            });
         } else {
            if (!!_logservice2.default.dialogService.showDialog) {
               confirmDeviceSteal = function confirmDeviceSteal() {
                  _logservice2.default.resourceManager.stealSession(sessionId, function (resources) {
                     _logservice2.default.logService.debug('session ' + sessionId + ' trying to steal the devices from session ' + stolenSessionId);
                     setResources(resources, onDone);
                  });
               };

               cancelDeviceSteal = function cancelDeviceSteal() {
                  _logservice2.default.logService.log('session ' + sessionId + ' failed to occupy devices, so RTAV function is not usable');
                  onDone(false);
               };

               stolenSessionId = _logservice2.default.resourceManager.getWorkingSessionId();
               // skip confirmation if devices are not used
               if (!_logservice2.default.wmksAdapter.isUsingDevices(stolenSessionId)) {
                  confirmDeviceSteal();
                  return;
               }
               _logservice2.default.dialogService.showDialog({
                  stolenSessionId: stolenSessionId
               }, confirmDeviceSteal, cancelDeviceSteal);
            } else {
               _logservice2.default.logService.log('session ' + sessionId + ' failed to occupy devices, so RTAV function is not usable');
               onDone(false);
            }
         }
      } else {
         onDone(true);
      }
   };

   /**
    * release all local resources
    */
   releaseResources = function releaseResources() {
      // clear local refer
      src = null;
      mediaEnc = null;
      // release
      if (_logservice2.default.resourceManager.hasOccupiedResources(sessionId)) {
         _logservice2.default.resourceManager.releaseResources(sessionId);
      }
      // reset flag
      hasResources = false;
      return true;
   };

   /**
    * close the hold resources, then the resources are not usable anymore
    */
   closeResources = function closeResources() {
      // release
      if (_logservice2.default.resourceManager.hasOccupiedResources(sessionId) && !!src) {
         src.close();
      }
   };

   return {
      /**
       * set all the callbacks
       */
      initialize: function initialize() {
         // inited header callback
         initDoneCallback = function (libHeader, deviceParam, isFackInit) {
            _logservice2.default.logService.trace('\nheader generated:');
            if (!libHeader || !libHeader.buffer) {
               _logservice2.default.logService.error("fail to get header, RTAV will stop working");
               return;
            }
            _logservice2.default.logService.trace(new Uint8Array(libHeader.buffer));
            sendingFunc({
               streamData: libHeader,
               dataCount: 1,
               timeStamp: 0
            });
            if (!isFackInit) {
               this.deviceParam = deviceParam;
               src.startStream(deviceParam, function (data) {
                  mediaEnc.encodeAudio(data);
               }, function (data) {
                  mediaEnc.encodeVideo(data);
               });
            }
         }.bind(this);
         // audio encoded callback, no others needed to be dealt so far
         audioDataCallback = function audioDataCallback(result, timeStamp) {
            var metaCount = 1;
            if (!dataChannel.audioEnable) {
               return;
            }
            if (result) {
               if (metaCacheA !== null) {
                  sendingFunc({
                     streamData: result,
                     dataCount: metaCacheA + metaCount,
                     timeStamp: timeStamp
                  });
                  metaCacheA = null;
               } else {
                  sendingFunc({
                     streamData: result,
                     dataCount: metaCount,
                     timeStamp: timeStamp
                  });
               }
            } else {
               if (metaCacheA !== null) {
                  metaCacheA += metaCount;
               } else {
                  metaCacheA = metaCount;
               }
            }
         };

         // video encoded callback
         videoDataCallback = function videoDataCallback(result, timeStamp, others) {
            var metaCount = 1,
                onDoneCallback = void 0,
                callbackParam = void 0;

            if (!dataChannel.videoEnable) {
               return;
            }
            if (result) {
               if (metaCacheV !== null) {
                  sendingFunc({
                     streamData: result,
                     dataCount: metaCacheV + metaCount,
                     timeStamp: timeStamp
                  });
                  metaCacheV = null;
               } else {
                  sendingFunc({
                     streamData: result,
                     dataCount: metaCount,
                     timeStamp: timeStamp
                  });
               }
            } else {
               if (metaCacheV !== null) {
                  metaCacheV += metaCount;
               } else {
                  metaCacheV = metaCount;
               }
            }
            if (!!others) {
               onDoneCallback = others.callback;
               callbackParam = others.callbackParam;
               if (typeof onDoneCallback === 'function') {
                  onDoneCallback(callbackParam);
               }
            }
         };
      },

      /**
       * The API for start a rtav streaming
       * @param  {object} encoderParam The params that will be used to config the source and encoder which generating the stream data.
       * @param  {function} sendingFunction The callback that will be used to send the stream data.
       * @return {boolean} This returns whether we can start a new rtav stream task.
       */
      startMediaIn: function startMediaIn(encoderParam, sendingFunction) {
         resetProperties(sendingFunction);
         if (!hasResources) {
            return false;
         }
         initEncoder(encoderParam);
         return true;
      },

      /**
       * The API for stop a rtav streaming
       */
      stopMediaIn: function stopMediaIn() {
         if (!hasResources) {
            return;
         }
         if (dataChannel.audioEnable) {
            this.disableAudioIn();
         }
         if (dataChannel.videoEnable) {
            this.disableVideoIn();
         }
      },

      /**
       * The API for enable audio in
       * we need to wait the sources inited which is a async process, then see whether this task can be processed successfullly
       * @param {function} callback will return whether enable success
       * @param {object} deviceMessageController This param is used to emit premission dialog related events
       */
      enableAudioIn: function enableAudioIn(callback, deviceMessageController) {
         var whenHasResources = function whenHasResources(canProcess) {
            if (!canProcess) {
               callback(false);
               return;
            }
            src.enable('audio', function (enableSuccess) {
               dataChannel.audioEnable = enableSuccess;
               if (enableSuccess) {
                  mediaEnc.enable('audio');
               }
               _logservice2.default.resourceManager.emitDeviceStatusChanged();
            }, deviceMessageController);
            callback(true);
         };
         this.processWhenHaveResources(whenHasResources);
      },

      /**
       * The API for disable audio in
       * we need to wait the sources inited which is a async process, then see whether this task can be processed successfullly
       * @return {boolean} This returns whether the disable action success, but treat to disable a released encoder as success
       */
      disableAudioIn: function disableAudioIn() {
         if (!hasResources) {
            _logservice2.default.logService.log('disable success for the encoder and src has already been released');
         }
         if (!dataChannel.audioEnable) {
            _logservice2.default.logService.log('audio has already being disabled, so no need to disable again');
            return true;
         }
         src.disable('audio');
         mediaEnc.disable('audio');
         dataChannel.audioEnable = false;
         _logservice2.default.resourceManager.emitDeviceStatusChanged();
         return true;
      },

      /**
       * The API for enable video in
       * we need to wait the sources inited which is a async process, then see whether this task can be processed successfullly
       * @param {function} callback will return whether enable success
       * @param {object} deviceMessageController This param is used to emit premission dialog related events
       */
      enableVideoIn: function enableVideoIn(callback, deviceMessageController) {
         var whenHasResources = function whenHasResources(canProcess) {
            if (!canProcess) {
               callback(false);
               return;
            }
            src.enable('video', function (enableSuccess, missingDevice) {
               dataChannel.videoEnable = enableSuccess;
               dataChannel.videoMissing = !!missingDevice;
               if (enableSuccess) {
                  mediaEnc.enable('video');
               }
               _logservice2.default.resourceManager.emitDeviceStatusChanged();
            }, deviceMessageController);
            callback(true);
         };
         this.processWhenHaveResources(whenHasResources);
      },

      /**
       * The API for disable video in
       * we need to wait the sources inited which is a async process, then see whether this task can be processed successfullly
       * @return {boolean} This returns whether the disable action success, but treat to disable a released encoder as success
       */
      disableVideoIn: function disableVideoIn() {
         if (!hasResources) {
            _logservice2.default.logService.log('disable success for the encoder and src has already been released');
            return true;
         }
         if (!dataChannel.videoEnable) {
            _logservice2.default.logService.log('video has already being disabled, so no need to disable again');
            return false;
         }
         src.disable('video');
         mediaEnc.disable('video');
         dataChannel.videoEnable = false;
         dataChannel.videoMissing = false;
         _logservice2.default.resourceManager.emitDeviceStatusChanged();
         return true;
      },

      /**
       * The API for user level of stop of RTAV
       * should be called when the rtav is turned off by user for a specified session
       * @return {boolean} This returns whether the userStop action success
       */
      userStop: function userStop() {
         this.stopMediaIn();
         releaseResources();
      },

      /**
       * The API for session level of stop of RTAV
       * should be called only when the hosted session is disconnectted
       * @return {boolean} This returns whether the stop action success
       */
      stop: function stop() {
         this.stopMediaIn();
         closeResources();
         releaseResources();
      },

      /**
       * @return {Boolean} This returns whether the controller is send stream in any kind
       */
      isSendingStream: function isSendingStream(type) {
         if (!hasResources) {
            return false;
         }
         if (type === 'video') {
            return dataChannel.videoEnable && !dataChannel.videoMissing && src.isActive(type) || this.deviceMessageManager.isPermissionPending(type);
         } else if (type === 'audio') {
            return dataChannel.audioEnable && src.isActive(type) || this.deviceMessageManager.isPermissionPending(type);
         }
         return dataChannel.videoEnable && !dataChannel.videoMissing && src.isActive('video') || dataChannel.audioEnable && src.isActive('audio') || this.deviceMessageManager.isPermissionPending();
      },

      /**
       * Try to get the resource, and when do, call processFunc, and call callback(true)
       * if not, call callback(false)
       * @param {function} processFunc The function that will be called when the resources are ready
       */
      processWhenHaveResources: function processWhenHaveResources(processFunc) {
         if (!hasResources) {
            initResources(function (success) {
               if (success) {
                  hasResources = success;
                  processFunc(true);
               } else {
                  _logservice2.default.logService.log('init resources fail');
                  processFunc(false);
               }
            }.bind(this));
         } else {
            processFunc(true);
         }
      },

      /**
       * onPermissionHandled and setMessageManager are added to handle cases like:
       * start_v, accept_v, start_a, stop_v, start_v, accept_a, accept_v
       * during stop_v we should not release encoders, and only after accept_v,
       * we should check whether we need to release encoders, since we allow the
       * status mismatch happens between client and agent so that agent will not
       * think it need a startstream, and client can't fake it safely, so we have
       * to prevent that case from happening from a earily stage, which is limite
       * the release of encoders when premiss dialog are pending, and check whether
       * we need to do that after it get dismissed, which should work well under
       * current design of force first desktop to handle all premission dialog then
       * another desktop can use it.
       *
       * one can find a explain why we need this in bug 1750132.
       *
       * So here we need to release encoder if it's not in use.
       */
      onPermissionHandled: function onPermissionHandled() {
         if (!mediaEnc || !mediaEnc.isInited()) {
            return;
         }
         if (mediaEnc.notInUse()) {
            _logservice2.default.logService.debug("clear encoders after premission dialog dismissed");
            mediaEnc.clear();
         }
      },

      /**
       * set messageManager into encoder so that we can check the agent-client
       * mis-match status to avoid bug 1750132.
       * Never clear massageManager since it's const and persistent
       * @param {object} manager A DeviceMessageManager instance
       */
      setMessageManager: function setMessageManager(manager) {
         massageManager = manager;
         if (!!mediaEnc) {
            mediaEnc.setMessageManager(manager);
         }
      },

      /**
       * restart stream will ensure the stream status in the media capture is started
       * i.e. it will start the stream if it has not started yet
       */
      restartStream: function restartStream() {
         if (!this.deviceParam) {
            _logservice2.default.logService.debug("restart will not execute before start is called");
            return;
         }
         if (!!src && !src.streamStarted) {
            src.startStream(this.deviceParam, function (data) {
               mediaEnc.encodeAudio(data);
            }, function (data) {
               mediaEnc.encodeVideo(data);
            });
         }
      }
   };
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/
/**
 * @fileoverview rtavsessioncontroller.js -- RtavSessionController
 * Class contains the logic for each rtav action, or how to controll classes to complete
 * a target action like "start streaming" or "enable audio".
 */

;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var settings = {
   // the default setting will be used only when no any agent setting readed.
   video: {
      defMaxFPS: 15, // admin might change this in the broker to avoid to use CPU too much
      defResWidth: 320,
      defResHeight: 240
   },
   audio: {
      sampleRate: 8000,
      channels: 1,
      bitsPerSample: 16
   },
   enabled: true
}; /*********************************************************
    * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
    *********************************************************/
/**
 * @fileoverview rtavsettings.js -- settings
 * settings for rtav feature
 * will support setter and getter for run time change in the next patch
 */

_logservice2.default.settings = settings;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SyncTimer;
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * @fileoverview synctimer.js -- SyncTimer
 * Class to control timer, not support pause yet
 */

function SyncTimer() {
   this.inited = false;
   this.startTime = 0;
};

/**
 * @return {number} return current system time
 */
SyncTimer.prototype.getNow = function () {
   return new Date().getTime();
};

SyncTimer.prototype.isInited = function () {
   return this.inited;
};
/**
 * reset the timer to init status
 */
SyncTimer.prototype.reset = function () {
   this.startTime = this.getNow();
   this.inited = true;
};

SyncTimer.prototype.clear = function () {
   this.startTime = 0;
   this.inited = false;
};
/**
 * @return {number} This returns the time from the timer-init moment
 */
SyncTimer.prototype.getTime = function () {
   if (!this.inited) {
      return 0;
   }
   var now = this.getNow();
   return now - this.startTime;
};

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*********************************************************
 * Copyright (C) 2015 VMware, Inc. All rights reserved.
 *********************************************************/
/**
 * @fileoverview typedarraysupport.js -- Uint8Array.from, Int16Array.from
 * In some browsers there are some browser APIs missing(like chrome < 45),
 * so we use this file to define a simple version of these functions which
 * are enough for us to use.
 */



/*global Int16Array, Uint8Array, Array*/

(function () {
   var appendFunction = function appendFunction(ArrayClass, data) {
      var i, typedArray;
      if (!data || !data.length) {
         return null;
      }
      typedArray = new ArrayClass(data.length);
      for (i = 0; i < data.length; i++) {
         typedArray[i] = data[i];
      }
      return typedArray;
   };

   if (!Uint8Array.from) {
      Uint8Array.from = function (data) {
         return appendFunction(Uint8Array, data);
      };
   }
   if (!Int16Array.from) {
      Int16Array.from = function (data) {
         return appendFunction(Int16Array, data);
      };
   }
   if (!Array.from) {
      Array.from = function (data) {
         return appendFunction(Array, data);
      };
   }
})();

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = VideoCapture;

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function VideoCapture() {
   this.inited = false;
   this.frameRateController = new _logservice2.default.FrameRateController();
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/
/**
 * @fileoverview videocapture.js -- VideoCapture
 * Class to handle video capturing
 */

;

VideoCapture.statusEnum = {
   Uninited: 'Uninited',
   Inited: 'Inited',
   Working: 'Working'
};
/**
 * Get what status this video src is in, cuurently only Uinited is detected, but keep the API as it
 * for future extension and debugging
 * @return {string} This returns one of the VideoCapture.statusEnum of 'Uninited', 'Inited', 'Working'
 */
VideoCapture.prototype.getStatus = function () {
   var status = void 0;
   if (!this.inited) {
      status = VideoCapture.statusEnum['Uninited'];
   } else {
      if (this.sessionID < 0) {
         status = VideoCapture.statusEnum['Inited'];
      } else {
         status = VideoCapture.statusEnum['Working'];
      }
   }
   return status;
};

/**
 * Deconstructure function, should be called when want to change the param, nor
 * we want a brand now capturing session.
 */
VideoCapture.prototype.clear = function () {
   if (!this.inited) {
      _logservice2.default.logService.error('this video capture is not inited, clear fail');
      return;
   }
   if (this.sessionID >= 0) {
      _logservice2.default.logService.debug('negative: the video capture is not stopped yet, stop it before clear it.');
      this.stop();
   }
   this.video = null;
   this.canvas = null;
   this.ctx = null;
   this.inited = false;
   this.syncTimer = null;
   this.dataCallback = null;
   this.losingDevice = false;
   this.deviceUnpluged = false;
   this.localStream = null;
};

/**
 * Init capturing video by binding events to the passed in stream, and later for each frame, call
 * the callback with it.
 * Similar to mVdoInput.Open for native clients, use prefs and timer, but here also pass in stream
 * and callback which is done differently for native clients.
 * and the caller should be similar to VCamServer::InitVideoSrcDev, to reset sync timer if needed.
 * it looks like "open" but the real open didn't happen here, it's acctually init the opened source,
 * we do not open it here to avoid anoying hint diaglog which is forced by some browsers like firefox.
 *
 * @param  {object} videoParam The parameter object that contains width, height and fps
 * @param  {object} syncTimer The timer object user to sync the audio and video
 * @param  {function} callback The frame dealing function for each frame
 */
VideoCapture.prototype.init = function (videoParam, syncTimer, callback) {
   if (this.inited) {
      _logservice2.default.logService.error('this video capture has already been inited, init fail');
      return;
   }
   if (typeof callback !== 'function') {
      return;
   }

   this.width = videoParam.width;
   this.height = videoParam.height;
   this.fps = videoParam.fps;
   this.frameRateController.setFPS(this.fps);

   this.dataCallback = callback;
   // Adjust size
   this.video = document.getElementById("video");
   this.video.setAttribute('width', this.width);
   this.video.setAttribute('height', this.height);
   // mute the video to fix bug 1587389
   this.video.volume = 0;
   // Adjust size
   this.canvas = document.getElementById("canvas");
   this.canvas.setAttribute('width', this.width);
   this.canvas.setAttribute('height', this.height);
   this.ctx = this.canvas.getContext('2d');
   if (!this.video || !this.canvas || !this.ctx || this.width !== this.canvas.width || this.height !== this.canvas.height) {
      return;
   }
   /**
    * use sessionID without sessionCount can also controll the workflow, but one can
    * not detect the error for calling start or stop with undesired timing, so do not
    * pick that design.
    */
   this.sessionID = -1; //current working sesssion ID
   this.sessionCount = 0; //total working session number ever created

   this.syncTimer = syncTimer;
   this.inited = true;
};

/**
 * Start capturing video, and if there is another working session, do nothing.
 * @param  {object} stream The stream object obtained by the getUserMedia
 */
VideoCapture.prototype.start = function (stream) {
   if (!stream) {
      _logservice2.default.logService.error('the video stream is not valid, start fail');
      return;
   }
   if (!this.inited) {
      _logservice2.default.logService.error('the video capture is not being inited, start fail');
      return;
   }
   if (this.sessionID >= 0) {
      _logservice2.default.logService.error('find existing video capturing session, start fail');
      return;
   }

   this.video.src = window.URL.createObjectURL(stream);
   this.localStream = stream;

   this.sessionID = this.sessionCount;
   this.sessionCount++;
   this.lastValidTime = -1;
   this.freezeCount = 0;
   this.losingDevice = false;
   this.deviceUnpluged = false;
   this.getNextFrame(this.sessionID);
};

/**
 * Stop capturing data, and enter waiting status.
 * The coming getNextFrame with old sessionID will not be processed after this call.
 */
VideoCapture.prototype.stop = function () {
   if (!this.inited) {
      _logservice2.default.logService.error('the video capture is not being inited, stop fail');
      return;
   }
   if (this.sessionID < 0) {
      _logservice2.default.logService.debug('find no video capturing session, skip stop');
      return;
   }
   this.losingDevice = false;
   this.deviceUnpluged = false;
   this.sessionID = -1;
};

/**
 * Will fetch a new frame if this.sessionID is the same of this.sessionID to handle
 * the async workflow of stop_V and start_V
 * maxFPS not supported yet, which it's a trival feature(would do later).
 *
 * @private
 * @param {number} sessionID The number use to mark the video srcource session,
 *     which is identical from a start_V to a stop_V to avoid parallel capturing.
 */
VideoCapture.prototype.getNextFrame = function (sessionID) {
   setTimeout(function () {
      if (!this.inited) {
         return;
      }
      if (this.sessionID < 0 && this.sessionID !== sessionID) {
         return;
      }
      var imgData = void 0,
          timeStamp = this.syncTimer.getTime();

      this.updateActiveStatus();
      this.ctx.drawImage(this.video, 0, 0, this.width, this.height);
      imgData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
      this.frameRateController.onFrameCaptured();
      this.dataCallback({
         data: imgData.data.buffer,
         timeStamp: timeStamp,
         others: {
            callbackParam: sessionID,
            callback: this.getNextFrame.bind(this)
         }
      });
   }.bind(this), this.frameRateController.getWaitTime());
};

/**
 * Update the device active status
 */
VideoCapture.prototype.updateActiveStatus = function () {
   var freezeTolerence = this.fps / 2 + 2;

   if (!!this.video.currentTime) {
      if (this.video.currentTime === this.lastValidTime) {
         this.freezeCount = this.freezeCount + 1;
         if (!this.losingDevice && this.freezeCount > freezeTolerence) {
            this.losingDevice = true;
            _logservice2.default.logService.debug('negative: seems the video device becomes invalid, please check');
            _logservice2.default.resourceManager.emitDeviceStatusChanged();
         }
      } else {
         this.freezeCount = 0;
         if (this.video.currentTime > 0) {
            this.lastValidTime = this.video.currentTime;
         }
         if (this.losingDevice) {
            this.losingDevice = false;
            _logservice2.default.logService.debug('negative: seems the video device becomes valid again, which means it might unstable');
            _logservice2.default.resourceManager.emitDeviceStatusChanged();
         }
      }
   }

   if (!!this.localStream && typeof this.localStream.active === 'boolean') {
      if (!this.localStream.active && !this.deviceUnpluged) {
         this.deviceUnpluged = true;
         _logservice2.default.logService.debug('negative: seems the audio device is unpluged');
         _logservice2.default.resourceManager.emitDeviceStatusChanged();
      }
   }
};

/**
 * This returns whether the device can provide valid data
 */
VideoCapture.prototype.isActive = function () {
   return !this.losingDevice && !this.deviceUnpluged;
};

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _logservice = __webpack_require__(7);

var _logservice2 = _interopRequireDefault(_logservice);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var wmksAdapter = function () {
   var sessionMap = {};
   return {
      /**
       * The function used to add in a wmks session
       * @param {string} sessionId The ID of the session
       * @param {object} session The vvcSession object that passed from wmks
       */
      addSession: function addSession(sessionId, session) {
         if (!_logservice2.default.settings.enabled) {
            return;
         }
         if (!sessionId || !session) {
            _logservice2.default.logService.error('can\'t add a invalid session' + sessionId);
            return;
         }
         sessionMap[sessionId] = new _logservice2.default.RtavSession(sessionId, session);
      },

      /**
       * The function used to remove a wmks session, should be call when the corresponding
       * session becomes invalid
       * @param {string} sessionId The ID of the session
       */
      removeSession: function removeSession(sessionId) {
         if (!_logservice2.default.settings.enabled) {
            return;
         }
         if (!sessionId || !sessionMap[sessionId]) {
            _logservice2.default.logService.error('can\'t remove a not-exist session' + sessionId);
            return;
         }
         sessionMap[sessionId].stop();
         if (sessionMap.hasOwnProperty(sessionId)) {
            delete sessionMap[sessionId];
         }
      },

      /**
       * The function used to active the rtav session on a valid wmks session, should be
       * called when the corresponding session becomes valid
       * The active means establish rtav sub vvc channel, and finishing the configuring steps,
       * and also tries to process the agent request when device can be obtained.
       * Currently, There can many actived sessions, which means there are many rtav sessions on
       * going, but only one session can send streaming data to the agent since we only allow one
       * to access to the device and encoder to avoid cosuming too much of resources.
       * @param {string} sessionId The ID of the session
       */
      activeSession: function activeSession(sessionId) {
         if (!_logservice2.default.settings.enabled) {
            return;
         }
         if (!sessionId || !sessionMap[sessionId]) {
            _logservice2.default.logService.error('can\'t active a not-exist session' + sessionId);
            return;
         }
         sessionMap[sessionId].start();
      },

      userStopSession: function userStopSession(sessionId) {
         if (!_logservice2.default.settings.enabled) {
            return;
         }
         if (!sessionId || !sessionMap[sessionId]) {
            _logservice2.default.logService.error('can\'t stop a not-exist session' + sessionId);
            return;
         }
         sessionMap[sessionId].userStop();
      },

      isUsingDevices: function isUsingDevices(sessionId, type) {
         if (!_logservice2.default.settings.enabled || !sessionId || !sessionMap[sessionId]) {
            return false;
         }
         return sessionMap[sessionId].isUsingDevices(type);
      },

      isAskingPremission: function isAskingPremission(sessionId, type) {
         if (!_logservice2.default.settings.enabled || !sessionId || !sessionMap[sessionId]) {
            return false;
         }
         return sessionMap[sessionId].isAskingPremission(type);
      }
   };
}(); /*********************************************************
      * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
      *********************************************************/
/**
 * @fileoverview wmksadapter.js -- wmksAdapter
 * Service to handle wmks session management
 *
 * Currently only support one wmks to use RTAV at the same time
 * and others have to wait the resources get released by that session
 * when it's closed.
 *
 * Should also support RTAV pause when the RTAV-active session is hidden(P2, minor, feature)
 */

exports.default = wmksAdapter;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = settingsWindowController;

var _jscdkClient = __webpack_require__(2);

var _setUserGlobalPrefHandler = __webpack_require__(13);

var _setUserGlobalPrefHandler2 = _interopRequireDefault(_setUserGlobalPrefHandler);

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

var _dialog_service_confirm = __webpack_require__(26);

var _dialog_service_confirm2 = _interopRequireDefault(_dialog_service_confirm);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function settingsWindowController($scope, $rootScope, $timeout, wmksService, userGlobalPref, entitledItemsService, ngDialog, WMKS, _) {
   // Initialize the prefs handler if this has not already been done
   if (!_jscdkClient.globalArray["set-user-global-preferences"]) {
      _jscdkClient.globalArray["set-user-global-preferences"] = new _setUserGlobalPrefHandler2.default();
   }

   // Whether high res mode is supported
   $scope.isHighResModeSupported = wmksService.isHighResModeSupported();

   // Whether high res mode is enabled or not. Starts off as being
   // disabled.
   $scope.isHighResModeEnabled = wmksService.isHighResModeEnabled();

   /**
    * Variable for determining if the reset applications button is
    * enabled. It will get the newset list every time setting dialog
    * is opened.
    */
   entitledItemsService.hasApplicationSession().then(function (applicationSessions) {
      $scope.resetButtonEnabled = !!applicationSessions && applicationSessions.length > 0;
   });

   $scope.areMacOSXKeyMappingsSupported = wmksService.areMacOSXKeyMappingsSupported();

   $scope.areMacOSXKeyMappingsEnabled = wmksService.areMacOSXKeyMappingsEnabled();

   $scope.isMacOS = wmksService.isMacOS();
   // Whether Windows key simulation is enabled.
   $scope.isWindowsKeyEnabled = wmksService.isWindowsKeyEnabled();

   $scope.isMP4Enabled = wmksService.isMP4Enabled();

   $scope.enableDPISync = userGlobalPref.getPrefData().enableDPISync === 'true';

   /*
    * toggleDPISync
    *
    * wrapped with multimon imcompatible detection
    * Since the binding is totally invalid, I think it's a good idea to
    *    use the setting dialog in launcher page...
    * This change is just making it working again, and refactory is needed
    *    for this wired service...
    *
    * p.s. use userGlobalPref to get value since this value is not store
    *    into the wmksService as other settings.
    */
   $scope.toggleDPISync = function () {
      wmksService.whenNotInMultimon(function () {
         $scope._toggleDPISync();
         $timeout(function () {
            $scope.toggleSwitches[0].isEnabled = userGlobalPref.getPrefData().enableDPISync === 'true';
         });
      });
      $timeout(function () {
         $scope.toggleSwitches[0].isEnabled = userGlobalPref.getPrefData().enableDPISync === 'true';
      });
   };

   /*
    * toggleMP4
    */
   $scope.toggleMP4 = function () {
      wmksService.whenNotInMultimon(function () {
         $scope._toggleMP4();
         $timeout(function () {
            $scope.toggleSwitches[3].isEnabled = $scope.isMP4Enabled;
         });
      });
      $timeout(function () {
         $scope.toggleSwitches[3].isEnabled = $scope.isMP4Enabled;
      });
   };

   /*
    * Method for toggling OSX Key mappings.
    */
   $scope.toggleUseMacOSXKeyMappings = function () {
      $scope.areMacOSXKeyMappingsEnabled = wmksService.toggleUseMacOSXKeyMappings();

      userGlobalPref.updatePrefData({
         name: 'useMacOSXKeyMappings',
         text: $scope.areMacOSXKeyMappingsEnabled ? "true" : "false",
         action: 'useMacOSXKeyMappings'
      });
      userGlobalPref.postPrefData();
   };

   /*
    * toggleWindowsKey
    *
    * Method for toggling Windows key simulation functionality.
    */
   $scope.toggleWindowsKey = function () {
      $scope.isWindowsKeyEnabled = wmksService.toggleWindowsKey();

      userGlobalPref.updatePrefData({
         name: 'enableWindowsKey',
         text: $scope.isWindowsKeyEnabled ? "true" : "false",
         action: 'enableWindowsKey'
      });
      userGlobalPref.postPrefData();
   };

   $scope._toggleDPISync = function () {
      $scope.enableDPISync = !$scope.enableDPISync;
      userGlobalPref.updatePrefData({
         name: 'enableDPISync',
         text: $scope.enableDPISync ? "true" : "false",
         action: 'enableDPISync'
      });
      userGlobalPref.postPrefData();
      wmksService.toggleHighResMode();
   };

   /*
    * _toggleMP4
    *
    * Method for toggling MP4 functionality.
    */
   $scope._toggleMP4 = function () {
      $scope.isMP4Enabled = wmksService.toggleMP4();

      userGlobalPref.updatePrefData({
         name: 'enableMP4',
         text: $scope.isMP4Enabled ? "true" : "false",
         action: 'enableMP4'
      });
      userGlobalPref.postPrefData();
   };

   $scope.toggleSwitches = [{
      id: 'dpi_syc',
      label: _('DPI_SYNC_M'),
      isSupported: $scope.isHighResModeSupported,
      isEnabled: $scope.enableDPISync,
      toggle: $scope.toggleDPISync
   }, {
      id: 'osx-keys',
      label: _('USE_OSX_KEY_MAPPINGS_M'),
      isSupported: wmksService.areMacOSXKeyMappingsSupported(),
      isEnabled: $scope.areMacOSXKeyMappingsEnabled,
      toggle: $scope.toggleUseMacOSXKeyMappings
   }, {
      id: 'win-key',
      label: _('ENABLE_WINDOWS_KEY_T'),
      text: _('ENABLE_WINDOWS_KEY_M', $scope.isMacOS ? _('CMD_KEY') : _('WIN_KEY')),
      isSupported: !WMKS.BROWSER.isIOS() && !WMKS.BROWSER.isAndroid(),
      isEnabled: $scope.isWindowsKeyEnabled,
      toggle: $scope.toggleWindowsKey
   }, {
      id: 'mp4',
      label: _('ALLOW_MP4_T'),
      isSupported: wmksService.isMP4Supported(),
      isEnabled: $scope.isMP4Enabled,
      toggle: $scope.toggleMP4
   }];

   /**
    * _resetResultCallback
    *
    * Callback to handle the response from attempting to reset all
    * apps. Brings up an error dialog if necessary.
    *
    * @param response the response from the server
    */
   function _resetResultCallback(response) {
      _appblastUtil2.default.LOGGER.log(response);
      $rootScope.$emit('toggleBusyOverlay');
      if (!response.success) {
         // tell the wmksService that our attempt to reset sessions
         // failed for the sessions in response.error.errorDetail
         wmksService.sessionResetDone(response.error.errorDetail);
         ngDialog.open({
            name: "ResetAllError",
            templateUrl: _dialog_service_error2.default,
            showClose: false,
            className: "session-ops-dialog",
            data: { errorMessage: response.error.userMsg }
         });
      }
   }

   /**
    * resetApplications
    *
    * UI Handler for resetting all applications
    */
   $scope.resetApplications = function () {
      _appblastUtil2.default.LOGGER.log("Reset all applications");
      $scope.closeThisDialog();
      ngDialog.openConfirm({
         name: "SessionOpsConfirmation",
         templateUrl: _dialog_service_confirm2.default,
         showClose: false,
         className: "session-ops-dialog",
         closeByDocument: false,
         data: {
            title: _('RESET_APPS_T'),
            message: _('RESET_APPS_M'),
            showWarning: true
         }
      }).then(function () {
         $rootScope.$emit('toggleBusyOverlay');
         wmksService.prepareForSessionReset();
         entitledItemsService.resetAllApplications(_resetResultCallback);
      });
   };
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * modal-dialog.js --
 *
 * Module to implement modal dialogs for the Blast UI using Angular JS.
 *
 */

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = contextMenuManager;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * context-menu-manager.js --
 *
 * Module for handling context menus. The module makes sure that only one
 * context menu is opened at a time and that clicking outside of the context
 * menu closes it. The ContextMenuManager exposes two methods. toggleMenu and
 * closeMenu detailed below.
 */

function contextMenuManager($window) {
   var contextMenuManager = {
      openedMenuId: null,
      closeCallback: null,
      scope: null
   },


   /**
    * Callback to be used to handle body click events when a context menu
    * is opened. If a menu is opened the callback will close it. It will
    * then unregister itself.
    *
    * @param e the jquery event for the click
    */
   bodySettingsMenuOpenedClickHandler = function bodySettingsMenuOpenedClickHandler(e) {
      if (contextMenuManager.openedMenuId) {
         contextMenuManager.closeCallback();
         contextMenuManager.scope.$apply();
         contextMenuManager.openedMenuId = null;
         contextMenuManager.closeCallback = null;
      }
      $(document).off("click", bodySettingsMenuOpenedClickHandler);
   };

   /**
    * Opens a menu with a given id. The exact behavior depends on whether
    * another menu is opened and what its id is:
    *
    * - If no other menu is opened it opens the menu
    * - If the currently opened menu has the same id as menuId that menu
    *   is closed and no other action is taken.
    * - If the currently openend menu has an id other than menuId that menu
    *   is closed and the new menu is opened.
    *
    * @param menuId an id for the menu to be opened
    * @param scope the scope under which operations to open and close the
    *    menu should take place
    * @param openCallback a callback to be used to open the menu
    * @param closeCallback a callback to be used to close the menu
    */
   contextMenuManager.toggleMenu = function (menuId, scope, openCallback, closeCallback) {
      var currentMenuId = contextMenuManager.openedMenuId;

      if (currentMenuId) {
         contextMenuManager.closeCallback();
         $(document).off("click", bodySettingsMenuOpenedClickHandler);
         contextMenuManager.openedMenuId = null;
         contextMenuManager.closeCallback = null;
      }

      if (currentMenuId === menuId) {
         return;
      }

      openCallback();
      contextMenuManager.openedMenuId = menuId;
      contextMenuManager.closeCallback = closeCallback;
      contextMenuManager.scope = scope;
      $(document).on("click", bodySettingsMenuOpenedClickHandler);
   };

   contextMenuManager.closeMenu = function () {
      if (contextMenuManager.openedMenuId) {
         contextMenuManager.closeCallback();
         $(document).off("click", bodySettingsMenuOpenedClickHandler);
         contextMenuManager.openedMenuId = null;
         contextMenuManager.closeCallback = null;
      }
   };

   return contextMenuManager;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

/**
 * sidebar.js --
 *
 * Module to implement sidebar component for Blast UI.
 *
 */

exports.runningItemsFilter = runningItemsFilter;
exports.availableItemsFilter = availableItemsFilter;
exports.SidebarController = SidebarController;
exports.sidebarDirective = sidebarDirective;

var _sidebar_template = __webpack_require__(266);

var _sidebar_template2 = _interopRequireDefault(_sidebar_template);

var _settings_window_template = __webpack_require__(265);

var _settings_window_template2 = _interopRequireDefault(_settings_window_template);

var _dialog_service_error = __webpack_require__(10);

var _dialog_service_error2 = _interopRequireDefault(_dialog_service_error);

var _dialog_service_confirm = __webpack_require__(26);

var _dialog_service_confirm2 = _interopRequireDefault(_dialog_service_confirm);

var _about_dialog = __webpack_require__(59);

var _about_dialog2 = _interopRequireDefault(_about_dialog);

var _multimon_setting_window_template = __webpack_require__(263);

var _multimon_setting_window_template2 = _interopRequireDefault(_multimon_setting_window_template);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _appblastUtil = __webpack_require__(8);

var _appblastUtil2 = _interopRequireDefault(_appblastUtil);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _jscdkBrokerError = __webpack_require__(15);

var _jscdkBrokerError2 = _interopRequireDefault(_jscdkBrokerError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function runningItemsFilter() {
   // Filter for running items given a search query string.
   return function (runningItems, query) {
      var output = [];
      var i = void 0;
      var instanceQueryFilter = function instanceQueryFilter(item) {
         return _appblastUtil2.default.UTIL.itemNameContainsQuery(item, query);
      };

      for (i = 0; i < runningItems.length; i++) {
         if (_appblastUtil2.default.UTIL.isLoadingItem(runningItems[i]) || _appblastUtil2.default.UTIL.isLoadingApp(runningItems[i])) {

            if (query === "") {
               /*
                * The special "Loading" item holds reconnecting sessions, and
                * should only be displayed if and we are not searching for anything.
                */
               runningItems[i].queryInstances = runningItems[i].instances;
               output.push(runningItems[i]);
            }
         } else if (_appblastUtil2.default.UTIL.itemNameContainsQuery(runningItems[i], query)) {
            // If parent app matches, assume all child instances are relevant
            runningItems[i].queryInstances = runningItems[i].instances;
            output.push(runningItems[i]);
         } else {
            // If any child instances match query, both parent app and all
            // matching child apps must be shown.
            var matchedInstances = runningItems[i].instances.filter(instanceQueryFilter);
            if (matchedInstances.length > 0) {
               runningItems[i].queryInstances = matchedInstances;
               output.push(runningItems[i]);
            }
         }
      }
      output.sort(_appblastUtil2.default.UTIL.itemSortHelper);
      return output;
   };
}

function availableItemsFilter() {
   return function (availableItems, query, onlyFavorites) {
      var output = [];

      for (var i = 0; i < availableItems.length; i++) {
         if (!_appblastUtil2.default.UTIL.itemNameContainsQuery(availableItems[i], query)) {
            continue;
         } else if (onlyFavorites && !availableItems[i].favorite) {
            continue;
         }
         output.push(availableItems[i]);
      }

      output.sort(_appblastUtil2.default.UTIL.itemSortHelper);

      return output;
   };
}

function SidebarController($scope, $window, $rootScope, $timeout, unityService, runningItemsModel, contextMenuManager, wmksService, entitledItemsModel, entitledItemsService, userGlobalPref, ngDialog, messageHandlerService, RTAVService, _, WMKS, idleSessionService, wmksServiceEventHandler, commonSvcService, normalizationService) {
   /**
    * SECURITY_SERVER_RESET_ERROR is special handle for bug 1560096.
    * In this case desktop/app cannot be launched after restarting
    * the security server.
    */
   var SECURITY_SERVER_RESET_ERROR = 'failed launching connection: com.vmware.vdi.broker.CoManagerRequiredException: No co-management availability for protocol BLAST',
       PROTOCOL_ERROR = 'Please try connecting via another protocol or logoff the existing session first',
       _searchElem = (0, _jquery2.default)(".search-input"),
       _touchDeviceRunner = void 0;

   // Assign util = AB.UTIL so the view can use it
   $scope.util = _appblastUtil2.default.UTIL;

   // Control global context menu visibility
   $scope.showGlobalContextMenu = false;

   // Control sub menu position and visibility.
   $scope.showItemContextMenu = false;

   // Control content panel visibility.
   $scope.showPanel = false;

   // Control copy/paste buttons visibility
   $scope.showClipboardButton = true;

   // App (or desktop) for which a context menu is open
   $scope.contextMenuItem = null;

   // Declares running items search query object.
   $scope.queryText = {
      "name": ""
   };

   // Whether to show only favorites or not
   $scope.showOnlyFavorites = false;

   // Flag to indicate whether or not the preferences should be persisted
   // when the sidebar is closed
   $scope.arePrefsDirty = false;

   // Promise used to track whether we have an outstanding timeout to
   // persist the perferences
   $scope.prefPromise = null;

   // Whether the Not Authenticated Dialog is open or not
   $scope.notAuthenticatedDialogOpen = false;

   // Stores the idle timeout warning dialog, if open
   $scope.idleTimeoutWarningDialog = null;

   // Stores the multimon setting window dialog, if open
   $scope.multimonSettingWindow = null;

   // controll whether show the avaiable item panel for user to launch
   // them, will be true for HWS
   $scope.showLaunchPanel = false;

   $scope.multimonOptionVisible = false;
   $scope.multimonStarted = false;

   /**
    * Given an app item, toggle the collapsed state of its instances
    * dropdown UI
    *
    * @param currentItem: the current item that requested the toggle
    */
   $scope.toggleIsCollapsed = function (currentItem) {
      if (_appblastUtil2.default.UTIL.isLoadingItem(currentItem) || _appblastUtil2.default.UTIL.isApp(currentItem)) {
         currentItem.isCollapsed = !currentItem.isCollapsed;
      }
   };

   $scope.activateItem = function (currentItem) {
      if (wmksService.isCurrentSession(currentItem.wmksKey)) {
         $scope._activateItem(currentItem);
         return;
      }
      wmksService.whenNotInMultimon(function () {
         $scope._activateItem(currentItem);
      });
   };

   /**
    * Handler to be called when item section is clicked.
    *
    * If we have only one unity window, we will activate this unity
    * Window. If there is more than one unity window we activate the
    * first one only if the app unless on of the windows has focus in
    * which case we bring that one to front.
    *
    * @TODO consider keeping track of the last window used for every app
    *    so we can bring that window to front when the app is activated
    *    via this method.
    *
    * For desktop item, do nothing in Q1 release.
    *
    * @param currentItem        the current item object which is clicked.
    */
   $scope._activateItem = function (currentItem) {
      var index = void 0,
          selectedItem = void 0;

      // The "Loading" item doesn't have an associated wmksKey
      if (!_appblastUtil2.default.UTIL.isLoadingItem(currentItem)) {
         wmksService.changeWmksSession(currentItem.wmksKey);
      }

      if (_appblastUtil2.default.UTIL.isLoadingItem(currentItem) || _appblastUtil2.default.UTIL.isApp(currentItem)) {
         // Only bring this app to front if it is not already in front.
         // Bring up the most recently used window if it is known,
         // otherwise bring up the first window in the instance list.
         if (currentItem.focusedItem === null) {
            if (currentItem.orderedInstances.length > 0) {
               index = currentItem.orderedInstances.length - 1;
               selectedItem = currentItem.orderedInstances[index];
            } else {
               selectedItem = currentItem.instances[0];
            }
         } else {
            selectedItem = currentItem.focusedItem;
         }

         // If we clicked the "Loading" item, set focus to the selected
         // instance
         if (_appblastUtil2.default.UTIL.isLoadingItem(currentItem)) {
            wmksService.changeWmksSession(selectedItem.wmksKey);
         }
         unityService.toggleWindow(selectedItem.wmksKey, selectedItem.windowId);
      }
   };

   $scope.activateWindow = function (runningItem) {
      wmksService.changeWmksSession(runningItem.wmksKey);
      unityService.toggleWindow(runningItem.wmksKey, runningItem.windowId);
   };

   /**
    * _findEntitledItem
    *
    * Helper function that when given a running item will find the
    * matching entitled item.
    *
    * @return the matching entitled item or undefined
    */
   function _findEntitledItem(item) {
      var list = void 0;

      /* istanbul ignore if */
      if (!item) {
         return;
      }

      list = $scope.entitledItems.filter(function (obj) {
         return obj.id === item.wmksKey;
      });

      /* istanbul ignore if */
      if (list.length !== 1) {
         return;
      }

      return list[0];
   }

   _touchDeviceRunner = function _touchDeviceRunner(func) {
      var isIOSSafari = WMKS.BROWSER.isSafari() && WMKS.BROWSER.isIOS(),
          isAndroidChrome = WMKS.BROWSER.isChrome() && WMKS.BROWSER.isAndroid();
      //todo: Add win phone
      if (isIOSSafari || isAndroidChrome) {
         _appblastUtil2.default.LOGGER.log("Touch device supported.");
         return func();
      } else {
         return false;
      }
   };

   /**
    * for Q1 only suuport chrome and firefox to reduce dev efforts
    *    and not support touch device and application sessions to reduce
    *    the testing and bug fixing efforts
    *
    *    set minial chrome version to 55 since it fix a DPI setting bug
    */
   $scope.updateMultimonMenuVisibility = function () {
      var isSupportedBrowser = WMKS.BROWSER.isChrome() && WMKS.BROWSER.version.major >= 55,
          isSupportedDevice = !WMKS.BROWSER.isTouchDevice(),
          currentSessionIsDesktop = wmksService.isCurrentSessionDesktop(),
          agentSupportMultimon = wmksService.hasMultimonCapacity(),
          DPIConnectionReady = wmksService.isCurrentSessionHasDPIChannelInited();

      $scope.multimonOptionVisible = isSupportedBrowser && isSupportedDevice && currentSessionIsDesktop && agentSupportMultimon && DPIConnectionReady;
   };

   $scope.globalContextMenuClicked = function (event) {
      $scope.updateMultimonMenuVisibility();
      contextMenuManager.toggleMenu("globalContext", $scope, function () {
         $scope.showGlobalContextMenu = true;
      }, function () {
         $scope.showGlobalContextMenu = false;
      });
      event.stopPropagation();
   };

   $scope.contextMenuClicked = function (runningItem, event) {
      contextMenuManager.toggleMenu(runningItem, $scope, function () {

         var entitledDesktop = _appblastUtil2.default.UTIL.isDesktop(runningItem) && _findEntitledItem(runningItem);

         (0, _jquery2.default)('.menu.item-context').css({
            top: event.target.getBoundingClientRect().top + 'px'
         });

         $scope.contextMenuItem = runningItem;
         $scope.showLogOffDesktop = !!entitledDesktop && !entitledDesktop.isShadow;

         $scope.showResetDesktop = !!entitledDesktop && entitledDesktop['reset-allowed-on-session'] === 'true';

         $scope.showRestartDesktop = !!entitledDesktop && entitledDesktop['reset-allowed-on-session'] === 'true' && _util2.default.brokerSupportRestartDesktop();

         $scope.showItemContextMenu = true;
      }, function () {
         $scope.contextMenuItem = null;
         $scope.showItemContextMenu = false;
      });
      event.stopPropagation();
   };

   $scope.ctrlAltDeleteClicked = function () {
      _appblastUtil2.default.LOGGER.log("Sending ctrl-alt-delete to active session.");
      wmksService.sendCtrlAltDel();
   };

   $scope.escClicked = function () {
      _appblastUtil2.default.LOGGER.log("Sending esc to active session.");
      wmksService.sendEsc();
   };

   /**
    * _sessionOpResultCallback
    *
    * Callback to handle results from a session operation call. Pops up an
    * error dialog if the call fails.
    *
    * @param item the item on which the call was performed.
    * @param response the response to the session operation call.
    */
   function _sessionOpResultCallback(item, response) {
      _appblastUtil2.default.LOGGER.log(response);
      $rootScope.$emit('toggleBusyOverlay');
      if (!response.success) {
         wmksService.sessionResetDone([item.wmksKey]);
         $scope.showErrorMessage(null, { rawMessage: response.error.userMsg });
      }
   }

   /**
    * _confirmSessionOp
    *
    * Helper function to bring up a confirmation dialog before a session
    * operation is performed.
    *
    * @param title the title for the confirmation dialog
    * @param message the message body for the dialog
    * @param callback the callback to invoke if the user clicks on OK.
    */
   function _confirmSessionOp(title, message, callback, currentItem, warning) {
      var item = $scope.contextMenuItem || currentItem,
          isTransferringFile = wmksService.isFileTransferringInSession(item.wmksKey),
          isTransferringPrintFile = wmksService.isPrintFileTransferringInSession(item.wmksKey),
          showWarn = typeof warning === 'undefined' ? true : warning;

      $scope.showPanel = !$scope.showPanel;
      ngDialog.openConfirm({
         name: "SessionOpsConfirmation", // dialog name
         templateUrl: _dialog_service_confirm2.default, // dialog template
         showClose: false, // do not show default close button
         className: "session-ops-dialog", // CSS class name for the dialog
         data: {
            title: title, // title string for the dialog
            message: message, // user readable message
            showWarning: showWarn, // show data loss warning
            isTransferringFile: isTransferringFile, // Whether some
            // desktop is
            // transferring file
            isTransferringPrintFile: isTransferringPrintFile
         },
         closeByEscape: true, // allow escape to close window
         closeByDocument: false // disallow clicking on background to
         // close window
      }).then(function () {
         if (wmksService.isCurrentSession(item.wmksKey)) {
            wmksService.quitMultimon();
         }
         callback(item);
      });
   }

   $scope.closeRunningApp = function (currentItem) {
      var i = 0,
          sortedInstances = void 0,
          instanceIds = [];

      if (!currentItem) {
         return;
      }

      _appblastUtil2.default.LOGGER.log("Close current item " + currentItem.name);
      if (_appblastUtil2.default.UTIL.isDesktop(currentItem)) {
         _confirmSessionOp(_("CLOSE_DESKTOP_T"), _("CLOSE_DESKTOP_M", $scope.contextMenuItem.name), function () {
            wmksService.requestDisconnect(currentItem.wmksKey);
         });
      } else {
         // Create a shallow copy of instances and sort on window name
         sortedInstances = currentItem.instances.slice();
         sortedInstances.sort(function (a, b) {
            return a.name.localeCompare(b.name);
         });

         // Close all instances in sorted order
         for (i = 0; i < sortedInstances.length; i++) {
            instanceIds.push(sortedInstances[i].windowId);
         }
         unityService.closeWindows(currentItem.wmksKey, instanceIds);
      }
   };

   /**
    * _logOffDesktopCallback
    *
    * Callback to log off a desktop.
    *
    * @param item the desktop to log off.
    */
   function _logOffDesktopCallback(item) {
      $rootScope.$emit('toggleBusyOverlay');
      entitledItemsService.killItem(item.wmksKey || item.id, entitledItemsService.itemTypeEnum.desktop, function (response) {
         _sessionOpResultCallback(item, response);
      });
   }

   /*
    _toggleShowPanel
    *
    * Toggles whether the sidebar is shown. On hide, persist dirty prefs
    */
   function _toggleShowPanel() {
      $timeout(function () {
         var showPanel = !$scope.showPanel,
             panelElement = (0, _jquery2.default)('.apps-panel');

         $scope.showPanel = !$scope.showPanel;
         contextMenuManager.closeMenu();

         if (panelElement && panelElement[0]) {
            panelElement[0].scrollTop = 0;
         }
         $scope.queryText = {
            "name": ""
         };

         $scope.showLaunchPanel = !messageHandlerService.isFromHWS();

         // If the prefs are dirty persist them
         if (!$scope.showPanel && $scope.arePrefsDirty) {
            $scope.prefPromise = $timeout(function () {
               userGlobalPref.postPrefData();
               $scope.arePrefsDirty = false;
               $scope.prefPromise = null;
            });
         }

         _touchDeviceRunner(function () {
            if (!showPanel && _searchElem.is(":focus")) {
               _searchElem.blur();
            }
         });
      });
   }

   // Bug 1823043 the element's height is calculted wrong.
   function _reviseAppPanelHeight() {
      // 98 is head-panel's height. Can't use $(".head-panel").height()
      // becasue the value is 0.
      var height = (0, _jquery2.default)("body").height() - 98;
      (0, _jquery2.default)(".apps-panel").css("max-height", height + "px");
   }

   /**
    * logOffDesktop
    *
    * UI handler for logging of a desktop.
    */
   $rootScope.collapseSidebar = function () {
      if ($scope.showPanel) {
         _toggleShowPanel();
      }
   };

   /**
    * logOffDesktop
    *
    * UI handler for logging of a desktop.
    */
   $scope.logOffDesktop = function () {
      _appblastUtil2.default.LOGGER.log("Log off Desktop: " + $scope.contextMenuItem.name);
      _confirmSessionOp(_("LOGOFF_DESKTOP_T"), _("LOGOFF_DESKTOP_M", $scope.contextMenuItem.name), _logOffDesktopCallback);
   };

   /**
    * _resetDesktopCallback
    *
    * Callback to reset a desktop.
    *
    * @param item the desktop to reset.
    */
   function _resetDesktopCallback(item) {
      $rootScope.$emit('toggleBusyOverlay');
      wmksService.prepareForSessionReset(item.wmksKey);
      entitledItemsService.resetDesktop(item.wmksKey, function (response) {
         _sessionOpResultCallback(item, response);
      });
   }

   /**
    * isRunningDesktopExist
    *
    * Check if there is running desktop session.
    *
    */
   $scope.isRunningDesktopExist = function () {
      for (var i = 0; i < $scope.runningItems.length; i++) {
         if (_appblastUtil2.default.UTIL.isDesktop($scope.runningItems[i])) {
            return true;
         }
      }
      return false;
   };

   /**
    * resetDesktop
    *
    * UI handler for resetting a desktop.
    */

   $scope.resetDesktop = function () {
      _appblastUtil2.default.LOGGER.log("Reset Desktop: " + $scope.contextMenuItem.name);
      $scope.showPanel = !$scope.showPanel;
      _confirmSessionOp(_("RESET_DESKTOP_T"), _("RESET_DESKTOP_M", $scope.contextMenuItem.name), _resetDesktopCallback);
   };

   /**
    * _restartDesktopCallback
    *
    * Callback to reset a desktop.
    *
    * @param item the desktop to reset.
    */
   function _restartDesktopCallback(item) {
      $rootScope.$emit('toggleBusyOverlay');
      wmksService.prepareForSessionReset(item.wmksKey);
      entitledItemsService.restartDesktop(item.wmksKey, function (response) {
         _sessionOpResultCallback(item, response);
      });
   }

   /**
    * restartDesktop
    *
    * UI handler for restarting a desktop.
    */

   $scope.restartDesktop = function () {
      _appblastUtil2.default.LOGGER.log("Restart Desktop: " + $scope.contextMenuItem.name);
      $scope.showPanel = !$scope.showPanel;
      _confirmSessionOp(_("RESTART_DESKTOP_T"), _("RESTART_DESKTOP_M", $scope.contextMenuItem.name), _restartDesktopCallback, null, false);
   };

   /*
    * Handler for the settings menu button.
    *
    * @param [in] e the jquery click event
    */
   $scope.settingsClicked = function () {
      ngDialog.open({
         name: "SettingsWindow", // dialog name
         templateUrl: _settings_window_template2.default, // dialog template
         className: "settings-window", // CSS class name
         controller: "settingsWindowController", // Window controller
         showClose: false, // do not show close button
         closeByEscape: true, // allow escape to close window
         closeByDocument: true // allow clicking on background to close
         // window
      });
   };

   /**
    * In Q1, we use the dialog to show 2 vertial display message since user
    *    is doing valid operations but the result is not a valid horizon
    *    multimon setting.
    * p.s. dialog service is suggested to procide identical API with options as
    *    dialogService.error(contentKey, optimalOptions);
    */
   $scope.showErrorMessage = function (contentKey, options) {
      options = options || {};
      ngDialog.open({
         name: "SessionOpsError", // dialog name
         templateUrl: _dialog_service_error2.default, // dialog template
         showClose: false, // do not show the default close button
         className: "session-ops-dialog", // css class to apply
         data: {
            errorMessage: options.rawMessage || _(contentKey, options.massageParam)
         }, // data object for $scope.ngDialogData
         closeByEscape: true, // allow escape to close window
         closeByDocument: true // allow clicking on background to
         // close window
      });
   };

   /**
    * This dialog is added accoring to PM's request
    */
   $scope.showWarningMessage = function (contentKey, options) {
      options = options || {};
      ngDialog.open({
         name: "SessionOpsWarning", // dialog name
         templateUrl: _dialog_service_error2.default, // dialog template
         showClose: false, // do not show the default close button
         className: "session-ops-dialog", // css class to apply
         data: {
            title: _("WARNING"),
            errorMessage: options.rawMessage || _(contentKey, options.massageParam)
         }, // data object for $scope.ngDialogData
         closeByEscape: true, // allow escape to close window
         closeByDocument: true // allow clicking on background to
         // close window
      });
   };

   /*
    * Handler for the multimon menu button.
    *
    * @param [in] e the jquery click event
    */
   $scope.multimonClicked = function () {
      var enableHighResolution = userGlobalPref.getPrefData().enableDPISync === 'true';

      normalizationService.setAgentDPI(wmksService.getCurrentSessionDPI());
      normalizationService.setDPISync(!enableHighResolution);
      $scope.multimonSettingWindow = ngDialog.open({
         name: "MultimonSettingWindow", // dialog name
         templateUrl: _multimon_setting_window_template2.default, // dialog template
         className: "settings-window", // CSS class
         controller: "multimonSettingWindowController", // Window controller
         showClose: false, // do not show close button
         closeByEscape: false, // do not allow escape to close window
         closeByDocument: false // do not allow clicking on background to
         // close
      });
      $scope.multimonSettingWindow.closePromise.then(function () {
         $scope.multimonSettingWindow = null;
      });
   };

   /*
    * Handler for the exit multimon menu button.
    *
    * @param [in] e the jquery click event
    */
   $scope.exitMultimonClicked = function () {
      $scope.ExitMultimonDialog = ngDialog.open({
         name: "ExitMultimon",
         templateUrl: _dialog_service_confirm2.default,
         className: "session-ops-dialog",
         data: {
            title: _('MM_QUIT_MULTIMON_T'),
            message: _('MM_QUIT_MULTIMON_M'),
            buttonLabelConfirm: _('OK'),
            buttonLabelCancel: _('CANCEL')
         },
         showClose: false,
         closeByEscape: true,
         closeByDocument: true,
         scope: function () {
            $scope.close = function () {
               $scope.ExitMultimonDialog.close();
            };
            $scope.confirm = function () {
               wmksService.quitMultimon();
               $scope.ExitMultimonDialog.close();
            };
            return $scope;
         }()
      });
   };

   /*
    * Handler for the about menu button.
    *
    * @param [in] e the jquery click event
    */
   $scope.aboutClicked = function () {
      _appblastUtil2.default.LOGGER.log("About");
      ngDialog.open({
         name: "AboutWindow", // dialog name
         templateUrl: _about_dialog2.default, // dialog template
         className: "about-window", // CSS class
         showClose: false, // do not show close button
         closeByEscape: true, // allow escape to close window
         closeByDocument: true // allow clicking on background to close
      });
   };

   $scope.toggleKeyboard = function () {
      _appblastUtil2.default.LOGGER.log("Toggle keyboard");
      wmksService.launchKeyboard();
   };

   $scope.isSupportedMobileDevice = function () {
      return _touchDeviceRunner(function () {
         return true;
      });
   };

   $scope.isTouchDevice = function () {
      return WMKS.BROWSER.isTouchDevice();
   };

   // need to remove the hover property
   _touchDeviceRunner(function () {
      _angular2.default.element('#cad').removeClass('icon-button-hover');
      _angular2.default.element('#clipboard').removeClass('icon-button-hover');
      _angular2.default.element('#contextMenu').removeClass('icon-button-hover');
   });

   /*
    * Handler to toggle clipboard panel visibility
    */
   $scope.openClipboardClicked = function () {
      $rootScope.$emit('toggleClipboardPanel');
   };

   /*
    * Handler to toggle file transfer panel visibility
    */
   $scope.openFileTransferPanel = function () {
      $rootScope.$emit('toggleFileTransferPanel');
   };

   /*
    * Callback to be invoked once the user confirms that they want to log out
    */
   function _logoutCallback() {
      _appblastUtil2.default.LOGGER.log("User confirmed logout");
      $rootScope.$emit('toggleBusyOverlay');

      wmksService.quitMultimon();

      wmksService.requestDisconnect();
   }

   /*
    * Handler for when the logout button is clicked.
    *
    * @Note: We do not stop propagation of the event to allow the body handler to
    *        fire. This will close the settings menu for us.
    */
   $scope.logoutClicked = function () {
      ngDialog.openConfirm({
         name: "DisconnectDialog",
         templateUrl: _dialog_service_confirm2.default,
         className: "session-ops-dialog",
         data: {
            title: _('CONFIRM_LOGOFF_BROKER_T'),
            message: _('CONFIRM_LOGOFF_BROKER_M'),
            showWarning: false
         },
         showClose: false,
         closeByEscape: true, // allow escape to close window
         closeByDocument: false // disallow clicking on background to
         // close window
      }).then(_logoutCallback);
   };

   commonSvcService.init(wmksService);

   $scope.runningItems = runningItemsModel.getRunningItems();

   runningItemsModel.addEventListener("valueChanged", function () {
      // hide the application context menu if the sidebar contents
      // have changed
      contextMenuManager.closeMenu();
      $scope.$apply();
   });

   runningItemsModel.addEventListener("noVisibleWindow", function () {
      if (!$scope.showPanel) {
         _toggleShowPanel();
      }

      // If there is no running desktop session, close ft panel
      if (!$scope.isRunningDesktopExist()) {
         $rootScope.$emit('toggleFileTransferPanel', true);
      }
   });

   // Close selected item.
   $scope.closeRunningInstance = function (instance) {
      unityService.closeWindow(instance.wmksKey, instance.windowId);
   };

   $scope.entitledItems = entitledItemsModel.getEntitledItems();
   entitledItemsModel.addEventListener("valueChanged", function () {
      $timeout(function () {
         $scope.$apply();
      });
   });

   /*
    * Handler to update the list of favorites once user global prefs are read
    */
   $rootScope.$on('userGlobalPrefsRead', function () {
      var prefs = userGlobalPref.getPrefData(),
          i = void 0,
          length = $scope.entitledItems.length;

      if (prefs && prefs.favorites) {
         for (i = 0; i < length; i++) {
            $scope.entitledItems[i].favorite = prefs.favorites.indexOf($scope.entitledItems[i].id) !== -1;
         }
      }
   });

   /**
    * _notAuthenticatedCallback
    *
    * Callback to handle not authenticated error. Displays a dialog and
    * then moves the user back to the login page.
    *
    * @param keepConnected: flags whether we should keep the broker
    *    connection, we keep the broker connection on idle disconnect
    * @param errorMsg the human readable message. If this is undefined a
    *    default message will be used.
    */
   function _notAuthenticatedCallback(event, params) {
      var callback = function callback() {
         // Requesting a disconnect should either close this window,
         // or take it back to the login page. But in case it doesn't
         // we want to be able to open another dialog in case a not
         // authenticated error comes from somewhere else
         $scope.notAuthenticatedDialogOpen = false;

         if (params && params.keepConnected) {
            _appblastUtil2.default.UTIL.returnToLauncher();
         } else {
            wmksService.requestDisconnect();
         }
      },
          errorMsg = _('NOT_AUTHENTICATED_M');

      // No need to bring up another dialog if one is opened
      if ($scope.notAuthenticatedDialogOpen) {
         return;
      }

      $scope.notAuthenticatedDialogOpen = true;

      if (params && params.errorMsg) {
         errorMsg = params.errorMsg;
      }

      ngDialog.openConfirm({
         name: "LaunchError",
         templateUrl: _dialog_service_error2.default,
         showClose: false,
         className: "session-ops-dialog",
         data: {
            errorMessage: errorMsg
         },
         closeByEscape: false, // do not allow escape to close window
         closeByDocument: false // do not allow clicking on background to
         // close window
      }).then(callback, callback); // use the same callback regardless of
      // how the dialog is closed
   }

   // Register to handle the not-authenticated event from the
   // idleSessionService
   idleSessionService.addEventListener('not-authenticated', function () {
      _appblastUtil2.default.LOGGER.info("not-authenticated is received");
      $scope.$apply(_notAuthenticatedCallback);
   });

   function _findRunningItemNameById(wmksKey) {
      var runningItems = runningItemsModel.getRunningItems();
      for (var i = 0; i < runningItems.length; i++) {
         if (runningItems[i].wmksKey === wmksKey) {
            return runningItems[i].name;
         }
      }
   }

   /**
    * Will pop out a dialog to confirm whether user wants to steal device
    * from other session.
    * Currently only desktops are supported, once the agent support RTAV
    * with RDSH, this code need to be changed
    * @param {object} info The object of RTAV device stealing, currently
    *    only stolenSessionId exists
    * @param {function} okCallback The ok callback
    * @param {function} cancelCallback The cancel callback
    */
   function _confirmRTAVsessionSteal(info, okCallback, cancelCallback) {
      var stolenDesktopName = void 0;

      if (!!info) {
         stolenDesktopName = _findRunningItemNameById(info.stolenSessionId);
      }
      if (!stolenDesktopName) {
         _appblastUtil2.default.LOGGER.error('invalid session steal');
         return;
      }
      _appblastUtil2.default.LOGGER.log('detect RTAV devices are being used by' + stolenDesktopName);
      ngDialog.open({
         name: "RTAVInitError",
         templateUrl: _dialog_service_error2.default,
         className: "session-ops-dialog",
         data: {
            title: _('RTAV_DEVICE_CONFLICT_T'),
            errorMessage: _("RTAV_DEVICE_CONFLICT_M"),
            buttonLabel: _('OK')
         },
         showClose: false,
         closeByEscape: true,
         closeByDocument: true
      });
      // call the cancelCallback here for we only need to show a error
      // dialog, and then we could send response to the agent.
      cancelCallback();
   }

   RTAVService.setDialogHandler(_confirmRTAVsessionSteal);

   /*
    * check before launch to ensure user will not loss the data for multimon
    */
   $scope.launchItem = function (item) {
      wmksService.whenNotInMultimon(function () {
         $scope._launchItem(item);
      });
   };

   /*
    * Launch item when user click on the entitled items.
    *
    * Todo: How to handle failure case. Popup a dialog or retry. :)
    *
    * @param item item to be launched.
    */
   $scope._launchItem = function (item) {
      var onDone = function onDone(response) {
         $rootScope.$emit('toggleBusyOverlay', false);
         // if the item is available, clear the timeout
         if (!!$scope.timeoutID) {
            clearTimeout($scope.timeoutID);
            $scope.timeoutID = null;
         }
         //close the server not response dialog here.
         if ($scope.serverNotRespondingDialog) {
            $scope.serverNotRespondingDialog.close();
         }
         if ((typeof response === 'undefined' ? 'undefined' : _typeof(response)) === 'object' && !response.success) {
            if (response.error && response.error.errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_DESKTOP_LAUNCH_ERROR && response.error.userMsg.indexOf(PROTOCOL_ERROR) > -1) {
               /*
                * If we start an RDP connection to a RDSH agent,
                * then try to steal the session from HTML Access,
                * we get an error saying "you have an existing session
                * that cannot be reconnected to with the specified protocol.
                * In this case, prompt the user whether to logoff from the RDP session.
                */
               _appblastUtil2.default.LOGGER.log("Log off Desktop: " + item.name);
               _confirmSessionOp(_("LOGOFF_RDP_SESSION_T"), _("LOGOFF_RDP_SESSION_M", item.name), _logOffDesktopCallback, item, false);
            } else if (response.error && response.error.errorType !== _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_NOT_AUTHENTICATED && !(response.error && response.error.errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_DESKTOP_LAUNCH_ERROR && response.error.errorMsg === SECURITY_SERVER_RESET_ERROR)) {
               ngDialog.open({
                  name: "LaunchError",
                  templateUrl: _dialog_service_error2.default,
                  showClose: false,
                  className: "session-ops-dialog",
                  data: {
                     errorMessage: response.error.userMsg
                  }
               });
            } else {
               _notAuthenticatedCallback(null, {
                  errorMsg: response.error.userMsg
               });
            }
         } else if ($scope.showPanel) {
            // hides panel on successful item launch
            _toggleShowPanel();
            // If we successfully launch then canLogoff should be
            // "true"
            if (_appblastUtil2.default.UTIL.isDesktop(item)) {
               item.canLogoff = "true";
            }
         }
      };
      $rootScope.$emit('toggleBusyOverlay');
      if (_appblastUtil2.default.UTIL.isApp(item)) {
         // Launch application.
         _appblastUtil2.default.LOGGER.log("Application " + item.name + " has been selected.");
         wmksService.connectToApplication(item.id, item['origin-id'], undefined, onDone, $scope.timeoutHandler);
      } else {
         _appblastUtil2.default.LOGGER.log("Desktop " + item.name + " has been selected.");
         wmksService.connectToDesktop(item.id, item.name, undefined, item.isShadow, onDone);
         $scope.timeoutHandler();
      }
   };

   $scope.timeoutHandler = function () {
      // When 30 seconds expire, display a warning dialog asking user
      // whether to cancel the request.
      $scope.timeoutID = setTimeout(function () {
         $rootScope.isJSCDKResponse = false;
         // Remove busy cursor.
         $rootScope.$emit('toggleBusyOverlay', false);
         $scope.timeoutID = null;
         // if there's no sso dialog, don't show keep connect dialog again.
         if (!!$rootScope.reAuthDialog) {
            return;
         }

         $scope.serverNotRespondingDialog = ngDialog.open({
            name: "ServerNotResponding",
            templateUrl: _dialog_service_confirm2.default,
            className: "session-ops-dialog",
            data: {
               title: _('SERVER_NOT_RESP_T'),
               message: _('SERVER_NOT_RESP_M'),
               buttonLabelConfirm: _('OK'),
               buttonLabelCancel: _('CANCEL')
            },
            showClose: false,
            closeByEscape: true,
            closeByDocument: true,
            scope: function () {
               $scope.close = function () {
                  // Press cancel btn, cancel launching item request.
                  if (!$rootScope.isJSCDKResponse) {
                     entitledItemsService.abortRequest();
                  }
                  $scope.serverNotRespondingDialog.close();
               };

               // use a new function to close the
               // dialog,closeThisDialog can't be rewriten here.
               $scope.confirm = function () {
                  // Press OK btn, keep on waiting
                  if (!$rootScope.isJSCDKResponse) {
                     //if there's no error dialog, display busy cursor
                     $rootScope.$emit('toggleBusyOverlay', true);
                  }
                  $scope.serverNotRespondingDialog.close();
               };
               return $scope;
            }()
         });
      }, 30 * 1000);
   };

   $scope.isCopy = true;
   $scope.isPasted = false;

   /*
    * enableShowOnlyFavorites
    *
    * Callback to enable favorites only mode for the available item list.
    */
   $scope.enableShowOnlyFavorites = function () {
      $scope.showOnlyFavorites = true;
   };

   /*
    * disableShowOnlyFavorites
    *
    * Callback to disable favorites only mode for the available item list.
    */
   $scope.disableShowOnlyFavorites = function () {
      $scope.showOnlyFavorites = false;
   };

   /*
    * toggleFavorite
    *
    * Callback to toggle whether an item should be a favorite or not.
    */
   $scope.toggleFavorite = function (item) {
      item.favorite = !item.favorite;

      userGlobalPref.updatePrefData({
         name: 'favorite',
         text: item.id,
         action: item.favorite ? 'FavOn' : 'FavOff'
      });

      // Mark the prefs as dirty so we persist them when the sidebar is
      // closed.
      $scope.arePrefsDirty = true;
   };

   $scope.$on('togglePanel', function (event, args) {
      _toggleShowPanel();
      _reviseAppPanelHeight();
   });

   $scope.$on('sliderMoveStart', function (event, args) {
      $scope.$apply(function () {
         contextMenuManager.closeMenu();
      });
   });

   $rootScope.setMultimonStarted = function (started) {
      $scope.$apply(function () {
         $scope.multimonStarted = started;
      });
   };

   wmksServiceEventHandler.addEventListener('idleSessionWarning', function () {
      // Don't show more than one warning at a time
      if (!!$scope.idleTimeoutWarningDialog || $scope.notAuthenticatedDialogOpen) {
         return;
      }
      $scope.idleTimeoutWarningDialog = ngDialog.open({
         name: "IdleDisconnectWarningDialog",
         templateUrl: _dialog_service_error2.default,
         className: "session-ops-dialog",
         data: {
            errorMessage: _("DESKTOP_IDLE_WARNING_M"),
            title: _('DESKTOP_IDLE_WARNING_T'),
            buttonLabel: _('OK')
         },
         showClose: false,
         closeByEscape: true,
         closeByDocument: true
      });
      $scope.idleTimeoutWarningDialog.closePromise.then(function () {
         $scope.idleTimeoutWarningDialog = null;
      });
   });

   wmksServiceEventHandler.addEventListener('sessionConnected', function (wmksKey) {
      // On current session connection, close the sidebar
      if ($scope.showPanel && wmksService.isCurrentSession(wmksKey)) {
         _toggleShowPanel();
      }

      if (wmksService.isCurrentSessionApp()) {
         $scope.isCurrentItemApp = true;
         $rootScope.$emit('toggleFileTransferPanel', true);
      } else {
         $scope.isCurrentItemApp = false;
      }
   });

   wmksServiceEventHandler.addEventListener('activeSessionChanged', function (wmksKey) {
      if (wmksService.isCurrentSessionApp()) {
         $scope.isCurrentItemApp = true;
         $rootScope.$emit('toggleFileTransferPanel', true);
      } else {
         $scope.isCurrentItemApp = false;
      }
   });

   wmksServiceEventHandler.addEventListener('sessionDisconnected', function (wmksKey, isApplicationSession) {
      if ($scope.idleTimeoutWarningDialog) {
         $timeout(function () {
            $scope.idleTimeoutWarningDialog.close();
         });
      }

      if (!$scope.showPanel && wmksService.isCurrentSession(wmksKey)) {
         _toggleShowPanel();
      }
   });

   wmksServiceEventHandler.addEventListener('sessionDisconnected', function (wmksKey, isApplicationSession, wasCurrentSession) {
      if (wasCurrentSession) {
         if ($scope.multimonSettingWindow) {
            $timeout(function () {
               $scope.multimonSettingWindow.close();
            });
         }
         wmksService.destroyMultimon();
      }
   });

   wmksServiceEventHandler.addEventListener('sessionDataReady', function (sessionData) {
      $scope.userName = sessionData.user;
      $scope.userInfo = sessionData.user;
      if (!!sessionData.domainName) {
         $scope.userInfo += '@' + sessionData.domainName;
      }
      $scope.desktopInfo = sessionData.desktopName;
   });
   wmksServiceEventHandler.listenerReadyForModule(wmksServiceEventHandler.MODULE_NAME.SIDEBAR);

   // Todo: Rewrite the HTML code for focused feature to avoid call those
   // functions many times.
   /**
    * Any selected application is focused.
    *
    * return true if current application or desktop is focused.
    *
    * @param [in] app the application object.
    */
   $scope.appHasFocus = function (currentItem) {
      return currentItem.isFocusedItem();
   };

   /**
    * Any selected unity window is focused.
    *
    * return true if the app of unity window and unity window itself are
    * both focused
    *
    * @param [in] app the application object.
    */
   $scope.unityWindowHasFocused = function (currentApp, currentItem) {
      return currentApp.isFocusedItem() && currentItem.isFocused;
   };

   /**
    * Handler to be called when the window is resized.
    *
    * Changes the max-height of the apps panel to make sure it scrolls
    * properly.
    */
   function resizeHandler() {
      var newMaxHeight = (0, _jquery2.default)(window).height() - (0, _jquery2.default)('.head-panel')[0].offsetHeight;
      if (newMaxHeight < 0) {
         newMaxHeight = 100;
      }

      (0, _jquery2.default)('.apps-panel').css('max-height', newMaxHeight);
   }

   resizeHandler();

   _angular2.default.element($window).bind('resize', resizeHandler);

   /*
    * Handler to be called when the apps panel is scrolled. Closes a context menu
    * if it is open. Needed because certain types of scrolling events do not
    * issue a mouse down event before hand (example: touch pad scrolling). If
    * the app-panel is scrolled then the menu will no longer line up with the
    * selected app. Instead of trying to move the menu we simply close it.
    */
   function scrollHandler() {
      $scope.$apply(function () {
         contextMenuManager.closeMenu();
      });
   }

   _angular2.default.element((0, _jquery2.default)('.apps-panel')).bind('scroll', scrollHandler);

   $scope.$on('$destroy', function handleDestroyEvent() {
      _angular2.default.element($window).unbind('resize', resizeHandler);
      _angular2.default.element((0, _jquery2.default)('.apps-panel')).unbind('scroll', scrollHandler);
      if (!!$scope.prefsPromise) {
         $timeout.cancel($scope.prefsPromise);
         $scope.prefsPromise = null;
      }
   });

   var launchItem4HWS = function launchItem4HWS(itemType, itemId) {
      var i = void 0,
          item = void 0,
          itemIsApp = void 0,
          targetItem = null;

      for (i = 0; i < $scope.entitledItems.length; i++) {
         item = $scope.entitledItems[i];
         itemIsApp = _appblastUtil2.default.UTIL.isApp(item);
         if ((item.id === itemId || item.name === itemId) && (!itemIsApp && itemType === "Desktop" || itemIsApp && itemType === "Application")) {
            targetItem = item;
         }
      }
      if (!!targetItem) {
         $scope.launchItem(targetItem);
      }
   };
   messageHandlerService.registerLaunchCallback(launchItem4HWS);
}

function sidebarDirective() {
   return {
      restrict: 'ACE',
      transclude: true,
      controller: 'SidebarController',
      scope: {},
      templateUrl: _sidebar_template2.default
   };
}

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function($) {

Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = verticalSliderDirective;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function verticalSliderDirective($window, AB) {
   function link(scope, element) {
      var body = _angular2.default.element(document).find('body'),
          startY = 0,
          maxYValue = function maxYValue() {
         return $window.innerHeight - element[0].offsetHeight;
      },
          clamp = function clamp(y) {
         return AB.UTIL.clamp(y, 0, maxYValue());
      },
          y = clamp(maxYValue() / 2),
          moving = false,
          moved = false;

      element.css({
         top: y + 'px'
      });

      function resizeHandler() {
         y = clamp(y);
         element.css({
            top: y + 'px'
         });
      }

      _angular2.default.element($window).bind('resize', resizeHandler);

      function sidebarMouseMove(event) {
         event.preventDefault();
         event.stopPropagation();
         var oldY = y;
         y = event.pageY - startY;

         y = clamp(y);

         if (y !== oldY) {
            moved = true;
            element.css({
               top: y + 'px'
            });
         }
      }

      function sidebarMouseUp(event) {
         if (!moved) {
            scope.onClick();
         }

         $(document).off('mousemove', sidebarMouseMove);
         $(document).off('mouseup', sidebarMouseUp);

         element.toggleClass(scope.elementDragStyles);
         body.toggleClass(scope.bodyDragStyles);

         moving = false;
      }

      element.on('mousedown', function (event) {
         // Prevent default dragging of selected content
         event.preventDefault();
         startY = event.pageY - y;
         moving = true;
         moved = false;

         scope.onMove();

         $(document).on('mousemove', sidebarMouseMove);
         $(document).on('mouseup', sidebarMouseUp);

         element.toggleClass(scope.elementDragStyles);
         body.toggleClass(scope.bodyDragStyles);
      });

      scope.$on('$destroy', function handleDestroyEvent() {
         _angular2.default.element($window).unbind('resize', resizeHandler);
         if (moving) {
            $(document).off('mousemove', sidebarMouseMove);
            $(document).off('mouseup', sidebarMouseUp);
         }
      });
   }

   return {
      restrict: 'E',
      link: link,
      scope: {
         onClick: '&',
         onMove: '&',
         elementDragStyles: '@',
         bodyDragStyles: '@'
      }
   };
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * vertical-slider.js --
 *
 * Module to implement a UI element that can be slid up and down the
 * entire document. The element is packaged as a directive named
 * verticalSlider.
 * The directive is responsible for allowing the use to move its contents by
 * dragging them. The directive also accepts allows the developer to configure
 * what action will be taken when the user clicks on the element but does not
 * move it.
 *
 * The actual visuals of the element are controlled via HTML and CSS.
 *
 * The directive expects the following attributes to be defined:
 *
 *   on-click = an expression that will be evaluated when the element is
 * clicked on on-move = an expression that will be evaluated when the element
 * is moved element-drag-styles = a list of css classes that will be toggled on
 * the element when it is dragged. body-drag-styles = a list of css classes
 * that will be toggled on the HTML body when the element is dragged.
 *
 * Sample use:
 *
 *     <vertical-slider class="panel-toggle-tab pointer-cursor"
 *               on-click="$emit('togglePanel')"
 *               on-move="$emit('sliderMoveStart')"
 *               element-drag-styles="pointer-cursor resize-cursor"
 *               body-drag-styles="resize-cursor">
 *        <img src="img/tab.png"/>
 *     </vertical-slider>
 *
 * Limitations:
 *    - The element can only be moved vertically and it moves the entire height
 * of the document body.
 *    - Double clicking is not supported.
 *
 */
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = CancelAuthenticationCommand;

var _jscdkClient = __webpack_require__(2);

var _doCancelAuthenticationHandler = __webpack_require__(200);

var _doCancelAuthenticationHandler2 = _interopRequireDefault(_doCancelAuthenticationHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * cancelAuthenticationCommand.js --
 *
 *      Cancels any currently active authentication.  Should be triggered by
 *      the application if the user cancels while partially through
 * authentication.
 *
 */

function CancelAuthenticationCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param cancelAuthenticationAction[in]
 *        - its property 'method' has the value 'CancelAuthentication'
 */
CancelAuthenticationCommand.prototype.execute = function (cancelAuthenticationAction) {
   var handlerList = void 0,
       cancelAuthObject = _jscdkClient.globalArray["do-cancel-authentication"],
       router = _jscdkClient.globalArray["router"];

   if (!cancelAuthObject) {
      cancelAuthObject = new _doCancelAuthenticationHandler2.default();
      _jscdkClient.globalArray[cancelAuthObject.messageName] = cancelAuthObject;
      _jscdkClient.globalArray[cancelAuthObject.responseTag] = cancelAuthObject;
   } else {
      cancelAuthObject.resetData();
   }

   handlerList = cancelAuthObject.composeHandlerList();

   router.postMessage(handlerList);
};

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = CancelCurrentRequestCommand;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jscdkClient = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * cancelCurrentReuqestCommand.js --
 *
 * Cancel the current AJAX request for JSCDK.
 *
 */

function CancelCurrentRequestCommand() {}

/**
 * Invoked by JSCDKController
 *
 * Abort the current AJAX request in router.
 */
CancelCurrentRequestCommand.prototype.execute = function (cancelRequestAction) {
   var doneAction = void 0,
       router = _jscdkClient.globalArray["router"];
   doneAction = cancelRequestAction.doneAction;
   if (!!router && !!router.recentXhrObject && _jquery2.default.isFunction(router.recentXhrObject.abort)) {
      router.recentXhrObject.abort();
      _jscdkLogger2.default.debug("Cancel current request complete.");
   } else {
      /*
       * If router or XHR object is null, it means the current AJAX request
       * hasn't started. Set the ajaxWasAbort flag to tell router not to
       * fire the request.
       */
      router.ajaxWasAborted = true;
      _jscdkLogger2.default.debug("AJAX request hasn't started yet.");
   }
   /*
    * Set UI to user's expected page for both correct and error cases.
    */
   if (!!doneAction) {
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(doneAction));
      _jscdkLogger2.default.debug("Done action: " + JSON.stringify(doneAction));
   } else {
      _jscdkLogger2.default.error("Done action is not set.");
   }
};

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ConnectToApplicationCommand;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _getApplicationConnectionHandler = __webpack_require__(205);

var _getApplicationConnectionHandler2 = _interopRequireDefault(_getApplicationConnectionHandler);

var _setUserGlobalPrefHandler = __webpack_require__(13);

var _setUserGlobalPrefHandler2 = _interopRequireDefault(_setUserGlobalPrefHandler);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ConnectToApplicationCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param selectApplicationAction[in]
 *        - its property 'method' has the value 'ConnectToApplication'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * connectToApplicationCommand.js --
 *
 * Called to setup and retrieve the parameters for a application connection.
 * The returned parameters should be used to launch an appropriate client for
 * the connection protocol, e.g. an RDP client when <protocol>RDP</protocol> is
 * returned.
 *    1. GetApplicationConnection
 *
 */

ConnectToApplicationCommand.prototype.execute = function (selectApplicationAction) {
   var handlerList = void 0,
       getApplicationConnObject = _jscdkClient.globalArray["get-application-connection"],
       router = _jscdkClient.globalArray["router"],
       setPrefHandler = _jscdkClient.globalArray["set-user-global-preferences"];

   if (!router) {
      _jscdkLogger2.default.info("router is null.");

      router = new _router2.default();
      _jscdkClient.globalArray[router.name] = router;
   }

   if (!setPrefHandler) {
      setPrefHandler = new _setUserGlobalPrefHandler2.default();
      _jscdkClient.globalArray[setPrefHandler.messageName] = setPrefHandler;
   }
   setPrefHandler.setRequestXML(selectApplicationAction.prefData);

   if (!getApplicationConnObject) {
      getApplicationConnObject = new _getApplicationConnectionHandler2.default();
      _jscdkClient.globalArray[getApplicationConnObject.messageName] = getApplicationConnObject;
      _jscdkClient.globalArray[getApplicationConnObject.responseTag] = getApplicationConnObject;
   } else {
      getApplicationConnObject.resetData();
   }

   getApplicationConnObject.setRequestXML(selectApplicationAction.applicationId, selectApplicationAction.protocol, selectApplicationAction.environmentInfo, selectApplicationAction.maximized, selectApplicationAction.launchParam);

   getApplicationConnObject.saveOriginId(selectApplicationAction.originId);

   handlerList = getApplicationConnObject.composeHandlerList();
   router.postMessage(handlerList);
};

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ConnectToBrokerCommand;

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _setLocaleHandler = __webpack_require__(216);

var _setLocaleHandler2 = _interopRequireDefault(_setLocaleHandler);

var _getConfigurationHandler = __webpack_require__(50);

var _addClientInfoHandler = __webpack_require__(196);

var _addClientInfoHandler2 = _interopRequireDefault(_addClientInfoHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ConnectToBrokerCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param connectBrokerAction[in]
 *        - its property 'method' has the value 'ConnectToBroker'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * connectToBrokerCommand.js --
 *
 * First stage of authentication:
 *    1. SetLocale
 *    2. GetConfiguration
 *
 */

ConnectToBrokerCommand.prototype.execute = function (connectBrokerAction) {
   var handlerList = void 0,
       samlSecret = void 0,
       unauthenticated = void 0,
       urlHandler = void 0,
       oneProtocol = void 0,
       brokerUrl = void 0,
       setLocaleObject = _jscdkClient.globalArray["set-locale"],
       getConfigurationObject = _jscdkClient.globalArray["get-configuration"],
       submitAuthenticationObject = _jscdkClient.globalArray["do-submit-authentication"],
       addClientInfoObject = _jscdkClient.globalArray["add-client-info"],
       router = _jscdkClient.globalArray["router"];

   //init GetConfigurationHandler to handle URL
   if (!getConfigurationObject) {
      getConfigurationObject = new _getConfigurationHandler.GetConfigurationHandler();
      _jscdkClient.globalArray[getConfigurationObject.messageName] = getConfigurationObject;
      _jscdkClient.globalArray[getConfigurationObject.responseTag] = getConfigurationObject;
   } else {
      getConfigurationObject.resetData();
   }

   urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");

   if (!!urlHandler) {
      samlSecret = urlHandler.params.samlArt;
      unauthenticated = urlHandler.params.unauthenticatedAccessEnabled;
      if (!!samlSecret) {
         _jscdkClient.globalArray["samlArt"] = samlSecret;
         getConfigurationObject.setAuthTypes(_getConfigurationHandler.HaveAuthTypesEnum.HAVEAUTHTYPE_SAML);
      } else if (!!unauthenticated && unauthenticated.toLowerCase() === 'true') {
         getConfigurationObject.setAuthTypes(_getConfigurationHandler.HaveAuthTypesEnum.HAVEAUTHTYPE_UNAUTH);
      } else {
         getConfigurationObject.setAuthTypes(_getConfigurationHandler.HaveAuthTypesEnum.HAVEAUTHTYPE_DEFAULT);
      }
   } else {
      getConfigurationObject.setAuthTypes(_getConfigurationHandler.HaveAuthTypesEnum.HAVEAUTHTYPE_DEFAULT);
   }

   // read in data from connectBrokerAction
   // "add-client-info" work after broker>= 9.0
   if (connectBrokerAction.hasOwnProperty("clientInfo") && _util2.default.brokerSupportApplication()) {
      if (!addClientInfoObject) {
         addClientInfoObject = new _addClientInfoHandler2.default();
         _jscdkClient.globalArray[addClientInfoObject.messageName] = addClientInfoObject;
         _jscdkClient.globalArray[addClientInfoObject.responseTag] = addClientInfoObject;
      } else {
         addClientInfoObject.resetData();
      }

      addClientInfoObject.clientInfo = connectBrokerAction.clientInfo;
   }

   if (!router) {
      _jscdkLogger2.default.info("router is null.");

      router = new _router2.default();
      _jscdkClient.globalArray[router.name] = router;
   }

   if (!!connectBrokerAction.supportedProtocols) {
      for (oneProtocol in connectBrokerAction.supportedProtocols) {
         if (connectBrokerAction.supportedProtocols.hasOwnProperty(oneProtocol)) {
            oneProtocol = oneProtocol.toUpperCase();
         }
      }
   } else {
      _jscdkLogger2.default.error("No supported protocols configured.");
      return;
   }

   _jscdkClient.globalArray["brokerAddress"] = connectBrokerAction.address;
   _jscdkClient.globalArray.supportedProtocols = connectBrokerAction.supportedProtocols;

   // Configure broker post address, specify whether a timestamp is appended to
   // the URL.
   brokerUrl = "https://" + connectBrokerAction.address + "/broker/xml" + (!!connectBrokerAction.mid ? connectBrokerAction.mid : "");
   router.setBrokerUrl(brokerUrl, !!connectBrokerAction.urlParam);

   // if bypassTunnel exists, put bypassTunnel into globalArray
   if (connectBrokerAction.bypassTunnel !== undefined) {
      _jscdkClient.globalArray.bypassTunnel = connectBrokerAction.bypassTunnel;
   } else {
      _jscdkClient.globalArray.bypassTunnel = true;
   }

   // reset submitAuthenticationObject for later usage when dealing with
   // <configuration>
   if (!!submitAuthenticationObject) {
      submitAuthenticationObject.resetData();
   }

   // send getconfiguration & setlocal to inform broker, but not prepare to
   // login
   if (!setLocaleObject) {
      setLocaleObject = new _setLocaleHandler2.default();
      _jscdkClient.globalArray[setLocaleObject.messageName] = setLocaleObject;
      _jscdkClient.globalArray[setLocaleObject.responseTag] = setLocaleObject;
   } else {
      setLocaleObject.resetData();
   }

   getConfigurationObject.setRequestXML(true);
   handlerList = getConfigurationObject.composeHandlerList();
   router.postMessage(handlerList);
};

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ConnectToDesktopCommand;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _getDesktopConnectionHandler = __webpack_require__(207);

var _getDesktopConnectionHandler2 = _interopRequireDefault(_getDesktopConnectionHandler);

var _setUserGlobalPrefHandler = __webpack_require__(13);

var _setUserGlobalPrefHandler2 = _interopRequireDefault(_setUserGlobalPrefHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ConnectToDesktopCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param selectDesktopAction[in]
 *        - its property 'method' has the value 'ConnectToDesktop'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * connectToDesktopCommand.js --
 *
 * Called to setup and retrieve the parameters for a desktop connection.
 * The returned parameters should be used to launch an appropriate client for
 * the connection protocol, e.g. an RDP client when <protocol>RDP</protocol> is
 * returned.
 *    1. GetDesktopConnection
 *
 */

ConnectToDesktopCommand.prototype.execute = function (selectDesktopAction) {
   var handlerList = void 0,
       getDesktopConnObject = _jscdkClient.globalArray["get-desktop-connection"],
       desktopPreferences = void 0,
       router = _jscdkClient.globalArray["router"],
       setPrefHandler = _jscdkClient.globalArray["set-user-global-preferences"];

   if (!router) {
      _jscdkLogger2.default.info("router is null.");

      router = new _router2.default();
      _jscdkClient.globalArray[router.name] = router;
   }

   if (!setPrefHandler) {
      setPrefHandler = new _setUserGlobalPrefHandler2.default();
      _jscdkClient.globalArray[setPrefHandler.messageName] = setPrefHandler;
   }
   setPrefHandler.setRequestXML(selectDesktopAction.prefData);

   if (!getDesktopConnObject) {
      getDesktopConnObject = new _getDesktopConnectionHandler2.default();
      _jscdkClient.globalArray[getDesktopConnObject.messageName] = getDesktopConnObject;
      _jscdkClient.globalArray[getDesktopConnObject.responseTag] = getDesktopConnObject;
   } else {
      getDesktopConnObject.resetData();
   }

   desktopPreferences = selectDesktopAction.preferences;

   getDesktopConnObject.setRequestXML(selectDesktopAction.desktopId, selectDesktopAction.protocol, selectDesktopAction.environmentInfo, selectDesktopAction.isShadow);

   getDesktopConnObject.setPreferences(desktopPreferences);

   handlerList = getDesktopConnObject.composeHandlerList();
   router.postMessage(handlerList);
};

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DisconnectSessionCommand;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _doDisconnectSessionHandler = __webpack_require__(201);

var _doDisconnectSessionHandler2 = _interopRequireDefault(_doDisconnectSessionHandler);

var _getLaunchItemsHandler = __webpack_require__(14);

var _getLaunchItemsHandler2 = _interopRequireDefault(_getLaunchItemsHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * disconnectSessionCommand.js --
 *
 * logoff session.
 *
 */

function DisconnectSessionCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param disconnectSessionAction[in]
 *        - its property 'method' has the value 'DisconnectSession'
 */
DisconnectSessionCommand.prototype.execute = function (disconnectSessionAction) {
   var handlerList = void 0,
       launchItemId = void 0,
       disconnectSessionObject = void 0,
       getLaunchItemsObject = void 0,
       supportedProtocols = void 0,
       supportedAppProtocols = void 0,
       type = void 0,
       router = _jscdkClient.globalArray['router'];

   launchItemId = disconnectSessionAction.launchItemId;

   // Get DisconnectSessionHandler
   disconnectSessionObject = _jscdkClient.globalArray['disconnect-session' + launchItemId];
   if (!disconnectSessionObject) {
      disconnectSessionObject = new _doDisconnectSessionHandler2.default();
      _jscdkClient.globalArray[disconnectSessionObject.messageName + launchItemId] = disconnectSessionObject;
      _jscdkClient.globalArray[disconnectSessionObject.responseTag + launchItemId] = disconnectSessionObject;
   } else {
      disconnectSessionObject.resetData();
   }
   // The targeted session ID.
   disconnectSessionObject.launchItemId = launchItemId;

   getLaunchItemsObject = _jscdkClient.globalArray["get-launch-items" + launchItemId];
   if (!getLaunchItemsObject) {
      getLaunchItemsObject = new _getLaunchItemsHandler2.default(true, true);
      _jscdkClient.globalArray[getLaunchItemsObject.messageName + launchItemId] = getLaunchItemsObject;
      _jscdkClient.globalArray[getLaunchItemsObject.responseTag + launchItemId] = getLaunchItemsObject;
   } else {
      getLaunchItemsObject.resetData();
   }

   getLaunchItemsObject.appendSubHandler(disconnectSessionObject);

   if (!!getLaunchItemsObject && !!router) {
      supportedProtocols = _jscdkClient.globalArray.supportedProtocols || ["BLAST"];
      type = {};
      type.name = "remote";
      type.protocols = supportedProtocols;
      supportedAppProtocols = [];
      supportedAppProtocols[0] = type;
      if (!!supportedProtocols) {
         getLaunchItemsObject.setRequestXML(supportedProtocols, supportedAppProtocols, false);
         handlerList = getLaunchItemsObject.composeHandlerList();
         router.postMessage(handlerList);
      } else {
         _jscdkLogger2.default.error("supported protocols is invalid.");
      }
   }
};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DoLockCommand;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _doLockHandler = __webpack_require__(49);

var _doLockHandler2 = _interopRequireDefault(_doLockHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DoLockCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param DoLockAction[in]
 *        - its property 'method' has the value 'DoLock'
 */
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * doLockCommand.js --
 *
 *      Called to lock the broker. Should be triggered by
 *      idle timeout if the user disactive for a long time.
 *
 */

DoLockCommand.prototype.execute = function (DoLockAction) {
   var doLockObject = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray["router"];
   if (!_util2.default.brokerSupportApplication()) {
      return;
   }
   doLockObject = _jscdkClient.globalArray["do-lock"];
   if (!doLockObject) {
      doLockObject = new _doLockHandler2.default();
      _jscdkClient.globalArray[doLockObject.messageName] = doLockObject;
      _jscdkClient.globalArray[doLockObject.responseTag] = doLockObject;
   } else {
      doLockObject.resetData();
   }

   if (!!doLockObject && !!router) {
      doLockObject.setRequestXML();
      handlerList = doLockObject.composeHandlerList();
      router.postMessage(handlerList);
   }
};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DoUnlockCommand;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _doUnlockHandler = __webpack_require__(203);

var _doUnlockHandler2 = _interopRequireDefault(_doUnlockHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DoUnlockCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param DoUnlockAction[in]
 *        - its property 'method' has the value 'DoUnlock'
 */
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * doUnlockCommand.js --
 *
 *      Called to unlock the broker
 *
 */

DoUnlockCommand.prototype.execute = function (DoUnlockAction) {
   var doUnlockObject = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray["router"];
   if (!_util2.default.brokerSupportApplication()) {
      return;
   }
   doUnlockObject = _jscdkClient.globalArray["do-unlock"];
   if (!doUnlockObject) {
      doUnlockObject = new _doUnlockHandler2.default();
      _jscdkClient.globalArray[doUnlockObject.messageName] = doUnlockObject;
      _jscdkClient.globalArray[doUnlockObject.responseTag] = doUnlockObject;
   } else {
      doUnlockObject.resetData();
   }

   if (!!doUnlockObject && !!router) {
      doUnlockObject.setRequestXML();
      handlerList = doUnlockObject.composeHandlerList();
      router.postMessage(handlerList);
   }
};

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = GetAuthenticationStatusCommand;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _getAuthenticationStatusHandler = __webpack_require__(40);

var _getAuthenticationStatusHandler2 = _interopRequireDefault(_getAuthenticationStatusHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GetAuthenticationStatusCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param GetAuthenticationStatusAction[in]
 *        - its property 'method' has the value 'GetAuthenticationStatus'
 */
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * getAuthenticationStatusCommand.js --
 *
 *      Called to get authantication status and also for idle time in the
 * broker
 *      cases that this will be called:
 *          1. timer want to know the last user active time on all tab of
 * browser through the broker
 *          2. unlock and client launched by Horizon all need send this first
 * to decide what to do next.
 *
 */

GetAuthenticationStatusCommand.prototype.execute = function (GetAuthenticationStatusAction) {
   var getAuthenticationStatusObject = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray["router"];

   // version check is here because GetAuthenticationStatus can not be the
   // first send XML
   if (!_util2.default.brokerSupportApplication()) {
      return;
   }
   getAuthenticationStatusObject = _jscdkClient.globalArray["get-authentication-status"];
   if (!getAuthenticationStatusObject) {
      getAuthenticationStatusObject = new _getAuthenticationStatusHandler2.default();
      _jscdkClient.globalArray[getAuthenticationStatusObject.messageName] = getAuthenticationStatusObject;
      _jscdkClient.globalArray[getAuthenticationStatusObject.responseTag] = getAuthenticationStatusObject;
   } else {
      getAuthenticationStatusObject.resetData();
   }

   if (!!getAuthenticationStatusObject && !!router) {
      getAuthenticationStatusObject.setRequestXML(false);
      if (GetAuthenticationStatusAction.workForSilentMode) {
         getAuthenticationStatusObject.setWorkForSilentModeFlag();
      }
      handlerList = getAuthenticationStatusObject.composeHandlerList();
      router.postMessage(handlerList);
   }
};

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = GetDesktopsCommand;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _getDesktopsHandler = __webpack_require__(17);

var _getDesktopsHandler2 = _interopRequireDefault(_getDesktopsHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GetDesktopsCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param getDesktopsAction[in]
 *        - its property 'method' has the value 'GetDesktops'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * getDesktopsCommand.js --
 *
 * get desktop list.
 *
 */

GetDesktopsCommand.prototype.execute = function (getDesktopsAction) {
   var getDesktopsObject = void 0,
       handlerList = void 0,
       supportedProtocols = void 0,
       router = _jscdkClient.globalArray["router"];

   getDesktopsObject = _jscdkClient.globalArray["get-desktops"];
   if (!getDesktopsObject) {
      getDesktopsObject = new _getDesktopsHandler2.default();
      _jscdkClient.globalArray[getDesktopsObject.messageName] = getDesktopsObject;
      _jscdkClient.globalArray[getDesktopsObject.responseTag] = getDesktopsObject;
   } else {
      getDesktopsObject.resetData();
   }

   if (!!getDesktopsObject && !!router) {
      supportedProtocols = _jscdkClient.globalArray.supportedProtocols;
      if (!!supportedProtocols) {
         getDesktopsObject.setRequestXML(supportedProtocols);
         handlerList = getDesktopsObject.composeHandlerList();
         router.postMessage(handlerList);
      } else {
         _jscdkLogger2.default.error("supported protocols is invalid.");
      }
   }
};

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = GetLaunchItemsCommand;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _getDesktopsHandler = __webpack_require__(17);

var _getDesktopsHandler2 = _interopRequireDefault(_getDesktopsHandler);

var _getLaunchItemsHandler = __webpack_require__(14);

var _getLaunchItemsHandler2 = _interopRequireDefault(_getLaunchItemsHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GetLaunchItemsCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param getLaunchItemsAction[in]
 *        - its property 'method' has the value 'GetLaunchItems'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * getLaunchItemsCommand.js --
 *
 * get launchitem list.
 *
 */

GetLaunchItemsCommand.prototype.execute = function (getLaunchItemsAction) {
   var getLaunchItemsObject = void 0,
       getDesktopsObject = void 0,
       handlerList = void 0,
       supportedProtocols = void 0,
       supportedAppProtocols = void 0,
       type = void 0,
       router = _jscdkClient.globalArray["router"];

   if (!_util2.default.brokerSupportApplication()) {
      getDesktopsObject = _jscdkClient.globalArray["get-desktops"];
      if (!getDesktopsObject) {
         getDesktopsObject = new _getDesktopsHandler2.default();
         _jscdkClient.globalArray[getDesktopsObject.messageName] = getDesktopsObject;
         _jscdkClient.globalArray[getDesktopsObject.responseTag] = getDesktopsObject;
      } else {
         getDesktopsObject.resetData();
      }

      if (!!getDesktopsObject && !!router) {
         supportedProtocols = _jscdkClient.globalArray.supportedProtocols;
         if (!!supportedProtocols) {
            getDesktopsObject.setRequestXML(supportedProtocols);
            handlerList = getDesktopsObject.composeHandlerList();
            router.postMessage(handlerList);
         } else {
            _jscdkLogger2.default.error("supported protocols is invalid.");
         }
      }
   } else {

      getLaunchItemsObject = _jscdkClient.globalArray["get-launch-items"];
      if (!getLaunchItemsObject) {
         getLaunchItemsObject = new _getLaunchItemsHandler2.default(getLaunchItemsAction.skipTunnelAndPref, getLaunchItemsAction.skipTimer);
         _jscdkClient.globalArray[getLaunchItemsObject.messageName] = getLaunchItemsObject;
         _jscdkClient.globalArray[getLaunchItemsObject.responseTag] = getLaunchItemsObject;
      } else {
         getLaunchItemsObject.resetData();
      }

      if (!!getLaunchItemsObject && !!router) {
         supportedProtocols = _jscdkClient.globalArray.supportedProtocols || ["BLAST"];
         type = {};
         type.name = "remote";
         type.protocols = supportedProtocols;
         supportedAppProtocols = [];
         supportedAppProtocols[0] = type;
         if (!!supportedProtocols) {
            getLaunchItemsObject.setRequestXML(supportedProtocols, supportedAppProtocols);
            handlerList = getLaunchItemsObject.composeHandlerList();
            router.postMessage(handlerList);
         } else {
            _jscdkLogger2.default.error("supported protocols is invalid.");
         }
      }
   }
};

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = GetTunnelConnectionCommand;

var _jscdkClient = __webpack_require__(2);

var _getTunnelConnectionHandler = __webpack_require__(23);

var _getTunnelConnectionHandler2 = _interopRequireDefault(_getTunnelConnectionHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2013-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * getTunnelConnectionCommand.js --
 *
 * get tunnel connection.
 *
 */

function GetTunnelConnectionCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param getTunnelConnAction[in]
 *        - its property 'method' has the value 'GetTunnelConnection'
 */
GetTunnelConnectionCommand.prototype.execute = function (getTunnelConnAction) {
  var getTunnelConnObject = void 0,
      handlerList = void 0,
      router = _jscdkClient.globalArray['router'];

  getTunnelConnObject = _jscdkClient.globalArray['get-tunnel-connection'];
  if (!getTunnelConnObject) {
    getTunnelConnObject = new _getTunnelConnectionHandler2.default();
    _jscdkClient.globalArray[getTunnelConnObject.messageName] = getTunnelConnObject;
    _jscdkClient.globalArray[getTunnelConnObject.responseTag] = getTunnelConnObject;
  } else {
    getTunnelConnObject.resetData();
  }

  getTunnelConnObject.setRequestXML(getTunnelConnAction.bypassTunnel);
  handlerList = getTunnelConnObject.composeHandlerList();
  router.postMessage(handlerList);
};

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = GetUserGlobalPrefCommand;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _getUserGlobalPrefHandler = __webpack_require__(51);

var _getUserGlobalPrefHandler2 = _interopRequireDefault(_getUserGlobalPrefHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function GetUserGlobalPrefCommand() {} /*********************************************************
                                        * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
                                        *********************************************************/

/**
 * GetUserGlobalPrefCommand.js --
 *
 *      get user global preference.
 *
 */

GetUserGlobalPrefCommand.prototype.execute = function () {
   var getGlbUserPrefObj = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray["router"];

   getGlbUserPrefObj = _jscdkClient.globalArray["get-user-global-preference"];
   if (!getGlbUserPrefObj) {
      getGlbUserPrefObj = new _getUserGlobalPrefHandler2.default();
      _jscdkClient.globalArray[getGlbUserPrefObj.messageName] = getGlbUserPrefObj;
      _jscdkClient.globalArray[getGlbUserPrefObj.responseTag] = getGlbUserPrefObj;
   } else {
      getGlbUserPrefObj.resetData();
   }

   if (!!getGlbUserPrefObj && !!router) {
      getGlbUserPrefObj.setRequestXML();
      handlerList = getGlbUserPrefObj.composeHandlerList();
      router.postMessage(handlerList);
   } else {
      _jscdkLogger2.default.error("supported protocols is invalid.");
      return false;
   }
};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = HandleURICommand;

var _jscdkClient = __webpack_require__(2);

var _urlHandler = __webpack_require__(55);

var _urlHandler2 = _interopRequireDefault(_urlHandler);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function HandleURICommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param handleURIAction[in]
 *        - handle (store/reset) the input parameters in an url-handler
 *    instance in JSCDK
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * handleURICommand.js --
 *
 * Store the Client URI.
 *
 */

HandleURICommand.prototype.execute = function (handleURIAction) {
   var urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");
   if (!urlHandler) {
      urlHandler = new _urlHandler2.default();
      _jscdkClient.globalArray[urlHandler.name] = urlHandler;
   }

   if (handleURIAction.operationType === "store") {
      urlHandler.handleUrlParams(handleURIAction);
   } else if (handleURIAction.operationType === "reset") {
      urlHandler.resetParams();
   }
};

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = InitRouterCommand;

var _jscdkClient = __webpack_require__(2);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function InitRouterCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param initRouterAction[in]
 *        - its property 'method' has the value 'InitRouter'
 */
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * initRouterCommand.js --
 *
 * init jscdkRouter with broker url
 *
 * designed to limit the JSCDK talk to one broker at a time
 * shall be the constructor of JSCDK after re-factory.
 */

InitRouterCommand.prototype.execute = function (initRouterAction) {
  var jscdkRouter = _jscdkClient.globalArray["router"];
  if (!jscdkRouter) {
    _jscdkLogger2.default.info("jscdkRouter is inited.");
    jscdkRouter = new _router2.default();
    _jscdkClient.globalArray[jscdkRouter.name] = jscdkRouter;
  } else {
    _jscdkLogger2.default.info("jscdkRouter has already been inited.");
  }
  jscdkRouter.setBrokerUrl(initRouterAction.brokerUrl, initRouterAction.urlParam);
};

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = KillSessionCommand;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _killSessionHandler = __webpack_require__(24);

var _killSessionHandler2 = _interopRequireDefault(_killSessionHandler);

var _getDesktopsHandler = __webpack_require__(17);

var _getDesktopsHandler2 = _interopRequireDefault(_getDesktopsHandler);

var _getLaunchItemsHandler = __webpack_require__(14);

var _getLaunchItemsHandler2 = _interopRequireDefault(_getLaunchItemsHandler);

var _killAllApplicationSessionsCtrl = __webpack_require__(208);

var _killAllApplicationSessionsCtrl2 = _interopRequireDefault(_killAllApplicationSessionsCtrl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function KillSessionCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param killSessionAction[in]
 *        - its property 'method' has the value 'KillSession'
 * do not split this command into two command for its function is
 * the same. after JSCDK refactory it will be only little difference
 * between them(just parameter are different), so provide with same
 * API.
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * killSessionCommand.js --
 *
 * to send killSession using applicationId/desktopId, or reset all application
 * sessions. can be used to logoff desktop or reset application-sessions.
 * it rely on the get getLaunchItem or getDesktops(when connecting old broker)
 */

KillSessionCommand.prototype.execute = function (killSessionAction) {
   if (killSessionAction.killAllApplicationSessions) {
      this.killAllApplicationSessions();
   } else {
      this.killSingleSession(killSessionAction.itemInfo);
   }
};

KillSessionCommand.prototype.sendGetLaunchItems = function (getLaunchItemsObject) {
   var supportedProtocols = void 0,
       supportedAppProtocols = void 0,
       type = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray['router'];

   if (!!getLaunchItemsObject && !!router) {
      supportedProtocols = _jscdkClient.globalArray.supportedProtocols || ["BLAST"];
      type = {};
      type.name = "remote";
      type.protocols = supportedProtocols;
      supportedAppProtocols = [];
      supportedAppProtocols[0] = type;
      if (!!supportedProtocols) {
         getLaunchItemsObject.setRequestXML(supportedProtocols, supportedAppProtocols, false);
         handlerList = getLaunchItemsObject.composeHandlerList();
         router.postMessage(handlerList);
      } else {
         _jscdkLogger2.default.error("supported protocols is invalid.");
      }
   }
};

KillSessionCommand.prototype.killAllApplicationSessions = function () {
   var killAllApplicationSessionsObject = void 0,
       getLaunchItemsObject = void 0,

   //please do not worry about the naming, it will be deleted after JSCDK
   // refactory
   getLaunchItemsObjectNameHeader = "pre-kill-all-application-sessions";

   if (!_util2.default.brokerSupportApplication()) {
      _jscdkLogger2.default.debug("error: broker do not support kill all application sessions!");
      return;
   }
   killAllApplicationSessionsObject = _jscdkClient.globalArray["kill-all-application-sessions"];
   if (!killAllApplicationSessionsObject) {
      killAllApplicationSessionsObject = new _killAllApplicationSessionsCtrl2.default();
      _jscdkClient.globalArray[killAllApplicationSessionsObject.messageName] = killAllApplicationSessionsObject;
      _jscdkClient.globalArray[killAllApplicationSessionsObject.responseTag] = killAllApplicationSessionsObject;
   }

   getLaunchItemsObject = _jscdkClient.globalArray[getLaunchItemsObjectNameHeader + "get-launch-items"];
   if (!getLaunchItemsObject) {
      getLaunchItemsObject = new _getLaunchItemsHandler2.default(true);
      _jscdkClient.globalArray[getLaunchItemsObjectNameHeader + getLaunchItemsObject.messageName] = getLaunchItemsObject;
      _jscdkClient.globalArray[getLaunchItemsObjectNameHeader + getLaunchItemsObject.responseTag] = getLaunchItemsObject;
   } else {
      getLaunchItemsObject.resetData();
   }

   getLaunchItemsObject.appendSubHandler(killAllApplicationSessionsObject);

   this.sendGetLaunchItems(getLaunchItemsObject);
};

KillSessionCommand.prototype.killSingleSession = function (itemInfo) {
   var handlerList = void 0,
       desktopId = void 0,
       itemId = void 0,
       killSessionObject = void 0,
       getDesktopsObject = void 0,
       getLaunchItemsObject = void 0,
       supportedProtocols = void 0,
       router = _jscdkClient.globalArray['router'];

   if (!itemInfo) {
      _jscdkLogger2.default.debug("error: the itemInfo do not exist for killSingleSession");
      return;
   }
   itemId = itemInfo.id;
   // Get KillSessionHandler
   killSessionObject = _jscdkClient.globalArray['kill-session' + itemId];
   if (!killSessionObject) {
      killSessionObject = new _killSessionHandler2.default();
      _jscdkClient.globalArray[killSessionObject.messageName + itemId] = killSessionObject;
      _jscdkClient.globalArray[killSessionObject.responseTag + itemId] = killSessionObject;
   } else {
      killSessionObject.resetData();
   }
   // The targeted item info.
   killSessionObject.itemInfo = itemInfo;
   if (!_util2.default.brokerSupportApplication()) {
      if (!itemInfo.isDesktop) {
         _jscdkLogger2.default.debug("error: broker do not support kill application!");
         return;
      }
      desktopId = itemId;
      // Get GetDesktopsHandler
      getDesktopsObject = _jscdkClient.globalArray['get-desktops' + desktopId];
      if (!getDesktopsObject) {
         getDesktopsObject = new _getDesktopsHandler2.default();
         _jscdkClient.globalArray[getDesktopsObject.messageName + desktopId] = getDesktopsObject;
         _jscdkClient.globalArray[getDesktopsObject.responseTag + desktopId] = getDesktopsObject;
      } else {
         getDesktopsObject.resetData();
      }
      // Trigger KillSessionHandler subsequent to GetDekstopsHandler.
      getDesktopsObject.appendSubHandler(killSessionObject);

      if (!!getDesktopsObject && !!router) {
         supportedProtocols = _jscdkClient.globalArray.supportedProtocols || ["BLAST"];
         if (!!supportedProtocols) {
            // DO not refresh UI at get-desktops response.
            getDesktopsObject.setRequestXML(supportedProtocols, false);
            handlerList = getDesktopsObject.composeHandlerList();
            router.postMessage(handlerList);
         } else {
            _jscdkLogger2.default.error("supported protocols is invalid.");
         }
      }
   } else {
      getLaunchItemsObject = _jscdkClient.globalArray["get-launch-items" + itemId];
      if (!getLaunchItemsObject) {
         getLaunchItemsObject = new _getLaunchItemsHandler2.default(true);
         _jscdkClient.globalArray[getLaunchItemsObject.messageName + itemId] = getLaunchItemsObject;
         _jscdkClient.globalArray[getLaunchItemsObject.responseTag + itemId] = getLaunchItemsObject;
      } else {
         getLaunchItemsObject.resetData();
      }
      getLaunchItemsObject.appendSubHandler(killSessionObject);
      this.sendGetLaunchItems(getLaunchItemsObject);
   }
};

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = LogoutBrokerCommand;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _doLogoutHandler = __webpack_require__(39);

var _doLogoutHandler2 = _interopRequireDefault(_doLogoutHandler);

var _setUserGlobalPrefHandler = __webpack_require__(13);

var _setUserGlobalPrefHandler2 = _interopRequireDefault(_setUserGlobalPrefHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function LogoutBrokerCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param logoutBrokerAction[in]
 *        - its property 'method' has the value 'LogoutFromBroker'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * logoutBrokerBrokerCommand.js --
 *
 * Logout from broker.
 *
 */

LogoutBrokerCommand.prototype.execute = function (logoutBrokerAction) {
   var handlerList = void 0,
       logoutBrokerObject = _jscdkClient.globalArray["do-logout"],
       router = _jscdkClient.globalArray["router"],
       idleTimerObject = void 0,
       setPrefHandler = _jscdkClient.globalArray["set-user-global-preferences"];

   // this code is added here instead of in onUpdate() is for avoid timer
   // triggered after broker just log off and returning response
   if (_util2.default.brokerSupportApplication()) {
      idleTimerObject = _jscdkClient.globalArray["idle-timeout-timer"];
      if (!idleTimerObject) {
         _jscdkLogger2.default.debug("timer don't exist when log out");
      } else {
         idleTimerObject.stop();
      }
   }

   if (!setPrefHandler) {
      setPrefHandler = new _setUserGlobalPrefHandler2.default();
      _jscdkClient.globalArray[setPrefHandler.messageName] = setPrefHandler;
   }
   setPrefHandler.setRequestXML(logoutBrokerAction.prefData);

   if (!logoutBrokerObject) {
      logoutBrokerObject = new _doLogoutHandler2.default();
      _jscdkClient.globalArray[logoutBrokerObject.messageName] = logoutBrokerObject;
      _jscdkClient.globalArray[logoutBrokerObject.responseTag] = logoutBrokerObject;
   } else {
      logoutBrokerObject.resetData();
   }

   if (logoutBrokerAction.needClearURI !== false) {
      //before sending response to UI, this flag will be cleared automaticly,
      // no need to clear it
      logoutBrokerObject.setNeedClearURIFlag();
   }
   handlerList = logoutBrokerObject.composeHandlerList();

   router.postMessage(handlerList, logoutBrokerAction.async, logoutBrokerAction.timeout);
};

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ReconnectApplicationSessionsCommand;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _reconnectApplicationSessionsCtrl = __webpack_require__(209);

var _reconnectApplicationSessionsCtrl2 = _interopRequireDefault(_reconnectApplicationSessionsCtrl);

var _getLaunchItemsHandler = __webpack_require__(14);

var _getLaunchItemsHandler2 = _interopRequireDefault(_getLaunchItemsHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * reconnectApplicationSessionsCommand.js --
 *
 * Called to setup and retrieve the parameters for application seesions
 * connection. The returned parameters should be used to launch appropriate
 * connection with Blast(default)
 *
 * will send getlaunchItem first, and later send
 * getApplicationSessionConnection for target sessions
 *
 * API struct "selectApplicationSessionAction" could be like:
 * {
 *    method                    : "ReconnectApplicationSessions",
 *    environmentInfo           : {%client info%},
 *    protocol                  : 'BLAST',
 *    disconnectAll             : false,
 *    targetSessionIds          : ["id1","id2"]
 * }
 *
 * due to lacking of UT and JSCDK is about to be refacted, I will not split
 * functions, instead I just add comments.
 */

function ReconnectApplicationSessionsCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param selectApplicationSessionAction[in]
 *        - its property 'method' has the value 'ReconnectApplicationSessions'
 */
ReconnectApplicationSessionsCommand.prototype.execute = function (selectApplicationSessionAction) {
   var reconnectCtrl = void 0,
       supportedProtocols = void 0,
       getLaunchItemsObject = void 0,

   //please do not worry about the naming, it will be deleted after JSCDK
   // refactory
   presetInfo = {},
       getLaunchItemsHeader = "pre-reconnect-all-application-sessions",
       supportedAppProtocols = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray['router'];

   if (!_util2.default.brokerSupportApplication()) {
      _jscdkLogger2.default.debug("error: broker do not support reconnect all application sessions!");
      return;
   }

   if (!router) {
      _jscdkLogger2.default.info("router is null.");

      router = new _router2.default();
      _jscdkClient.globalArray[router.name] = router;
   }

   // config reconnectApplicationSessions Object
   supportedProtocols = _jscdkClient.globalArray.supportedProtocols || ["BLAST"];
   presetInfo.environmentInfo = selectApplicationSessionAction.environmentInfo;
   presetInfo.protocol = selectApplicationSessionAction.protocol || 'BLAST';
   presetInfo.disconnectAll = selectApplicationSessionAction.disconnectAll;

   reconnectCtrl = _jscdkClient.globalArray["reconnect-application-sessions"];
   if (!reconnectCtrl) {
      reconnectCtrl = new _reconnectApplicationSessionsCtrl2.default();
      _jscdkClient.globalArray[reconnectCtrl.messageName] = reconnectCtrl;
      _jscdkClient.globalArray[reconnectCtrl.responseTag] = reconnectCtrl;
   }
   reconnectCtrl.targetSessionIds = selectApplicationSessionAction.targetSessionIds;
   // excludedOriginalId is an id indicating the corresponding session
   // should not to be reconnected
   reconnectCtrl.excludedOriginalId = selectApplicationSessionAction.excludedOriginalId;
   reconnectCtrl.presetInfo = presetInfo;

   // config getLaunchItems Object
   getLaunchItemsObject = _jscdkClient.globalArray[getLaunchItemsHeader + "get-launch-items"];
   if (!getLaunchItemsObject) {
      getLaunchItemsObject = new _getLaunchItemsHandler2.default(true, true);
      _jscdkClient.globalArray[getLaunchItemsHeader + getLaunchItemsObject.messageName] = getLaunchItemsObject;
      _jscdkClient.globalArray[getLaunchItemsHeader + getLaunchItemsObject.responseTag] = getLaunchItemsObject;
   } else {
      getLaunchItemsObject.resetData();
   }

   getLaunchItemsObject.appendSubHandler(reconnectCtrl);

   if (!!getLaunchItemsObject && !!router) {
      // start getLaunchItem sending
      supportedAppProtocols = [{
         name: "remote",
         protocols: supportedProtocols
      }];
      getLaunchItemsObject.setRequestXML(supportedProtocols, supportedAppProtocols, false);
      handlerList = getLaunchItemsObject.composeHandlerList();
      router.postMessage(handlerList);
   } else {
      _jscdkLogger2.default.error('the jscdk is in wired status');
   }
};

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ResetDesktopCommand;

var _jscdkClient = __webpack_require__(2);

var _resetDesktopHandler = __webpack_require__(41);

var _resetDesktopHandler2 = _interopRequireDefault(_resetDesktopHandler);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ResetDesktopCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param resetDesktopAction[in]
 *        - its property 'method' has the value 'ResetDesktop'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * resetDesktopCommand.js --
 *
 * reset desktop.
 *
 */

ResetDesktopCommand.prototype.execute = function (resetDesktopAction) {
   var handlerList = void 0,
       desktopId = void 0,
       resetDesktopObject = void 0,
       router = _jscdkClient.globalArray["router"];

   desktopId = resetDesktopAction.desktopId;
   resetDesktopObject = router.getHandler("reset-desktop", desktopId);

   if (!resetDesktopObject) {
      resetDesktopObject = new _resetDesktopHandler2.default();
      _jscdkClient.globalArray[resetDesktopObject.messageName + resetDesktopObject.requestId] = resetDesktopObject;
      _jscdkClient.globalArray[resetDesktopObject.responseTag + resetDesktopObject.requestId] = resetDesktopObject;
      /**
       * update MessageHandler.prototype.requestIdKV
       * the format is {responseTag1+desktop-id1 : requestId1,
       * responseTag2+desktop-id2 : requestId2} such as key of
       * ResetDesktopHandler is "reset-desktop"+desktopId
       */
      _messageHandler.MessageHandler.prototype.requestIdKV[resetDesktopObject.responseTag + desktopId] = resetDesktopObject.requestId;
   } else {
      resetDesktopObject.resetData();
   }

   if (!!desktopId) {
      resetDesktopObject.setRequestXML(desktopId);
      handlerList = resetDesktopObject.composeHandlerList();

      router.postMessage(handlerList);
   }
};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = RestartDesktopCommand;

var _jscdkClient = __webpack_require__(2);

var _restartDesktopHandler = __webpack_require__(53);

var _restartDesktopHandler2 = _interopRequireDefault(_restartDesktopHandler);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function RestartDesktopCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param RestartDesktopAction[in]
 *        - its property 'method' has the value 'RestartDesktop'
 */
/*********************************************************
 * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * RestartDesktopCommand.js --
 *
 * Restart desktop.
 *
 */

RestartDesktopCommand.prototype.execute = function (RestartDesktopAction) {
   var handlerList = void 0,
       desktopId = void 0,
       RestartDesktopObject = void 0,
       router = _jscdkClient.globalArray["router"];

   desktopId = RestartDesktopAction.desktopId;
   RestartDesktopObject = router.getHandler("restart-desktop", desktopId);

   if (!RestartDesktopObject) {
      RestartDesktopObject = new _restartDesktopHandler2.default();
      _jscdkClient.globalArray[RestartDesktopObject.messageName + RestartDesktopObject.requestId] = RestartDesktopObject;
      _jscdkClient.globalArray[RestartDesktopObject.responseTag + RestartDesktopObject.requestId] = RestartDesktopObject;
      /**
       * update MessageHandler.prototype.requestIdKV
       * the format is {responseTag1+desktop-id1 : requestId1,
       * responseTag2+desktop-id2 : requestId2} such as key of
       * RestartDesktopHandler is "Restart-desktop"+desktopId
       */
      _messageHandler.MessageHandler.prototype.requestIdKV[RestartDesktopObject.responseTag + desktopId] = RestartDesktopObject.requestId;
   } else {
      RestartDesktopObject.RestartData();
   }

   if (!!desktopId) {
      RestartDesktopObject.setRequestXML(desktopId);
      handlerList = RestartDesktopObject.composeHandlerList();

      router.postMessage(handlerList);
   }
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = RollbackDesktopCommand;

var _jscdkClient = __webpack_require__(2);

var _rollbackCheckoutDesktopHandler = __webpack_require__(210);

var _rollbackCheckoutDesktopHandler2 = _interopRequireDefault(_rollbackCheckoutDesktopHandler);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function RollbackDesktopCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param rollbackDesktopAction[in]
 *        - its property 'method' has the value 'RollbackDesktop'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * rollbackDesktopCommand.js --
 *
 * rollback desktop.
 *
 */

RollbackDesktopCommand.prototype.execute = function (rollbackDesktopAction) {
   var handlerList = void 0,
       desktopId = void 0,
       rollbackDesktopObject = void 0,
       router = _jscdkClient.globalArray["router"];

   desktopId = rollbackDesktopAction.desktopId;

   if (!!router && !!desktopId) {
      rollbackDesktopObject = router.getHandler("rollback-checkout-desktop", desktopId);
      if (!rollbackDesktopObject) {
         rollbackDesktopObject = new _rollbackCheckoutDesktopHandler2.default();
         _jscdkClient.globalArray[rollbackDesktopObject.messageName + rollbackDesktopObject.requestId] = rollbackDesktopObject;
         _jscdkClient.globalArray[rollbackDesktopObject.responseTag + rollbackDesktopObject.requestId] = rollbackDesktopObject;
         /**
          * update MessageHandler.prototype.requestIdKV
          * the format is {responseTag1+desktop-id1 : requestId1,
          * responseTag2+desktop-id2 : requestId2} such as key of
          * RollbackCheckoutDesktopHandler is
          * "rollback-checkout-desktop"+desktopId
          */
         _messageHandler.MessageHandler.prototype.requestIdKV[rollbackDesktopObject.responseTag + desktopId] = rollbackDesktopObject.requestId;
      } else {
         rollbackDesktopObject.resetData();
      }

      if (!!rollbackDesktopObject) {
         rollbackDesktopObject.setRequestXML(desktopId);
         handlerList = rollbackDesktopObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }
};

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SetEnvironmentInfoCommand;

var _jscdkClient = __webpack_require__(2);

function SetEnvironmentInfoCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param SetEnvironmentInfoAction[in]
 *        - its property 'method' has the value 'SetEnvironmentInfo'
 */
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * setEnvironmentInfoCommand.js --
 *
 *      This API is added to minimize the change to support:
 *      https://confluence.eng.vmware.com/pages/viewpage.action?pageId=233382996
 *      Where whenever a request is sent, environment info is needed.
 *      Since the environment content never changes and we have too many APIs to
 *      indirectly sending this XML as the first step, use this method to minimize
 *      the changes in both JSCDK, and HTML Access.
 *
 *      p.s. After JSCDK refactory, it should be in a model and shared among
 *      more XMLs with filters.
 */

SetEnvironmentInfoCommand.prototype.execute = function (SetEnvironmentInfoAction) {
  _jscdkClient.globalArray['environment-information'] = SetEnvironmentInfoAction.data;
};

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SetLastUserActivityCommand;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _setLastUserActivityHandler = __webpack_require__(54);

var _setLastUserActivityHandler2 = _interopRequireDefault(_setLastUserActivityHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SetLastUserActivityCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param SetLastUserActivityAction[in]
 *        - its property 'method' has the value 'SetLastUserActivity'
 */
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * setLastUserActivityCommand.js --
 *
 *      Called to provent the broker from locking itself due to idle timeout.
 *
 */

SetLastUserActivityCommand.prototype.execute = function (SetLastUserActivityAction) {
   var setLastUserActivityObject = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray["router"],
       inactiveTimeVar = void 0,
       inactiveTimeStr = void 0;

   if (!_util2.default.brokerSupportApplication()) {
      return;
   }
   setLastUserActivityObject = _jscdkClient.globalArray["set-last-user-activity"];
   if (!setLastUserActivityObject) {
      setLastUserActivityObject = new _setLastUserActivityHandler2.default();
      _jscdkClient.globalArray[setLastUserActivityObject.messageName] = setLastUserActivityObject;
      _jscdkClient.globalArray[setLastUserActivityObject.responseTag] = setLastUserActivityObject;
   } else {
      setLastUserActivityObject.resetData();
   }

   if (!!setLastUserActivityObject && !!router) {
      //accept both number and string format
      inactiveTimeVar = SetLastUserActivityAction.data.inactiveTime;
      inactiveTimeStr = inactiveTimeVar.toString();
      setLastUserActivityObject.setRequestXML(inactiveTimeStr);
      handlerList = setLastUserActivityObject.composeHandlerList();
      router.postMessage(handlerList);
   }
};

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SetUserGlobalPrefCommand;

var _jscdkClient = __webpack_require__(2);

var _setUserGlobalPrefHandler = __webpack_require__(13);

var _setUserGlobalPrefHandler2 = _interopRequireDefault(_setUserGlobalPrefHandler);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SetUserGlobalPrefCommand() {} /*********************************************************
                                        * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
                                        *********************************************************/

/**
 * setUserGlobalPrefCommand.js --
 *    set user global preference command
 */

SetUserGlobalPrefCommand.prototype.execute = function (setPrefAction) {
   var router = _jscdkClient.globalArray["router"],
       setPrefHandler = _jscdkClient.globalArray["set-user-global-preferences"];
   if (!router || !setPrefHandler) {
      _jscdkLogger2.default.error("No router or setPrefHandler instance");
   }

   if (!setPrefHandler) {
      setPrefHandler = new _setUserGlobalPrefHandler2.default();
      _jscdkClient.globalArray[setPrefHandler.messageName] = setPrefHandler;
   }
   setPrefHandler.setRequestXML(setPrefAction.prefData);

   router.postMessage(setPrefHandler.composeHandlerList(), setPrefAction.async, setPrefAction.timeout);
};

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SetViewURICommand;

var _urlHandler = __webpack_require__(55);

var _urlHandler2 = _interopRequireDefault(_urlHandler);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkClient = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SetViewURICommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param setViewURIAction[in]
 *        - its property 'method' has the value 'SetViewURI'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * setViewURICommand.js --
 *
 * Pass the View URI to JSCDK.
 *
 */

SetViewURICommand.prototype.execute = function (setViewURIAction) {
  var urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler"),
      url = !!setViewURIAction ? setViewURIAction.queryString : '';

  if (!urlHandler) {
    urlHandler = new _urlHandler2.default();
    _jscdkClient.globalArray[urlHandler.name] = urlHandler;
  }

  urlHandler.handleUrlParams(url);
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SubmitAuthInfoCommand;

var _jscdkClient = __webpack_require__(2);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _doSubmitAuthenticationHandler = __webpack_require__(202);

var _doSubmitAuthenticationHandler2 = _interopRequireDefault(_doSubmitAuthenticationHandler);

var _getTunnelConnectionHandler = __webpack_require__(23);

var _getTunnelConnectionHandler2 = _interopRequireDefault(_getTunnelConnectionHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SubmitAuthInfoCommand() {}

/*
 * submitAuthInfoCommand.js
 *
 * Invoked by JSCDKController
 *
 * @param submitAuthInfoAction[in]
 *        - its property 'method' has the value 'SubmitAuthInfo'
 */
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * submitAuthInfoCommand.js --
 *
 * Submit the user's credential and authenticate the user against the broker
 *    1. DoSubmitAuthentication
 *
 */

SubmitAuthInfoCommand.prototype.execute = function (submitAuthInfoAction) {
   var handlerList = void 0,
       authInfoObject = _jscdkClient.globalArray["do-submit-authentication"],
       router = _jscdkClient.globalArray["router"],
       getTunnelConnObject = _jscdkClient.globalArray["get-tunnel-connection"];

   if (!router) {
      _jscdkLogger2.default.info("router is null.");

      router = new _router2.default();
      _jscdkClient.globalArray[router.name] = router;
   }

   if (!submitAuthInfoAction.type) {
      _jscdkLogger2.default.error("Authentication type is empty.");
      return;
   }

   // create message handler object
   if (!authInfoObject) {
      authInfoObject = new _doSubmitAuthenticationHandler2.default();
      _jscdkClient.globalArray[authInfoObject.messageName] = authInfoObject;
      _jscdkClient.globalArray[authInfoObject.responseTag] = authInfoObject;
   } else {
      authInfoObject.resetData();
   }
   authInfoObject.setAuthAction(submitAuthInfoAction);
   authInfoObject.setReAuthFlag(submitAuthInfoAction.reAuth);
   authInfoObject.setDesktopReAuthFlag(submitAuthInfoAction.isDesktopReAuth);

   if (submitAuthInfoAction.reAuth) {
      if (!getTunnelConnObject) {
         _jscdkLogger2.default.debug("error: getTunnelConnObject do not exist when reAuth is true");
      }
   } else {
      if (!getTunnelConnObject) {
         getTunnelConnObject = new _getTunnelConnectionHandler2.default();
         _jscdkClient.globalArray[getTunnelConnObject.messageName] = getTunnelConnObject;
         _jscdkClient.globalArray[getTunnelConnObject.responseTag] = getTunnelConnObject;
      } else {
         getTunnelConnObject.resetData();
      }
   }

   handlerList = authInfoObject.composeHandlerList();
   router.postMessage(handlerList);
   authInfoObject.clearCreds();
};

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = TimerCtrlCommand;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _idleTimeoutTimerController = __webpack_require__(56);

var _idleTimeoutTimerController2 = _interopRequireDefault(_idleTimeoutTimerController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function TimerCtrlCommand() {}

/**
 * Invoked by JSCDKController
 *
 * @param timerCtrlAction[in]
 *        - its property 'method' has the value 'TimerCtrl'
 */
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * timerCtrlCommand.js --
 *
 *      API to timer for webClient
 *
 */

TimerCtrlCommand.prototype.execute = function (timerCtrlAction) {
   var idleTimerObject = _jscdkClient.globalArray["idle-timeout-timer"],
       idleTimeout = void 0,
       userActivityInterval = void 0,
       lastUserActiveTime = void 0,
       actionType = timerCtrlAction.type,
       initType = timerCtrlAction.initType,
       router = void 0;

   if (timerCtrlAction.bypassApplicationVersionCheck === "true") {
      if (!router) {
         _jscdkLogger2.default.info("router is inited.");
         router = new _router2.default();
         _jscdkClient.globalArray[router.name] = router;
      } else {
         _jscdkLogger2.default.error("router has already inited.");
      }
      router.setBrokerUrl(timerCtrlAction.brokerUrl, timerCtrlAction.brokerUrlWithTimestamp);
   }
   if (!_util2.default.brokerSupportApplication()) {
      return;
   }
   if (actionType === "InitTimer") {
      idleTimeout = timerCtrlAction.idleTimeout;
      userActivityInterval = timerCtrlAction.userActivityInterval;
      if (!idleTimerObject) {
         idleTimerObject = new _idleTimeoutTimerController2.default();
         idleTimerObject.init(userActivityInterval, idleTimeout, initType);
         _jscdkClient.globalArray[idleTimerObject.globalName] = idleTimerObject;
         idleTimerObject.start();
      } else {
         _jscdkLogger2.default.debug("warning: reinit timer for Web Client reused-session unlocked");
         idleTimerObject.ensureStopped();
         idleTimerObject.reset(initType);
         idleTimerObject.start();
      }
   } else {
      if (!idleTimerObject) {
         _jscdkLogger2.default.error("timer do not exist when JSCDK recieve a non-init request");
      }
      lastUserActiveTime = timerCtrlAction.lastUserActiveTime;
      if (actionType === "stopTimer") {
         idleTimerObject.stop();
      } else if (actionType === "sendLastUserActiveTime") {
         idleTimerObject.setlastUserActiveTime(lastUserActiveTime, true, false); //only sendXML
      } else if (actionType === "syncWithTimer4AboutToTimeout" || actionType === "syncWithTimer4Timeout") {
         idleTimerObject.setUITimeForCompare(lastUserActiveTime);
         idleTimerObject.requestBrokerTimeForCompareFor(actionType);
      } else if (actionType === "showAboutToTimeoutDialogCallback") {
         idleTimerObject.setlastUserActiveTime(lastUserActiveTime, true, true); //refresh
         // timer
         // and
         // sendXML
      } else {
         _jscdkLogger2.default.error("TimerCtrlCommand recieved a undefined request");
      }
   }
};

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = AddClientInfoHandler;

var _messageHandler = __webpack_require__(4);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jscdkClient = __webpack_require__(2);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function AddClientInfoHandler() {
   var router = void 0;
   // member variables below
   this.messageName = "add-client-info";
   this.messageText = "add-client-info";
   this.responseTag = "addClientInfo";

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}
// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * AddClientInfoHandler.js --
 *
 *      Implementation of the message handler to add client info.
 */

AddClientInfoHandler.prototype = new _messageHandler.MessageHandler();
// constructor
AddClientInfoHandler.constructor = AddClientInfoHandler;

/**
 * Add the request XML for add-client-info.
 */
AddClientInfoHandler.prototype.setRequestXML = function () {
   var addClientStatsListElements = "",
       key = void 0,
       addClientCommonInfo = this.clientInfo.addClientCommonInfo,
       addClientStatsList = this.clientInfo.addClientStats,
       clientCommonInfo = this.clientInfo.clientCommonInfo,
       clientStatsList = this.clientInfo.clientStats;

   this.requestXML = "";

   for (key in addClientCommonInfo) {
      if (addClientCommonInfo.hasOwnProperty(key)) {
         this.requestXML += _util2.default.createElement(key, addClientCommonInfo[key]);
      }
   }
   // Generate the <client-stats> section.
   for (key in addClientStatsList) {
      if (addClientStatsList.hasOwnProperty(key)) {
         addClientStatsListElements += _util2.default.createElement(key, addClientStatsList[key], { "scrub": "NONE" });
      }
   }

   for (key in clientCommonInfo) {
      if (clientCommonInfo.hasOwnProperty(key)) {
         addClientStatsListElements += _util2.default.createElement('stat', clientCommonInfo[key], { "scrub": "NONE", "name": key });
      }
   }

   for (key in clientStatsList) {
      if (clientStatsList.hasOwnProperty(key)) {
         addClientStatsListElements += _util2.default.createElement('stat', clientStatsList[key], { "scrub": "NONE", "name": key });
      }
   }

   this.requestXML += addClientStatsListElements;
};

/**
 * Parse client information from the response XML of GetConfiguration
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return Object. key-value pairs parsed from response, if error then return
 *    null
 */
AddClientInfoHandler.prototype.parseResult = function (responseXML) {
   var xmlDoc = (0, _jquery2.default)(responseXML),
       ret = {},
       brokerElem = void 0,
       resultText = void 0;

   brokerElem = (0, _jquery2.default)(xmlDoc.children()[0]);
   if (!brokerElem) {
      _jscdkLogger2.default.error("response of " + this.getMessageName() + " error");
      return null;
   }

   resultText = brokerElem.find("result").text();
   if (!!resultText && resultText.trim() !== "") {
      ret["result"] = resultText;
   } else {
      return null;
   }
   return ret;
};

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = CertAuthHandler;

var _messageHandler = __webpack_require__(4);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkClient = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CertAuthHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "cert-auth";
   this.messageText = "cert-auth";

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
} /*********************************************************
   * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * certAuthHandler.js --
 *
 *     handle certificate authentication
 */

CertAuthHandler.prototype = new _messageHandler.MessageHandler(); // inherits MessageHandler
// prototype
CertAuthHandler.constructor = CertAuthHandler; // constructor

/**
 * Set the request XML for saml authentication.
 *
 * @param accept [in] string containing either "true" or "false".
 */

CertAuthHandler.prototype.setRequestXML = function (accept) {
   var nameText = _util2.default.createElement("name", "accept");
   var acceptText = _util2.default.createElement("values", _util2.default.createElement("value", accept));
   var paramText = _util2.default.createElement("param", nameText + acceptText);
   var paramsText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", "cert-auth");
   this.requestXML += paramsText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ChangeWindowsPasswordHandler;

var _messageHandler = __webpack_require__(4);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkClient = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ChangeWindowsPasswordHandler() {
   // member variables below
   this.messageName = "windows-password-expired";
   this.messageText = "windows-password-expired";

   // register dependencies here
   var router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * changeWindowsPasswordHandler.js --
 *
 *      A sub-handler for DoSubmitAuthenticationHandler.
 */

ChangeWindowsPasswordHandler.prototype = new _messageHandler.MessageHandler();
// constructor
ChangeWindowsPasswordHandler.constructor = ChangeWindowsPasswordHandler;

/**
 * Set the request XML for windows-password-expired request.
 *
 * @param oldPassword [in] old password for the windows-password-expired
 *    request.
 * @param newPassword1 [in] new password1 for the windows-password-expired
 *    request.
 * @param newPassword2 [in] new password2 for the windows-password-expired
 *    request.
 */

ChangeWindowsPasswordHandler.prototype.setRequestXML = function (oldPassword, newPassword1, newPassword2) {
   var oldPasswordText = void 0,
       newPassword1Text = void 0,
       newPassword2Text = void 0,
       paramText = void 0;

   this.requestXML = "";

   oldPasswordText = _util2.default.createElement("name", "oldPassword");
   oldPasswordText += _util2.default.createElement("values", _util2.default.createElement("value", oldPassword));
   newPassword1Text = _util2.default.createElement("name", "newPassword1");
   newPassword1Text += _util2.default.createElement("values", _util2.default.createElement("value", newPassword1));
   newPassword2Text = _util2.default.createElement("name", "newPassword2");
   newPassword2Text += _util2.default.createElement("values", _util2.default.createElement("value", newPassword2));
   paramText = _util2.default.createElement("param", oldPasswordText);
   paramText += _util2.default.createElement("param", newPassword1Text);
   paramText += _util2.default.createElement("param", newPassword2Text);

   paramText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", "windows-password-expired");
   this.requestXML += paramText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DisclaimerHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _messageHandler = __webpack_require__(4);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkClient = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * disclaimerHandler.js --
 *
 *      A sub-handler for DoSubmitAuthenticationHandler for accepting
 *      disclaimer.
 */

function DisclaimerHandler() {
   // member variables below
   this.messageName = "disclaimer";
   this.messageText = "disclaimer";

   // register dependencies here
   var router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
DisclaimerHandler.prototype = new _messageHandler.MessageHandler();
// constructor
DisclaimerHandler.constructor = DisclaimerHandler;

/**
 * Set the request XML for accepting disclaimer authentication.
 */

DisclaimerHandler.prototype.setRequestXML = function () {
   var paramText = void 0,
       acceptText = _util2.default.createElement("name", "accept");
   acceptText += _util2.default.createElement("values", _util2.default.createElement("value", "true"));
   paramText = _util2.default.createElement("param", acceptText);

   paramText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", "disclaimer");
   this.requestXML += paramText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/**
 * parse the response of winCredsHandler
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return Object. key-value pairs parsed from response, if error then return
 *    null
 */

DisclaimerHandler.prototype.parseResult = function (responseXML) {
   var authResponse = {};
   _util2.default.addItemForJson(authResponse, "screen", (0, _jquery2.default)(responseXML).children("name").text());
   (0, _jquery2.default)(responseXML).children("params").children("param").each(function () {
      var child = (0, _jquery2.default)(this);
      var nameText = child.find("name").text();
      var valueList = [];
      child.find("value").each(function () {
         valueList.push((0, _jquery2.default)(this).text());
      });
      _util2.default.addItemForJson(authResponse, nameText, valueList);
   });

   return authResponse;
};

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DoCancelAuthenticationHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * doCancelAuthenticationHandler.js --
 *
 *      Implementation of the message handler to cancel authentication.
 */

function DoCancelAuthenticationHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "do-cancel-authentication";
   this.messageText = "do-cancel-authentication";
   this.responseTag = "cancel-authentication";

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
   }
}

// inherits MessageHandler prototype
DoCancelAuthenticationHandler.prototype = new _messageHandler.MessageHandler();

// constructor
DoCancelAuthenticationHandler.constructor = DoCancelAuthenticationHandler;

/**
 * parse configuration information from the response XML of GetConfiguration
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return Object. key-value pairs parsed from response, if error then return null
 */
DoCancelAuthenticationHandler.prototype.parseResult = function (responseXML) {
   var cancelAuthResponse = {},
       xmlDoc = (0, _jquery2.default)(responseXML),
       brokerTag = void 0,
       responses = void 0,
       result = void 0;

   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of doCancelAuthenticationHandler error");
      return null;
   }

   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   _util2.default.addItemForJson(cancelAuthResponse, "result", result);
   return cancelAuthResponse;
};

DoCancelAuthenticationHandler.prototype.onUpdated = function () {
   var cancelAuthAction = { name: "Portal" };
   var router = _util2.default.getObject(_jscdkClient.globalArray, "router");

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this);
   /**
    * Currently we ignore failure because some older brokers do not support
    * this message.  The only valid error from a broker that supports this
    * feature is ALREADY_AUTHENTICATED, but we will hopefully never get that
    * error because we will only trigger this handler if we aren't fully
    * authenticated.
    */
   this.setState(_messageHandler.StateEnum.DONE);

   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(cancelAuthAction));
   if (!!router) {
      router.setDoCancelAuthentication();
      _jscdkLogger2.default.info("Cancel authentication completed.");
   }
   if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
      _jscdkLogger2.default.debug("Cancel authentication result is OK.");
   } else {
      _jscdkLogger2.default.error("Cancel authentication failed.");
   }
};

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DisconnectSessionHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DisconnectSessionHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "disconnect-session";
   this.messageText = "disconnect-session";
   this.responseTag = "disconnect-session";
   this.composedHandlerList = [];

   this.launchItemId = '';

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * disconnectSessionHandler.js --
 *
 *      Implementation of the message handler to disconnect session.
 */

DisconnectSessionHandler.prototype = new _messageHandler.MessageHandler();
// constructor
DisconnectSessionHandler.constructor = DisconnectSessionHandler;

/**
 * parse information from the response XML of disconnect-session
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return Object. key-value pairs parsed from response, if error then return
 *    null
 */
DisconnectSessionHandler.prototype.parseResult = function (responseXML) {
   var disconnectSessionResponse = {},
       xmlDoc = (0, _jquery2.default)(responseXML),
       brokerTag = void 0,
       responses = void 0,
       result = void 0;

   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of disconnectSessionHandler error");
      return null;
   }

   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   if (result === "ok" || result === "error") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases.
       */
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(disconnectSessionResponse, nameText, (0, _jquery2.default)(this).text());
      });
   }

   return disconnectSessionResponse;
};

/**
 * Set the request XML for disconnect-session
 * @param sessionId[in] session id to disconnect-session
 *
 */
DisconnectSessionHandler.prototype.setRequestXML = function (sessionId) {
   var sessionIdElem = void 0;
   sessionIdElem = _util2.default.createElement("session-id", sessionId);
   this.requestXML = sessionIdElem;
};

/**
 * callback when received notification from handlers in dependency list or
 * router
 *
 */
DisconnectSessionHandler.prototype.onUpdated = function () {
   var disconnectSessionAction = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
         _jscdkLogger2.default.debug('disconnect-session succeeds.');

         // Disconnect session succeeds
         disconnectSessionAction = { name: "DisconnectSession", result: "ok" };
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(disconnectSessionAction));
      }
   } else if (this.state === _messageHandler.StateEnum.FAIL) {
      /*
       * Disconnect session failed.
       * The DisconnectionSessionfailed is needed to avoid bug 1374808.
       */
      _jscdkLogger2.default.debug('disconnect-session failed. Session ID:' + this.launchItemId);
      disconnectSessionAction = { name: "DisconnectSessionFailed", result: "failed" };
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(disconnectSessionAction));
   } else {
      _router2.default.prototype.pushErrorToUser(this);
   }
};

/**
 * Triggered by the parent handler
 *
 */
DisconnectSessionHandler.prototype.triggerExecution = function () {
   var getLaunchItemsObject = void 0,
       desktops = void 0,
       targetDesktop = void 0,
       sessionId = void 0,
       handlerList = void 0,
       launchItemId = this.launchItemId,
       router = _jscdkClient.globalArray['router'];

   _messageHandler.MessageHandler.prototype.triggerExecution.apply(this);

   // Get session ID of the desktop whose id equals desktopId.
   getLaunchItemsObject = this.parentHandler;
   if (!getLaunchItemsObject) {
      getLaunchItemsObject = _jscdkClient.globalArray['get-launch-items' + launchItemId];
   }
   if (!!getLaunchItemsObject && !!getLaunchItemsObject.content["parsedResult"]) {
      desktops = getLaunchItemsObject.content["parsedResult"]["desktops"];
   }
   if (!!desktops) {
      targetDesktop = getLaunchItemsObject.findDesktop(launchItemId, desktops);
   }
   if (!!targetDesktop) {
      sessionId = targetDesktop["session-id"];
   } else {
      // While there is no desktop id associated with the session id,
      // Assuming the launchItemId is an application session id.
      sessionId = launchItemId;
   }

   // Disconnect the given session.
   if (!!sessionId && sessionId.trim() !== "") {
      this.setRequestXML(sessionId);
      handlerList = this.composeHandlerList();
      router.postMessage(handlerList);
   }
};

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DoSubmitAuthenticationHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _winCredsHandler = __webpack_require__(218);

var _winCredsHandler2 = _interopRequireDefault(_winCredsHandler);

var _securIDPasscodeHandler = __webpack_require__(213);

var _securIDPasscodeHandler2 = _interopRequireDefault(_securIDPasscodeHandler);

var _unauthHandler = __webpack_require__(217);

var _unauthHandler2 = _interopRequireDefault(_unauthHandler);

var _securIDNextTokenCodeHandler = __webpack_require__(212);

var _securIDNextTokenCodeHandler2 = _interopRequireDefault(_securIDNextTokenCodeHandler);

var _securIDPinChangeHandler = __webpack_require__(214);

var _securIDPinChangeHandler2 = _interopRequireDefault(_securIDPinChangeHandler);

var _securIDWaitHandler = __webpack_require__(215);

var _securIDWaitHandler2 = _interopRequireDefault(_securIDWaitHandler);

var _disclaimerHandler = __webpack_require__(199);

var _disclaimerHandler2 = _interopRequireDefault(_disclaimerHandler);

var _changeWindowsPasswordHandler = __webpack_require__(198);

var _changeWindowsPasswordHandler2 = _interopRequireDefault(_changeWindowsPasswordHandler);

var _samlHandler = __webpack_require__(211);

var _samlHandler2 = _interopRequireDefault(_samlHandler);

var _certAuthHandler = __webpack_require__(197);

var _certAuthHandler2 = _interopRequireDefault(_certAuthHandler);

var _getDesktopsHandler = __webpack_require__(17);

var _getDesktopsHandler2 = _interopRequireDefault(_getDesktopsHandler);

var _getLaunchItemsHandler = __webpack_require__(14);

var _getLaunchItemsHandler2 = _interopRequireDefault(_getLaunchItemsHandler);

var _getTunnelConnectionHandler = __webpack_require__(23);

var _getTunnelConnectionHandler2 = _interopRequireDefault(_getTunnelConnectionHandler);

var _idleTimeoutTimerController = __webpack_require__(56);

var _idleTimeoutTimerController2 = _interopRequireDefault(_idleTimeoutTimerController);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DoSubmitAuthenticationHandler() {
   var getConfigurationObject = void 0,
       router = void 0;

   // member variables below
   this.messageName = "do-submit-authentication";
   this.messageText = "do-submit-authentication";
   this.responseTag = "submit-authentication";

   this.authAction = {};
   this.reAuthFlag = false;
   // Cache the credential handler, clear it after sending login info
   this.credsHandler = null;

   // register dependencies below
   getConfigurationObject = _util2.default.getObject(_jscdkClient.globalArray, 'get-configuration');
   if (!!getConfigurationObject) {
      this.registerHandler(getConfigurationObject, 'state');
   }
   router = _util2.default.getObject(_jscdkClient.globalArray, 'router');
   if (!!router) {
      this.registerHandler(router, 'receiver');
      this.registerHandler(router, 'doLogout');
      this.registerHandler(router, 'doCancelAuthentication');
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * doSubmitAuthenticationHandler.js --
 *
 *      Implementation of the message handler to submit authentication.
 */

DoSubmitAuthenticationHandler.prototype = new _messageHandler.MessageHandler();
// constructor
DoSubmitAuthenticationHandler.constructor = DoSubmitAuthenticationHandler;

DoSubmitAuthenticationHandler.prototype.setReAuthFlag = function (isReAuth) {
   this.reAuthFlag = isReAuth || false;
};

DoSubmitAuthenticationHandler.prototype.setDesktopReAuthFlag = function (isDesktopReAuth) {
   this.desktopReAuthFlag = isDesktopReAuth || false;
};

/**
 * Set the authentication action JSON.
 * @param action[in] the authentication action.
 */

DoSubmitAuthenticationHandler.prototype.setAuthAction = function (action) {
   var handler = void 0;
   this.authAction = action;
   if (action.type === "WindowsPassword") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "windows-password");
      if (!handler) {
         handler = new _winCredsHandler2.default();
      }
      handler.setRequestXML(action.domain, action.username, action.secret);
   } else if (action.type === "SecurIDPasscode") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "securid-passcode");
      if (!handler) {
         handler = new _securIDPasscodeHandler2.default();
      }
      handler.setRequestXML(action.username, action.secret);
   } else if (action.type === "SecurIDNextTokenCode") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "securid-nexttokencode");
      if (!handler) {
         handler = new _securIDNextTokenCodeHandler2.default();
      }
      handler.setRequestXML(action.secret);
   } else if (action.type === "SecurIDPinChange") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "securid-pinchange");
      if (!handler) {
         handler = new _securIDPinChangeHandler2.default();
      }
      handler.setRequestXML(action.pin1, action.pin2);
   } else if (action.type === "SecurIDWait") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "securid-wait");
      if (!handler) {
         handler = new _securIDWaitHandler2.default();
      }
      handler.setRequestXML();
   } else if (action.type === "Disclaimer") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "disclaimer");
      if (!handler) {
         handler = new _disclaimerHandler2.default();
      }
      handler.setRequestXML();
   } else if (action.type === "WindowsPasswordExpired") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "windows-password-expired");
      if (!handler) {
         handler = new _changeWindowsPasswordHandler2.default();
      }
      handler.setRequestXML(action.oldPassword, action.newPassword1, action.newPassword2);
   } else if (action.type === "SAML") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "saml");
      if (!handler) {
         handler = new _samlHandler2.default();
      }
      handler.setRequestXML(action.secret);
   } else if (action.type === "CertAuth") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "cert-auth");
      if (!handler) {
         handler = new _certAuthHandler2.default();
      }
      handler.setRequestXML(action.accept);
   } else if (action.type === "Unauthenticated") {
      handler = _util2.default.getObject(_jscdkClient.globalArray, "unauthenticated");
      if (!handler) {
         handler = new _unauthHandler2.default();
      }
      handler.setRequestXML(action.username);
   }

   if (!_jscdkClient.globalArray[handler.messageText]) {
      _jscdkClient.globalArray[handler.messageText] = handler;
   }
   if (!this.subHandlerList[handler.messageText]) {
      this.subHandlerList[handler.messageText] = handler;
   }

   if (!!handler) {
      this.requestXML = handler.requestXML;
      this.credsHandler = handler.messageName;
   } else {
      _jscdkLogger2.default.error("Sub handler for authentication is not defined!");
   }
};

/**
 * parse the response of doSubmitAuthentication
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */

DoSubmitAuthenticationHandler.prototype.parseResult = function (responseXML) {
   var authResponse = {},
       brokerTag = void 0,
       result = void 0,
       xmlDoc = (0, _jquery2.default)(responseXML),
       responses = void 0,
       screenXML = void 0,
       partialError = {};

   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);

   if (!brokerTag) {
      _jscdkLogger2.default.error("response of doSubmitAuthentication error");
      return null;
   }

   responses = brokerTag.children(this.responseTag);

   result = responses.children("result").text();
   if (result === "ok" || result === "error") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases.
       */
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(authResponse, nameText, (0, _jquery2.default)(this).text());
      });
   } else if (result === "partial") {
      /*
       * For the "partial" result, different dialogues will be shown to user
       * depending on different response types. Here calling the sub-handler's
       * parseResult function to parse them.
       */
      screenXML = responses.find("screen");
      _util2.default.addItemForJson(partialError, "screen", (0, _jquery2.default)(screenXML).children("name").text());
      (0, _jquery2.default)(screenXML).children("params").children("param").each(function () {
         var child = (0, _jquery2.default)(this),
             nameText = child.find("name").text(),
             isReadOnly = child.find("readonly").length,
             valueList = [];
         if (isReadOnly !== 0) {
            _util2.default.addItemForJson(partialError, nameText + "ReadOnly", "yes");
         } else {
            _util2.default.addItemForJson(partialError, nameText + "ReadOnly", "no");
         }
         child.find("value").each(function () {
            // Special handle for unauthenticated login
            if (partialError.screen === 'unauthenticated' && nameText === 'username') {
               valueList.push({
                  value: (0, _jquery2.default)(this).text(),
                  default: !!(0, _jquery2.default)(this).attr('default')
               });
            } else {
               valueList.push((0, _jquery2.default)(this).text());
            }
         });
         // If user input domain\username, adjust the username
         if (partialError.screen === "windows-password" && nameText === "username") {
            var winCredsHandler = _util2.default.getObject(_jscdkClient.globalArray, "windows-password");
            if (!!winCredsHandler && !!winCredsHandler.cachedDomainUsername) {
               valueList[0] = winCredsHandler.cachedDomainUsername;
            }
         }
         _util2.default.addItemForJson(partialError, nameText, valueList);
      });

      _util2.default.addItemForJson(authResponse, "result", result);
      _jquery2.default.extend(authResponse, partialError);
   }
   return authResponse;
};

/**
 * Do the desktops list connections after the authentication is done.
 *
 */
DoSubmitAuthenticationHandler.prototype.onAuthenticationDone = function () {
   var handlerList = void 0,
       getDesktopsObject = void 0,
       getLaunchItemsObject = void 0,
       addClientInfoObject = void 0,
       getTunnelConnObject = void 0,
       protocolsJson = [],
       supportedAppProtocols = void 0,
       type = void 0,
       router = _jscdkClient.globalArray["router"],
       idleTimerObject = void 0,
       parsedResult = void 0,
       userActivityInterval = void 0,
       idleTimeout = void 0,
       doReAuthAction = void 0;

   if (!this.reAuthFlag) {
      // "add-client-info" work after broker>= 9.0
      if (_util2.default.brokerSupportApplication()) {
         // send addClientInfo request
         addClientInfoObject = _jscdkClient.globalArray["add-client-info"];
         if (!!addClientInfoObject && addClientInfoObject.hasOwnProperty("clientInfo")) {
            addClientInfoObject.setRequestXML();
            if (!!router) {
               handlerList = addClientInfoObject.composeHandlerList();
               router.postMessage(handlerList);
            }
         }
      }

      // send getTunnelConnection request
      getTunnelConnObject = _util2.default.getObject(_jscdkClient.globalArray, "get-tunnel-connection");
      if (!getTunnelConnObject) {
         getTunnelConnObject = new _getTunnelConnectionHandler2.default();
         _jscdkClient.globalArray[getTunnelConnObject.messageName] = getTunnelConnObject;
         _jscdkClient.globalArray[getTunnelConnObject.responseTag] = getTunnelConnObject;
      } else {
         getTunnelConnObject.resetData();
      }

      getTunnelConnObject.setRequestXML(_jscdkClient.globalArray.bypassTunnel);
      if (!!getTunnelConnObject && !!router) {
         handlerList = getTunnelConnObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   }

   if (!_util2.default.brokerSupportApplication()) {
      // send getDesktops request
      getDesktopsObject = _util2.default.getObject(_jscdkClient.globalArray, "get-desktops");
      if (!getDesktopsObject) {
         getDesktopsObject = new _getDesktopsHandler2.default();
      } else {
         getDesktopsObject.resetData();
      }
      _jscdkClient.globalArray[getDesktopsObject.messageName] = getDesktopsObject;
      _jscdkClient.globalArray[getDesktopsObject.responseTag] = getDesktopsObject;

      protocolsJson = _util2.default.getObject(_jscdkClient.globalArray, "supportedProtocols");

      //In desktop page, after reauth, post a unlock message to UI.
      if (this.desktopReAuthFlag) {
         doReAuthAction = { name: "unLock", result: "ok" };
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(doReAuthAction));
      }

      if (!protocolsJson) {
         _jscdkLogger2.default.error("Supported protocols missing.");
         return;
      }

      getDesktopsObject.setRequestXML(protocolsJson);
      if (!!getDesktopsObject && !!router) {
         handlerList = getDesktopsObject.composeHandlerList();
         router.postMessage(handlerList);
      }
   } else {
      //launch idle timer
      idleTimerObject = _jscdkClient.globalArray["idle-timeout-timer"];
      if (!idleTimerObject) {
         idleTimerObject = new _idleTimeoutTimerController2.default();
         _jscdkClient.globalArray[idleTimerObject.globalName] = idleTimerObject;
      }
      parsedResult = this.content["parsedResult"];
      userActivityInterval = parseInt(parsedResult["user-activity-interval"], 10);
      idleTimeout = parseInt(parsedResult["idle-timeout"], 10);
      //init every time user logs in, could only happen in the UI
      idleTimerObject.init(userActivityInterval, idleTimeout, "Portal");
      idleTimerObject.ensureUpdatedOrStarted();

      //In desktop page, after reauth, post a unlock message to UI.
      if (this.desktopReAuthFlag) {
         doReAuthAction = { name: "unLock", result: "ok" };
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(doReAuthAction));
      }

      // send getLaunchItems request
      getLaunchItemsObject = _util2.default.getObject(_jscdkClient.globalArray, "get-launch-items");
      if (!getLaunchItemsObject) {
         getLaunchItemsObject = new _getLaunchItemsHandler2.default();
         _jscdkClient.globalArray[getLaunchItemsObject.messageName] = getLaunchItemsObject;
         _jscdkClient.globalArray[getLaunchItemsObject.responseTag] = getLaunchItemsObject;
      } else {
         getLaunchItemsObject.resetData();
      }

      protocolsJson = _util2.default.getObject(_jscdkClient.globalArray, "supportedProtocols");
      if (!protocolsJson) {
         _jscdkLogger2.default.error("Supported protocols missing.");
         return;
      }

      if (!!getLaunchItemsObject && !!router) {
         type = {};
         type.name = "remote";
         type.protocols = protocolsJson;
         supportedAppProtocols = [];
         supportedAppProtocols[0] = type;
         if (!!protocolsJson) {
            getLaunchItemsObject.setRequestXML(protocolsJson, supportedAppProtocols);
            handlerList = getLaunchItemsObject.composeHandlerList();
            router.postMessage(handlerList);
         } else {
            _jscdkLogger2.default.error("supported protocols is invalid.");
         }
      }
   }
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */

DoSubmitAuthenticationHandler.prototype.onUpdated = function () {
   var errorCode = void 0,
       parsedResult = void 0,
       getConfigurationObject = _jscdkClient.globalArray["get-configuration"];

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.content["parsedResult"]) {
      parsedResult = this.content["parsedResult"];
      if (!!parsedResult["error-code"]) {
         errorCode = parsedResult["error-code"];
         if (errorCode === "ALREADY_AUTHENTICATED") {
            this.setState(_messageHandler.StateEnum.DONE);
         }
      }

      if (parsedResult["result"] === "partial") {
         if (getConfigurationObject) {
            /**
             * GetConfigurationHandler handles the authentication related
             * dialogs.
             */
            getConfigurationObject.handleParsedResult(this.content["parsedResult"]);
         } else {
            _jscdkLogger2.default.error("Wrong case, no get-configuration but has do-submit-authentication");
         }
      }
   }

   // ensure handler has done its task and request is from "WindowsPassword" to
   // JSCDK
   if (this.state === _messageHandler.StateEnum.DONE) {
      this.onAuthenticationDone();
   }
   // push error to UI
   _router2.default.prototype.pushErrorToUser(this);
};

/**
 * This function is used to clear all the credential info stored in cache
 * It is requested from bug 1537589
 */
DoSubmitAuthenticationHandler.prototype.clearCreds = function () {
   if (!!this.credsHandler) {
      _jscdkClient.globalArray[this.credsHandler].requestXML = '';
   }
};

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DoUnlockHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _getConfigurationHandler = __webpack_require__(50);

var _timerUtil = __webpack_require__(25);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DoUnlockHandler() {
   // member variables below
   this.messageName = "do-unlock";
   this.messageText = "do-unlock";
   this.responseTag = "unlock";

   // register dependencies here
   var router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * doUnlockHandler.js --
 *
 *      Implementation of the message handler to send doUnlock.
 */

DoUnlockHandler.prototype = new _messageHandler.MessageHandler();
DoUnlockHandler.constructor = DoUnlockHandler;

DoUnlockHandler.prototype.setRequestXML = function () {
   // handle SAML
   var samlNameElem = void 0,
       haveAuthTypesElem = void 0,
       authTypes = void 0,
       getConfigObject = _jscdkClient.globalArray["get-configuration"];

   this.requestXML = "";
   if (getConfigObject) {
      authTypes = getConfigObject.getAuthTypes();

      if (authTypes === _getConfigurationHandler.HaveAuthTypesEnum.HAVEAUTHTYPE_SAML) {
         samlNameElem = _util2.default.createElement("name", "saml");
         haveAuthTypesElem = _util2.default.createElement("have-authentication-types", samlNameElem);
         this.requestXML = haveAuthTypesElem;
      }
   }
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
DoUnlockHandler.prototype.onUpdated = function () {

   var parsedResult = void 0,
       getConfigurationObject = _jscdkClient.globalArray["get-configuration"],
       router = _util2.default.getObject(_jscdkClient.globalArray, "router");

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      // prepare for already authentication case(locked is treated as already
      // authenticated)
      (0, _timerUtil.prepareForAlreadyAuthenticated)();
      // handler response to continue re-authentication
      if (!!this.content["parsedResult"]) {
         parsedResult = this.content["parsedResult"];
         if (getConfigurationObject) {
            //let GetConfigurationHandler handles the authentication related
            // dealing.
            getConfigurationObject.handleParsedResult(parsedResult, true);
         } else {
            _jscdkLogger2.default.error("Wrong case, no get-configuration but has do-unlock");
         }
      }
   }
   // push error to UI
   router.pushErrorToUser(this);
};

/**
 * parse locale information from the response XML of GetConfiguration
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return Object. key-value pairs parsed from response, if error then return
 *    null
 */
DoUnlockHandler.prototype.parseResult = function (responseXML) {
   var responseBody = void 0,
       brokerTag = void 0,
       responses = void 0,
       resultText = void 0,
       unlockResponse = {},
       authTag = void 0,
       authScreenTag = void 0;

   if (!responseXML || responseXML === "") {
      return null;
   }
   responseBody = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(responseBody.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of getAuthenticationStatus error");
      return null;
   }
   responses = brokerTag.children(this.responseTag);
   resultText = responses.children("result").text();
   if (!!resultText && resultText.trim() !== "") {
      unlockResponse["result"] = resultText;
   } else {
      _jscdkLogger2.default.error("response of getAuthenticationStatus error, no valid result tag");
      return null;
   }
   if (resultText === "ok") {
      authTag = brokerTag.find("authentication");
      if (!authTag) {
         _jscdkLogger2.default.error("No authentication element in response of do-unlock");
         return null;
      }

      authScreenTag = authTag.children("screen");
      if (!authScreenTag) {
         _jscdkLogger2.default.error("No screen element in response of do-unlock");
         return null;
      }
      _util2.default.addItemForJson(unlockResponse, "screen", (0, _jquery2.default)(authScreenTag).children("name").text());

      (0, _jquery2.default)(authScreenTag).children("params").children("param").each(function () {
         var child = (0, _jquery2.default)(this),
             nameText = child.find("name").text(),
             isReadOnly = child.find("readonly").length,
             valueList = [];

         if (isReadOnly !== 0) {
            _util2.default.addItemForJson(unlockResponse, nameText + "ReadOnly", "yes");
         } else {
            _util2.default.addItemForJson(unlockResponse, nameText + "ReadOnly", "no");
         }
         child.find("value").each(function () {
            valueList.push((0, _jquery2.default)(this).text());
         });
         _util2.default.addItemForJson(unlockResponse, nameText, valueList);
      });
   } else if (resultText === "error") {
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(unlockResponse, nameText, (0, _jquery2.default)(this).text());
      });
   }
   return unlockResponse;
};

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = FrontController;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function FrontController() {

   /**
    * Dictionary of command name to command class mappings.
    */
   var _commands = {};

   /**
    * Register a command class with the controller,
    * against a command name.
    *
    * @param commandName   command name
    * @param commandClass  command class e.g. ConnectToBrokerClass
    */
   this.addCommand = function (commandName, commandClass) {
      _commands[commandName] = commandClass;

      _jscdkLogger2.default.debug("Command [" + commandName + "] is added.");
   };

   /**
    * Returns the command class registered with the command name.
    *
    * @param commandName   command name
    * @returns  command class
    */
   this.getCommand = function (commandName) {
      if (_commands[commandName]) {
         return _commands[commandName];
      }

      _jscdkLogger2.default.warning("Command [" + commandName + "] is not registered.");
      return null;
   };

   /**
    * Deregister a command class with the command name.
    *
    * @param commandName   command name
    */
   this.removeCommand = function (commandName) {
      if (!!_commands[commandName]) {
         _commands[commandName] = null;
         delete _commands[commandName];

         _jscdkLogger2.default.debug("Command [" + commandName + "] is removed.");
      }
   };

   /**
    * Check if a command name to command class mapping is registered.
    *
    * @param commandName   command name
    * @returns Boolean true - registered, false - not registered
    */
   this.containCommand = function (commandName) {
      return !!this.getCommand(commandName);
   };

   /**
    * Execute a command by invoking its execute() method.
    *
    * @param action
    *        action is the request object
    *        which must contain a property called 'method'
    *        method corresponds to command name
    */
   this.execute = function (action) {
      var commandName = action.method;
      var commandClass = this.getCommand(commandName);
      if (commandClass) {
         return new commandClass().execute(action);
      }

      _jscdkLogger2.default.warning("Command [" + commandName + "] fails to execute.");
   };
} /*********************************************************
   * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/**
 * frontController.js --
 *
 * A base class for front controller,
 * that delegates requests to appropriate command classes.
 *
 * The role of front controller is to first register command handlers
 * against requests. Then per request, the front controller looks up
 * its table of registered events, finds the appropriate command for handling
 * the request and invokes the command by calling its execute() method.
 *
 */

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

/**
 * getApplicationConnectionHandler.js --
 *
 *      Implementation of the message handler to get application connection.
 */

exports.default = GetApplicationConnectionHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _setUserGlobalPrefHandler = __webpack_require__(13);

var _setUserGlobalPrefHandler2 = _interopRequireDefault(_setUserGlobalPrefHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlastType = {
   CURRENT: "current",
   NEW: "new"
};

function GetApplicationConnectionHandler() {
   // member variables
   this.messageName = "get-application-connection";
   this.messageText = "get-application-connection";
   this.responseTag = "application-connection";
   // Use current blastType by default.
   this.blastType = BlastType.CURRENT;

   this.preferences = {};

   this.originId = null;

   // register dependencies here
   var getLaunchItemsObject = void 0;
   var getTunnelConnObject = void 0,
       setPrefObject = void 0;
   var router = void 0;
   getLaunchItemsObject = _util2.default.getObject(_jscdkClient.globalArray, "get-launch-items");
   if (!!getLaunchItemsObject) {
      this.registerHandler(getLaunchItemsObject, "state");
   }
   getTunnelConnObject = _util2.default.getObject(_jscdkClient.globalArray, "get-tunnel-connection");
   if (!!getTunnelConnObject) {
      this.registerHandler(getTunnelConnObject, "state");
   }
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }

   // maybe not good to invoke the SetUserGlobalPrefHandler every time, would
   // be changed when re-factorying
   setPrefObject = _util2.default.getObject(_jscdkClient.globalArray, "set-user-global-preferences");
   if (!setPrefObject) {
      setPrefObject = new _setUserGlobalPrefHandler2.default();
      _jscdkClient.globalArray["set-user-global-preferences"] = setPrefObject;
   }
   this.composedHandlerList = [this, setPrefObject];
}

GetApplicationConnectionHandler.prototype = new _messageHandler.MessageHandler(); // inherits
// MessageHandler
// prototype
GetApplicationConnectionHandler.constructor = GetApplicationConnectionHandler;

GetApplicationConnectionHandler.prototype.saveOriginId = function (originId) {
   this.originId = originId;
};

GetApplicationConnectionHandler.prototype.isAppParamSupported = function () {
   return parseFloat(_jscdkClient.globalArray["brokerVersion"]) >= parseFloat(_jscdkClient.globalArray["applicationParamVersion"]);
};

/**
 * Generate xml  for launching params, written in a format that
 *     could be easily extended to support other params
 * @param  {object} launchParam The Object that contains launching params could
 *    be
 *     {args:["C:\Users\uesr01\Documents\test.docx",
 *    C:\Users\uesr01\Documents\the_other_test.docx]}
 * @return {string} The xml in the form of string
 */
GetApplicationConnectionHandler.prototype.getParamElement = function (launchParam) {
   var args = void 0,
       i = void 0,
       nameElement = "",
       paramElements = "",
       commandLineElement = "";

   if ((typeof launchParam === 'undefined' ? 'undefined' : _typeof(launchParam)) !== "object" || !this.isAppParamSupported()) {
      return "";
   }

   args = launchParam.args;
   if (Array.isArray(args) && args.length > 0) {
      nameElement = _util2.default.createElement("name", "appCommandLine");
      for (i = 0; i < args.length; i++) {
         if (args[i] !== "") {
            commandLineElement += _util2.default.createElement("value", args[i]);
         }
      }
      if (commandLineElement !== "") {
         commandLineElement = _util2.default.createElement("values", commandLineElement);
         paramElements += _util2.default.createElement("param", nameElement + commandLineElement);
      }
   }

   if (paramElements !== "") {
      paramElements = _util2.default.createElement("params", paramElements);
   }
   return paramElements;
};

/**
 * Set the request XML for getApplicationConnection.
 *
 * @param applicationId [in] application id to connect
 * @param protocol [in] which protocol to use
 * @param environmentInfo [in] optional object containing client info key/value
 *    pairs
 */
GetApplicationConnectionHandler.prototype.setRequestXML = function (applicationId, protocol, environmentInfo, maximized, launchParam) {
   var isWS1Mode = _jscdkClient.globalArray['ws1Mode'],
       urlHandler = void 0,
       applicationIdElement = _util2.default.createElement("application-id", applicationId),
       nameElement = _util2.default.createElement("name", protocol),
       protocolElement = _util2.default.createElement("protocol", nameElement),
       maximizedElement = typeof maximized === 'boolean' ? _util2.default.createElement("maximized", maximized) : _util2.default.createElement("maximized", "true"),
       environmentElement = "",
       infoElements = "",
       samlElement = "",
       key = void 0,
       paramElements = void 0;

   if (isWS1Mode) {
      urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");
      if (!!urlHandler && !!urlHandler.params && !!urlHandler.params.samlArt) {
         samlElement = _util2.default.createElement("saml-artifact", urlHandler.params.samlArt);
      }
   }

   // Generate the <environment-info> section if it was specified.
   if ((typeof environmentInfo === 'undefined' ? 'undefined' : _typeof(environmentInfo)) === "object") {
      for (key in environmentInfo) {
         if (environmentInfo.hasOwnProperty(key)) {
            infoElements += _util2.default.createElement("info", environmentInfo[key], {
               "name": key
            });
         }
      }
      environmentElement = _util2.default.createElement("environment-information", infoElements);
   }

   paramElements = this.getParamElement(launchParam);

   this.requestXML = applicationIdElement + samlElement + maximizedElement + protocolElement + environmentElement + paramElements;
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
GetApplicationConnectionHandler.prototype.onUpdated = function () {
   var parsedResult = void 0,
       needConnectionText = void 0,
       protocolName = void 0,
       token = void 0,
       launchArgs = void 0,
       address = void 0,
       port = void 0,
       userMessage = void 0,
       showApplicationAction = {},
       applicationResolution = {},
       content = {},
       router = void 0,
       id = void 0,
       userName = void 0,
       domainName = void 0,
       enableUsb = void 0,
       enableMmr = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (!!this.content["parsedResult"]) {
         parsedResult = this.content["parsedResult"];
         needConnectionText = parsedResult["new-connection-needed"];
         if (needConnectionText === "true") {
            protocolName = parsedResult["protocol"];
            if (protocolName.toLowerCase() === "blast") {
               id = parsedResult["id"];
               userName = parsedResult["user-name"];
               domainName = parsedResult["domain-name"];
               address = parsedResult["address"];
               port = parsedResult["port"];
               token = parsedResult["token"];
               if (!!token) {
                  launchArgs = JSON.parse(token);
                  if (!launchArgs) {
                     userMessage = _util2.default._("VMware Blast token error: JSON formatting is not valid.");
                     _jscdkLogger2.default.error("Blast token is not a valid JSON.");
                  } else if (!launchArgs["a"]) {
                     userMessage = _util2.default._("VMware Blast token error: VMware Blast token has no 'a' property.");
                     _jscdkLogger2.default.error("Blast token has no 'a' property.");
                  }
                  if (!!userMessage) {
                     // push error to UI
                     _router2.default.prototype.pushSelfDefinedError(this, userMessage);
                  }
               } else {
                  //throw an error
                  userMessage = _util2.default._("VMware Blast token error: token does not exist.");
                  _jscdkLogger2.default.error("Blast token does not exist.");
                  _router2.default.prototype.pushSelfDefinedError(this, userMessage);
               }
               enableUsb = parsedResult["enable-usb"];
               enableMmr = parsedResult["enable-mmr"];

               showApplicationAction.name = "ShowAppBlastApplication";
               content.id = id;
               content.userName = userName;
               content.domainName = domainName;
               content.url = this.createAppBlastLaunchApplicationAction(address, port, launchArgs);
               content.enableUsb = enableUsb;
               content.enableMmr = enableMmr;
               content.preferences = this.preferences;
               content.preferences.blastType = this.blastType;
               content.isApplicationSession = true;
               content.originId = this.originId;
               showApplicationAction.content = content;
            } else {
               // PCoIP or RDP just tells the UI about all of the parameters.
               showApplicationAction.name = "LaunchApplication";
               showApplicationAction.content = parsedResult;
            }
         } else {
            // no need to connect to a application that is currently connected
            showApplicationAction.name = "ApplicationAlreadyConnected"; // TODO:
            // should
            // add
            // map
            // in
            // the
            // UI
            // side
            // for
            // this
            // action
            id = parsedResult["id"];
            content.id = id;
            showApplicationAction.content = content;
            //can throw an exception here instead if needed
         }
         router = _jscdkClient.globalArray["router"];
         // Common code for appblast or others.
         if (!!router) {
            showApplicationAction.content.brokerUrl = encodeURIComponent(router.brokerUrl);
         }
         /**
          * parsed results of getApplicationConnection are of no use after this
          * function; reset data before UI refresh to avoid it triggered by
          * dependencies for multiple times reset data should be before
          * JSCDKSetUI to avoid unpredictable error during SetUI
          */
         this.content = {};
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(showApplicationAction));
      }
   }
   // if the error is special for this handler, alert
   _router2.default.prototype.pushErrorToUser(this);
};

/**
 * parse application connection information from the response XML
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */

GetApplicationConnectionHandler.prototype.parseResult = function (responseXML) {
   var brokerTag = void 0;
   var responses = void 0;
   var result = void 0;
   var tokenText = void 0;
   var applicationConnectionResponse = {};
   var xmlDoc = void 0;
   var listeners = void 0;
   var listenersNode = void 0;
   var listenerNode = void 0;
   var listener = void 0;
   var agentResponseNode = void 0;
   var agentResponse = void 0;
   var errorCode = void 0;
   var protocol = void 0;
   var protocolObj = void 0;
   var i = void 0;

   xmlDoc = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   if (result === "ok") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases
       */
      //make no check for the new-connection-needed property existence with
      // result set "ok", the absent of this property will cause response.name
      // = "ApplicationAlreadyConnected" in onUpdated(), if <id> is at least
      // provided
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(applicationConnectionResponse, nameText, (0, _jquery2.default)(this).text());
      });

      listenersNode = _util2.default.getChildNode((0, _jquery2.default)(responses)[0], "additional-listeners", 0);
      if (!!listenersNode) {
         listenerNode = listenersNode.getElementsByTagName("additional-listener");
      }
      if (!!listenerNode) {
         listeners = [];
         for (i = 0; i < listenerNode.length; i++) {
            listener = {};
            _util2.default.addItemForJson(listener, "name", listenerNode[i].getAttribute("name"));
            _util2.default.addItemForJson(listener, "value", (0, _jquery2.default)(listenerNode[i]).text());
            listeners[i] = listener;
         }

         _util2.default.addItemForJson(applicationConnectionResponse, "additional-listeners", listeners);
      }
      // handle token and default values here
      tokenText = applicationConnectionResponse["protocol-settings"];
      if (!!tokenText) {
         _util2.default.addItemForJson(applicationConnectionResponse, "token", tokenText);
      }
      return applicationConnectionResponse;
   } else if (result === "error") {
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(applicationConnectionResponse, nameText, (0, _jquery2.default)(this).text());
      });

      agentResponseNode = _util2.default.getChildNode((0, _jquery2.default)(responses)[0], "agent-response", 0);
      if (!!agentResponseNode) {
         agentResponse = {};
         errorCode = _util2.default.getChildNode(agentResponseNode, "error-code", 0);
         _util2.default.addItemForJson(agentResponse, "error-code", (0, _jquery2.default)(errorCode).text());

         protocol = _util2.default.getChildNode(agentResponseNode, "protocol", 0);
         if (!!protocol) {
            protocolObj = {};
            _util2.default.addItemForJson(protocolObj, "name", (0, _jquery2.default)(_util2.default.getChildNode(protocol, "name", 0)).text());
            _util2.default.addItemForJson(protocolObj, "error-code", (0, _jquery2.default)(_util2.default.getChildNode(protocol, "error-code", 0)).text());
            _util2.default.addItemForJson(agentResponse, "protocol", protocolObj);
         }

         _util2.default.addItemForJson(applicationConnectionResponse, "agent-response", agentResponse);
      }

      return applicationConnectionResponse;
   }
   return applicationConnectionResponse;
};

/**
 * Create the action to launch Blast application.
 *
 * @param host[in] the host for Blast.
 * @param port[in] the port for Blast.
 * @param args[in] the launch arguments for Blast.
 * @return launchUrl as a string for the application connection.
 */

GetApplicationConnectionHandler.prototype.createAppBlastLaunchApplicationAction = function (host, port, args) // TODO: may need to be changed when blast url
// format is known
{
   /*
    * Construct appblast application url.
    * https://view.corp.com/r/r-token-value/?vauth=auth-token-value (BSG)
    * OR
    * https://view.corp.com/d/d-token-value/?vauth=auth-token-value (direct)
    */
   var r = void 0,
       launchUrl = void 0;

   if (args.r) {
      r = '/r/' + args.r;
   } else {
      r = '/d/' + _util2.default.getUuid();
   }
   launchUrl = ['https://', host, ':', port, encodeURI(r), '/?vauth=', encodeURIComponent(args.a)].join('');
   _jscdkLogger2.default.trace("Blast url generated");
   return launchUrl;
};

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

/**
 * getApplicationSessionConnectionHandler.js --
 *
 *      Implementation of the message handler to get application session
 * connection.
 */

exports.default = GetApplicationSessionConnectionHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlastType = {
   CURRENT: "current",
   NEW: "new"
};

function GetApplicationSessionConnectionHandler() {
   // member variables
   this.messageName = "get-application-session-connection";
   this.messageText = "get-application-session-connection";
   this.responseTag = "application-session-connection";

   this.composedHandlerList = [];

   // Use current blastType by default.
   this.blastType = BlastType.CURRENT;
   this.callbackFunction = null;
   this.targetAppSessionId = null;
   this.originId = null;

   this.preferences = {};

   // register dependencies here
   var getLaunchItemsObject = void 0;
   var getTunnelConnObject = void 0;
   var router = void 0;
   getLaunchItemsObject = _util2.default.getObject(_jscdkClient.globalArray, "get-launch-items");
   if (!!getLaunchItemsObject) {
      this.registerHandler(getLaunchItemsObject, "state");
   }
   getTunnelConnObject = _util2.default.getObject(_jscdkClient.globalArray, "get-tunnel-connection");
   if (!!getTunnelConnObject) {
      this.registerHandler(getTunnelConnObject, "state");
   }
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

GetApplicationSessionConnectionHandler.prototype = new _messageHandler.MessageHandler(); // inherits
// MessageHandler
// prototype
GetApplicationSessionConnectionHandler.constructor = GetApplicationSessionConnectionHandler;

/**
 * using a bool to switch to call back API, which will be formal one after JSCDK
 * refactory
 */
GetApplicationSessionConnectionHandler.prototype.setCallbackFunction = function (callbackFunction) {
   this.callbackFunction = callbackFunction;
};

GetApplicationSessionConnectionHandler.prototype.setOriginId = function (originId) {
   this.originId = originId;
};

/**
 * Set the request XML for getApplicationSessionConnection.
 *
 * @param applicationSessionId [in] applicationSession id to connect
 * @param protocol [in] which protocol to use
 * @param environmentInfo [in] optional object containing client info key/value
 *    pairs
 */

GetApplicationSessionConnectionHandler.prototype.setRequestXML = function (applicationSessionId, protocol, environmentInfo, disconnectAll) {
   var applicationSessionIdElement = _util2.default.createElement("application-session-id", applicationSessionId),
       nameElement = _util2.default.createElement("name", protocol),
       protocolElement = _util2.default.createElement("protocol", nameElement),
       disconnectAllElement = "",
       environmentElement = "",
       infoElements = "",
       key = void 0,
       attrArray = void 0;

   if (disconnectAll === false) {
      disconnectAllElement = _util2.default.createElement("disconnect-all-sessions", false);
   } else {
      disconnectAllElement = _util2.default.createElement("disconnect-all-sessions", true);
   }

   this.targetAppSessionId = applicationSessionId;

   // Generate the <environment-info> section if it was specified.
   if ((typeof environmentInfo === 'undefined' ? 'undefined' : _typeof(environmentInfo)) === "object") {
      for (key in environmentInfo) {
         if (environmentInfo.hasOwnProperty(key)) {
            infoElements += _util2.default.createElement("info", environmentInfo[key], { "name": key });
         }
      }
      environmentElement = _util2.default.createElement("environment-information", infoElements);
   }

   this.requestXML = applicationSessionIdElement + disconnectAllElement + protocolElement + environmentElement;
};

GetApplicationSessionConnectionHandler.prototype.getConvertedResponse = function (responseAction) {
   var responseObj = {};

   responseObj.success = true;
   responseObj.sessionId = this.targetAppSessionId;
   switch (responseAction.name) {
      case "ShowAppBlastApplicationSession":
         responseObj.protocolIsBlast = true;
         responseObj.needNewConnectionWithBlast = true;
         responseObj.content = responseAction.content;
         responseObj.content.originId = this.originId;
         break;
      case "LaunchApplicationSession":
         responseObj.protocolIsBlast = false;
         responseObj.orgResponse = responseAction.content;
         break;
      case "ApplicationSessionAlreadyConnected":
         responseObj.protocolIsBlast = true;
         responseObj.needNewConnectionWithBlast = false;
         responseObj.content = { originId: this.originId };
         break;
   }
   return responseObj;
};

GetApplicationSessionConnectionHandler.prototype.hasError = function () {
   return !!this.content["error"];
};

GetApplicationSessionConnectionHandler.prototype.getErrorResponseBy = function (errorObj) {
   return {
      success: false,
      error: errorObj,
      sessionId: this.targetAppSessionId
   };
};

GetApplicationSessionConnectionHandler.prototype.handleSelfDefinedError = function (userMessage) {
   var errorObj = void 0,
       errorResponse = void 0;

   if (typeof this.callbackFunction === 'function') {
      errorObj = _util2.default.getSelfDefinedErrorObjectBy(this, userMessage);
      errorResponse = this.getErrorResponseBy(errorObj);
      this.callbackFunction(errorObj);
      this.callbackFunction = null;
   } else {
      _router2.default.prototype.pushSelfDefinedError(this, userMessage);
   }
};

GetApplicationSessionConnectionHandler.prototype.handleSuccess = function (responseAction) {
   var convertedResult = void 0;

   if (typeof this.callbackFunction === 'function') {
      convertedResult = this.getConvertedResponse(responseAction);
      this.callbackFunction(convertedResult);
      this.callbackFunction = null;
   } else {
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(responseAction));
   }
};

GetApplicationSessionConnectionHandler.prototype.handleError = function () {
   var errorObj = void 0,
       errorResponse = void 0,
       key = this.messageName;

   if (typeof this.callbackFunction === 'function') {
      errorObj = this.content["error"][key];
      errorResponse = this.getErrorResponseBy(errorObj);
      this.callbackFunction(errorResponse);
      this.callbackFunction = null;
   } else {
      _router2.default.prototype.pushErrorToUser(this);
   }
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
GetApplicationSessionConnectionHandler.prototype.onUpdated = function () {
   var parsedResult = void 0,
       needConnectionText = void 0,
       protocolName = void 0,
       token = void 0,
       launchArgs = void 0,
       address = void 0,
       port = void 0,
       userMessage = void 0,
       showApplicationSessionAction = {},
       applicationSessionResolution = {},
       content = {},
       router = void 0,
       id = void 0,
       userName = void 0,
       domainName = void 0,
       enableUsb = void 0,
       enableMmr = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
         parsedResult = this.content["parsedResult"];
         needConnectionText = parsedResult["new-connection-needed"];
         if (needConnectionText === "true") {
            protocolName = parsedResult["protocol"];
            if (protocolName.toLowerCase() === "blast") {
               id = parsedResult["id"];
               userName = parsedResult["user-name"];
               domainName = parsedResult["domain-name"];
               address = parsedResult["address"];
               port = parsedResult["port"];
               token = parsedResult["token"];
               if (!!token) {
                  launchArgs = JSON.parse(token);
                  if (!launchArgs) {
                     userMessage = _util2.default._("VMware Blast token error: JSON formatting is not valid.");
                     _jscdkLogger2.default.error("Blast token is not a valid JSON.");
                  } else if (!launchArgs["a"]) {
                     userMessage = _util2.default._("VMware Blast token error: VMware Blast token has no 'a' property.");
                     _jscdkLogger2.default.error("Blast token has no 'a' property.");
                  }
                  if (!!userMessage) {
                     // push error to UI
                     this.handleSelfDefinedError(userMessage);
                  }
               } else {
                  //throw an error
                  userMessage = _util2.default._("VMware Blast token error: token does not exist.");
                  _jscdkLogger2.default.error("Blast token does not exist.");
                  this.handleSelfDefinedError(userMessage);
               }
               enableUsb = parsedResult["enable-usb"];
               enableMmr = parsedResult["enable-mmr"];

               showApplicationSessionAction.name = "ShowAppBlastApplicationSession";
               content.id = id;
               content.userName = userName;
               content.domainName = domainName;
               content.url = this.createAppBlastLaunchApplicationSessionAction(address, port, launchArgs);
               content.enableUsb = enableUsb;
               content.enableMmr = enableMmr;
               content.preferences = this.preferences;
               content.preferences.blastType = this.blastType;
               content.isApplicationSession = true;
               showApplicationSessionAction.content = content;
            } else {
               // PCoIP or RDP just tells the UI about all of the parameters.
               showApplicationSessionAction.name = "LaunchApplicationSession";
               showApplicationSessionAction.content = parsedResult;
            }
         } else {
            // no need to connect to a application that is currently connected
            showApplicationSessionAction.name = "ApplicationSessionAlreadyConnected"; // TODO: should add map in
            // the UI side for this
            // action
            id = parsedResult["id"];
            content.id = id;
            showApplicationSessionAction.content = content;
            //can throw an exception here instead if needed
         }
         router = _jscdkClient.globalArray["router"];
         // Common code for appblast or others.
         if (!!router) {
            showApplicationSessionAction.content.brokerUrl = encodeURIComponent(router.brokerUrl);
         }
         /**
          * parsed results of getApplicationSessionConnection are of no use
          * after this function; reset data before UI refresh to avoid it
          * triggered by dependencies for multiple times reset data should be
          * before JSCDKSetUI to avoid unpredictable error during SetUI
          */
         this.content = {};

         this.handleSuccess(showApplicationSessionAction);
      }
   }
   // if the error is special for this handler, alert

   if (this.hasError()) {
      this.handleError();
   }
};

/**
 * parse applicationSession connection information from the response XML
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */

GetApplicationSessionConnectionHandler.prototype.parseResult = function (responseXML) {
   var brokerTag = void 0;
   var responses = void 0;
   var result = void 0;
   var tokenText = void 0;
   var applicationSessionConnectionResponse = {};
   var xmlDoc = void 0;
   var listeners = void 0;
   var listenersNode = void 0;
   var listenerNode = void 0;
   var listener = void 0;
   var agentResponseNode = void 0;
   var agentResponse = void 0;
   var errorCode = void 0;
   var protocol = void 0;
   var protocolObj = void 0;
   var i = void 0;

   xmlDoc = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   if (result === "ok") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases
       */
      //make no check for the new-connection-needed property existence with
      // result set "ok", the absent of this property will cause
      // response.name = "ApplicationAlreadyConnected" in onUpdated(), works
      // well if <id> is at least provided
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(applicationSessionConnectionResponse, nameText, (0, _jquery2.default)(this).text());
      });

      listenersNode = _util2.default.getChildNode((0, _jquery2.default)(responses)[0], "additional-listeners", 0);
      if (!!listenersNode) {
         listenerNode = listenersNode.getElementsByTagName("additional-listener");
      }
      if (!!listenerNode) {
         listeners = [];
         for (i = 0; i < listenerNode.length; i++) {
            listener = {};
            _util2.default.addItemForJson(listener, "name", listenerNode[i].getAttribute("name"));
            _util2.default.addItemForJson(listener, "value", (0, _jquery2.default)(listenerNode[i]).text());
            listeners[i] = listener;
         }

         _util2.default.addItemForJson(applicationSessionConnectionResponse, "additional-listeners", listeners);
      }
      // handle token and default values here
      tokenText = applicationSessionConnectionResponse["protocol-settings"];
      if (!!tokenText) {
         _util2.default.addItemForJson(applicationSessionConnectionResponse, "token", tokenText);
      }
      return applicationSessionConnectionResponse;
   } else if (result === "error") {
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         _util2.default.addItemForJson(applicationSessionConnectionResponse, nameText, (0, _jquery2.default)(this).text());
      });

      agentResponseNode = _util2.default.getChildNode((0, _jquery2.default)(responses)[0], "agent-response", 0);
      if (!!agentResponseNode) {
         agentResponse = {};
         errorCode = _util2.default.getChildNode(agentResponseNode, "error-code", 0);
         _util2.default.addItemForJson(agentResponse, "error-code", (0, _jquery2.default)(errorCode).text());

         protocol = _util2.default.getChildNode(agentResponseNode, "protocol", 0);
         if (!!protocol) {
            protocolObj = {};
            _util2.default.addItemForJson(protocolObj, "name", (0, _jquery2.default)(_util2.default.getChildNode(protocol, "name", 0)).text());
            _util2.default.addItemForJson(protocolObj, "error-code", (0, _jquery2.default)(_util2.default.getChildNode(protocol, "error-code", 0)).text());
            _util2.default.addItemForJson(agentResponse, "protocol", protocolObj);
         }

         _util2.default.addItemForJson(applicationSessionConnectionResponse, "agent-response", agentResponse);
      }

      return applicationSessionConnectionResponse;
   }
   return applicationSessionConnectionResponse;
};

/**
 * Create the action to launch Blast applicationSession.
 *
 * @param host[in] the host for Blast.
 * @param port[in] the port for Blast.
 * @param args[in] the launch arguments for Blast.
 * @return launchUrl as a string for the applicationSession connection.
 */

GetApplicationSessionConnectionHandler.prototype.createAppBlastLaunchApplicationSessionAction = function (host, port, args) {
   /*
    * Construct appblast applicationSession url.
    * https://view.corp.com/r/r-token-value/?vauth=auth-token-value (BSG)
    * OR
    * https://view.corp.com/d/d-token-value/?vauth=auth-token-value (direct)
    */
   var r = void 0,
       launchUrl = void 0;

   if (args.r) {
      r = '/r/' + args.r;
   } else {
      r = '/d/' + _util2.default.getUuid();
   }
   launchUrl = ['https://', host, ':', port, encodeURI(r), '/?vauth=', encodeURIComponent(args.a)].join('');
   _jscdkLogger2.default.trace("Blast url generated");
   return launchUrl;
};

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

/**
 * getDesktopConnectionHandler.js --
 *
 *      Implementation of the message handler to get desktop connection.
 */

exports.default = GetDesktopConnectionHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _setUserGlobalPrefHandler = __webpack_require__(13);

var _setUserGlobalPrefHandler2 = _interopRequireDefault(_setUserGlobalPrefHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlastType = {
   CURRENT: "current",
   NEW: "new"
};

function GetDesktopConnectionHandler() {
   var getDesktopsObject = void 0,
       getTunnelConnObject = void 0,
       router = void 0,
       setPrefObject = void 0;

   // member variables
   this.messageName = "get-desktop-connection";
   this.messageText = "get-desktop-connection";
   this.responseTag = "desktop-connection";
   // Use current blastType by default.
   this.blastType = BlastType.CURRENT;

   this.preferences = {};

   // register dependencies here
   getDesktopsObject = _util2.default.getObject(_jscdkClient.globalArray, "get-desktops");
   if (!!getDesktopsObject) {
      this.registerHandler(getDesktopsObject, "state");
   }
   getTunnelConnObject = _util2.default.getObject(_jscdkClient.globalArray, "get-tunnel-connection");
   if (!!getTunnelConnObject) {
      this.registerHandler(getTunnelConnObject, "state");
   }
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }

   // maybe not good to invoke the SetUserGlobalPrefHandler every time, would
   // be changed when re-factorying
   setPrefObject = _util2.default.getObject(_jscdkClient.globalArray, "set-user-global-preferences");
   if (!setPrefObject) {
      setPrefObject = new _setUserGlobalPrefHandler2.default();
      _jscdkClient.globalArray["set-user-global-preferences"] = setPrefObject;
   }
   this.composedHandlerList = [this, setPrefObject];
}

//inherits MessageHandler prototype
GetDesktopConnectionHandler.prototype = new _messageHandler.MessageHandler();

GetDesktopConnectionHandler.constructor = GetDesktopConnectionHandler;

/**
 * Set the request XML for getDesktopConnection.
 *
 * @param desktopId [in] desktop id to connect
 * @param protocol [in] which protocol to use
 * @param environmentInfo [in] optional object containing client info
 *    key/value pairs
 */

GetDesktopConnectionHandler.prototype.setRequestXML = function (desktopId, protocol, environmentInfo, isShadow) {
   var isWS1Mode = _jscdkClient.globalArray['ws1Mode'],
       urlHandler = void 0,
       desktopIdElement = _util2.default.createElement("desktop-id", desktopId),
       nameElement = _util2.default.createElement("name", protocol),
       protocolElement = _util2.default.createElement("protocol", nameElement),
       environmentElement = "",
       infoElements = "",
       samlElement = "",
       key = void 0;

   if (isShadow) {
      desktopIdElement = _util2.default.createElement("shadow-session-id", desktopId);
   }

   if (isWS1Mode) {
      urlHandler = _util2.default.getObject(_jscdkClient.globalArray, "url-handler");
      if (!!urlHandler && !!urlHandler.params && !!urlHandler.params.samlArt) {
         samlElement = _util2.default.createElement("saml-artifact", urlHandler.params.samlArt);
      }
   }

   // Generate the <environment-info> section if it was specified.
   if ((typeof environmentInfo === 'undefined' ? 'undefined' : _typeof(environmentInfo)) === "object") {
      for (key in environmentInfo) {
         if (environmentInfo.hasOwnProperty(key)) {
            infoElements += _util2.default.createElement("info", environmentInfo[key], { "name": key });
         }
      }
      environmentElement = _util2.default.createElement("environment-information", infoElements);
   }

   this.requestXML = desktopIdElement + samlElement + protocolElement + environmentElement;
};

/**
 * Set the preferences for getDesktopConnection.
 *
 * @param desktopPreferences [in] the desktop preferences JSON.
 */

GetDesktopConnectionHandler.prototype.setPreferences = function (desktopPreferences) {
   this.preferences = desktopPreferences;
   _jscdkLogger2.default.debug("Desktop preferences is " + JSON.stringify(this.preferences));
};

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
GetDesktopConnectionHandler.prototype.onUpdated = function () {
   var parsedResult = void 0,
       protocolName = void 0,
       token = void 0,
       launchArgs = void 0,
       address = void 0,
       port = void 0,
       userMessage = void 0,
       showDesktopAction = {},
       desktopResolution = {},
       content = {},
       redirectProperties = void 0,
       router = void 0,
       id = void 0,
       userName = void 0,
       domainName = void 0,
       isShadow = false;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (!!this.content["parsedResult"]) {
         parsedResult = this.content["parsedResult"];
         /**
          * We need to try to find if redirection properties exist for DaaS.
          * If so, there will be no other properties.
          */
         redirectProperties = parsedResult['redirect-properties'];
         if (!!redirectProperties && redirectProperties['server-address'] && redirectProperties['desktop-name'] && redirectProperties['saml-art'] && redirectProperties['desktop-protocol'] && redirectProperties['desktop-protocol'].toLowerCase() === "blast") {
            // Do the redirection
            showDesktopAction.name = "ShowAppBlastDesktop";
            content.redirectProperties = redirectProperties;
            showDesktopAction.content = content;
         } else {
            // No redirection
            protocolName = parsedResult["protocol"];
            if (protocolName.toLowerCase() === "blast") {
               id = parsedResult["id"];
               if (!id) {
                  id = parsedResult["shadow-session-id"];
                  isShadow = id ? true : false;
               }
               userName = parsedResult["user-name"];
               domainName = parsedResult["domain-name"];
               address = parsedResult["address"];
               port = parsedResult["port"];
               token = parsedResult["token"];
               launchArgs = JSON.parse(token);

               if (!launchArgs) {
                  userMessage = _util2.default._("VMware Blast token error: JSON formatting is not valid.");
                  _jscdkLogger2.default.error("Blast token is not a valid JSON.");
               }
               if (!launchArgs["a"]) {
                  userMessage = _util2.default._("VMware Blast token error: VMware Blast token has no 'a' property.");
                  _jscdkLogger2.default.error("Blast token has no 'a' property.");
               }
               if (!!userMessage) {
                  // push error to UI
                  _router2.default.prototype.pushSelfDefinedError(this, userMessage);
               }

               showDesktopAction.name = "ShowAppBlastDesktop";
               content.id = id;
               content.userName = userName;
               content.domainName = domainName;
               content.url = this.createAppBlastLaunchAction(address, port, launchArgs);
               content.preferences = this.preferences;
               content.preferences.blastType = this.blastType;
               content.isApplicationSession = false;
               content.isShadow = isShadow;
               showDesktopAction.content = content;
            } else {
               // PCoIP or RDP just tells the UI about all of the parameters.
               showDesktopAction.name = "LaunchDesktop";
               showDesktopAction.content = parsedResult;
            }
            router = _jscdkClient.globalArray["router"];
            // Common code for appblast or others.
            if (!!router) {
               showDesktopAction.content.brokerUrl = encodeURIComponent(router.brokerUrl);
            }
         }

         /**
          * parsed results of getDesktopConnection are of no use after this
          * function; reset data before UI refresh to avoid it triggered by
          * dependencies for multiple times reset data should be before
          * JSCDKSetUI to avoid unpredictable error during SetUI
          */
         this.content = {};
         (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(showDesktopAction));
      }
   }
   // if the error is special for this handler, alert
   _router2.default.prototype.pushErrorToUser(this);
};

/**
 * parse desktop connection information from the response XML
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */

GetDesktopConnectionHandler.prototype.parseResult = function (responseXML) {
   var self = this;
   var brokerTag = void 0;
   var responses = void 0;
   var result = void 0;
   var tokenText = void 0;
   var desktopConnectionResponse = {};
   var xmlDoc = void 0;

   xmlDoc = (0, _jquery2.default)(responseXML);
   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   if (result === "ok" || result === "error") {
      /*
       * Add the "ok" and "error" response to the response JSON struct,
       * because for the "ok" and "error" result, the response XML structure
       * are the same, the following code can work in both cases.
       */
      responses.children().each(function () {
         var nameText = this.localName || this.baseName;
         if (nameText === 'redirect-properties') {
            desktopConnectionResponse['redirect-properties'] = self.parseRedirectProperties((0, _jquery2.default)(this).children());
         } else {
            _util2.default.addItemForJson(desktopConnectionResponse, nameText, (0, _jquery2.default)(this).text());
         }
      });

      // handle token and default values here
      tokenText = desktopConnectionResponse["protocol-settings"];
      if (!!tokenText) {
         _util2.default.addItemForJson(desktopConnectionResponse, "token", tokenText);
      }
   }
   return desktopConnectionResponse;
};

/**
 * Create the action to launch Blast desktop.
 *
 * @param host[in] the host for Blast.
 * @param port[in] the port for Blast.
 * @param args[in] the launch arguments for Blast.
 * @return launchUrl as a string for the desktop connection.
 */

GetDesktopConnectionHandler.prototype.createAppBlastLaunchAction = function (host, port, args) {
   /*
    * Construct appblast desktop url.
    * https://view.corp.com/r/r-token-value/?vauth=auth-token-value (BSG)
    * OR
    * https://view.corp.com/d/d-token-value/?vauth=auth-token-value (direct)
    */
   var r = void 0;
   if (args.r) {
      r = '/r/' + args.r;
   } else {
      r = '/d/' + _util2.default.getUuid();
   }
   var launchUrl = ['https://', host, ':', port, encodeURI(r), '/?vauth=', encodeURIComponent(args.a)].join('');
   _jscdkLogger2.default.trace("Blast url generated");
   return launchUrl;
};

/**
 * Parse the redirect properties from broker response
 *
 * @param properties
 * @returns object contains all the redirect properties
 */
GetDesktopConnectionHandler.prototype.parseRedirectProperties = function (properties) {
   if (!properties || !properties.length) {
      return {};
   }

   var i = void 0,
       property = void 0,
       attrName = void 0,
       attrValue = void 0,
       res = {};

   for (i = 0; i < properties.length; i++) {
      property = properties[i];
      attrName = property.getAttribute('name');
      attrValue = property.textContent;
      if (!!attrName) {
         res[attrName] = attrValue;
      }
   }
   return res;
};

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = KillAllApplicationSessionsCtrl;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _killSessionHandler = __webpack_require__(24);

var _killSessionHandler2 = _interopRequireDefault(_killSessionHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * killAllApplicationSessionsCtrl.js--
 *
 *      middleware to reset all application sessions by
 *      sending multiple kill-session, will be deleted when
 *      JSCDK refactory by just using callback. It currently
 *      is used to solve the naming conflict and seperate the
 *      logic out.
 */

function KillAllApplicationSessionsCtrl() {
   // member variables below
   this.messageName = "kill-all-application-sessions";
   this.messageText = "kill-all-application-sessions";
   this.responseTag = "kill-all-application-sessions";
}

// inherits MessageHandler prototype
KillAllApplicationSessionsCtrl.prototype = new _messageHandler.MessageHandler();
// constructor
KillAllApplicationSessionsCtrl.constructor = KillAllApplicationSessionsCtrl;

KillAllApplicationSessionsCtrl.prototype.dealWithResponses = function (dataList) {
   var i = void 0,
       data = void 0,
       killAllApplicationSessionsAction = void 0,
       router = _jscdkClient.globalArray['router'],
       errorObj = void 0,
       failIdList = [];

   if (!dataList || !Array.isArray(dataList) || dataList.length <= 0) {
      _jscdkLogger2.default.error("the response list is invalid");
      return;
   }
   // here assume all error are of the same type, so only store the last one
   for (i = 0; i < dataList.length; i++) {
      data = dataList[i];
      if (data.result === "fail") {
         failIdList.push(data.sessionId);
         errorObj = data.error;
      }
   }
   if (failIdList.length === 0) {
      // Kill application sessions succeeds
      killAllApplicationSessionsAction = {
         name: "KillAllApplicationSessions",
         result: "ok"
      };
      (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(killAllApplicationSessionsAction));
   } else {
      // this is for reusing pushErrorToUser, will be brifer after jscdk
      // refactory, didn't rename error now
      errorObj.errorDetail = failIdList;
      this.content = {
         error: {
            test: errorObj
         }
      };
      router.pushErrorToUser(this);
   }
};

KillAllApplicationSessionsCtrl.prototype.getApplicationSessions = function () {
   var getLaunchItemsObject = void 0;
   getLaunchItemsObject = this.parentHandler;
   if (!getLaunchItemsObject) {
      getLaunchItemsObject = _jscdkClient.globalArray[this.messageName + "get-launch-items"];
   }
   if (!!getLaunchItemsObject && !!getLaunchItemsObject.content["parsedResult"]) {
      return getLaunchItemsObject.content["parsedResult"]["application-sessions"];
   }
   return null;
};

KillAllApplicationSessionsCtrl.prototype.getValidAndInvalidIdLists = function (applicationSessions) {
   var key = void 0,
       applicationSessionId = void 0,
       applicationSessionIdList = [],
       invalidOriginIdList = [];
   for (key in applicationSessions) {
      if (applicationSessions.hasOwnProperty(key)) {
         applicationSessionId = applicationSessions[key].id;
         // kill one of the application session.
         if (!!applicationSessionId && applicationSessionId.trim() !== "") {
            applicationSessionIdList.push(applicationSessionId);
         } else {
            invalidOriginIdList.push(applicationSessions[key]["origin-id"]);
         }
      }
   }
   return {
      valid: applicationSessionIdList,
      invalid: invalidOriginIdList
   };
};

KillAllApplicationSessionsCtrl.prototype.pushResetFailToUser = function () {
   var errorObj = {},
       router = _jscdkClient.globalArray['router'],
       errorMessage = void 0;

   errorObj.name = "JSCDK_ERROR_LOGOFF_POOL_FAILED";
   errorMessage = _util2.default._("Application sessions cannot be reset. Please contact your system administrator.");
   router.pushSelfDefinedError(errorObj, errorMessage);
   this.setState(_messageHandler.StateEnum.FAIL);
};

/**
 * Triggered by the parent handler
 *
 */
KillAllApplicationSessionsCtrl.prototype.triggerExecution = function () {
   var validAndInvalidIdLists = void 0,
       applicationSessionIdList = void 0,
       targetApplicationSessionId = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray['router'],
       killSessionObject = void 0,
       i = void 0,
       infoCombiner = void 0;

   _messageHandler.MessageHandler.prototype.triggerExecution.apply(this);

   validAndInvalidIdLists = this.getValidAndInvalidIdLists(this.getApplicationSessions());

   if (validAndInvalidIdLists.invalid.length === 0) {
      applicationSessionIdList = validAndInvalidIdLists.valid;
      if (applicationSessionIdList.length > 0) {
         // sending kill sessions
         infoCombiner = new _util2.default.InfoCombiner(applicationSessionIdList.length, this.dealWithResponses.bind(this));
         for (i = 0; i < applicationSessionIdList.length; i++) {
            targetApplicationSessionId = applicationSessionIdList[i];
            killSessionObject = _jscdkClient.globalArray['kill-session' + targetApplicationSessionId];
            if (!killSessionObject) {
               killSessionObject = new _killSessionHandler2.default();
               _jscdkClient.globalArray[killSessionObject.messageName + targetApplicationSessionId] = killSessionObject;
               _jscdkClient.globalArray[killSessionObject.responseTag + targetApplicationSessionId] = killSessionObject;
            } else {
               killSessionObject.resetData();
            }
            killSessionObject.setCallbackFunction(infoCombiner.onInfoReceived);
            killSessionObject.setRequestXML(targetApplicationSessionId);
            handlerList = killSessionObject.composeHandlerList();
            router.postMessage(handlerList);
         }
         this.setState(_messageHandler.StateEnum.DONE);
      } else {
         //fail to get a non-empty list, report error
         _jscdkLogger2.default.warning("There is no application session to be reset");
         this.pushResetFailToUser();
      }
   } else {
      //fail to get the list, report error
      _jscdkLogger2.default.error("The application sessions with origin-id(in list)" + JSON.stringify(validAndInvalidIdLists.invalid) + " cannot be reset.");
      this.pushResetFailToUser();
   }
};

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ReconnectAllApplicationSessionsCtrl;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _getApplicationSessionConnectionHandler = __webpack_require__(206);

var _getApplicationSessionConnectionHandler2 = _interopRequireDefault(_getApplicationSessionConnectionHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * reconnectApplicationSessionsCtrl.js--
 *
 *      middleware to reconnect application sessions by
 *      sending multiple get-application-session-connection,
 *      will be deleted when JSCDK refactory by just using
 *      callback. It currently is used to solve the naming
 *      conflict and seperate the logic out.
 *
 *      the repeating codes will be totally removed when JSCDK
 *      refactorying.
 *
 *      can't be called when last request is still being processed.
 */

function ReconnectAllApplicationSessionsCtrl() {
   // member variables below
   this.messageName = "reconnect-application-sessions";
   this.messageText = "reconnect-application-sessions";
   this.responseTag = "reconnect-application-sessions";
   this.presetInfo = {};
}

// inherits MessageHandler prototype
ReconnectAllApplicationSessionsCtrl.prototype = new _messageHandler.MessageHandler();
// constructor
ReconnectAllApplicationSessionsCtrl.constructor = ReconnectAllApplicationSessionsCtrl;

/**
 * public, standard exit point
 *
 * serve as the callback to handle all of the getApplicationSessionConnect XML
 * responses. will return a merged response to UI layer.
 */
ReconnectAllApplicationSessionsCtrl.prototype.dealWithResponses = function (dataList, self) {
   var i = void 0,
       data = void 0,
       router = _jscdkClient.globalArray['router'],
       errorObj = void 0,
       failIdList = [],
       successList = [];

   if (!dataList || !Array.isArray(dataList) || dataList.length <= 0) {
      _jscdkLogger2.default.error("the response list is invalid");
      return;
   }
   // here assume all error are of the same type, so only store the last one
   for (i = 0; i < dataList.length; i++) {
      data = dataList[i];
      if (data.success) {
         successList.push(data);
      } else {
         failIdList.push(data.sessionId);
         errorObj = data.error;
      }
   }
   if (failIdList.length === 0) {
      // reconnect application sessions success
      self.pushReconnectSuccessToUser(dataList);
   } else {
      // this is for reusing pushErrorToUser, will be brifer after jscdk
      // refactory, didn't rename error now
      errorObj.errorDetail = { failedSessionIdList: failIdList, successSessionList: successList };
      self.content = {
         error: {
            reconnectError: errorObj
         }
      };
      router.pushErrorToUser(self);
   }
};

/**
 * private, util
 * get application sesssion list from the parent handler, i.e. the
 * getLaunchItemHandler
 */
ReconnectAllApplicationSessionsCtrl.prototype.getApplicationSessions = function () {
   var getLaunchItemsObject = void 0;

   getLaunchItemsObject = this.parentHandler;
   if (!getLaunchItemsObject) {
      getLaunchItemsObject = _jscdkClient.globalArray[this.messageName + "get-launch-items"];
   }
   if (!!getLaunchItemsObject && !!getLaunchItemsObject.content["parsedResult"]) {
      return getLaunchItemsObject.content["parsedResult"]["application-sessions"];
   }
   return null;
};

/**
 * private
 *
 * @param tergetIdList out: of array
 *      will be filled with application session Ids
 * @param applicationSessions in: of Object
 *      formatted as part of get-launch-item response
 */
ReconnectAllApplicationSessionsCtrl.prototype.getAllValidAppSession = function (applicationSessions) {
   var key = void 0,
       applicationSessionId = void 0,
       sessionOriginId = void 0,
       idList = [],
       originIdList = [],
       excludedId = this.excludedOriginalId;

   for (key in applicationSessions) {
      if (applicationSessions.hasOwnProperty(key)) {
         applicationSessionId = applicationSessions[key].id;
         sessionOriginId = applicationSessions[key]["origin-id"];
         if (!!applicationSessionId && applicationSessionId.trim() !== "" && sessionOriginId !== excludedId) {
            idList.push(applicationSessionId);
            originIdList.push(sessionOriginId);
         }
      }
   }

   return { idList: idList, originIdList: originIdList };
};

/**
 * private
 *
 * pick out those invalid ids in the tergetIdList, and return it, the
 * definition of invalid is that the application session ID is requested but
 * not found in the valid application session list that returned from broker or
 * only consist of blanks.
 *
 * @param tergetIdList in: of Array
 *     the request application session list
 * @param applicationSessions in: of Object
 *     the active application session list get from the broker.
 */
ReconnectAllApplicationSessionsCtrl.prototype.getInvalidIdList = function (tergetIdList, applicationSessions) {
   var key = void 0,
       applicationSessionId = void 0,
       invalidRequestedSessionIdList = [],
       i = void 0,
       targetId = void 0,
       targetSessionIdExist = void 0;

   for (i = 0; i < tergetIdList.length; i++) {
      targetId = tergetIdList[i];
      targetSessionIdExist = false;
      for (key in applicationSessions) {
         if (applicationSessions.hasOwnProperty(key)) {
            applicationSessionId = applicationSessions[key].id;
            if (!!applicationSessionId && applicationSessionId.trim() !== "" && targetId === applicationSessionId) {
               targetSessionIdExist = true;
               break;
            }
         }
      }
      if (!targetSessionIdExist) {
         invalidRequestedSessionIdList.push(targetId);
      }
   }
   return invalidRequestedSessionIdList;
};

/**
 * private
 */
ReconnectAllApplicationSessionsCtrl.prototype.pushReconnectFailToUser = function (errorDetail) {
   var errorObj = {},
       router = _jscdkClient.globalArray['router'],
       errorMessage = void 0;

   errorObj.name = "JSCDK_ERROR_RECONNECT_POOL_FAILED";
   errorMessage = _util2.default._("Application sessions cannot be reconnected. Please contact your system administrator.");
   router.pushSelfDefinedError(errorObj, errorMessage, errorDetail);
   this.setState(_messageHandler.StateEnum.FAIL);
};

/**
 * private
 */
ReconnectAllApplicationSessionsCtrl.prototype.pushReconnectSuccessToUser = function (successSessionContent) {
   var reconnectSuccessAction = {};

   reconnectSuccessAction.name = "ReconnectAppSession";
   reconnectSuccessAction.content = successSessionContent;
   (0, _jscdkClient.JSCDKSetUI)(JSON.stringify(reconnectSuccessAction));
   this.setState(_messageHandler.StateEnum.DONE);
};

/**
 * private
 * return coresponding Origin Id in a list for each applicationSession that in
 * the tergetIdList(input param). the searching process is done with the input
 * param applicationSessions
 */
ReconnectAllApplicationSessionsCtrl.prototype.getOriginIdList = function (tergetIdList, applicationSessions) {
   var key = void 0,
       applicationSessionId = void 0,
       originIdList = [],
       i = void 0,
       targetId = void 0;

   for (i = 0; i < tergetIdList.length; i++) {
      targetId = tergetIdList[i];
      for (key in applicationSessions) {
         if (applicationSessions.hasOwnProperty(key)) {
            applicationSessionId = applicationSessions[key].id;
            if (targetId === applicationSessionId) {
               originIdList[i] = applicationSessions[key]["origin-id"];
               break;
            }
         }
      }
   }
   return originIdList;
};

/**
 * public, the only entry point
 *
 * Triggered by the parent handler
 * invoke getApplicationSessionConnection XML sendings
 */
ReconnectAllApplicationSessionsCtrl.prototype.triggerExecution = function () {
   var invalidIdList = void 0,
       allValidAppSessionInfo = void 0,
       targetIds = void 0,
       targetOriginIds = void 0,
       targetId = void 0,
       targetOriginId = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray['router'],
       AppSessionReconnector = void 0,
       i = void 0,
       infoCombiner = void 0;

   _messageHandler.MessageHandler.prototype.triggerExecution.apply(this);

   targetIds = this.targetSessionIds;
   if (targetIds.length === 0) {
      allValidAppSessionInfo = this.getAllValidAppSession(this.getApplicationSessions());
      targetIds = allValidAppSessionInfo.idList;
      targetOriginIds = allValidAppSessionInfo.originIdList;
      if (targetIds.length === 0) {
         // still no targets, then just treat as success
         this.pushReconnectSuccessToUser([]);
         return;
      }
   } else {
      invalidIdList = this.getInvalidIdList(targetIds, this.getApplicationSessions());
      if (!!invalidIdList && invalidIdList.length > 0) {
         this.pushReconnectFailToUser({ notExistingSessionIdList: invalidIdList });
         return;
      }
      targetOriginIds = this.getOriginIdList(targetIds, this.getApplicationSessions());
   }

   // sending reconnect sessions
   infoCombiner = new _util2.default.InfoCombiner(targetIds.length, this.dealWithResponses, this);
   for (i = 0; i < targetIds.length; i++) {
      targetId = targetIds[i];
      targetOriginId = targetOriginIds[i];

      // get AppSessionReconnector
      AppSessionReconnector = _jscdkClient.globalArray['get-application-session-connection' + targetId];
      if (!AppSessionReconnector) {
         AppSessionReconnector = new _getApplicationSessionConnectionHandler2.default();
         _jscdkClient.globalArray[AppSessionReconnector.messageName + targetId] = AppSessionReconnector;
         _jscdkClient.globalArray[AppSessionReconnector.responseTag + targetId] = AppSessionReconnector;
      } else {
         AppSessionReconnector.resetData();
      }

      // config and send request
      AppSessionReconnector.setCallbackFunction(infoCombiner.onInfoReceived);
      AppSessionReconnector.setOriginId(targetOriginId);
      AppSessionReconnector.setRequestXML(targetId, this.presetInfo.protocol, this.presetInfo.environmentInfo, this.presetInfo.disconnectAll);
      handlerList = AppSessionReconnector.composeHandlerList();
      router.postMessage(handlerList);
   }
   this.setState(_messageHandler.StateEnum.DONE);
};

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = RollbackCheckoutDesktopHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

var _router = __webpack_require__(6);

var _router2 = _interopRequireDefault(_router);

var _getDesktopsHandler = __webpack_require__(17);

var _getDesktopsHandler2 = _interopRequireDefault(_getDesktopsHandler);

var _getLaunchItemsHandler = __webpack_require__(14);

var _getLaunchItemsHandler2 = _interopRequireDefault(_getLaunchItemsHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * rollbackCheckoutDesktopHandler.js --
 *
 *      Implementation of the message handler to rollback desktop which is
 * checked out
 */

function RollbackCheckoutDesktopHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "rollback-checkout-desktop";
   this.messageText = "rollback-checkout-desktop";
   this.responseTag = "rollback-checkout-desktop";
   /**
    * requestId will increase when a new instance is created
    * use prototype requestId to share in all instances
    */
   RollbackCheckoutDesktopHandler.prototype.requestId += 1;

   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
   }
}

// inherits MessageHandler prototype
RollbackCheckoutDesktopHandler.prototype = new _messageHandler.MessageHandler();
// constructor
RollbackCheckoutDesktopHandler.constructor = RollbackCheckoutDesktopHandler;

/**
 * parse information from the response XML of rollbackCheckoutDesktop
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
RollbackCheckoutDesktopHandler.prototype.parseResult = function (responseXML) {
   var rollbackCheckoutDesktopResponse = {},
       xmlDoc = (0, _jquery2.default)(responseXML),
       brokerTag = void 0,
       responses = void 0,
       result = void 0;

   brokerTag = (0, _jquery2.default)(xmlDoc.children()[0]);
   if (!brokerTag) {
      _jscdkLogger2.default.error("response of rollbackCheckoutDesktopHandler error");
      return null;
   }

   responses = brokerTag.children(this.responseTag);
   result = responses.children("result").text();
   _util2.default.addItemForJson(rollbackCheckoutDesktopResponse, "result", result);
   return rollbackCheckoutDesktopResponse;
};

/**
 * Set the request XML for rollbackCheckoutDesktop
 * @param desktopId[in] desktop id to undo a previous checkout
 *
 */
RollbackCheckoutDesktopHandler.prototype.setRequestXML = function (desktopId) {
   var desktopIdElem = void 0;
   desktopIdElem = _util2.default.createElement("desktop-id", desktopId);
   this.requestXML = desktopIdElem;
};

RollbackCheckoutDesktopHandler.prototype.onUpdated = function () {
   var router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   var logoutFromBrokerAction = void 0;
   var getDesktopsObject = void 0;
   var getLaunchItemsObject = void 0;
   var supportedProtocols = void 0;
   var supportedAppProtocols = void 0;
   var handlerList = void 0;
   var type = void 0;

   _messageHandler.MessageHandler.prototype.onUpdated.apply(this);

   if (this.state === _messageHandler.StateEnum.DONE) {
      if (!!this.content["parsedResult"] && this.content["parsedResult"]["result"] === "ok") {
         _jscdkLogger2.default.debug("rollbackCheckoutDesktop result is OK.");
         if (!_util2.default.brokerSupportApplication()) {
            //send getDesktops request again and refresh desktop list in UI
            getDesktopsObject = _jscdkClient.globalArray["get-desktops"];
            if (!getDesktopsObject) {
               getDesktopsObject = new _getDesktopsHandler2.default();
               _jscdkClient.globalArray[getDesktopsObject.messageName] = getDesktopsObject;
               _jscdkClient.globalArray[getDesktopsObject.responseTag] = getDesktopsObject;
            } else {
               getDesktopsObject.resetData();
            }

            if (!!getDesktopsObject && !!router) {
               supportedProtocols = _jscdkClient.globalArray.supportedProtocols;
               if (!!supportedProtocols) {
                  getDesktopsObject.setRequestXML(supportedProtocols);
                  handlerList = getDesktopsObject.composeHandlerList();
                  router.postMessage(handlerList);
               } else {
                  _jscdkLogger2.default.error("supported protocols is invalid.");
               }
            }
         } else {
            getLaunchItemsObject = _jscdkClient.globalArray["get-launch-items"];
            if (!getLaunchItemsObject) {
               getLaunchItemsObject = new _getLaunchItemsHandler2.default();
               _jscdkClient.globalArray[getLaunchItemsObject.messageName] = getLaunchItemsObject;
               _jscdkClient.globalArray[getLaunchItemsObject.responseTag] = getLaunchItemsObject;
            } else {
               getLaunchItemsObject.resetData();
            }

            if (!!getLaunchItemsObject && !!router) {
               supportedProtocols = _jscdkClient.globalArray.supportedProtocols;
               type = {};
               type.name = "remote";
               type.protocols = supportedProtocols;
               supportedAppProtocols = [];
               supportedAppProtocols[0] = type;
               if (!!supportedProtocols) {
                  getLaunchItemsObject.setRequestXML(supportedProtocols, supportedAppProtocols);
                  handlerList = getLaunchItemsObject.composeHandlerList();
                  router.postMessage(handlerList);
               } else {
                  _jscdkLogger2.default.error("supported protocols is invalid.");
               }
            }
         }
      } else {
         _jscdkLogger2.default.error("rollbackCheckoutDesktop failed.");
         // XXX TODO: handle errors later(need update errorController), such as
         // INVALID_MVDI_STATE
      }
   }

   _router2.default.prototype.pushErrorToUser(this);
};

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SamlHandler;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SamlHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "saml";
   this.messageText = "saml";

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * samlHandler.js --
 *
 *     handle SAML authentication
 */

SamlHandler.prototype = new _messageHandler.MessageHandler();
// constructor
SamlHandler.constructor = SamlHandler;

/**
 * Set the request XML for saml authentication.
 *
 * @param secret [in] base64-encoded SAML artifact.
 */

SamlHandler.prototype.setRequestXML = function (secret) {
   var nameText = _util2.default.createElement("name", "artifact");
   var secretText = _util2.default.createElement("values", _util2.default.createElement("value", secret));
   var paramText = _util2.default.createElement("param", nameText + secretText);
   var paramsText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", "saml");
   this.requestXML += paramsText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SecurIDNextTokenCodeHandler;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SecurIDNextTokenCodeHandler() {
   var router = void 0;
   // member variables below
   this.messageName = "securid-nexttokencode";
   this.messageText = "securid-nexttokencode";

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * securIDNextTokenCodeHandler.js --
 *
 *      A sub-handler for DoSubmitAuthenticationHandler for SecurIDNextTokenCode
 *      authentication.
 */

SecurIDNextTokenCodeHandler.prototype = new _messageHandler.MessageHandler();
// constructor
SecurIDNextTokenCodeHandler.constructor = SecurIDNextTokenCodeHandler;

/**
 * Set the request XML for next token code authentication.
 *
 * @param tokenCode [in] token code for the securid authentication.
 */

SecurIDNextTokenCodeHandler.prototype.setRequestXML = function (tokenCode) {
   var tokenCodeText = void 0;
   var paramText = void 0;
   tokenCodeText = _util2.default.createElement("name", "tokencode");
   tokenCodeText += _util2.default.createElement("values", _util2.default.createElement("value", tokenCode));
   paramText = _util2.default.createElement("param", tokenCodeText);

   paramText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", this.messageName);
   this.requestXML += paramText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SecurIDPasscodeHandler;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SecurIDPasscodeHandler() {
   var router = void 0;
   // member variables below
   this.messageName = "securid-passcode";
   this.messageText = "securid-passcode";

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * securIDPasscodeHandler.js --
 *
 *      A sub-handler for DoSubmitAuthenticationHandler for SecurIDPasscode
 *      authentication.
 */

SecurIDPasscodeHandler.prototype = new _messageHandler.MessageHandler();
// constructor
SecurIDPasscodeHandler.constructor = SecurIDPasscodeHandler;

/**
 * Set the request XML for Windows passcode authentication.
 *
 * @param username [in] username for the securid authentication.
 * @param passcode [in] passcode for the securid authentication.
 */

SecurIDPasscodeHandler.prototype.setRequestXML = function (username, passcode) {
   var usernameText = void 0;
   var passcodeText = void 0;
   var paramText = void 0;
   usernameText = _util2.default.createElement("name", "username");
   usernameText += _util2.default.createElement("values", _util2.default.createElement("value", username));
   passcodeText = _util2.default.createElement("name", "passcode");
   passcodeText += _util2.default.createElement("values", _util2.default.createElement("value", passcode));
   paramText = _util2.default.createElement("param", usernameText);
   paramText += _util2.default.createElement("param", passcodeText);

   paramText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", this.messageName);
   this.requestXML += paramText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SecurIDPinChangeHandler;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SecurIDPinChangeHandler() {
   var router = void 0;
   // member variables below
   this.messageName = "securid-pinchange";
   this.messageText = "securid-pinchange";

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * securIDPinChangeHandler.js --
 *
 *      A sub-handler for DoSubmitAuthenticationHandler for securIDPinChange
 *      authentication.
 */

SecurIDPinChangeHandler.prototype = new _messageHandler.MessageHandler();
// constructor
SecurIDPinChangeHandler.constructor = SecurIDPinChangeHandler;

/**
 * Set the request XML for securIDPinChange authentication.
 *
 * @param pin1 [in] new PIN input
 * @param pin2 [in] comfirm PIN input
 */

SecurIDPinChangeHandler.prototype.setRequestXML = function (pin1, pin2) {
   var pin1Text = void 0;
   var pin2Text = void 0;
   var paramText = void 0;
   pin1Text = _util2.default.createElement("name", "pin1");
   pin1Text += _util2.default.createElement("values", _util2.default.createElement("value", pin1));
   pin2Text = _util2.default.createElement("name", "pin2");
   pin2Text += _util2.default.createElement("values", _util2.default.createElement("value", pin2));
   paramText = _util2.default.createElement("param", pin1Text);
   paramText += _util2.default.createElement("param", pin2Text);

   paramText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", this.messageName);
   this.requestXML += paramText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SecurIDWaitHandler;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SecurIDWaitHandler() {
   var router = void 0;
   // member variables below
   this.messageName = "securid-wait";
   this.messageText = "securid-wait";

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * securIDWaitHandler.js --
 *
 *      A sub-handler for DoSubmitAuthenticationHandler for securIDWait
 *      authentication.
 */

SecurIDWaitHandler.prototype = new _messageHandler.MessageHandler();
// constructor
SecurIDWaitHandler.constructor = SecurIDWaitHandler;

/**
 * Set the request XML for securIDWait authentication.
 *
 */

SecurIDWaitHandler.prototype.setRequestXML = function () {
   var paramText = void 0;

   paramText = _util2.default.createElement("params", "");
   this.requestXML = _util2.default.createElement("name", this.messageName);
   this.requestXML += paramText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SetLocaleHandler;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SetLocaleHandler() {
   // member variables below
   this.messageName = "set-locale";
   this.messageText = "set-locale";
   this.responseTag = "set-locale";
   this.properties = null; // properties in xml, key-value, such as locale:en_GB

   // register dependencies here
   var router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }

   this.requestXML = _util2.default.createElement("locale", _util2.default.l10N.getLocale());
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * setLocaleHandler.js --
 *
 *      Implementation of the message handler to set locale.
 */

SetLocaleHandler.prototype = new _messageHandler.MessageHandler();
SetLocaleHandler.constructor = SetLocaleHandler;

/**
 * callback when received notification from handlers in dependency list or
 * network
 *
 */
SetLocaleHandler.prototype.onUpdated = function () {
   _messageHandler.MessageHandler.prototype.onUpdated.apply(this); // call parent class's
   // onUpdated
   // XXX TODO: more own update operations
};

/**
 * parse locale information from the response XML of GetConfiguration
 *
 * @param responseXML[in] response of xmlhttprequest from view broker
 * @return key-value pairs parsed from response, if error then return null
 */
SetLocaleHandler.prototype.parseResult = function (responseXML) {
   if (!responseXML || responseXML === "") {
      return null;
   }
   var responseBody = (0, _jquery2.default)(responseXML);
   var ret = {};
   var brokerElem = void 0;
   var responseTagElem = void 0;
   var resultElem = void 0;
   var resultText = void 0;
   brokerElem = responseBody.find("broker");
   if (!brokerElem) {
      _jscdkLogger2.default.error("response of " + this.getMessageName() + " error");
      return null;
   }
   responseTagElem = brokerElem.find(this.responseTag);
   resultElem = responseTagElem.find("result");
   resultText = resultElem.text();
   if (!!resultText && resultText.trim() !== "") {
      ret["result"] = resultText;
   } else {
      return null;
   }
   return ret;
};

// add more functions here

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = UnauthHandler;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function UnauthHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "unauthenticated";
   this.messageText = "unauthenticated";

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * unauthHandler.js --
 *
 *      A sub-handler for DoSubmitAuthenticationHandler.
 */

UnauthHandler.prototype = new _messageHandler.MessageHandler();
// constructor
UnauthHandler.constructor = UnauthHandler;

/**
 * Set the request XML for unauthenticated.
 *
 * @param username [in] username for the windows password authentication.
 */

UnauthHandler.prototype.setRequestXML = function (username) {
   var usernameText = void 0,
       paramText = void 0;

   usernameText = _util2.default.createElement("name", "username");
   usernameText += _util2.default.createElement("values", _util2.default.createElement("value", username.trim()));
   paramText = _util2.default.createElement("param", usernameText);

   paramText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", "unauthenticated");
   this.requestXML += paramText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = WinCredsHandler;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _messageHandler = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function WinCredsHandler() {
   var router = void 0;

   // member variables below
   this.messageName = "windows-password";
   this.messageText = "windows-password";
   this.cachedDomainUsername = "";

   // register dependencies here
   router = _util2.default.getObject(_jscdkClient.globalArray, "router");
   if (!!router) {
      this.registerHandler(router, "receiver");
      this.registerHandler(router, "doLogout");
      this.registerHandler(router, "doCancelAuthentication");
   }
}

// inherits MessageHandler prototype
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * winCredsHandler.js --
 *
 *      A sub-handler for DoSubmitAuthenticationHandler.
 */

WinCredsHandler.prototype = new _messageHandler.MessageHandler();
// constructor
WinCredsHandler.constructor = WinCredsHandler;

/**
 * Set the request XML for Windows password authentication.
 *
 * @param domain [in] domain for the windows password authentication.
 * @param username [in] username for the windows password authentication.
 * @param password [in] password for the windows password authentication.
 */

WinCredsHandler.prototype.setRequestXML = function (domain, username, password) {
   var usernameText = void 0,
       domainText = void 0,
       passwordText = void 0,
       paramText = void 0,
       backslash = void 0;

   /**
    * Three login username format is supported:
    * 1. username        (broker supported)
    * 2. username@domain (broker supported)
    * 3. domain\username (broker not supported)
    *
    * We need to parse username and domain from #3
    */

   if (this.isDomainUsername(username)) {
      this.cachedDomainUsername = username;
      backslash = username.indexOf('\\');
      domain = username.substr(0, backslash);
      username = username.substr(backslash + 1);
   } else {
      this.cachedDomainUsername = "";
   }

   usernameText = _util2.default.createElement("name", "username");
   usernameText += _util2.default.createElement("values", _util2.default.createElement("value", username.trim()));
   domainText = _util2.default.createElement("name", "domain");
   domainText += _util2.default.createElement("values", _util2.default.createElement("value", domain.trim()));
   passwordText = _util2.default.createElement("name", "password");
   passwordText += _util2.default.createElement("values", _util2.default.createElement("value", password));
   paramText = _util2.default.createElement("param", usernameText);
   paramText += _util2.default.createElement("param", domainText);
   paramText += _util2.default.createElement("param", passwordText);

   paramText = _util2.default.createElement("params", paramText);
   this.requestXML = _util2.default.createElement("name", "windows-password");
   this.requestXML += paramText;
   this.requestXML = _util2.default.createElement("screen", this.requestXML);
};

WinCredsHandler.prototype.isDomainUsername = function (username) {
   if (!username) {
      return false;
   }
   return username.indexOf('\\') !== -1;
};

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = JSCDKError;
/*********************************************************
 * Copyright (C) 2012-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * jscdkError.js --
 *
 * A base class defining JSCDK errors,
 * each error is defined by an error codes and the associated error string.
 *
 */

function JSCDKError(errorCode, errorMessage) {
   this.code = errorCode;
   this.message = errorMessage;
}

JSCDKError.prototype.getErrorCode = function () {
   return this.code;
};

JSCDKError.prototype.getErrorMessage = function () {
   return this.message;
};

JSCDKError.prototype.toString = function () {
   return "Error Code: " + this.code + ", Error Message: " + this.message;
};

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.timerTypeEnum = undefined;
exports.Timer = Timer;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var timerTypeEnum = exports.timerTypeEnum = {
   timeout: "timeoutTimer",
   interval: "intervalTimer"
}; /*********************************************************
    * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
    *********************************************************/

/**
 * timer.js --
 *
 * timer class
 *
 */

function Timer(timerType) {
   if (timerType !== timerTypeEnum.timeout && timerType !== timerTypeEnum.interval) {
      _jscdkLogger2.default.error("unknown type string passed in Timer()");
      return;
   }
   this.type = timerType;
   this.timerValue = -1;
   this.timerId = null;
   this.eventCallbackFunc = null;
   this.enable = false;
   this.params = null;
   if (this.type === timerTypeEnum.timeout) {
      this.targetTime = -1;
      this.timerCreateFunction = function (callback, milliSecends, params) {
         if (!!this.timerId) {
            _jscdkLogger2.default.error("timeout timerId " + this.timerId + " do exist whild try create it");
            return;
         }
         this.timerId = setTimeout(callback, milliSecends, params);
         _jscdkLogger2.default.debug("timeout timer " + this.timerId + " created");
      };
      this.timerStopFunction = function () {
         if (!this.timerId) {
            _jscdkLogger2.default.error("timeout timerId don't exist when try stop it");
            this.setDisable();
            return;
         }
         clearTimeout(this.timerId);
         _jscdkLogger2.default.debug("timeout timer " + this.timerId + " deleted");
         this.timerId = null;
      };
   } else {
      this.timerCreateFunction = function (callback, milliSecends, params) {
         if (!!this.timerId) {
            _jscdkLogger2.default.error("interval timerId " + this.timerId + " do exist whild try create it");
            return;
         }
         this.timerId = setInterval(callback, milliSecends, params);
         _jscdkLogger2.default.debug("interval timer " + this.timerId + " created");
      };
      this.timerStopFunction = function () {
         if (!this.timerId) {
            _jscdkLogger2.default.error("interval timerId don't exist when try stop it");
            this.setDisable();
            return;
         }
         clearInterval(this.timerId);
         _jscdkLogger2.default.debug("interval timer " + this.timerId + " deleted");
         this.timerId = null;
      };
   }
}

//only store functions in prototype
Timer.prototype = {};
Timer.constructor = Timer;

Timer.prototype.getCurrentTime = function () {
   return new Date().getTime();
};

Timer.prototype.isEnabled = function () {
   return this.enable === true;
};

Timer.prototype.init = function (eventCallbackFunc, timerValue, params) {
   if (!this.isEnabled()) {
      return;
   }
   if (timerValue <= 0) {
      //invalid
      if (this.isEnabled()) {
         _jscdkLogger2.default.debug("timer init with negtive timeout value:" + timerValue);
         this.discard();
      }
      return;
   }
   this.timerValue = timerValue;
   this.eventCallbackFunc = eventCallbackFunc;
   this.params = params;
};

Timer.prototype.ensureUpdatedOrStarted = function () {
   if (!this.isEnabled()) {
      return;
   }
   if (!!this.timerId) {
      this.stop();
      this.start();
   } else {
      this.start();
   }
};

Timer.prototype.start = function () {
   if (!this.isEnabled()) {
      return;
   }
   if (this.type === timerTypeEnum.timeout) {
      //the absolute time in secs that once reached, the callback will be
      // triggered
      this.targetTime = this.getCurrentTime() + this.timerValue;
   }
   this.timerCreateFunction(this.eventCallbackFunc, this.timerValue, this.params);
};

Timer.prototype.stop = function () {
   if (!this.isEnabled()) {
      return;
   }
   this.timerStopFunction();
};

Timer.prototype.getTargetTime = function () {
   if (!this.isEnabled()) {
      return null;
   }
   var restTime = null;
   if (this.type === timerTypeEnum.timeout && this.targetTime > 0) {
      restTime = this.targetTime - this.getCurrentTime();
      _jscdkLogger2.default.debug("\nget timer rest time:" + restTime);
   } else {
      _jscdkLogger2.default.error("getRestTime is being misused!");
   }
   return this.targetTime;
};

Timer.prototype.updateTimeoutValue = function (newTimerValue) {
   if (!this.isEnabled()) {
      return;
   }
   if (this.type === timerTypeEnum.timeout) {
      if (newTimerValue < 0) {
         _jscdkLogger2.default.debug("timeout timer not reset with new timeout value:" + newTimerValue);
         return;
      }
      this.timerValue = newTimerValue;
      this.stop();
      this.start();
      _jscdkLogger2.default.debug("timeout timer reset with new timeout value:" + newTimerValue);
   } else {
      _jscdkLogger2.default.error("the updateTimeoutValue method is not for the intervalTimer");
   }
};

Timer.prototype.setEnable = function () {
   this.enable = true;
};

Timer.prototype.setDisable = function () {
   this.enable = false;
};

Timer.prototype.discard = function () {
   //only preserve type info
   this.stop();
   this.timerValue = -1;
   this.timerId = null;
   this.eventCallbackFunc = null;
   this.params = null;
   if (this.type === timerTypeEnum.timeout) {
      this.targetTime = -1;
   }
   this.setDisable();
};

Timer.prototype.ensureStopped = function () {
   if (!this.isEnabled()) {
      return;
   }
   this.discard();
};

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = UserActiveTimeSyncCtrl;

var _jscdkClient = __webpack_require__(2);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _getAuthenticationStatusHandler = __webpack_require__(40);

var _getAuthenticationStatusHandler2 = _interopRequireDefault(_getAuthenticationStatusHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

/**
 * userActiveTimeSyncCtrl.js --
 *
 *      Implementation of the functions to handle response of
 * <authentication-status>.
 */

function UserActiveTimeSyncCtrl() {
   this.idleTimerObject = _util2.default.getObject(_jscdkClient.globalArray, "idle-timeout-timer");
   if (!this.idleTimerObject) {
      _jscdkLogger2.default.error("UserActiveTimeSyncCtrl must be used after idleTimerObject is inited");
      return;
   }
   if (this.idleTimerObject.brokerVersionInvalid()) {
      return;
   }
   // member variables below
   this.ctrlName = "get-broker-sso-time-ctrl";
   this.callBackType = null;
   this.response = null;
}

UserActiveTimeSyncCtrl.prototype = {};
UserActiveTimeSyncCtrl.constructor = UserActiveTimeSyncCtrl;

// request send dealing functions
UserActiveTimeSyncCtrl.prototype.requestBrokerSSOTime = function (callBackType) {
   if (this.idleTimerObject.brokerVersionInvalid()) {
      return;
   }
   this.callBackType = callBackType;
   var getAuthenticationStatusObject = void 0,
       handlerList = void 0,
       router = _jscdkClient.globalArray["router"];

   getAuthenticationStatusObject = _jscdkClient.globalArray["get-authentication-status"];
   if (!getAuthenticationStatusObject) {
      getAuthenticationStatusObject = new _getAuthenticationStatusHandler2.default();
      _jscdkClient.globalArray[getAuthenticationStatusObject.messageName] = getAuthenticationStatusObject;
      _jscdkClient.globalArray[getAuthenticationStatusObject.responseTag] = getAuthenticationStatusObject;
   } else {
      getAuthenticationStatusObject.resetData();
   }

   if (!!getAuthenticationStatusObject && !!router) {
      getAuthenticationStatusObject.setRequestXML(true);
      handlerList = getAuthenticationStatusObject.composeHandlerList();
      router.postMessage(handlerList);
   }
};

// response dealing functions
UserActiveTimeSyncCtrl.prototype.dealWithAuthenticationStatusXML = function (response) {
   if (this.idleTimerObject.brokerVersionInvalid()) {
      return;
   }
   this.response = response;
   if (this.callBackType === "syncWithTimer4AboutToTimeout" || this.callBackType === "syncWithTimer4Timeout") {
      this.dealWithSSOTime();
   } else {
      _jscdkLogger2.default.debug('unknown callBackType in GetAuthenticationStatusHandler');
   }
};

UserActiveTimeSyncCtrl.prototype.dealWithSSOTime = function () {
   var idleTimerObject = this.idleTimerObject,
       timeToBrokerLocked = void 0;

   if (this.callBackType === "syncWithTimer4AboutToTimeout" || this.callBackType === "syncWithTimer4Timeout") {
      if (!idleTimerObject) {
         _jscdkLogger2.default.error("timerController do not exist in GetAuthenticationStatusHandler.onUpdated()");
         return;
      }
      if (this.response.sso === "unlocked") {
         //push that time in the timer controller, and start the comparation
         timeToBrokerLocked = this.response["time-to-sso-lock"];
         idleTimerObject.setBrokerTimeForCompare(timeToBrokerLocked);
         idleTimerObject.compareToAct(this.callBackType);
      } else {
         this.detectBrokerLocked();
      }
   }
};

UserActiveTimeSyncCtrl.prototype.detectBrokerLocked = function () {
   //deal with locked case
   var idleTimerObject = this.idleTimerObject;
   if (!!idleTimerObject) {
      idleTimerObject.detectBrokerLocked();
   } else {
      _jscdkLogger2.default.error("timerController do not exist when UserActiveTimeSyncCtrl detect session locked");
   }
};

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = BlastDesktopCtrl;

var _jscdkClient = __webpack_require__(2);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function BlastDesktopCtrl($window, $scope, $rootScope, mainService, connectionServerModel, blastSessionsModel, clientModel, connectionURIModel, multiSiteService, viewService, constants, userGlobalPref, baseViewService, jscdkLauncherInvoker) {
   // Initialize BlastDesktopCtrl controller.
   $scope.init = function () {
      var data = mainService.data;

      if (!!data && !!data.content) {
         if (!!data.content.redirectProperties) {
            // Multi-site redirection
            try {
               multiSiteService.redirectAndStartSession(data.content.redirectProperties);
               return;
            } catch (e) {
               _jscdkLogger2.default.debug('Error: fail to redirect due to: ' + e);
            }
         }

         if (data.content.isApplicationSession) {
            blastSessionsModel.saveFromXmlResponse(data.content);
         }
         $scope.blastURL = data.content.url;
         $scope.desktopId = data.content.id;
         $scope.preferences = data.content.preferences;
         $scope.url = data.content.url;
         $scope.isApplicationSession = data.content.isApplicationSession;
         $scope.isShadow = data.content.isShadow;
         if (!!data.content.userName) {
            // Get valid username
            var containsAt = data.content.userName.indexOf('@');
            if (containsAt !== -1) {
               connectionServerModel.username = data.content.userName.substr(0, containsAt);
            } else {
               connectionServerModel.username = data.content.userName;
            }
         }
         if (!!data.content.domainName) {
            connectionServerModel.domain = data.content.domainName;
         }
         // Save desktop data
         $scope.saveDesktopData($scope.desktopId, $scope.preferences.desktopName, connectionServerModel.host, $scope.blastURL, $scope.isApplicationSession, $scope.isShadow);

         /**
          * Stop idle timeout related timers to avoid timer triggered
          * after js is deleted.
          */
         jscdkLauncherInvoker.stopTimer();
         // Display desktop full screen.
         (0, _jquery2.default)('.ui-body').addClass('ui-full-page');
         // load the appblast desktop in place of this client.
         $rootScope.CLIENT_MODE = constants.CLIENT_MODE.DESKTOP;

         viewService.goBlastPage();
      }

      // Initialize view. Hide header and hide strip.
      $scope.initView(true, true);
      // Set current controller.
      mainService.currentController = this;
   };

   $scope.saveDesktopData = function (desktopId, desktopName, host, blastURL, isApplicationSession, isShadow) {
      var router = _jscdkClient.globalArray['router'],
          sessionStorage = $window.sessionStorage,
          savedData = void 0,
          value = void 0,
          SAMLart = void 0,
          closeOnExitFlag = void 0,
          horizonId = void 0;

      SAMLart = _util2.default.getUrlParam($window.location.href.toLowerCase(), 'samlart');
      if (!!SAMLart) {
         closeOnExitFlag = true;
      } else {
         closeOnExitFlag = false;
      }

      horizonId = connectionServerModel.horizonId;
      if (!horizonId && !!connectionURIModel.params) {
         horizonId = connectionURIModel.params.horizonId;
      }

      savedData = {
         user: connectionServerModel.username,
         domainName: connectionServerModel.domain,
         idleTimeout: connectionServerModel.idleTimeout,
         userActivityXMLSendingInterval: connectionServerModel.userActivityXMLSendingInterval,
         brokerSupportIdleTimeout: _util2.default.brokerSupportApplication(),
         desktopId: desktopId,
         desktopName: desktopName,
         referer: $window.location.href,
         rebrand: clientModel.rebrandEnable,
         brokerUrl: router.brokerUrl,
         brokerUrlWithTimestamp: router.brokerUrlWithTimestamp,
         blastURL: blastURL,
         isApplicationSession: isApplicationSession,
         isShadow: isShadow,
         closeOnExit: closeOnExitFlag,
         horizonId: horizonId,
         logLevel: clientModel.logLevel
      };

      /**
       * write this oject into session storage
       * seal this function here, easy for put into util-service
       * for
       * other usage it can also be stringify to a root name, but
       * this will influence info-reading.
       */
      (function (savedData) {
         var key = void 0;
         for (key in savedData) {
            if (savedData.hasOwnProperty(key)) {
               value = savedData[key];
               sessionStorage.setItem(key, value);
            }
         }
      })(savedData);
   };

   $scope.$on('$locationChangeStart', function (event, next, current) {
      /**
       * Only post data when launching desktop/app, but not when user
       * clicks back button.
       */
      if (baseViewService.isJumpingToDesktop(next, current)) {
         userGlobalPref.postPrefData();
      }
   });

   $scope.init();
}

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.scrollTopDirective = scrollTopDirective;
exports.viewAutofocusDirective = viewAutofocusDirective;
exports.unstorablePasswordDirective = unstorablePasswordDirective;
exports.fallbackSrcDirective = fallbackSrcDirective;
exports.progressCircleDirective = progressCircleDirective;
exports.helpLinkDirective = helpLinkDirective;
exports.downloadLinkdirective = downloadLinkdirective;
exports.highlightDirective = highlightDirective;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _progressCircle = __webpack_require__(270);

var _progressCircle2 = _interopRequireDefault(_progressCircle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/
//should spoort highlighting both app and desktop, added to html later, then
// filename should also be changed

function scrollTopDirective() {
   return {
      restrict: 'A',
      scope: {
         isHighlighted: '&scrollTop'
      },
      link: function link(scope, elem, attrs) {
         // whehter this desktop is highlighted
         if (scope.isHighlighted()) {
            // scroll 10px to the top.
            (0, _jquery2.default)('html, body').animate({
               scrollTop: elem.offset().top - 10
            }, 150);
         }
      }
   };
}

function viewAutofocusDirective($timeout) {
   return {
      link: function link(scope, elem, attrs, ctrl) {

         function setFocus() {
            if (attrs.viewAutofocus === 'true') {
               $timeout(function () {
                  elem[0].focus();
               });
            }
         }

         attrs.$observe('viewAutofocus', setFocus);
      }
   };
}

function unstorablePasswordDirective($timeout) {
   return {
      link: function link(scope, elem, attrs) {
         $timeout(function () {
            (0, _jquery2.default)(elem[0]).prop('type', 'password');
         }, 200);
      }
   };
}

function fallbackSrcDirective() {
   return {
      link: function postLink(scope, iElement, iAttrs) {
         if (!iAttrs.ngSrc) {
            iElement.addClass('default-icon');
         } else {
            iElement.bind('error', function () {
               (0, _jquery2.default)(this).addClass(iAttrs.fallbackSrc);
            });
         }
      }
   };
}

function progressCircleDirective() {
   return {
      restrict: 'E',
      templateUrl: _progressCircle2.default
   };
}

function helpLinkDirective(viewClientModel, utilService, _, $timeout, $rootScope, localize) {
   return {
      restrict: 'E',
      replace: true,
      link: function link(scope, element) {
         var showLink = function showLink() {
            $timeout(function () {
               //Rebrand the help URL
               var helpUrl = viewClientModel.rebrandHelpUrl || utilService.getLinkByType('helpPages'),
                   name = _('help_with_vmware_horizon');
               element.html(name);
               element.attr('href', helpUrl);
               scope.showHelpLink = true;
            });
         };

         $rootScope.$on("model:localizationReady", function (event, data) {
            /**
             * In most cases,
             * localize.translate('help_with_vmware_horizon') does not
             * get the correct result because the resource is downloaded
             * asynchronously. model:localizationReady event is emitted
             * by localize service when the downloaded is finished using
             * $timeout to un-block the waiting widget UI using
             * '$rootScope' not 'scope' to register the event is for
             * performance consideration.  $emit is cheaper than
             * $broadcast
             */
            showLink();
         });

         if (localize.localizationReady) {
            showLink();
         }
      },
      template: '<a class="home-link" id="helpLink" href="" target="_blank" ng-show="showHelpLink"></a>'
   };
}

function downloadLinkdirective(_, $timeout, $rootScope, viewClientModel, localize) {
   return {
      restrict: 'E',
      replace: true,
      link: function link(scope, element) {
         var showLink = function showLink() {
            $timeout(function () {
               //Rebrand the installer URL
               var name = _(viewClientModel.osLiteral);
               element.html(name);
               element.attr('href', viewClientModel.nativeInstallerLink);
               // For unit testing
               scope.nativeInstallerLink = viewClientModel.nativeInstallerLink;
            });
         };

         $rootScope.$on("model:localizationReady", function (event, data) {
            /**
             * In most cases,
             * localize.translate('help_with_vmware_horizon') does not
             * get the correct result because the resource is downloaded
             * asynchronously. model:localizationReady event is emitted
             * by localize service when the downloaded is finished using
             * $timeout to un-block the waiting widget UI using
             * '$rootScope' not 'scope' to register the event is for
             * performance consideration.  $emit is cheaper than
             * $broadcast
             */
            showLink();
         });

         if (localize.localizationReady) {
            showLink();
         }
      },
      template: '<a class="home-link" id="downloadLink" href="" target="_blank"></a>'
   };
}

function highlightDirective() {
   return {
      restrict: 'A',
      link: function link(scope, elem, attrs) {
         var toggle = function toggle(enabled) {
            if (enabled) {
               elem.addClass('highlight');
            } else {
               elem.removeClass('highlight');
            }
         };

         toggle(scope[attrs.highlight]);
         scope.$watch(attrs.highlight, toggle);
      }
   };
}

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.headerDirective = headerDirective;
exports.HeaderCtrl = HeaderCtrl;

var _settingDialogLauncher = __webpack_require__(277);

var _settingDialogLauncher2 = _interopRequireDefault(_settingDialogLauncher);

var _about_dialog = __webpack_require__(59);

var _about_dialog2 = _interopRequireDefault(_about_dialog);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _headerDefault = __webpack_require__(268);

var _headerDefault2 = _interopRequireDefault(_headerDefault);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function headerDirective() {
   return {
      replace: true,
      restrict: 'E',
      templateUrl: _headerDefault2.default
   };
}

function HeaderCtrl($rootScope, $scope, connectionServerModel, utilService, dialogService) {
   $scope.init = function () {
      var searchInput = (0, _jquery2.default)('#header-search');

      // Portal URL.
      $scope.host = 'https://' + connectionServerModel.host;
      // Logout function.
      $scope.logout = function () {
         utilService.showLogoutDialog();
      };

      $scope.showAllStyle = 'show-all-on';
      $scope.showFavStyle = 'show-fav-off';
      // Bind close dialog method.
      (0, _jquery2.default)('#closeAboutBtn').on('click', $scope.closeAboutDialog);
      // Focus on search input on receiving searchFocus event.
      $rootScope.$on('searchFocus', function () {
         searchInput.focus();
      });
   };

   $scope.showAll = function () {
      $rootScope.onlyFavorites = false;
      $scope.showAllStyle = 'show-all-on';
      $scope.showFavStyle = 'show-fav-off';
   };

   $scope.showFavorites = function () {
      $rootScope.onlyFavorites = true;
      $scope.showAllStyle = 'show-all-off';
      $scope.showFavStyle = 'show-fav-on';
   };

   $scope.showSetting = function () {
      dialogService.predefined({
         name: "SettingsWindowLauncher",
         templateUrl: _settingDialogLauncher2.default,
         className: "settings-window",
         controller: "LauncherSettingsWindowController",
         showClose: false,
         closeByEscape: true,
         closeByDocument: true
      });
   };

   $scope.showHelp = function () {
      dialogService.predefined({
         name: "AboutWindow", // dialog name
         templateUrl: _about_dialog2.default, // dialog template
         className: "about-window", // CSS class
         showClose: false, // do not show close button
         closeByEscape: true, // allow escape to close window
         closeByDocument: true // allow clicking on background to close
      });
   };

   $scope.enterKeypress = function (evt, callback) {
      if ($rootScope.isDialogServiceKeyPress === true) {
         /**
          * When dialog is closed, the focus could go back to header
          * element. And at this time it is possible that user is still
          * holding the key and then the the key up event is received.
          * That's not what we want.
          */
         $rootScope.isDialogServiceKeyPress = false;
         return;
      }
      if (!!evt && evt.keyCode === 13 && typeof callback === 'function') {
         // Enter key is pressed.
         callback();
         // Prevent default behavior.
         evt.preventDefault();
      }
   };

   $scope.init();
}

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = HomeWarningCtrl;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function HomeWarningCtrl($scope, utilService, mainService, viewClientModel, storageService) {
   $scope.init = function () {
      var browserCompatible = utilService.isCompatibleBrowser(),
          cookieEnabled = storageService.cookie.isEnabled(),
          canvasSupported = utilService.hasCanvasAndContext();

      $scope.helpLinkAddress = utilService.getLinkByType('helpPages');
      $scope.MIN_VERSION = viewClientModel.MIN_VERSION;
      // Name of the controller.
      $scope.name = 'Warning';
      // Set current controller.
      mainService.currentController = this;
      // The browser is compatible but the cookie is disabled, show
      // cookie warning msg.
      $scope.showCookieWarning = browserCompatible && canvasSupported && !cookieEnabled;
      // Allow to use web client if cookie is enabled and canvas is
      // supported.
      $scope.continueAllowed = cookieEnabled && canvasSupported;
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Display mobile layout on Android and Windows Phone.
      $scope.isMobileBrowser = viewClientModel.mIsAndroid || viewClientModel.mIsWinMobile;
      // Native client installer URL
      $scope.nativeInstallerLink = viewClientModel.nativeInstallerLink;
   };

   $scope.cancel = function () {
      window.location.href = viewClientModel.nativeInstallerLink;
   };

   $scope.goNext = function () {
      mainService.show('Brokers');
   };

   $scope.init();
}

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = jscdkLauncherInvoker;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function jscdkLauncherInvoker($window, viewClientModel, connectionURIModel, userGlobalPref, dpiService, storageService, connectionServerModel, constants) {
   var _this = this;

   this.applicationSessionArray = [];
   this.mainService = null;

   this._invokeJSCDK = function (action) {
      // TODO: Move to jscdkUIAdapter later
      _this.mainService.invokeJSCDK(action);
   };

   /**
    * send last user active time of this local tab to timer-controller
    * in JSCDK Invoke it recieving action from JSCDK in main-service/
    * show()
    */
   this.sendLastUserActiveTimeToTimerCtrl = function (actionTrigger, lastUserActiveTime) {
      if (!_angular2.default.isNumber(lastUserActiveTime)) {
         _jscdkLogger2.default.warning('lastUserActiveTime is NOT a valid number!');
         return;
      }

      var sendLastUserActiveTimeAction = void 0,
          actionType = null;

      switch (actionTrigger) {
         case 'RequestLastUserActiveTime':
            actionType = 'sendLastUserActiveTime';
            break;
         case 'AboutToTimeout':
            actionType = 'syncWithTimer4AboutToTimeout';
            break;
         case 'Timeout':
            actionType = 'syncWithTimer4Timeout';
            break;
         case 'showAboutToTimeoutDialogCallback':
            actionType = 'showAboutToTimeoutDialogCallback';
            break;
         default:
            _jscdkLogger2.default.warning('unknown actionTrigger in' + ' sendLastUserActiveTimeToTimerCtrl()');
            return;
      }

      // send UI detected last user active time as default value
      sendLastUserActiveTimeAction = {
         method: 'TimerCtrl',
         type: actionType,
         lastUserActiveTime: lastUserActiveTime
      };
      _this.mainService.invokeTimerCtrl(sendLastUserActiveTimeAction);
   };

   this.sendInitTimerXML = function (onlyEnableIntervalTimer) {
      var initTimerAction = void 0;

      initTimerAction = {
         method: 'TimerCtrl',
         type: 'InitTimer',
         initType: 'Portal',
         idleTimeout: connectionServerModel.idleTimeout,
         userActivityInterval: connectionServerModel.userActivityXMLSendingInterval
      };
      if (onlyEnableIntervalTimer) {
         initTimerAction.idleTimeout = -1;
      }
      _this.mainService.invokeTimerCtrl(initTimerAction);
   };

   /**
    * send do-unlock command
    * Invoke it after recieving dolock success massage and triggered by
    * user click ok in get-my-things-back dialog
    */
   this.sendDoUnlock = function () {
      var sendDoUnlockAction = {
         method: 'DoUnlock'
      };
      _this._invokeJSCDK(sendDoUnlockAction);
   };

   /**
    * Logoff desktop
    *
    * @param desktopId Desktop ID
    */
   this.logoffDesktop = function (desktopId) {
      var logoffDesktopAction = {};
      logoffDesktopAction.method = 'KillSession';
      logoffDesktopAction.itemInfo = {
         id: desktopId,
         isDesktop: true
      };
      _this._invokeJSCDK(logoffDesktopAction);
   };

   /**
    * Reset all application sessions
    * will send <kill-session> to the broker to kill the specified
    * application session
    *
    * will be changed when refactory JSCDK to merge handler & XMLs
    *
    * the orignal idea is
    */
   this.resetAllApplicationSessions = function () {
      var resetApplicationSessionAction = {};
      resetApplicationSessionAction.method = 'KillSession';
      resetApplicationSessionAction.killAllApplicationSessions = true;
      _this._invokeJSCDK(resetApplicationSessionAction);
   };

   /**
    * Reset desktop
    *
    * @param desktopId Desktop ID
    */
   this.reset = function (desktopId) {
      var resetDesktopAction = {};
      resetDesktopAction.method = 'ResetDesktop';
      resetDesktopAction.desktopId = desktopId;
      _this._invokeJSCDK(resetDesktopAction);
   };

   /**
    * Restart desktop
    *
    * @param desktopId Desktop ID
    */
   this.restart = function (desktopId) {
      var restartDesktopAction = {};
      restartDesktopAction.method = 'RestartDesktop';
      restartDesktopAction.desktopId = desktopId;
      _this._invokeJSCDK(restartDesktopAction);
   };

   /**
    * Cancel the current JSCDK request, if one exists. This function is
    * used to cancel things like authentication requests.
    *
    * @param doneAction[in] action to request after cancellation.
    */
   this.cancelCurrentRequest = function (doneAction) {
      _this._invokeJSCDK({
         method: 'CancelCurrentRequest',
         doneAction: doneAction
      });
   };

   this.cancelAuthentication = function () {
      _this._invokeJSCDK({
         method: 'CancelAuthentication'
      });
   };

   // stop the idle timeout related timers in the jscdk
   this.stopTimer = function () {
      var stopTimerAction = {
         method: 'TimerCtrl',
         type: 'stopTimer'
      };
      _this.mainService.invokeTimerCtrl(stopTimerAction);
   };

   // Logout the connection server.
   this.logout = function (needClearURI) {
      var logoutAction = {
         method: 'LogoutFromBroker',
         prefData: userGlobalPref.toFlatFormat()
      };
      // Clear session cookies.
      storageService.cookie.clearSessionCookies();
      // Reset server model.
      connectionServerModel.reset();
      // Clear URI model for normal logout.
      if (needClearURI === false) {
         logoutAction.needClearURI = false;
      } else {
         connectionURIModel.clear(false);
         //need to close the tab when logged out or when try to do
         // that?
      }
      _this._invokeJSCDK(logoutAction);
   };

   /**
    * Go back to server landing page.
    * It will go to homeconnectctrl.
    * For both webclient and Chromeclient, homeconnectctrl is
    * used for connect to broker.
    * For webclient, there is a cloud btn.
    * For Chromeclient, there is no UI.
    */
   this.goServerLanding = function () {
      _this.mainService.show('Brokers');
   };

   this.setURI = function () {
      var viewURIAction = {
         method: 'SetViewURI',
         queryString: $window.location.href,
         brokerURL: $window.location.hostname
      };

      _this._invokeJSCDK(viewURIAction);
   };

   /**
    * Retrieve launchitemss of the current session.
    * Invoke it when ALREADY_AUTHENTICATED.
    */
   this.retrieveLaunchItems = function () {
      var getLaunchItemsAction = {
         method: 'GetLaunchItems'
      };
      _this._invokeJSCDK(getLaunchItemsAction);
   };

   this._findApplicationSession = function (application) {
      var i = void 0,
          applicationOriginId = application['origin-id'];

      for (i = 0; i < this.applicationSessionArray.length; i++) {
         if (applicationOriginId === this.applicationSessionArray[i]['origin-id']) {
            return i;
         }
      }
      return -1;
   };

   this.isApplicationConnected = function (application) {
      var i = this._findApplicationSession(application);

      return i !== -1 && this.applicationSessionArray[i].state === 'connected';
   };

   /**
    * Disconnect the application session if it's currently connected
    * and the application's origin-id matches an application session's
    * origin-id. The disconnection is needed to avoid bug 1369190 but
    * and we only disconnect connected application sessions to avoid
    * bug
    * 1374799.
    *
    * @return true if this function disconnected an application
    *    session, false if it did not.
    */
   this.disconnectApplication = function (application) {
      if (!_this.isApplicationConnected(application)) {
         _jscdkLogger2.default.debug('Application: ' + application.id + ' does not have a corresponding application session.');
         return;
      }

      var i = _this._findApplicationSession(application);
      _this._invokeJSCDK({
         method: 'DisconnectSession',
         launchItemId: _this.applicationSessionArray[i].id
      });
   };

   /**
    * this method should be moved to a service for better unit testing
    * there's another connectToBroker method in util-service.  Should
    * consider to combine both of the method
    */
   this.connectToBroker = function () {
      var connectBrokerAction = {},
          clientCommonInfo = void 0,
          clientStats = void 0,
          addClientCommonInfo = void 0,
          addClientStats = void 0,
          userAgent = navigator.userAgent,
          isHandheldDevice = !!userAgent.match(/(iPad)|(iPhone)|(iPod)|(android)|(IEMobile)|(webOS)/i),
          matches = void 0,
          browserName = 'unknown',
          browserVersion = void 0,
          browserArch = navigator.platform,
          key = void 0;

      // Connect To the Broker
      connectBrokerAction.method = 'ConnectToBroker';
      connectBrokerAction.address = connectionServerModel.host;
      connectBrokerAction.supportedProtocols = connectionServerModel.supportedProtocols;

      //ignore ISO for now
      if (!!connectionURIModel.isF5Session()) {
         connectBrokerAction.mid = connectionURIModel.getF5postFix();
      }

      if (userAgent.toLowerCase().match(/(iphone|ipod|ipad)/i)) {
         // Apple iOS6 introduced a new xml post bug where the browser
         // would cache response if the request data did not change.
         // Hack to make sure we always request a new url, by adding a
         // timestamp whenever get an iOS browser
         connectBrokerAction.urlParam = '?_ab=' + _jquery2.default.now();
      }

      // Match pattern like 'Chrome/26.0.1410.64' to retrieve browser
      // name and version.
      matches = userAgent.match(/(opera|chrome|safari|firefox|msie|trident)\/?\s*(\.?\d+(\.\d+)*)/i);
      if (!!matches) {
         browserName = matches[1];
         browserVersion = matches[2];
      }

      // For Microsoft Edge, the useragent is like:
      // "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36
      // (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36
      // Edge/12.0". Match pattern Edge, because there's a "chrome"
      // string in it.
      if (userAgent.toLowerCase().indexOf('edge')) {
         matches = userAgent.match(/(edge)\/?\s*(\.?\d+(\.\d+)*)/i);
         if (!!matches) {
            browserName = matches[1];
            browserVersion = matches[2];
         }
      }

      if (browserName === 'Safari') {
         // For Safari, the version is in 'Version/6.0.3'.
         matches = userAgent.match(/version\/([\.\d]+)/i);
         if (!!matches) {
            browserVersion = matches[1];
         }
      } else if (browserName === 'Trident') {
         // For IE 11, the version is in 'rv:11.0'.
         browserName = 'Internet Explorer';
         matches = userAgent.match(/rv[:\s]([\w.]+)/i);
         if (!!matches) {
            browserVersion = matches[1];
         }
      }
      // For Chromebook, detect browser-arch from userAgent text.
      matches = userAgent.match(/cros\s*[a-z0-9_\.]*/i);
      if (!!matches) {
         browserArch = matches[0];
      }

      // Client common info
      clientCommonInfo = {
         // 'VMware'
         'client-vendor': viewClientModel.vendor,
         // 'VMware Horizon HTML Access'
         'client-product': viewClientModel.product,
         // View client version
         'client-version': viewClientModel.version + '-' + viewClientModel.buildNum,
         // 'Chrome Apps'
         'client-arch': viewClientModel.arch
      };
      // Client platform specific info
      clientStats = {
         // Browser info
         'browser-user-agent': userAgent,
         // Browser core
         'browser-core': browserName,
         // Browser version
         'browser-version': browserVersion,
         // System info
         'browser-arch': browserArch,
         // Is mobile device
         'browser-is-handheld': isHandheldDevice ? 'true' : 'false'
      };

      addClientCommonInfo = {
         'entity-type': 'CLIENT',
         'data-type': 'configuration'
      };

      addClientStats = {
         // the same with windows client
         'entity-id': 'singleton'
      };

      connectBrokerAction.clientInfo = {
         'clientCommonInfo': clientCommonInfo,
         'clientStats': clientStats,
         'addClientCommonInfo': addClientCommonInfo,
         'addClientStats': addClientStats
      };

      viewClientModel.onReady(function () {
         /**
          * sync model into jscdk to init environment info for get-launch-item to
          * support: https://jira-hzn.eng.vmware.com/browse/DPM-1211
          * decouple from current _getEnvironmentInfo since they are different,
          * and under current code structure better to be seperated.
          */
         var environmentInfo = {};

         if (!!viewClientModel.ipAddress) {
            environmentInfo['IP_Address'] = viewClientModel.ipAddress;
            environmentInfo['Machine_Name'] = viewClientModel.machineName;
         }
         if (!!viewClientModel.clientID) {
            environmentInfo['Client_ID'] = viewClientModel.clientID;
         }
         environmentInfo['Client_Version'] = viewClientModel.version + '-' + viewClientModel.buildNum;
         environmentInfo['Type'] = constants.viewclientType;
         _this._invokeJSCDK({
            "method": "SetEnvironmentInfo",
            "data": environmentInfo
         });

         _this._invokeJSCDK(connectBrokerAction);
      });
   };

   this.checkAuthenticationStatus = function () {
      var authStatusCheckAction = {
         method: 'GetAuthenticationStatus',
         workForSilentMode: true
      };

      _this._invokeJSCDK(authStatusCheckAction);
   };

   this.launchApplication = function (appInfo) {
      var application = appInfo.application,
          args = appInfo.args,
          selectApplicationAction = {};

      // connect to application
      selectApplicationAction.method = 'ConnectToApplication';
      /*
       * launch application for the specific protocol
       * currently, only BLAST is allowed.
       */
      selectApplicationAction.protocol = connectionServerModel.connectionProtocol;
      selectApplicationAction.applicationId = application.id;
      selectApplicationAction.originId = application['origin-id'];
      selectApplicationAction.maximized = 'false';
      selectApplicationAction.environmentInfo = _this._getEnvironmentInfo(false);

      selectApplicationAction.preferences = {
         applicationName: application.name,
         resolution: {
            'x': 0,
            'y': 0,
            'w': (0, _jquery2.default)(window).width(),
            'h': (0, _jquery2.default)(window).height()
         }
      };
      if (!!args) {
         selectApplicationAction.launchParam = {
            "args": args
         };
      }

      selectApplicationAction.prefData = userGlobalPref.toFlatFormat();
      _this._invokeJSCDK(selectApplicationAction);
   };

   this.launchDesktop = function (desktop) {
      var selectDesktopAction = {},
          ratio = 1;

      selectDesktopAction.method = 'ConnectToDesktop';
      /* launch desktop for the specific protocol
       * currently, only BLAST is allowed.
       */
      selectDesktopAction.protocol = connectionServerModel.connectionProtocol;
      selectDesktopAction.desktopId = desktop.id;
      selectDesktopAction.isShadow = desktop.isShadow;
      if (!selectDesktopAction.isShadow) {
         selectDesktopAction.environmentInfo = _this._getEnvironmentInfo(true);
      }

      selectDesktopAction.preferences = {
         desktopName: desktop.name,
         resolution: {
            'x': 0,
            'y': 0,
            'w': (0, _jquery2.default)(window).width() * ratio,
            'h': (0, _jquery2.default)(window).height() * ratio
         }
      };

      selectDesktopAction.prefData = userGlobalPref.toFlatFormat();
      _this._invokeJSCDK(selectDesktopAction);
   };

   this.acceptDisclaimer = function () {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'Disclaimer'
      };

      _this._invokeJSCDK(submitAuthInfoAction);
   };

   this.changePassword = function (oldPassword, newPassword1, newPassword2) {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'WindowsPasswordExpired'
      };
      submitAuthInfoAction.oldPassword = oldPassword;
      submitAuthInfoAction.newPassword1 = newPassword1;
      submitAuthInfoAction.newPassword2 = newPassword2;

      _this._invokeJSCDK(submitAuthInfoAction);
   };

   this.submitUnauthenticated = function (username) {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'Unauthenticated',
         username: username
      };

      _this._invokeJSCDK(submitAuthInfoAction);
   };

   this.submitWindowsPassword = function (username, password, domain, reAuth) {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'WindowsPassword',
         username: username,
         secret: password,
         domain: domain
      };
      if (reAuth) {
         submitAuthInfoAction.reAuth = true;
      }

      _this._invokeJSCDK(submitAuthInfoAction);
   };

   this.submitSecurIDNextTokenCode = function (passcode) {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'SecurIDNextTokenCode',
         secret: passcode
      };

      _this._invokeJSCDK(submitAuthInfoAction);
   };

   this.submitSecurIDPasscode = function (username, passcode) {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'SecurIDPasscode',
         username: username,
         secret: passcode
      };

      _this._invokeJSCDK(submitAuthInfoAction);
   };

   this.submitSecurIDPinChange = function (pin1, pin2) {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'SecurIDPinChange',
         pin1: pin1,
         pin2: pin2
      };

      _this._invokeJSCDK(submitAuthInfoAction);
   };

   this.submitSecurIDWait = function () {
      var submitAuthInfoAction = {
         method: 'SubmitAuthInfo',
         type: 'SecurIDWait'
      };

      _this._invokeJSCDK(submitAuthInfoAction);
   };

   this._getEnvironmentInfo = function (isDesktop) {
      var environmentInfo = {};

      if (!!viewClientModel.ipAddress) {
         environmentInfo['IP_Address'] = viewClientModel.ipAddress;
         environmentInfo['Machine_Name'] = viewClientModel.machineName;
      }
      if (!!viewClientModel.clientID) {
         environmentInfo['Client_ID'] = viewClientModel.clientID;
      }
      if (!!viewClientModel.version) {
         environmentInfo['Client_Version'] = viewClientModel.version + '-' + viewClientModel.buildNum;
      }
      if (!!viewClientModel.windowsTimezone && isDesktop) {
         environmentInfo['TZID'] = viewClientModel.windowsTimezone;
      }
      environmentInfo['Type'] = constants.viewclientType;

      environmentInfo['Displays.SystemDpi'] = dpiService.getDPI();

      return environmentInfo;
   };
} /*********************************************************
   * Copyright (C) 2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = mainService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jscdkClient = __webpack_require__(2);

var _jscdkBrokerError = __webpack_require__(15);

var _jscdkBrokerError2 = _interopRequireDefault(_jscdkBrokerError);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mainService($rootScope, utilService, $route, dialogService, viewClientModel, connectionURIModel, _, viewService, timeoutService, userGlobalPref, brokerSessionStorageService, viewCtrlService, jscdkLauncherInvoker, constants, $window, ws1Service) {
   var _this2 = this;

   var COMANAGEMENT_ERROR = 'failed launching desktop: No co-management availability for protocol BLAST',
       TUNNEL_ERROR = 'failed launching desktop: com.vmware.vdi.sessionclientapi.TunnelManager$TunnelManagerException',
       PROTOCOL_ERROR = 'Please try connecting via another protocol or logoff the existing session first';

   // Data got from JSCDK library.
   this.data = null;
   // View controller for the current workspace.
   this.currentController = null;

   // Initialize JSCDK library.
   this.init = function () {
      // Product version (e.g. 1.0-00000)
      // if (!!VIEWCLIENT.clientVersion) {
      //    viewClientModel.version = VIEWCLIENT.clientVersion;
      // }
      // Configure rebrand name to replace the title element
      if (!!viewClientModel.rebrandName) {
         utilService.rebrand(viewClientModel.rebrandName);
      }

      (0, _jscdkClient.jscdkClientSetUIController)(this);
      //jscdkClientSetSessionStorage(window.sessionStorage); for replace
      // the sso with session storage
      jscdkLauncherInvoker.mainService = this;

      //init lastUserActiveTime
      timeoutService.bindUserActivity();
   };
   /**
    * Call JSCDK lib.
    *
    * @param action [in] the action sent to JSCDK
    */
   this.invokeJSCDK = function (action) {
      var actionString = JSON.stringify(action);

      _jscdkLogger2.default.debug('UI request to JSCDK : ' + _util2.default.censorMessage(actionString, 'JSON'));
      // Clear data.
      this.data = null;
      (0, _jscdkClient.UIEventToJSCDK)(actionString);
      // Change cursor to busy and disable buttons.
      this.currentController.connecting();
   };

   /**
    * Call timer controller in JSCDK lib.
    *
    * need this for chrome client, or this is no valid currentController
    * for this.currentController.connecting(); and the truth that sending
    * a request to timerCtrl should not change the UI in any way.
    *
    * @param action Object:
    *     the action sent to timer controller
    * @return nothing
    */
   this.invokeTimerCtrl = function (action) {
      var actionString = JSON.stringify(action);

      if (action.method !== 'TimerCtrl') {
         _jscdkLogger2.default.debug('invokeTimerCtrl must be used to send action with method = \'TimerCtrl\'\nreturn');
         return;
      }
      _jscdkLogger2.default.debug('UI request to TimerCtrl : ' + _util2.default.censorMessage(actionString, 'JSON'));
      (0, _jscdkClient.UIEventToJSCDK)(actionString);
   };

   /**
    * Switch page at JSCDK response.
    *
    * @param action [in] the action from JSCDK
    */
   this.responseToJSCDKEvent = function (action) {
      var data = _jquery2.default.parseJSON(action),
          content = data.content;

      if (!data.ignoreData) {
         this.data = data;
      }

      if (!content) {
         _jscdkLogger2.default.debug('JSCDK response to UI : ' + _util2.default.censorMessage(action, 'JSON'));
      } else {
         _jscdkLogger2.default.debug('JSCDK response to UI : { name: ' + data.name + ', content: ' + _util2.default.censorMessage(JSON.stringify(content), 'JSON'));
      }
      this.show(data.name);
   };

   /**
    * Check if the current controller is of mapping name.
    *
    * @param controller [in] view controller instance
    * @param name       [in] mapping name registered
    *                        in the controllers' dictionary
    * @returns true if matched; false if not matched
    */
   this.isCurrentController = function (name) {
      return this.currentController.name === name;
   };

   /**
    * return whether the input UI change request is an authentication one
    *
    * 'WindowsPasswordExpired', 'Disclaimer', 'SecurIDNextTokenCode',
    * 'SecurIDPinChange', 'SecurIDWait' must happen with either
    * 'SecurIDPasscode' or 'WindowsPassword', so do not do the clear work
    *
    * the HWS case is not supported yet.
    */
   this.isNewAuthenticating = function (name, data) {
      var i = void 0,
          authenticationNameList = ['SecurIDPasscode'];
      if (name === 'WindowsPassword' && !(data.content.usernameReadOnly === 'yes' && data.content.domainReadOnly === 'yes')) {
         return true;
      }
      for (i = 0; i < authenticationNameList.length; i++) {
         if (name === authenticationNameList[i]) {
            return true;
         }
      }
      return false;
   };

   /**
    * Switch pages.
    *
    * @param name [in] mapping name registered
    *                  in the controllers' dictionary
    * @param obj  [in] initialization parameter
    */
   this.show = function (name) {
      var _this = this;

      var okCallback = null,
          favoriteHandler = null;

      // Handler special cases.
      switch (name) {
         case 'ShowError':
            // Enable current page.
            this.currentController.enable();
            // Show error dialog.
            this.showError(this.data);
            return;
         case 'Timeout':
            /**
             * TODO: should hide or disable error dialog, current dialog
             * is not support multi-thread
             */
            jscdkLauncherInvoker.sendLastUserActiveTimeToTimerCtrl(name, timeoutService.getLastUserActivityTime());
            return;
         case 'RequestLastUserActiveTime':
         case 'AboutToTimeout':
            jscdkLauncherInvoker.sendLastUserActiveTimeToTimerCtrl(name, timeoutService.getLastUserActivityTime());
            return;
         case 'showAboutToTimeoutDialog':
            okCallback = function okCallback(currentController) {
               jscdkLauncherInvoker.sendLastUserActiveTimeToTimerCtrl('showAboutToTimeoutDialogCallback', timeoutService.getLastUserActivityTime());
               currentController.enable();
            };
            var timeoutDialog = dialogService.error({
               data: {
                  title: _('dialog_title_about_to_timeout'),
                  errorMessage: _('dialog_confirm_about_to_timeout')
               },
               controller: ['$scope', function ($scope) {
                  $scope.close = function () {
                     okCallback(_this.currentController);
                     timeoutDialog.close();
                  };
               }]
            });
            return;
         case 'AlreadyLock':
            // Logout broker if it is in anonymous mode
            if (viewClientModel.isAnonymousMode) {
               jscdkLauncherInvoker.logout();
               return;
            }
            break;
         case 'DoLock':
            okCallback = function okCallback() {
               jscdkLauncherInvoker.sendDoUnlock();
            };
            var doLockDialog = dialogService.error({
               data: {
                  title: _('dialog_title_locked'),
                  errorMessage: _('dialog_confirm_locked')
               },
               controller: ['$scope', function ($scope) {
                  $scope.close = function () {
                     okCallback();
                     doLockDialog.close();
                  };
               }]
            });
            return;
         case 'SessionUnlocked':
            if (!!connectionURIModel.params) {
               // URI connection reuses the previous session.
               connectionURIModel.reuseSession = true;
            }
            // Already authenticated, navigate to the desktops or
            // launchitems page and ensure the timer is started
            if (_util2.default.brokerSupportApplication()) {
               timeoutService.initTimers();
            }
            jscdkLauncherInvoker.retrieveLaunchItems();
            return;
         case 'LockedNewTab':
            // open a new tab and found it locked
            if (!!connectionURIModel.params) {
               // URI connection reuses the previous session.
               connectionURIModel.reuseSession = true;
            }
            timeoutService.initIntervalTimer();
            jscdkLauncherInvoker.sendDoUnlock();
            return;
         // two cases for user act in the select page in slient mode
         case 'AuthenticationStatusLocked':
            // found locked, when try to launch a desktop
            jscdkLauncherInvoker.sendDoUnlock();
            return;
         case 'AuthenticationStatusUnlocked':
            if (!utilService.authenticationStatusCheck.isLaunchAction()) {
               this.currentController.enable();
            }
            utilService.authenticationStatusCheck.doAction(this.currentController);
            return;
         // this case try to disconnect first
         case 'ApplicationAlreadyConnected':
            jscdkLauncherInvoker.disconnectApplication(this.currentController.currentApplication);
            return;
         /**
          * As disconnectsession is only use in this case, if there're
          * other cases add a flag. The DisconnectionSessionfailed is
          * needed to avoid bug 1374808. Ignore the disconnect error and
          * launch the application anyway.
          */
         case 'DisconnectSession':
         case 'DisconnectSessionFailed':
            if (this.currentController.name === 'GetLaunchItems') {
               this.currentController.ajaxBusy = false;
               this.currentController.launchApplication(this.currentController.currentApplication, this.currentController.focusElement, this.currentController.bufferedArgs);
               this.currentController.bufferedArgs = null;
            } else {
               _jscdkLogger2.default.debug('Not in the launchitems page.');
            }
            return;
         case 'GetUserGlobalPref':
            favoriteHandler = _jscdkClient.globalArray['get-user-global-preferences'];
            userGlobalPref.setPrefData(favoriteHandler.prefData);
            if (!!this.data && !!this.data.content) {
               if (!!this.data.content.applications) {
                  favoriteHandler.markFavorite(this.data.content.applications);
               }
               if (!!this.data.content.desktops) {
                  favoriteHandler.markFavorite(this.data.content.desktops);
               }
            }
            return;
         case 'SetUserGlobalPref':
            userGlobalPref.onDataSent();
            return;
         case 'Brokers':
            // clear preference data when logout
            userGlobalPref.clearPrefData();
            break;
         case 'KillAllApplicationSessions':
            this.currentController.enable();
            $rootScope.applicationCanSet = false;
            return;
         case 'CertAuth':
            // Certificate authentication.
            $rootScope.certAuth = true;
            return;
      }

      if (!!this.data && !!this.data.content && !!this.data.content.clientConfig) {
         utilService.updateClientConfig(this.data.content.clientConfig);
      }

      // clear brokerSessionStorage for previous broker session exist no
      // more
      if (this.isNewAuthenticating(name, this.data)) {
         brokerSessionStorageService.clear();
         viewClientModel.isAnonymousMode = false;
         $rootScope.showPreference = true;
         if (utilService.supportLocalStorage()) {
            window.localStorage.removeItem(constants.CLIENT_LOGIN_KEY);
         }
      }

      // Reset certAuth flag to false.
      if ($rootScope.certAuth) {
         $rootScope.certAuth = false;
      }

      if (this.isCurrentController(name)) {
         // Enable current page.
         this.currentController.enable(name, this.data);
         // Refresh current page.
         this.currentController.init();
      } else {
         // Tear down the current page.
         this.currentController.tearDown();

         viewService.switchView({
            action: name,
            controller: this.currentController,
            data: this.data
         });
      }
   };

   this.getOKCallbackOnBrokerError = function (callbackFunc, callbackParams) {
      return function () {
         utilService.runFunctionIfNotHWSOrF5.call(_this2, callbackFunc, callbackParams);
      };
   };

   /**
    * Handle error response from the connection server.
    *
    */
   this.showError = function (data) {
      var errorType = void 0,
          userMsg = void 0,
          errorMsg = void 0,
          okCallback = null;

      if (!!data && !!data.content) {
         errorType = data.content.errorType;
         userMsg = data.content.errorText;
         errorMsg = data.content.errorMessage;

         if (errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_ALREADY_AUTHENTICATED) {
            if (!!data.content.workspaceOneServerHostname && !ws1Service.isLaunchedFromWS1()) {
               // Invalid session, handle off to WS1
               ws1Service.redirectToWS1(data.content.workspaceOneServerHostname, $window);
               return;
            }

            if (!!connectionURIModel.params) {
               // URI connection reuses the previous session.
               connectionURIModel.reuseSession = true;
            }
            // Already authenticated, navigate to the desktops or
            // launchitems page and ensure the timer is started
            if (_util2.default.brokerSupportApplication()) {
               timeoutService.initTimers();
            }
            jscdkLauncherInvoker.retrieveLaunchItems();
            return;
         }

         if (errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_AUTHENTICATION_FAILED) {
            // Check if invalid workspace one mode first
            if (!!data.content.workspaceOneServerHostname) {
               // Invalid session, handle off to WS1
               ws1Service.redirectToWS1(data.content.workspaceOneServerHostname, $window);
               return;
            }

            if ($rootScope.certAuth) {
               // Certificate authentication failed. Press OK, go back to
               // portal page.
               okCallback = _this2.getOKCallbackOnBrokerError(viewService.gotoPortal);
            } else {
               // Press OK, close the error dialog and navigate back to
               // the home page.
               okCallback = _this2.getOKCallbackOnBrokerError.call(utilService, jscdkLauncherInvoker.goServerLanding);
            }
         } else if (errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_TIMEOUT) {
            // Press OK, close the error dialog and navigate back to the
            // home page.
            okCallback = _this2.getOKCallbackOnBrokerError.call(utilService, jscdkLauncherInvoker.goServerLanding);
         } else if (errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_NOT_ENTITLED) {
            /**
             * Not an entitled user to the item. need to update the UI.
             * Refresh the select page with the newest data
             */
            okCallback = _this2.getOKCallbackOnBrokerError.call(utilService, function () {
               if (_util2.default.brokerSupportApplication()) {
                  timeoutService.initTimers();
               }
               jscdkLauncherInvoker.retrieveLaunchItems();
            });
         } else if (errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_DESKTOPS_ERROR || errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_LAUNCH_ITEMS_ERROR || errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_TUNNEL_ERROR) {
            /**
             * Not able to show the select page. Needs to go back and
             * login with another username. Logout the broker.
             */
            okCallback = _this2.getOKCallbackOnBrokerError.call(utilService, jscdkLauncherInvoker.logout);
         } else if (errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_NOT_AUTHENTICATED) {
            // clear brokerSessionStorage for broker session exist no more
            brokerSessionStorageService.clear();
            if (utilService.supportLocalStorage()) {
               window.localStorage.removeItem(constants.CLIENT_LOGIN_KEY);
            }
            userMsg = _('error_not_authenticated');
            // Press OK, close the error dialog and navigate back to the
            // home page.
            okCallback = _this2.getOKCallbackOnBrokerError.call(utilService, jscdkLauncherInvoker.goServerLanding);
         } else if (errorType === _jscdkBrokerError2.default.JSCDK_BROKER_ERROR_DESKTOP_LAUNCH_ERROR) {
            // When tunnel connection hasn't been established
            // successfully, if Blast Secure Gateway is turned on, a 'No
            // co-management error' is returned; otherwise, a
            // 'TunnelManagerException' error is returned.
            if (errorMsg.indexOf(COMANAGEMENT_ERROR) >= 0 || errorMsg.indexOf(TUNNEL_ERROR) >= 0) {
               // Probably caused by the tunnel connection problem.
               userMsg = _('error_no_comanagement');
               okCallback = _this2.getOKCallbackOnBrokerError.call(utilService, jscdkLauncherInvoker.logout);
            } else {
               okCallback = _this2.getOKCallbackOnBrokerError.call(utilService);
            }

            if (userMsg.indexOf(PROTOCOL_ERROR) >= 0 && _this2.currentController.currentDesktop) {
               // if the desktop need to logoff first, show confirm
               // dialog instead of error dialog.
               utilService.logOffConfirmation(_this2.currentController.currentDesktop);
               return;
            }
         } else if (errorType === 'JSCDK_ERROR_LOGOFF_POOL_FAILED') {
            // Desktop is disabled before user logs off
            okCallback = _this2.getOKCallbackOnBrokerError.call(utilService, jscdkLauncherInvoker.goServerLanding);
         } else if (errorType === 'CONNECT_TO_BROKER_ERROR') {
            // back to sever selector page when connection to broker fails
            okCallback = _this2.getOKCallbackOnBrokerError(viewService.gotoPortal);
         }

         // Show error dialog.
         var dialog = dialogService.error({
            data: {
               title: _('ERROR'),
               errorMessage: userMsg
            },
            closeByEscape: false,
            closeByDocument: false,
            controller: ['$scope', function ($scope) {
               $scope.close = function () {
                  if (typeof okCallback === 'function') {
                     okCallback();
                  }
                  dialog.close();
               };
            }]
         });
      } else {
         // Refresh current page.
         $route.reload();
      }
   };

   this.init();
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = tabSyncService;
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/
/**
 * @fileoverview tabsync-service.js -- tabSyncService
 * This service will send and listen to storage sync event on the IE
 * with version below or equal to 11, and will close the host tab if
 * information is processed by other tabs.
 */

function tabSyncService($window, utilService) {
   /**
    * @this tabSyncService
    * @param  {object} event The browser event triggered by changes in
    *    other tab
    */
   var onStorageChange = function onStorageChange(event) {
      var message = void 0,
          eventKey = this.eventKey;

      if (event.key === eventKey) {
         message = JSON.parse(event.newValue);
         if (message.origin === 'oldTab' && message.data === 'Merged') {
            $window.opener = null;
            $window.open("", "_self");
            $window.close();
         }
      }
   };

   /**
    * init function used to set the url informations, will add response
    * listener and send out a event right away if all params are valid.
    * works only for IE with version below 11 which not support
    * postMessage well.
    * @param  {object} uriInfo         The object contains info about uri
    * @param  {string} brokerAddress   The current broker address
    * @param  {object} localStorageObj The localStorageObject use for
    *    Unit Testing
    */
   this.init = function (uriInfo, brokerAddress, localStorageObj) {
      var itemType = void 0,
          itemId = void 0,
          horizonId = void 0,
          userName = void 0,
          domainName = void 0;

      if (utilService.supportPostMessage() || this.inited || !uriInfo) {
         return;
      }
      horizonId = uriInfo.horizonId;
      userName = encodeURIComponent(uriInfo.userName);
      domainName = uriInfo.domainName;
      if (!!uriInfo.desktopId) {
         itemType = 'Desktop';
         itemId = encodeURIComponent(uriInfo.desktopId);
      } else if (!!uriInfo.applicationId) {
         itemType = 'Application';
         itemId = encodeURIComponent(uriInfo.applicationId);
      }
      if (!localStorageObj) {
         localStorageObj = $window.localStorage;
      }
      if (!!horizonId && !!userName && !!domainName && !!itemType && !!itemId && !!localStorageObj) {
         $window.addEventListener("storage", onStorageChange.bind(this), false);

         this.eventKey = "HWS_BKA_" + brokerAddress;
         localStorageObj.setItem(this.eventKey, JSON.stringify({
            origin: 'newTab',
            data: {
               horizonId: horizonId,
               userName: userName,
               domainName: domainName,
               itemType: itemType,
               itemId: itemId
            }
         }));
         this.inited = true;
      }
   };
}

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = timeoutService;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function timeoutService($window, connectionServerModel, storageService, jscdkLauncherInvoker) {
   var _this = this;

   var userActivityTime = 0;

   this.setUserActivityTime = function () {
      userActivityTime = new Date().getTime();
   };

   this.getLastUserActivityTime = function () {
      return userActivityTime;
   };

   this.bindUserActivity = function () {
      _this.setUserActivityTime();
      // Listen to all the events for tracking user activity.
      (0, _jquery2.default)(document).bind('mousemove.useractivity mousedown.useractivity mouseup.useractivity', _this.setUserActivityTime);
      (0, _jquery2.default)(document).bind('keydown.useractivity keyup.useractivity', _this.setUserActivityTime);
      (0, _jquery2.default)(document).bind('touchstart.useractivity touchmove.useractivity touchend.useractivity', _this.setUserActivityTime);
      (0, _jquery2.default)(document).bind('orientationchange.useractivity', _this.setUserActivityTime);
      (0, _jquery2.default)(document).bind('extendedmonitoruse.useractivity', _this.setUserActivityTime);
      (0, _jquery2.default)(document).bind('primarymonitoruse.useractivity', _this.setUserActivityTime);
   };

   this._readTimerFromCookieToConnectionServerModel = function () {
      var idleTimeout = void 0,
          userActivityXMLSendingInterval = void 0;

      // Current idleTimeout value
      idleTimeout = connectionServerModel.idleTimeout;
      if (!idleTimeout) {
         // Read idleTimeout from cookie
         idleTimeout = storageService.cookie.read(storageService.cookie.COOKIE_IDLE_TIMEOUT);
         if (!idleTimeout) {
            _jscdkLogger2.default.debug('error: idleTimeout don\'t exist in the cookie');
         }
         // Cache idleTimeout in the server model.
         connectionServerModel.idleTimeout = idleTimeout;
      } else {
         _jscdkLogger2.default.debug('warning: idleTimeout already exist in the connectionServerModel');
      }
      // Current user-activity-interval value
      userActivityXMLSendingInterval = connectionServerModel.userActivityXMLSendingInterval;
      if (!userActivityXMLSendingInterval) {
         // Read user-activity-interval value from cookie
         userActivityXMLSendingInterval = storageService.cookie.read(storageService.cookie.COOKIE_SEND_TIME_INTERVAL);
         if (!userActivityXMLSendingInterval) {
            _jscdkLogger2.default.debug('error: userActivityXMLSendingInterval don\'t exist in the cookie');
         }
         // Cache user-activity-interval value in the server model.
         connectionServerModel.userActivityXMLSendingInterval = userActivityXMLSendingInterval;
      } else {
         _jscdkLogger2.default.debug('warning: userActivityXMLSendingInterval already exist in the connectionServerModel');
      }
   };

   // name the interface with clear name instead of flag
   this.initTimers = function () {
      this._readTimerFromCookieToConnectionServerModel();
      jscdkLauncherInvoker.sendInitTimerXML();
   };

   this.initIntervalTimer = function () {
      this._readTimerFromCookieToConnectionServerModel();
      jscdkLauncherInvoker.sendInitTimerXML(true);
   };
}

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = utilService;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function utilService(connectionURIModel, _, dialogService, localize, brokerSessionStorageService, viewClientModel, jscdkLauncherInvoker, $window) {
   /**
    * The desktop is open on the server but it is running a different
    * protocol, press OK to log off the current session.
    *
    */
   this.logOffConfirmation = function (desktop) {
      var dialog = dialogService.confirm({
         data: {
            title: _('dialog_title_logoff_retry'),
            message: _('dialog_confirm_logoff_retry')
         },
         controller: ['$scope', function ($scope) {
            $scope.confirm = function () {
               jscdkLauncherInvoker.logoffDesktop(desktop.id);
               dialog.close();
            };
         }]
      });
   };

   // Case insensitive string compare.
   this.ignoreCaseEquals = function (str1, str2) {
      if (!str1 || !str2) {
         return false;
      }

      return str1.toLowerCase() === str2.toLowerCase();
   };

   // Rebrand page title
   this.rebrand = function (rebrandName) {
      $window.document.title = rebrandName;
   };

   // Detect whether the browser supports sessionStorage.
   this.isSessionStorageAllowed = function () {
      try {
         $window.sessionStorage.setItem('closeOnExit', false);
         return true;
      } catch (e) {
         _jscdkLogger2.default.error('This browser does not support sessionStorage. ' + e);
         return false;
      }
   };

   // Detect if it's a WebKit browser.
   this.isWebKitBrowser = function () {
      return (/AppleWebKit/.test(navigator.userAgent)
      );
   };

   // Get link by its type
   this.getLinkByType = function (type) {
      var locale = localize.getLocale(),
          map = viewClientModel.linkModel[type];

      if (map.hasOwnProperty(locale)) {
         return map[locale];
      }

      return map.en;
   };

   this.showLogoutDialog = function () {
      var dialog = dialogService.confirm({
         data: {
            title: _('dialog_title_logout'),
            message: _('dialog_confirm_logout')
         },
         controller: ['$scope', function ($scope) {
            $scope.confirm = function () {
               jscdkLauncherInvoker.logout();
               dialog.close();
            };
         }],
         closeByDocument: false
      });
   };

   // Get query string from model
   this.getQueryStringFromModel = function (model) {
      var queryString = 'https://' + model.host + '?',
          keys = void 0;

      for (keys in model) {
         if (model.hasOwnProperty(keys) && keys !== 'host') {
            queryString += keys + '=' + model[keys] + '&';
         }
      }
      return queryString.substring(0, queryString.length - 1);
   };

   // Get largest icon from icons
   this.getLargestIcon = function (icons) {
      var iconsLength = Object.keys(icons).length,
          i = void 0,
          largeFlag = 0;

      for (i = 0; i < iconsLength; i++) {
         if (parseInt(icons[i].height, 10) > parseInt(icons[largeFlag].height, 10)) {
            largeFlag = i;
         }
      }
      return largeFlag;
   };

   /* in silent mode, when user want to do action in the selector page,
    * the authentication status must be checked before allow user do it
    *
    * this handler can only record one request at a time, but ajaxBusy
    * will force user send most one request at a time.
    */
   this.authenticationStatusCheck = function () {
      var callbackFunc = null,
          callbackParams = null,
          action = null,
          itemType = null;

      return {
         callBackWhenUnlocked: function callBackWhenUnlocked(callbackFunction, callbackParameters, actionName, targetItemType) {
            callbackFunc = callbackFunction;
            callbackParams = callbackParameters;
            action = actionName;
            itemType = targetItemType;

            jscdkLauncherInvoker.checkAuthenticationStatus();
         },

         clearAction: function clearAction() {
            callbackFunc = null;
            callbackParams = null;
            action = null;
            itemType = null;
         },

         doAction: function doAction(scope) {
            if (typeof callbackFunc === 'function') {
               callbackFunc.call(scope, callbackParams);
               this.clearAction();
            }
         },

         popAction: function popAction(scope) {
            var result = {
               item: callbackParams,
               action: action,
               itemType: itemType
            };
            /**
             * launch item without valid check, act same as always stay in
             * select page. by adding this will provide a better animation
             * effect after finishing re-auth.
             */
            if (action === 'start-session' || action === 'reset-all' && itemType === 'application') {
               this.doAction(scope);
               return null;
            }
            if (typeof callbackFunc === 'function') {
               this.clearAction();
            }
            return result;
         },

         isLaunchAction: function isLaunchAction() {
            return action === 'start-session';
         }
      };
   }();

   /**
    * hasCanvasAndContext
    *
    *    Tests if the browser supports the use of <canvas> elements
    * properly with the ability to retrieve its draw context.
    *
    * @return Boolean. true if the browser supports HTML5 canvas; false
    *    otherwise.
    */
   this.hasCanvasAndContext = function () {
      try {
         var canvas = $window.document.createElement('canvas');
         var result = !!canvas.getContext; // convert to Boolean, invert
         // again.
         canvas = null; // was never added to DOM, don't need to remove
         return result;
      } catch (e) {
         return false;
      }
   };

   /**
    * runFunctionIfNotHWSOrF5
    *
    * Handle callback function according to runtime
    * If in HWSession/ F5 instead of normal session, window should be
    * closed directly, or run the callback function
    */
   this.runFunctionIfNotHWSOrF5 = function (callbackFunc, callbackParams) {
      if (connectionURIModel.isHWSession() || connectionURIModel.isF5Session()) {
         // NOTE: This won't work in any modern browser when the window
         // is not opened via script / ahref.
         $window.open('', '_self', '');
         $window.close();
         return;
      }

      var self = this;
      if (typeof callbackFunc === 'function') {
         callbackFunc.call(self, callbackParams);
      } else {
         _jscdkLogger2.default.info('Param callbackFunc is not a function.');
      }
   };

   /**
    * isCompatibleBrowser
    *
    *    Verifies the version of the browser and check if it's supported.
    *
    * @return Boolean. true if the browser is supported; false otherwise.
    */
   this.isCompatibleBrowser = function () {
      // Add Android support first
      if (viewClientModel.mIsWinMobile) {
         return false;
      } else if (viewClientModel.mIsAndroid) {
         return viewClientModel.mIsChrome && viewClientModel.mVersionChrome >= viewClientModel.MIN_VERSION.Chrome;
      } else if (viewClientModel.mIsIOS) {
         return viewClientModel.mIsIOSSafari;
      } else {
         return viewClientModel.mIsIE && viewClientModel.mVersionIE >= viewClientModel.MIN_VERSION.IE || viewClientModel.mIsChrome && viewClientModel.mVersionChrome >= viewClientModel.MIN_VERSION.Chrome || viewClientModel.mIsGecko && viewClientModel.mVersionGecko >= viewClientModel.MIN_VERSION.Gecko || viewClientModel.mIsWebKit && viewClientModel.mVersionWebKit >= viewClientModel.MIN_VERSION.WebKit;
      }
   };

   /**
    * @return This returns whether the host browser is supporting
    *    postMessage API well
    */
   this.supportPostMessage = function () {
      return !(viewClientModel.mIsIE && viewClientModel.mVersionIE <= 11);
   };

   /**
    * position
    *
    *    Returns the position of the element.
    *
    * @param jQuery element
    * @return position of the element.
    */
   this.position = function (elem) {
      return elem.position();
   };

   /**
    * isHidden
    *
    *    Check whether an element is hidden.
    *
    * @param jQuery element.
    * @return it is hidden or not.
    */
   this.isHidden = function (elem) {
      return elem.is(':hidden');
   };

   this.isVADC = function () {
      return _util2.default.getUrlParam($window.location.href.toLowerCase(), 'vadc') !== null;
   };

   this.updateClientConfig = function (clientConfig) {
      if (!clientConfig) {
         return;
      }

      /**
       * Store the value after authentication, otherwise they could be
       * deleted.
       */
      if (typeof clientConfig['clientHideDomainList'] !== 'undefined') {
         viewClientModel.clientHideDomainList = clientConfig['clientHideDomainList'];
      }
      if (typeof clientConfig['clientHideServerInformation'] !== 'undefined') {
         viewClientModel.clientHideServerInformation = clientConfig['clientHideServerInformation'];
      }
      if (typeof clientConfig['enableCredentialCleanupForHTMLAccess'] !== 'undefined') {
         viewClientModel.credentialCleanup = clientConfig['enableCredentialCleanupForHTMLAccess'];
      }
   };

   this.storeClientConfig = function () {
      /**
       * Store the values in items-controller.js
       * NOTE: the values should be the same with baseviewclient-model.js
       */
      brokerSessionStorageService.write('clientHideDomainList', viewClientModel.clientHideDomainList);
      brokerSessionStorageService.write('clientHideServerInformation', viewClientModel.clientHideServerInformation);
      brokerSessionStorageService.write('credentialCleanup', viewClientModel.credentialCleanup);
   };

   this.supportLocalStorage = function () {
      try {
         $window.localStorage.setItem('testKey', 'foobar');
         $window.localStorage.removeItem('testKey');
         return true;
      } catch (err) {
         return false;
      }
   };
}

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.equalToDirective = equalToDirective;
exports.serverNameDirective = serverNameDirective;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function equalToDirective() {
   return {
      require: 'ngModel',
      link: function link(scope, elem, attrs, ctrl) {
         function checkEquals(changedTagValue) {
            var currentTagValue = ctrl.$viewValue;
            var anotherTagValue = attrs.equalTo;
            // set validity
            ctrl.$setValidity('equalTo', currentTagValue === anotherTagValue);
            return currentTagValue;
         }

         // watch own value and re-validate on change
         ctrl.$parsers.unshift(checkEquals);
         attrs.$observe('equalTo', checkEquals);
      }
   };
}

function serverNameDirective() {
   return {
      require: 'ngModel',
      link: function link(scope, elem, attrs, ctrl) {
         function checkForProtocol(val) {
            if (!val || !!val && val.match(/^(https:\/\/)?([a-z0-9\-\.:\[\]])+$/i)) {
               // Protocol must be https. Host name only contains
               // characters, numbers, -, :, [ or ].
               ctrl.$setValidity('serverName', true);
               return val;
            }

            // set validity
            ctrl.$setValidity('serverName', false);
         }

         // watch own value and re-validate on change
         ctrl.$parsers.unshift(checkForProtocol);
      }
   };
}

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = viewService;

var _angular = __webpack_require__(5);

var _angular2 = _interopRequireDefault(_angular);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function viewService($location, $timeout, utilService, connectionURIModel, tabSyncService, baseViewService, URIParamValidator, dialogService, jscdkLauncherInvoker, _, constants, ws1Service) {
   var _this = this;

   // View controllers' dictionary.
   this.map = {
      Start: '/home',
      WindowsPasswordExpired: '/changepassword',
      SecurIDNextTokenCode: '/securidnexttoken',
      SecurIDPinChange: '/securidpinchange',
      SecurIDWait: '/securidwait',
      GetLaunchItems: '/launchitems',
      ShowAppBlastDesktop: '/blastdesktop',
      ShowAppBlastApplication: '/blastdesktop',
      Warning: '/warning',
      Portal: function Portal() {
         _this.gotoPortal();
      },
      Logout: function Logout() {
         if (utilService.supportLocalStorage()) {
            window.localStorage.removeItem(constants.CLIENT_LOGIN_KEY);
         }
         var logoutToPortal = _this.logoutToPortal;
         if (logoutToPortal && !utilService.isVADC()) {
            _this.gotoPortal(); // default behavior
         } else {
            _this.logoutToPortal = true; // reset the stupid flag
            $timeout(function () {
               utilService.authenticationStatusCheck.clearAction();
               baseViewService.changeLocation('/home');
            });
         }
      },
      Brokers: function Brokers(param) {
         _this.connectToBroker(param.data);
      },
      SecurIDPasscode: function SecurIDPasscode(param) {
         _this.gotoStart(param);
      },
      WindowsPassword: function WindowsPassword(param) {
         _this.gotoStart(param);
      },
      Disclaimer: function Disclaimer(param) {
         _this.gotoStart(param);
      },
      Unauthenticated: function Unauthenticated(param) {
         _this.gotoStart(param);
      }
   };

   /**
    * It's terrible to use a flag, however this is the only way doing it at the
    * time For logout behavior, normally when a user logs out, it goes to
    * portal.  However, if user A already logged in, user B uses URI to launch
    * a desktop in the same browser instance.  We need B to confirm if logs out
    * user A.  In this case, it goes to login page, not portal.  The root cause
    * of adding this flag is, as of now, when sending logout command to broker,
    * main service gets the response.
    * (the truth is whatever it is sending or who ever is sending, main service
    * gets the respnose).  The 'show' method of main service is invoked with
    * 'logout' passed.  However, main service does not know which case it is
    * (normal logout or another user is acting this behavior). That's why a
    * flag is required when user logs out to indicate which page is goes to. We
    * need to let the caller of jscdk to get the response instead of main
    * service.
    */
   this.logoutToPortal = true;

   this.gotoStart = function (param) {
      /** if current controller name or its parent name is not start,
       ** change location to show the page.
       */
      if (param.controller.isAuthenticating()) {
         param.controller.enable(param.action, param.data);
      } else {
         baseViewService.changeLocation('/home');
      }
   };

   this.gotoPortal = function () {
      baseViewService.gotoPortal();
   };

   this.connectToBroker = function (data) {
      if (!!data && !!data.params) {
         // Store URI parameters.
         connectionURIModel.params = data.params;
         tabSyncService.init(connectionURIModel.params, $location.host());

         // Validate the URI params
         if (!URIParamValidator.isValid(connectionURIModel.params)) {
            var dialog = dialogService.error({
               data: {
                  title: _('ERROR'),
                  errorMessage: _('LOGIN_URI_PARAMS')
               },
               controller: ['$scope', function ($scope) {
                  $scope.close = function () {
                     _this.gotoPortal();
                     dialog.close();
                  };
               }]
            });
            return;
         }
      }

      // If spID exist in URI, update it to local storage
      var spID = connectionURIModel.getSpID();
      if (!!spID) {
         ws1Service.storeSpId(spID);
      }

      // cancel previous user launch/reset/logoff trial
      utilService.authenticationStatusCheck.clearAction();

      jscdkLauncherInvoker.connectToBroker();
   };

   /** switch view according to the map,
    ** param include action name and current controller's message.
    */
   this.switchView = function (param) {
      var value = void 0;
      if (!!param.action && this.map.hasOwnProperty(param.action)) {
         value = this.map[param.action];
         if (_angular2.default.isFunction(value)) {
            value(param);
         } else {
            // it's path name
            $timeout(function () {
               baseViewService.locationChange = true;
               $location.path(value);
            });
         }
      } else {
         param.controller.enable(param.action, param.data);
      }
   };

   this.goBlastPage = function () {
      // TODO wait for html5 mode change
      baseViewService.changeLocation('/desktop');
   };
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = viewCtrlService;
/*********************************************************
 * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function viewCtrlService($rootScope, $timeout) {
   // Header buttons visibility
   $rootScope.header = {
      hide: true,
      logout: false,
      home: false,
      add: true,
      log: false,
      striphide: false
   };

   // Footer visibility
   $rootScope.footer = {
      protocolRegister: false
   };

   // Exit button control
   $rootScope.exit = {
      sendLogoff: false,
      isExit: false
   };

   $rootScope.initView = function (hideHeader, hideStrip) {
      if (typeof hideHeader === 'undefined') {
         // Hide header by default.
         hideHeader = true;
      }
      if (typeof hideStrip === 'undefined') {
         // Show strip by default.
         hideStrip = false;
      }

      // Disabled submit button or not.
      $rootScope.disabled = false;
      // Busy indicator.
      $rootScope.ajaxBusy = false;
      // Show the header.
      $rootScope.header.hide = hideHeader;
      // Show the strip.
      $rootScope.header.striphide = hideStrip;
   };

   // Connecting to JSCDK.
   $rootScope.connecting = function () {
      $rootScope.ajaxBusy = true;
      $rootScope.disabled = true;
   };

   // Enable view.
   $rootScope.enable = function () {
      $timeout(function () {
         $rootScope.ajaxBusy = false;
         $rootScope.disabled = false;
      });
   };

   // Tear down a view. Do some cleanup work.
   $rootScope.tearDown = function () {
      // For sub controllers to override.
   };

   $rootScope.isAuthenticating = function () {
      return this.parentController === 'Start' || this.name === 'Start';
   };
}

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = LaunchItemsCtrl;

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function LaunchItemsCtrl($scope, $rootScope, $timeout, connectionServerModel, viewClientModel, mainService, storageService, LaunchItemsCtrlService, utilService, safeStorageService, userGlobalPref, _, connectionURIModel, dialogService, credCleanService, timezone, jscdkLauncherInvoker, brokerSessionStorageService, constants) {
   // Timeout timer ID
   var timeoutID = null;

   // Store user info in the local storage.
   var storeUserInfo = function storeUserInfo() {
      var tokenUsername = void 0,
          username = void 0,
          domain = void 0,
          horizonId = void 0;

      // Current token user name
      tokenUsername = connectionServerModel.tokenUsername;
      if (!!tokenUsername) {
         // Write domain name into cookie
         storageService.cookie.write(storageService.cookie.COOKIE_TOKEN_USER_NAME, tokenUsername);
      }
      // Current user name
      username = connectionServerModel.username;
      if (!username) {
         // Read user name from cookie
         username = storageService.cookie.read(storageService.cookie.COOKIE_USER_NAME);
         if (!username) {
            // If username is not available, use token username
            // instead.
            username = tokenUsername;
         }
         // Cache user name in the server model.
         connectionServerModel.username = username;
      } else {
         // Write user name into cookie
         storageService.cookie.write(storageService.cookie.COOKIE_USER_NAME, username);
      }
      // Current domain name
      domain = connectionServerModel.domain;
      if (!domain) {
         // Read domain name from cookie
         domain = storageService.cookie.read(storageService.cookie.COOKIE_DOMAIN_NAME);
         // Cache domain name in the server model.
         connectionServerModel.domain = domain;
      } else {
         // Write domain name into cookie
         storageService.cookie.write(storageService.cookie.COOKIE_DOMAIN_NAME, domain);
      }
      // HWS session indentifier
      horizonId = connectionServerModel.horizonId;
      if (!!horizonId) {
         // Write Horizon ID into cookie
         storageService.cookie.write(storageService.cookie.COOKIE_HORIZON_ID, horizonId);
      }
   };

   var writeTimerInfoFromConnectionServerModel2Cookie = function writeTimerInfoFromConnectionServerModel2Cookie() {
      var idleTimeout = void 0,
          userActivityXMLSendingInterval = void 0;

      // Current idleTimeout value
      idleTimeout = connectionServerModel.idleTimeout;
      if (!idleTimeout) {
         _jscdkLogger2.default.error('idleTimeout don\'t exist in connectionServerModel');
      } else {
         // Write user idleTimeout into cookie
         storageService.cookie.write(storageService.cookie.COOKIE_IDLE_TIMEOUT, idleTimeout);
      }
      // Current user-activity-interval value
      userActivityXMLSendingInterval = connectionServerModel.userActivityXMLSendingInterval;
      if (!userActivityXMLSendingInterval) {
         _jscdkLogger2.default.error('idleTimeout don\'t exist in connectionServerModel');
      } else {
         // Write user-activity-interval value into cookie
         storageService.cookie.write(storageService.cookie.COOKIE_SEND_TIME_INTERVAL, userActivityXMLSendingInterval);
      }
   };

   var storeInfoForBlastSideBar = function storeInfoForBlastSideBar(objectSet) {
      var key = void 0;
      for (key in objectSet) {
         if (objectSet.hasOwnProperty(key)) {
            safeStorageService.setItem(key, objectSet[key], null);
         }
      }
   };
   // Initialize LaunchItemsCtrl controller.
   $scope.init = function () {
      var data = mainService.data,
          userAgent = navigator.userAgent,
          brokerUrl = void 0;

      if (!!data && !!data.timerInfo) {
         if (!!data.timerInfo.idleTimeout) {
            connectionServerModel.idleTimeout = data.timerInfo.idleTimeout;
         }
         if (!!data.timerInfo.userActivityXMLSendingInterval) {
            connectionServerModel.userActivityXMLSendingInterval = data.timerInfo.userActivityXMLSendingInterval;
         }
      } else {
         _jscdkLogger2.default.error('launchItemsResponse have no data!');
      }
      $scope.activeItem = null;
      // Name of the controller.
      $scope.name = 'GetLaunchItems';
      // Desktops binding model.
      $scope.desktops = [];
      //Applications binding model.
      $scope.applications = [];
      // Current click application.
      $scope.currentApplication = null;
      // Buffered app launching cmd.
      $scope.bufferedArgs = null;
      // Current click desktop.
      $scope.currentDesktop = null;
      // Whether to show the available items. It should be true for HWS
      $scope.showLaunchPanel = !connectionURIModel.isHWSession();
      /**
       * Initialize view. Show header and show strip.
       * Hide the header if in WS1 mode
       */
      $scope.initView(!$scope.showLaunchPanel);
      // Show logout button in none-HWS env.
      if (connectionURIModel.isHWSession()) {
         $rootScope.header.logout = false;
      } else {
         $rootScope.header.logout = true;
      }

      $rootScope.onlyFavorites = false;
      // Set current controller.
      mainService.currentController = this;
      writeTimerInfoFromConnectionServerModel2Cookie();

      brokerUrl = 'https://' + connectionServerModel.host + '/broker/xml';
      if (!!connectionURIModel.isF5Session()) {
         brokerUrl += connectionURIModel.getF5postFix();
      }

      storeInfoForBlastSideBar({
         EntitledItems: mainService.data,
         ClientInfo: {
            id: viewClientModel.clientID,
            ip: viewClientModel.ipAddress,
            machineName: viewClientModel.machineName,
            windowsTimezone: viewClientModel.windowsTimezone
         },
         BrokerUrlInfo: {
            url: brokerUrl,
            urlParam: userAgent.toLowerCase().match(/(iphone|ipod|ipad)/i)
         }
      });

      // Render launchItems.
      LaunchItemsCtrlService.renderLaunchItems.call($scope, mainService.data);
      // Store user info.
      storeUserInfo();
      // Show the searchbar.
      $rootScope.header.searchbar = true;

      $scope.favTip = _('mark_fav');
      $scope.unfavTip = _('unmark_fav');
      $scope.showline = true;

      if (jscdkLauncherInvoker.applicationSessionArray.length > 0) {
         $rootScope.applicationCanSet = true;
      } else {
         $rootScope.applicationCanSet = false;
      }

      // Listen to up/down arrow keyup event.
      (0, _jquery2.default)(document).on('keydown', $scope.moveFocus);

      $timeout(function () {
         $rootScope.$emit('searchFocus');
      });

      credCleanService.init();
      utilService.storeClientConfig();

      /**
       * If user enters launch items page, and there is no user switch dialog,
       * we can say they login broker session successfully.
       *
       * And at this moment we should add a flag to mark the session already
       * logged in. See app-center-controller.js for the log off part
       *
       * NOTE: don't put this code before
       * LaunchItemsCtrlService.renderLaunchItems.
       *
       * Because it should handle URI first
       * And if there is a switch user dialog, user might cancel the dialog and
       * decide not to switch session
       */
      if (!$scope.switchUserDialog) {
         /**
          * Don't use brokerSessionStorageService here because it may use
          * COOKIE to simulate localStorage
          */
         if (utilService.supportLocalStorage()) {
            window.localStorage.setItem(constants.CLIENT_LOGIN_KEY, true);
         }

         /**
          * Mark this session as anonymous.
          *
          * When user first login with anonymous account, there must be
          * unauthenticatedAccessEnabled=true in URI.
          *
          * But later if user reuses the session, it is possible that
          * unauthenticatedAccessEnabled=true doesn't exist in URI.
          *
          * That's to say, we can only use URI to check anonymous mode in
          * the first time. Then please use
          * viewClientModel.isAnonymousMode instead.
          */
         if (connectionURIModel.isAnonymous()) {
            brokerSessionStorageService.write(constants.ANONYMOUS_MODE_KEY, true);
            viewClientModel.isAnonymousMode = true;
            $rootScope.showPreference = false;
         }
      }
   };

   $scope.$watch('header.search', function () {
      $scope.search = $scope.header.search;
   });

   $scope.launchDesktop = function (desktop, event) {
      $scope.currentDesktop = desktop;
      viewClientModel.windowsTimezone = timezone.getWindowsTimezone();
      LaunchItemsCtrlService.launchDesktop.call($scope, desktop, event);
   };

   $scope.logoffDesktop = function (desktop) {
      LaunchItemsCtrlService.logoffDesktop.call($scope, desktop);
   };

   $scope.resetDesktop = function (desktop) {
      LaunchItemsCtrlService.resetDesktop.call($scope, desktop);
   };

   $scope.restartDesktop = function (desktop) {
      LaunchItemsCtrlService.restartDesktop.call($scope, desktop);
   };

   $scope.launchApplication = function (application, event, args) {
      LaunchItemsCtrlService.launchApplication.call($scope, application, event, args);
   };

   $scope.highlightItems = function (item, event) {
      LaunchItemsCtrlService.highlightItems.call($scope, item, event);
   };

   $scope.isHighlighted = function (item) {
      return LaunchItemsCtrlService.isHighlighted.call($scope, item);
   };

   $scope.launchCurrentApplication = function (application, event, args) {
      // Save application data to use for reconnection.
      $scope.currentApplication = application;
      // Check whether the application is in the already connected
      // application session.
      if (jscdkLauncherInvoker.isApplicationConnected(application)) {
         jscdkLauncherInvoker.disconnectApplication(application);
      } else {
         // if the application's origin-id is not found in the already
         // connected farm, launch this Application directly.
         $scope.launchApplication(application, event, args);
      }
   };

   $scope.show = function (item) {
      if ($rootScope.onlyFavorites) {
         return item.favorite;
      } else {
         return true;
      }
   };

   $scope.makeFavorite = function (item, event) {
      if (event) {
         event.stopPropagation();
      }
      item.favorite = !item.favorite;
      userGlobalPref.updatePrefData({
         name: 'favorite',
         text: item.id,
         action: item.favorite ? 'FavOn' : 'FavOff'
      });
   };

   $scope.showNoFavorites = function (desktops, applications) {
      var noDesktopFav = true,
          noAppFavorites = true,
          i = void 0;

      for (i = 0; i < desktops.length; i++) {
         if (desktops[i].favorite) {
            noDesktopFav = false;
            break;
         }
      }
      for (i = 0; i < applications.length; i++) {
         if (applications[i].favorite) {
            noAppFavorites = false;
            break;
         }
      }
      if ((noDesktopFav || noAppFavorites) && $rootScope.onlyFavorites) {
         $scope.showline = false;
      } else {
         $scope.showline = true;
      }

      return noDesktopFav && noAppFavorites && $rootScope.onlyFavorites;
   };

   $scope.itemTitle = function (item) {
      if (!!item.favorite) {
         return this.unfavTip;
      } else {
         return this.favTip;
      }
   };

   $scope.keypressHandler = function (evt) {
      if (!!evt && evt.keyCode === 32) {
         // Prevent default behavoir when Space key is pressed.
         evt.preventDefault();
      }
   };

   $scope.keyboardHandler = function (evt, item, isDesktop) {
      var callback = void 0,
          callbackParams = void 0;

      if (!evt) {
         return;
      }

      switch (evt.keyCode) {
         case 13:
            // Enter key
            callback = isDesktop ? $scope.launchDesktop : $scope.launchCurrentApplication;
            callbackParams = [item, evt.target];
            break;
         case 32:
            // Space key
            callback = $scope.makeFavorite;
            callbackParams = [item, evt];
            break;
         default:
      }

      if (typeof callback === 'function') {
         // Invoke keyboard handler.
         callback.apply($scope, callbackParams);
         // Prevent default behavior.
         evt.preventDefault();
      }
   };

   $scope.moveFocusUpRow = function (list, curr) {
      var position = void 0,
          top = void 0,
          left = void 0,
          above = void 0,
          elem = void 0,
          i = void 0;

      if (!list || curr < 0 || curr >= list.length) {
         return -1;
      }

      // Get the top and left position of the focused element.
      position = utilService.position((0, _jquery2.default)(list[curr]));
      top = position.top;
      left = position.left;

      // Find backwards from the current position.
      for (i = curr - 1; i > -1; i--) {
         elem = (0, _jquery2.default)(list[i]);

         if (utilService.isHidden(elem)) {
            continue;
         }

         position = utilService.position(elem);

         if (!above && position.top !== top) {
            // Top position of the above row.
            above = position.top;
         }

         if (position.top === above && position.left <= left) {
            /*
             * Element is on the above row and
             * it is left aligned with focused element
             * or is the last element of the row.
             */
            return i;
         }
      }

      return -1;
   };

   $scope.moveFocusDownRow = function (list, curr) {
      var i = void 0,
          position = void 0,
          top = void 0,
          left = void 0,
          bottom = void 0,
          elem = void 0,
          next = -1;

      if (!list || curr < 0 || curr >= list.length) {
         return -1;
      }

      // Get the top and left position of the focused element.
      position = utilService.position((0, _jquery2.default)(list[curr]));
      top = position.top;
      left = position.left;

      // Down arrow key is pressed.
      for (i = curr + 1; i < list.length; i++) {
         elem = (0, _jquery2.default)(list[i]);

         if (utilService.isHidden(elem)) {
            continue;
         }

         position = utilService.position(elem);

         if (!bottom && position.top !== top) {
            // Top position of the bottom row.
            bottom = position.top;
         }

         if (!!bottom && (position.top !== bottom || position.left > left)) {
            // Return when the bottom row is scanned or the left align
            // element is found.
            break;
         }

         if (position.top === bottom && position.left <= left) {
            /*
             * Element is on the bottom row and
             * it is left aligned with the focused element
             * or is the last element of the row.
             */
            next = i;
         }
      }

      return next;
   };

   $scope.moveFocusLeft = function (list, curr) {
      var next = -1,
          elem = void 0,
          i = void 0;

      if (!list || curr < 0 || curr >= list.length) {
         return -1;
      }

      for (i = curr - 1; i > -1; i--) {
         elem = (0, _jquery2.default)(list[i]);

         if (utilService.isHidden(elem)) {
            continue;
         }

         // Previous element.
         next = i;
         break;
      }

      return next;
   };

   $scope.moveFocusRight = function (list, curr) {
      var next = -1,
          elem = void 0,
          i = void 0;

      if (!list || curr < 0 || curr >= list.length) {
         return -1;
      }

      for (i = curr + 1; i < list.length; i++) {
         elem = (0, _jquery2.default)(list[i]);

         if (utilService.isHidden(elem)) {
            continue;
         }

         // Next element.
         next = i;
         break;
      }

      return next;
   };

   $scope.moveFocus = function (evt) {
      var list = void 0,
          index = void 0,
          next = void 0,
          elem = void 0,
          i = void 0;

      if (dialogService.hasDialogOpen() > 0 || !evt || evt.keyCode < 37 || evt.keyCode > 40) {
         /**
          * Return if a dialog is popped up, or
          * key other than up/down/left/right arrow key is pressed.
          */
         return;
      }

      // Get desktop and application elements list.
      list = (0, _jquery2.default)('ul.ui-desktop-list li');

      // Find out the index of focused element in the list.
      index = Array.prototype.indexOf.call(list, $scope.focusElement);

      // If no element is focused, focus on the first one when down
      // arrow key is pressed.
      if (index === -1) {
         // Down arrow key is pressed.
         if (evt.keyCode === 40) {
            // Focus on the first visible element if down arrow key is
            // pressed.
            for (i = 0; i < list.length; i++) {
               elem = (0, _jquery2.default)(list[i]);

               if (utilService.isHidden(elem)) {
                  continue;
               }

               elem.focus();
               break;
            }

            // Prevent default behavior.
            evt.preventDefault();
         }

         return;
      }

      switch (evt.keyCode) {
         case 38:
            // Up arrow key is pressed.
            next = $scope.moveFocusUpRow(list, index);
            break;

         case 40:
            // Down arrow key is pressed.
            next = $scope.moveFocusDownRow(list, index);
            break;

         case 37:
            // Left arrow key is pressed.
            next = $scope.moveFocusLeft(list, index);
            break;

         case 39:
            // Right arrow key is pressed.
            next = $scope.moveFocusRight(list, index);
            break;

         default:
      }

      if (next > -1) {
         // Set focus
         (0, _jquery2.default)(list[next]).focus();
         // Prevent default behavior.
         evt.preventDefault();
      } else if (evt.keyCode === 38) {
         /**
          *  Up arrow key is pressed while focus is
          *  on the first line. Set focus in the search
          *  input box.
          */
         $rootScope.$emit('searchFocus');
         // Prevent default behavior.
         evt.preventDefault();
      }
   };

   $scope.removeHighlight = function () {
      $scope.activeItem = null;
      $scope.focusElement = null;
   };

   // Override connecting method
   $scope.connecting = function () {
      // Invoke parent's connecting method.
      $rootScope.connecting();
      // Clear timer.
      $scope.clearTimer();

      // Is launching a desktop or an application.
      if ($scope.isLaunchingItem) {
         $scope.isLaunchingItem = false;

         /**
          * When 30 seconds expire, display a dialog
          * asking user whether to cancel the request.
          */
         timeoutID = setTimeout(function () {
            // Remove busy cursor.
            $rootScope.enable();

            timeoutID = null;
            var dialog = dialogService.confirm({
               data: {
                  title: _('dialog_title_cancel_startsession'),
                  message: _('dialog_confirm_cancel_startsession')
               },
               closeByEscape: false,
               closeByDocument: false,
               controller: ['$scope', function ($scope) {
                  $scope.confirm = function () {
                     // Press OK btn, display busy cursor.
                     $rootScope.connecting();
                     dialog.close();
                  };
                  $scope.close = function () {
                     // Press cancel btn, cancel launching item request.
                     jscdkLauncherInvoker.cancelCurrentRequest();
                     // Remove busy cursor.
                     $rootScope.enable();
                     dialog.close();
                  };
               }]
            });
         }, 30 * 1000);
      }
   };

   // Clear timeout timer.
   $scope.clearTimer = function () {
      if (timeoutID !== null) {
         // Clear timer.
         clearTimeout(timeoutID);
         timeoutID = null;
      }
   };

   // Override teardown method
   $scope.tearDown = function () {
      // Remove event listener.
      (0, _jquery2.default)(document).off('keydown', $scope.moveFocus);
      // Clear timeout timer.
      $scope.clearTimer();
   };

   $scope.enable = function () {
      // Invoke parent's enable method.
      $rootScope.enable();
      // Clear timer.
      $scope.clearTimer();
   };

   $scope.init();
}

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = LaunchItemsCtrlService;

var _util = __webpack_require__(3);

var _util2 = _interopRequireDefault(_util);

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function LaunchItemsCtrlService(connectionServerModel, mainService, utilService, dialogService, safeStorageService, _, connectionURIModel, viewService, jscdkLauncherInvoker) {
   // Process URI action for application.
   function processURIAction4App(self, application, action, args) {
      if (utilService.ignoreCaseEquals(action, 'start-session') || !action) {
         // We need to fill in the mainService.currentController with
         // self or otherwise launching an application will fail if
         // we need to steal a session.
         mainService.currentController = self;
         self.currentApplication = application;
         self.bufferedArgs = args;
         // Launch application.
         self.launchCurrentApplication(application, null, args);
      } else if (utilService.ignoreCaseEquals(action, 'browse')) {
         // Highlight the application.
         self.highlightItems(application);
      }
   }

   // Process URI action for desktop.
   function processURIAction4Desktop(self, desktop, action) {
      if (utilService.ignoreCaseEquals(action, 'logoff')) {
         if (desktop.logoffEnabled) {
            // Logoff desktop.
            self.logoffDesktop(desktop);
         } else {
            // Failed to logoff the desktop.
            self.highlightItems(desktop);
            // Show error dialog.
            dialogService.error({
               data: {
                  title: _('ERROR'),
                  errorMessage: _('error_logoff_no_session', desktop.name)
               }
            });
         }
      } else if (utilService.ignoreCaseEquals(action, 'reset')) {
         if (desktop.resetEnabled) {
            // Reset desktop.
            self.resetDesktop(desktop);
         } else {
            // Failed to reset the desktop.
            self.highlightItems(desktop);
            dialogService.error({
               data: {
                  title: _('ERROR'),
                  errorMessage: _('error_reset_not_allowed', desktop.name)
               }
            });
         }
      } else if (utilService.ignoreCaseEquals(action, 'restart')) {
         if (desktop.restartEnabled) {
            // Restart desktop.
            self.restartDesktop(desktop);
         } else {
            // Failed to restart the desktop.
            self.highlightItems(desktop);
            dialogService.error({
               data: {
                  title: _('ERROR'),
                  errorMessage: _('error_restart_not_allowed', desktop.name)
               }
            });
         }
      } else if (utilService.ignoreCaseEquals(action, 'browse')) {
         // Highlight desktop.
         self.highlightItems(desktop);
      } else if (utilService.ignoreCaseEquals(action, 'start-session') || !action) {
         // Launch desktop.
         self.launchDesktop(desktop);
      }
   }

   /**
    * storeLaunchingItemInfoForBlastSideBar
    *
    * store the current launching item info. If item is desktop,
    * desktopId and desktopName is required. originID is clear to
    * empty string. If item is application, originID is required.
    */
   function storeLaunchingItemInfoForBlastSideBar(desktopInfo, originID) {
      safeStorageService.setItem('OriginDesktop', desktopInfo);
      safeStorageService.setItem('OriginAppID', originID);
      safeStorageService.setItem('TriedSSLVerify', {});
      // Hack for now for we need an API in safeStorageService.
      window.sessionStorage.removeItem('SSS_RunningSession');
   }

   /**
    * URI handler
    * return {canContinuePreviousAction: bool,
             * shouldClearPreviousAction: bool}. and if first flag is true, the
    * second one should not be defined, i.e.
    * {canContinuePreviousAction: true}
    */
   function handleURI(self, desktops, applications) {
      var i = void 0,
          length = void 0,
          desktop = void 0,
          application = void 0,
          searchedItems = false;

      /** TODO: this async design will cause bug.
       *  The shouldClearPreviousAction will not be set true as
       * expected. To solve this bug, the whole function will be
       * redesigned.
       */
      if (connectionURIModel.reuseSession) {
         var shouldClearPreviousAction = false;
         connectionURIModel.isIdenticalUser(connectionServerModel.host, function (isIdentical) {
            if (!isIdentical) {
               /**
                * Current URI connection has different connection
                * info from that of the session. Confirm with the
                * user whether to reuse the present session.
                */
               connectionURIModel.reuseSession = false;
               shouldClearPreviousAction = true;
               /*
                * If it's a HWS session, logout connection server immediately.
                * Otherwise, confirm with the user whether to logout or not.
                */
               if (connectionURIModel.isHWSession()) {
                  // Logout desktop, but with uri info in jscdk and
                  // UI reserved.
                  jscdkLauncherInvoker.logout(false);
                  viewService.logoutToPortal = false;
               } else {
                  self.switchUserDialog = dialogService.confirm({
                     data: {
                        title: _('dialog_title_logout'),
                        message: _('dialog_confirm_logout')
                     },
                     controller: ['$scope', function ($scope) {
                        $scope.confirm = function () {
                           // Logout desktop, but with uri info in
                           // jscdk and UI reserved.
                           jscdkLauncherInvoker.logout(false);
                           viewService.logoutToPortal = false;
                           self.switchUserDialog.close();
                           self.switchUserDialog = null;
                        };
                     }]
                  });
               }
            } else {
               // if is identical user, update connecting info accordingly
               if (connectionURIModel.isHWSession()) {
                  /**
                   * only for HWS, should not move this line out of
                   * the "if" condition, or the normal URL will
                   * have a corner regression
                   */
                  connectionServerModel.loadFromURIModel(connectionURIModel);
               }
            }
         });
         if (shouldClearPreviousAction) {
            return {
               canContinuePreviousAction: false,
               shouldClearPreviousAction: true
            };
         }
      } else {
         /**
          * When first time launched by vIDM(workspace),
          * connectionServerModel should be updated as well. Otherwise
          * nothing could be stored in cookie. When next time launched by
          * vIDM with a different user, client wouldn't be able to realize
          * it is a different session. See bug 1766419
          *
          */
         if (connectionURIModel.isHWSession()) {
            connectionServerModel.loadFromURIModel(connectionURIModel);
         }
      }

      /**
       * NOTE:
       * This is for vIDM integration case. See bug 1770485
       *
       * vIDM uses the wrong URI to launch application, e.g.
       * https://pod2-vcs1.blr.trcint.com/portal/webclient/index.html?
       * applicationId=cn%3Dwordpad,ou%3Dapplications,dc%3Dvdi,dc%3Dvmware,
       * dc%3Dint&SAMLart=AAQAAA/Hs7t/WV3jvQAZ6XcIqPsJs0EeMl%2BMImpRKY8RlqOW
       * %2Bhg%2BGCOOGWg%3D&user=idmadmin&domainName=blr.trcint.com&
       * desktopName=WordPad&horizonId=184a3bbe-aa23-49ce-8372-857c0abb44ae
       * #/launchitems
       *
       * This URI contains applicationId and desktopName at the same time.
       * In our early code, desktopName is not supported. So the launch can
       * work. However, we introduce desktopName as a new parameter in 16q4,
       * which cause vIDM cannot launch application.
       *
       * As vIDM already releases at this time (2016-11-24), we have to
       * provide a workaround for them.
       *
       * Above all, we still first search the desktop list and then
       * the application list.
       * if none can be found in both list, we will then prompt a dialog.
       *
       * If we don't even search the list (while there is no desktop or
       * application info), we will still use the old code to return.
       */
      if (!!connectionURIModel.params && (!!connectionURIModel.params.desktopId || !!connectionURIModel.params.desktopName || !!connectionURIModel.params.collabSessionId) && !!desktops) {

         searchedItems = true;

         for (i = 0, length = desktops.length; i < length; i++) {
            desktop = desktops[i];
            if (utilService.ignoreCaseEquals(desktop.id, connectionURIModel.params.desktopId) || utilService.ignoreCaseEquals(desktop.name, connectionURIModel.params.desktopId) || utilService.ignoreCaseEquals(desktop.name, connectionURIModel.params.desktopName) || utilService.ignoreCaseEquals(desktop.id, connectionURIModel.params.collabSessionId)) {
               // Process URI action.
               processURIAction4Desktop(self, desktop, connectionURIModel.params.action);
               // delete desktopId to avoid further usage, can't clear
               // all the params for bug 1450429.
               connectionURIModel.params.desktopId = null;
               // help to fix a logic defect introduced when songlil
               // added the desktopName support, or the desktopName
               // might get reused later if launch is canceled
               connectionURIModel.params.desktopName = null;

               connectionURIModel.params.collabSessionId = null;
               return {
                  canContinuePreviousAction: false,
                  shouldClearPreviousAction: false
               };
            }
         }
      }

      if (!!connectionURIModel.params && (!!connectionURIModel.params.applicationId || !!connectionURIModel.params.applicationName) && !!applications) {

         searchedItems = true;

         for (i = 0, length = applications.length; i < length; i++) {
            application = applications[i];
            if (utilService.ignoreCaseEquals(application.id, connectionURIModel.params.applicationId) || utilService.ignoreCaseEquals(application.name, connectionURIModel.params.applicationId) || utilService.ignoreCaseEquals(application.name, connectionURIModel.params.applicationName)) {
               processURIAction4App(self, application, connectionURIModel.params.action, connectionURIModel.params.args);
               // delete applicationId, applicationName and args to
               // avoid further usage.
               connectionURIModel.params.applicationId = null;
               connectionURIModel.params.applicationName = null;
               connectionURIModel.params.args = null;
               return {
                  canContinuePreviousAction: false,
                  shouldClearPreviousAction: false
               };
            }
         }
      }

      if (searchedItems) {
         // Show error dialog.
         var dialog = dialogService.error({
            data: {
               title: _('ERROR'),
               errorMessage: _('error_item_not_found', connectionURIModel.params.desktopId || connectionURIModel.params.desktopName || connectionURIModel.params.applicationId || connectionURIModel.params.applicationName || connectionURIModel.params.collabSessionId)
            },
            controller: ['$scope', function ($scope) {
               $scope.close = function () {
                  utilService.runFunctionIfNotHWSOrF5(null);
                  dialog.close();
               };
            }]
         });
         return {
            canContinuePreviousAction: false,
            shouldClearPreviousAction: true
         };
      }

      return {
         canContinuePreviousAction: true
      };
   }

   /**
    * add this function cause the desktop object for display is not
    * the same before and after the reauth. And whether the action can
    * be processed now is also unknown, so check the validation of
    * action again, even some times ago it's valid.
    *
    * should be old broker compatible cause the applications will be
    * empty, and this function should never be involved.
    *
    * the itemType is just in case application and desktop have same
    * id, could be added in the action string, but I choose not to for
    * easy to be understanded.
    */
   function handlePreviousAction(self, desktops, applications, previousAction) {
      var previousTargetItem = previousAction.item,
          action = previousAction.action,
          itemType = previousAction.itemType,
          args = void 0,
          targetItemId = void 0,
          i = void 0,
          length = void 0,
          desktop = void 0,
          application = void 0;

      if (!previousTargetItem || !action || !itemType) {
         return;
      }
      if (itemType === "application") {
         previousTargetItem = previousTargetItem.application;
         args = previousTargetItem.args;
      }

      targetItemId = previousTargetItem.id;
      if (!targetItemId) {
         _jscdkLogger2.default.debug('error: cann\'t find the id in previousAction Object');
         return;
      }

      //search desktops
      if (!!desktops && itemType === 'desktop') {
         for (i = 0, length = desktops.length; i < length; i++) {
            desktop = desktops[i];
            if (utilService.ignoreCaseEquals(desktop.id, targetItemId)) {
               processURIAction4Desktop(self, desktop, action);
               return;
            }
         }
      }
      //search applications
      if (!!applications && itemType === 'application') {
         for (i = 0, length = applications.length; i < length; i++) {
            application = applications[i];
            if (utilService.ignoreCaseEquals(application.id, targetItemId)) {
               processURIAction4App(self, application, action, args);
               return;
            }
         }
      }
      // not found target
      _jscdkLogger2.default.warning('can\'t find the target of previous action, please check with system admin');
   }

   function _launchDesktop(desktop) {
      /*jshint validthis: true*/
      var errorMsg = '',
          scope = this;

      if (utilService.isSessionStorageAllowed()) {
         if (!!desktop) {
            // Store current desktop to persistent storage
            storeLaunchingItemInfoForBlastSideBar({
               id: desktop.id,
               name: desktop.name
            }, '');
            scope.isLaunchingItem = true;

            jscdkLauncherInvoker.launchDesktop(desktop);
         }
      } else {
         if (utilService.isWebKitBrowser()) {
            errorMsg = 'error_private_browsing';
         } else {
            errorMsg = 'error_unsupported_browser';
         }

         mainService.currentController.enable();
         dialogService.error({
            data: {
               title: _('ERROR'),
               errorMessage: _(errorMsg)
            }
         });
      }
   }

   function _logoffDesktop(desktop) {
      var logoffCallback = void 0;

      logoffCallback = function logoffCallback(desktop) {
         // Disable logoff button.
         desktop.logoffEnabled = false;
         // Logoff desktop.
         jscdkLauncherInvoker.logoffDesktop(desktop.id);
      };

      var dialog = dialogService.confirm({
         data: {
            title: _('dialog_title_logoff'),
            message: _('dialog_confirm_logoff')
         },
         controller: ['$scope', function ($scope) {
            $scope.confirm = function () {
               logoffCallback(desktop);
               dialog.close();
            };
         }]
      });
   }

   function _resetDesktop(desktop) {
      var resetCallback = void 0;

      resetCallback = function resetCallback(desktop) {
         // Logoff desktop.
         jscdkLauncherInvoker.reset(desktop.id);
      };

      var dialog = dialogService.confirm({
         data: {
            title: _('dialog_title_reset'),
            message: _('dialog_confirm_reset')
         },
         controller: ['$scope', function ($scope) {
            $scope.confirm = function () {
               resetCallback(desktop);
               dialog.close();
            };
         }]
      });
   }

   function _restartDesktop(desktop) {
      var restartCallback = void 0;

      restartCallback = function restartCallback(desktop) {
         jscdkLauncherInvoker.restart(desktop.id);
      };

      var dialog = dialogService.confirm({
         data: {
            title: _('dialog_title_restart'),
            message: _('dialog_confirm_restart')
         },
         controller: ['$scope', function ($scope) {
            $scope.confirm = function () {
               restartCallback(desktop);
               dialog.close();
            };
         }]
      });
   }

   function _launchApplication(appInfo) {
      /*jshint validthis: true*/
      var application = appInfo.application,
          errorMsg = '',
          scope = this;

      if (!application) {
         _jscdkLogger2.default.error('Can\'t get the application data.');
         return;
      }

      if (utilService.isSessionStorageAllowed()) {
         if (!!application) {
            // Store current application to persistent storage
            storeLaunchingItemInfoForBlastSideBar({
               id: '',
               name: ''
            }, application['origin-id']);
            scope.isLaunchingItem = true;

            jscdkLauncherInvoker.launchApplication(appInfo);
         }
      } else {
         /*
          * In private browsing mode,Safari,iOS safari and the Android browsers
          * do not support setting sessionStorage or loaclStorage.
          * In this case,there's no Android browsers, so use webkit to check whether it's private mode.
          */
         if (utilService.isWebKitBrowser()) {
            errorMsg = 'error_private_browsing';
         } else {
            errorMsg = 'error_unsupported_browser';
         }

         dialogService.error({
            data: {
               title: _('ERROR'),
               errorMessage: _(errorMsg)
            }
         });
      }
   }

   return {
      // Render launch items list.
      renderLaunchItems: function renderLaunchItems(data) {
         var desktops = void 0,
             desktop = void 0,
             desktopKey = void 0,
             shadowSessions = void 0,
             shadowSession = void 0,
             shadowSessionKey = void 0,
             applications = void 0,
             application = void 0,
             applicationKey = void 0,
             applicationSessions = void 0,
             applicationSessionKey = void 0,
             nextStepFlags = void 0,
             previousAction = void 0;
         jscdkLauncherInvoker['applicationSessionArray'] = [];

         if (!!data && !!data.content) {
            desktops = data.content.desktops;
            for (desktopKey in desktops) {
               if (desktops.hasOwnProperty(desktopKey)) {
                  desktop = desktops[desktopKey];

                  if (desktop['protocol-match'] === 'false') {
                     // Don't show this desktop because its display
                     // protocol is not allowed.
                     continue;
                  }

                  _jquery2.default.extend(desktop, {
                     isShadow: false,
                     resetEnabled: false,
                     restartEnabled: false,
                     logoffEnabled: false,
                     highlight: false
                  });

                  if (desktop.canLogoff === 'true' && desktop.state !== '') {
                     desktop.logoffEnabled = true;
                  }

                  if (desktop['reset-allowed'] === 'true' && desktop['reset-allowed-on-session'] === 'true') {
                     desktop.resetEnabled = true;
                  }

                  if (desktop['reset-allowed'] === 'true' && desktop['reset-allowed-on-session'] === 'true' && _util2.default.brokerSupportRestartDesktop()) {
                     desktop.restartEnabled = true;
                  }

                  this.desktops.push(desktop);
               }
            }

            shadowSessions = data.content.shadowSessions;
            for (shadowSessionKey in shadowSessions) {
               if (shadowSessions.hasOwnProperty(shadowSessionKey)) {
                  shadowSession = shadowSessions[shadowSessionKey];
                  // We treat all shadow sessions as desktop sessions.
                  if (shadowSession['protocol-match'] === 'false') {
                     continue;
                  }

                  _jquery2.default.extend(shadowSession, {
                     isShadow: true,
                     resetEnabled: false,
                     restartEnabled: false,
                     logoffEnabled: false,
                     highlight: false
                  });

                  this.desktops.push(shadowSession);
               }
            }

            applications = data.content.applications;
            for (applicationKey in applications) {
               if (applications.hasOwnProperty(applicationKey)) {
                  application = applications[applicationKey];

                  if (application['protocol-match'] === 'false') {
                     // Don't show this application because its
                     // display protocol is not allowed.
                     continue;
                  }

                  _jquery2.default.extend(application, {
                     resetEnabled: false,
                     logoffEnabled: false,
                     highlight: false
                  });
                  application.icon = application.icons[utilService.getLargestIcon(application.icons)];

                  this.applications.push(application);
               }
            }
            //store the application-sessions data
            applicationSessions = data.content.applicationSessions;
            for (applicationSessionKey in applicationSessions) {
               if (applicationSessions.hasOwnProperty(applicationSessionKey)) {
                  jscdkLauncherInvoker['applicationSessionArray'].push(applicationSessions[applicationSessionKey]);
               }
            }

            if (this.desktops.length > 0 || this.applications.length > 0) {
               // Handle URI.
               nextStepFlags = handleURI(this, this.desktops, this.applications);
               if (nextStepFlags.canContinuePreviousAction) {
                  // continue action.
                  previousAction = utilService.authenticationStatusCheck.popAction(this);
                  if (!!previousAction) {
                     handlePreviousAction(this, this.desktops, this.applications, previousAction);
                  }
               } else if (nextStepFlags.shouldClearPreviousAction) {
                  utilService.authenticationStatusCheck.clearAction();
               }
            } else {
               var dialog = dialogService.error({
                  data: {
                     title: _('ERROR'),
                     errorMessage: _('error_none_desktops')
                  },
                  controller: ['$scope', function ($scope) {
                     $scope.close = function () {
                        // Logout desktop.
                        utilService.runFunctionIfNotHWSOrF5(function () {
                           jscdkLauncherInvoker.logout();
                        });
                        dialog.close();
                     };
                  }]
               });
               utilService.authenticationStatusCheck.clearAction();
            }
         }
      },

      launchDesktop: function launchDesktop(desktop, event) {
         this.highlightItems(desktop, event);
         this.isLaunchingItem = true;
         if (this.ajaxBusy) {
            return;
         }
         if (!_util2.default.brokerSupportApplication()) {
            _launchDesktop.call(this, desktop);
         } else {
            utilService.authenticationStatusCheck.callBackWhenUnlocked(_launchDesktop, desktop, 'start-session', 'desktop');
         }
      },

      logoffDesktop: function logoffDesktop(desktop) {
         if (!desktop.logoffEnabled || this.ajaxBusy) {
            return;
         }
         if (!_util2.default.brokerSupportApplication()) {
            _logoffDesktop(desktop);
         } else {
            utilService.authenticationStatusCheck.callBackWhenUnlocked(_logoffDesktop, desktop, 'logoff', 'desktop');
         }
      },

      resetDesktop: function resetDesktop(desktop) {
         if (!desktop.resetEnabled || this.ajaxBusy) {
            return;
         }
         if (!_util2.default.brokerSupportApplication()) {
            _resetDesktop(desktop);
         } else {
            utilService.authenticationStatusCheck.callBackWhenUnlocked(_resetDesktop, desktop, 'reset', 'desktop');
         }
      },

      restartDesktop: function restartDesktop(desktop) {
         if (!desktop.restartEnabled || this.ajaxBusy) {
            return;
         }
         utilService.authenticationStatusCheck.callBackWhenUnlocked(_restartDesktop, desktop, 'restart', 'desktop');
      },

      highlightItems: function highlightItems(item, event) {
         this.activeItem = item;
         if (!!event) {
            this.focusElement = event.target;
         }
      },

      launchApplication: function launchApplication(application, event, args) {
         this.highlightItems(application, event);
         this.isLaunchingItem = true;
         if (this.ajaxBusy) {
            return;
         }
         if (!_util2.default.brokerSupportApplication()) {
            _jscdkLogger2.default.error('application is not supported by the broker');
         } else {
            utilService.authenticationStatusCheck.callBackWhenUnlocked(_launchApplication, {
               application: application,
               args: args
            }, 'start-session', 'application');
         }
      },

      isHighlighted: function isHighlighted(item) {
         return item === this.activeItem;
      },

      handleURI: handleURI
   };
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*********************************************************
                                                                                                                                                                                                                                                                               * Copyright (C) 2017 VMware, Inc. All rights reserved.
                                                                                                                                                                                                                                                                               *********************************************************/

exports.default = anonymousSelectDirective;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function anonymousSelectDirective($timeout) {
   return {
      restrict: 'A',
      require: '?ngModel',
      link: function link(scope, element, attrs, ngModel) {
         var widget = null;
         element.selectmenu({
            position: { my: "left top+5", at: "left bottom" }
         });
         widget = element.selectmenu('widget');
         element.selectmenu('menuWidget').addClass('overflow');
         widget.addClass('anonymous-select');

         scope.$watch(attrs.ngModel, function () {
            element.selectmenu('refresh');
         });
         element.on('selectmenuselect', function ($event, ui) {
            // Refer to http://api.jqueryui.com/selectmenu/#event-select
            var userName = ui.item.value;

            var _loop = function _loop(i) {
               if (scope.usernames[i].value.toLocaleLowerCase() === userName.toLocaleLowerCase()) {
                  //use timeout to solve $digest already in progress, make
                  // the scope.credential.domain binded with select value.
                  $timeout(function () {
                     scope.credential.username = scope.usernames[i];
                  });
                  return {
                     v: void 0
                  };
               }
            };

            for (var i = 0; i < scope.usernames.length; i++) {
               var _ret = _loop(i);

               if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
            }
            throw 'Select username error!';
         });
         widget.keydown(function (e) {
            var c = e.keyCode;
            // Call login when press enter.
            if (c === 13) {
               scope.$apply(attrs.selectMenu);
            } else if (c === 40) {
               //Expand the dropdown when press down key.
               var isExpand = widget.attr('aria-expanded');
               if (isExpand === 'false') {
                  element.selectmenu('open');
               }
            }
         });

         scope.$watch(function () {
            return scope.ajaxBusy;
         }, function (newValue, oldValue) {
            if (newValue === true) {
               (0, _jquery2.default)("#unauthenticatedUsername").selectmenu("option", "disabled", true);
            } else {
               (0, _jquery2.default)("#unauthenticatedUsername").selectmenu("option", "disabled", false);
            }
         });
      }
   };
}

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = ChangePasswordCtrl;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function ChangePasswordCtrl($scope, $timeout, mainService, utilService, connectionServerModel, jscdkLauncherInvoker) {
   var renderData = function renderData(data) {
      if (!!data && !!data.content) {
         if (!!data.content.username) {
            $scope.username = data.content.username;
         }
         if (!!data.content.oldpassword) {
            $scope.credential.oldpassword = data.content.oldpassword;
         }
         // Set error message.
         if (!!data.content.error) {
            $scope.error = data.content.error;
         }
      }
   };

   // Initialize ChangePasswordCtrl controller.
   $scope.init = function () {
      $scope.loadingAllow = true;
      var data = mainService.data;

      // Name of the controller.
      $scope.name = 'WindowsPasswordExpired';
      // Set host address.
      $scope.host = connectionServerModel.host;
      // Error message.
      $scope.error = '';
      // User credentials.
      $scope.credential = {
         oldpassword: '',
         newpassword: '',
         newpasswordRepeat: ''
      };
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;

      renderData(data);
   };

   $scope.changePassword = function (form) {
      if (form.$valid && !$scope.ajaxBusy) {
         jscdkLauncherInvoker.changePassword($scope.credential.oldpassword, $scope.credential.newpassword, $scope.credential.newpasswordRepeat);
      }
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      if ($scope.ajaxBusy) {
         jscdkLauncherInvoker.cancelCurrentRequest({
            name: 'WindowsPasswordExpired',
            content: {
               oldpassword: $scope.credential.oldpassword,
               error: $scope.error
            }
         });
      } else {
         jscdkLauncherInvoker.cancelAuthentication();
      }
   };

   $scope.keyPress = function (event, form) {
      if (!!event && event.keyCode === 13) {
         // Press enter key.
         $scope.changePassword(form);
      }
   };

   $scope.init();
}

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = DisclaimerCtrl;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function DisclaimerCtrl($scope, $rootScope, $timeout, mainService, utilService, jscdkLauncherInvoker) {
   var renderData = function renderData(data) {
      var message = void 0;

      if (!!data && !!data.content) {
         message = data.content.label;
         // Normalize pre-login message that each newline starts with
         // '\n'.
         $scope.disclaimerText = message.replace(/(\r\n|\r|\n)/g, '\n');
      }
   };

   $scope.init = function () {
      $scope.loadingAllow = true;
      var data = mainService.data;

      // Name of the controller.
      $scope.name = 'Disclaimer';
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;

      renderData(data);
      this.parentController = "Start";
   };

   $scope.accept = function () {
      jscdkLauncherInvoker.acceptDisclaimer();
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      utilService.runFunctionIfNotHWSOrF5(function () {
         jscdkLauncherInvoker.cancelAuthentication();
      });
   };

   $scope.init();
}

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = domainSelectMenuDirective;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function domainSelectMenuDirective($timeout, viewClientModel) {
   return {
      restrict: 'A',
      require: '?ngModel',
      link: function link(scope, element, attrs, ngModel) {
         var widget = null;
         element.selectmenu({
            position: { my: "left top+5", at: "left bottom" }
         });
         widget = element.selectmenu('widget');
         element.selectmenu('menuWidget').addClass('overflow');
         widget.addClass('domain-select');

         scope.$watch(attrs.ngModel, function () {
            element.selectmenu('refresh');
         });
         element.on('selectmenuselect', function () {
            // Value of element is 'string:xxx'
            var domainName = element.val().substr("string:".length),
                i = void 0;
            for (i = 0; i < scope.domains.length; i++) {
               if (scope.domains[i].toLocaleLowerCase() === domainName.toLocaleLowerCase()) {
                  break;
               }
            }
            if (i >= scope.domains.length) {
               throw 'Select domain error!';
            }
            //use timeout to solve $digest already in progress, make
            // the scope.credential.domain binded with select value.
            $timeout(function () {
               scope.$apply(scope.credential.domain = scope.domains[i]);
            });
         });
         widget.keydown(function (e) {
            var c = e.keyCode;
            // Call login when press enter.
            if (c === 13) {
               scope.$apply(attrs.selectMenu);
            } else if (c === 40) {
               //Expand the dropdown when press down key.
               var isExpand = widget.attr('aria-expanded');
               if (isExpand === 'false') {
                  element.selectmenu('open');
               }
            }
         });
         scope.$watch(function () {
            return scope.domainReadOnly;
         }, function (newValue, oldValue) {
            if (newValue === true) {
               (0, _jquery2.default)("#domain").selectmenu("option", "disabled", true);
            } else {
               (0, _jquery2.default)("#domain").selectmenu("option", "disabled", false);
            }
         });

         /**
          * Hide domain list
          * clientHideDomainList is set in getConfigurationHandler.js
          */
         if (viewClientModel.clientHideDomainList) {
            (0, _jquery2.default)("#domain-button").addClass('ui-hide');

            // Use the same way to hide domain
            if (scope.isPhone) {
               (0, _jquery2.default)("#domain").addClass('ui-hide');
            }
         }
      }
   };
} /*********************************************************
   * Copyright (C) 2016-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.LoginCtrl = LoginCtrl;
exports.WaitingCtrl = WaitingCtrl;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function LoginCtrl($scope, $rootScope, mainService, utilService, storageService, jscdkLauncherInvoker) {
   var widgets = ['Waiting', 'SecurIDPasscode', 'WindowsPassword', 'Disclaimer', 'Unauthenticated'];

   $scope.init = function () {
      // Name of the controller.
      $scope.name = 'Start';
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;
      $scope.connectToBroker();
   };

   $scope.connectToBroker = function () {
      // first time enter authentication
      if (!$rootScope.initialized) {
         $rootScope.initialized = true;
         $scope.doCompatibilityCheckAndInitialize();
      } else {
         // idletimeout don't clear user's last action
         if (mainService.data && widgets.indexOf(mainService.data.name) >= 0) {
            $scope.enable(mainService.data.name, mainService.data.content);
         } else {
            jscdkLauncherInvoker.connectToBroker();
         }
      }
   };

   /*
    * doCompatibilityCheckAndInitialize
    *
    *    Verifies the version of the browser and check if cookie is enabled.
    *    If the browser is supported and cookie is enabled, launch
    *    web client. Otherwise, display the browser compatibility warning.
    *
    * @param data Locale and product data retrieved from the server.
    *             null if the request failed.
    */
   $scope.doCompatibilityCheckAndInitialize = function () {
      var ok = utilService.isCompatibleBrowser();

      if (!storageService.cookie.isEnabled()) {
         // User cannot login the connection server when the cookie is
         // disabled.
         ok = false;
      }

      // Enable browser support warning everytime instead of first use
      // only.
      if (ok) {
         if (!window.location.search) {
            // cancel previous user launch/reset/logoff trial
            utilService.authenticationStatusCheck.clearAction();

            jscdkLauncherInvoker.connectToBroker();
         } else {
            jscdkLauncherInvoker.setURI();
         }
      } else {
         // Display browser warnings.
         mainService.show('Warning');
      }
   };

   $scope.enable = function (name, data) {
      var i = void 0,
          e = void 0;
      if (!name) {
         /*If action name is null, set the action's name to waiting.*/
         name = 'Waiting';
      }
      for (i = 0; i < widgets.length; i++) {
         e = widgets[i];
         if (e === name) {
            $scope['show' + name] = true;
            $rootScope.enable();
         } else {
            $scope['show' + e] = false;
         }
      }
   };

   $scope.init();
}

function WaitingCtrl($scope, $rootScope) {
   $rootScope.showWaiting = true;
}

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SecuridNextTokenCodeCtrl;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function SecuridNextTokenCodeCtrl($scope, $rootScope, $timeout, connectionServerModel, mainService, utilService, jscdkLauncherInvoker, _) {
   var renderData = function renderData(data) {
      if (!!data && !!data.content) {
         if (!!data.content.label) {
            $scope.title = data.content.label;
         }

         if (!!data.content.authChallenge) {
            $scope.challengeString = data.content.authChallenge;
         }
      }
   };

   // Initialize LoginCtrl controller.
   $scope.init = function () {
      $scope.loadingAllow = true;
      var data = mainService.data;

      // Name of the controller.
      $scope.name = 'SecurIDNextTokenCode';
      // Set host address.
      $scope.host = connectionServerModel.host;
      // User credentials.
      $scope.credential = {
         passcode: ''
      };
      // Dialog title.
      $scope.title = _('dialog_title_login');
      // Challenge string.
      $scope.challengeString = _('dialog_challenge_nexttoken');
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;

      renderData(data);
   };

   // Login method.
   $scope.login = function (form) {
      if (form.$valid) {
         jscdkLauncherInvoker.submitSecurIDNextTokenCode($scope.credential.passcode);
      }
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      if ($scope.ajaxBusy) {
         jscdkLauncherInvoker.cancelCurrentRequest({
            name: 'SecurIDNextTokenCode',
            content: {
               label: $scope.title,
               authChallenge: $scope.challengeString
            }
         });
      } else {
         jscdkLauncherInvoker.cancelAuthentication();
      }
   };

   $scope.keyPress = function (event, form) {
      if (!!event && event.keyCode === 13) {
         // Press enter key.
         $scope.login(form);
      }
   };

   $scope.init();
}

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SecuridPasscodeCtrl;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function SecuridPasscodeCtrl($scope, $rootScope, $timeout, connectionServerModel, mainService, utilService, jscdkLauncherInvoker, _) {
   var renderData = function renderData(data) {
      if (!!data && !!data.content) {
         if (!!data.content.username) {
            $scope.credential.username = data.content.username;
         }

         if (!!data.content.error) {
            $scope.error = data.content.error;
         }

         if (!!data.content.label) {
            $scope.title = data.content.label;
            $scope.titleString = _('dialog_prompt_passcode', data.content.label);
         }

         if (!!data.content.authType) {
            $scope.authType = data.content.authType.toUpperCase();
         }
      }
   };

   // Initialize LoginCtrl controller.
   $scope.init = function () {
      $scope.loadingAllow = true;
      var data = mainService.data;

      // Name of the controller.
      $scope.name = 'SecurIDPasscode';
      // Set host address.
      $scope.host = connectionServerModel.host;
      // Error message.
      $scope.error = '';
      // Is RSA authentication.
      $scope.authType = 'RSA';
      // User credentials.
      $scope.credential = {
         username: '',
         passcode: ''
      };
      // Dialog title.
      $scope.title = _('dialog_title_login');
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;

      renderData(data);
      this.parentController = "Start";
   };

   // Login method.
   $scope.login = function (form) {
      if (form.$valid) {
         connectionServerModel.tokenUsername = $scope.credential.username;

         jscdkLauncherInvoker.submitSecurIDPasscode($scope.credential.username, $scope.credential.passcode);
      }
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      if ($scope.ajaxBusy) {
         jscdkLauncherInvoker.cancelCurrentRequest({
            name: 'SecurIDPasscode',
            content: {
               username: $scope.credential.username,
               label: $scope.title,
               authType: $scope.authType
            }
         });
      } else {
         jscdkLauncherInvoker.cancelAuthentication();
      }
   };

   $scope.keyPress = function (event, form) {
      if (!!event && event.keyCode === 13) {
         // Press enter key.
         $scope.login(form);
      }
   };

   /**
    * Fix Bug 1229360: The sign in button is inactive when Username
    * only contains Non-ASCII characters in IE11 browser.
    *
    * The reason is in IE11, entering non-ASCII codes in the text
    * input
    * doesn't dispatch change event, while AngularJS 1.2.2 library
    * relies on change event to do data-binding.
    *
    * The workaround is at focus out, update binding value if
    * necessary. TODO: Update AngularJS library.
    */
   $scope.updateUsername = function () {
      var value = (0, _jquery2.default)('#securUsername').val();
      if ($scope.credential && value !== $scope.credential.username) {
         $scope.credential.username = value;
      }
   };
   $scope.init();
} /*********************************************************
   * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SecuridPinChangeCtrl;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function SecuridPinChangeCtrl($scope, $rootScope, $timeout, connectionServerModel, mainService, utilService, jscdkLauncherInvoker, _) {
   var renderData = function renderData(data) {
      if (!!data && !!data.content) {
         if (!!data.content.error) {
            $scope.error = data.content.error;
         }

         if (!!data.content.message) {
            $scope.prompt = _('dialog_prompt_pinchange') + data.content.message;
         }

         /**
          * handle UI of three types of PIN change
          *
          * (1) MUST_CHOOSE_PIN: show textfields (pin1 and pin2) with
          * blank
          * (2) CANNOT_CHOOSE_PIN: show textfield pin1 with value
          * readonly returned from broker
          * (3) USER_SELECTABLE: show textfield pin1 with value
          * editable returned from broker
          *
          */
         if (!!data.content.pin1) {
            $scope.pin1Type = 'text';
            $scope.pin1 = data.content.pin1;
         }
         if (data.content.pin1ReadOnly === 'yes') {
            $scope.pin1ReadOnly = true;
         }
      }
   };

   // Initialize LoginCtrl controller.
   $scope.init = function () {
      $scope.loadingAllow = true;
      var data = mainService.data;

      // Name of the controller.
      $scope.name = 'SecurIDPinChange';
      // Error message.
      $scope.error = '';
      $scope.pin1 = '';
      $scope.pin2 = '';
      $scope.prompt = '';
      $scope.pin1Type = 'password';
      $scope.pin1ReadOnly = false;
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;

      renderData(data);
   };

   // Login method.
   $scope.login = function (form) {
      if (form.$valid) {
         jscdkLauncherInvoker.submitSecurIDPinChange($scope.pin1, $scope.pin2);
      }
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      if ($scope.ajaxBusy) {
         jscdkLauncherInvoker.cancelCurrentRequest({
            name: 'SecurIDPinChange',
            content: {
               message: $scope.prompt,
               pin1: $scope.pin1,
               pin1ReadOnly: $scope.pin1ReadOnly
            }
         });
      } else {
         jscdkLauncherInvoker.cancelAuthentication();
      }
   };

   $scope.keyPress = function (event, form) {
      if (!!event && event.keyCode === 13) {
         // Press enter key.
         $scope.login(form);
      }
   };

   $scope.init();
}

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = SecuridWaitCtrl;
/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function SecuridWaitCtrl($scope, $rootScope, $timeout, connectionServerModel, mainService, utilService, jscdkLauncherInvoker) {
   // Initialize LoginCtrl controller.
   $scope.init = function () {
      $scope.loadingAllow = true;
      var data = mainService.data;

      // Name of the controller.
      $scope.name = 'SecurIDWait';
      // Set host address.
      $scope.host = connectionServerModel.host;
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;
   };

   // Login method.
   $scope.login = function () {
      jscdkLauncherInvoker.submitSecurIDWait();
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      if ($scope.ajaxBusy) {
         jscdkLauncherInvoker.cancelCurrentRequest({
            name: 'SecurIDWait'
         });
      } else {
         jscdkLauncherInvoker.cancelAuthentication();
      }
   };

   $scope.init();
}

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = UnauthenticatedCtrl;
/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

function UnauthenticatedCtrl($scope, connectionServerModel, _, viewService, mainService, jscdkLauncherInvoker, connectionURIModel, utilService, dialogService) {
   $scope._getDefaultUser = function (usernames) {
      for (var i = 0; i < usernames.length; i++) {
         if (usernames[i].default) {
            return usernames[i];
         }
      }

      // If not find the default username, just use the first one
      return usernames[0];
   };

   $scope._renderData = function (data) {
      if (!!data && !!data.content) {
         if (!!data.content.usernames) {
            $scope.usernames = data.content.usernames;

            $scope.credential.username = $scope._getDefaultUser(data.content.usernames);

            $scope._setDisplayName($scope.usernames);
         }

         if (!!data.content.currentUsername) {
            $scope.credential.username = data.content.currentUsername;
         }

         if (!!data.content.error) {
            $scope.error = data.content.error;
         }

         $scope._tryAutoConnect(data);
      }
   };

   $scope._setDisplayName = function (usernames) {
      usernames.forEach(function (username) {
         if (username.default) {
            // Append ' (default)' to default username
            username.displayName = username.value + _('DEFAULT_FOR_ANONYMOUS');
         } else {
            username.displayName = username.value;
         }
      });
   };

   $scope._verifyUsername = function (username, usernames) {
      for (var i = 0; i < usernames.length; i++) {
         if (utilService.ignoreCaseEquals(username, usernames[i].value)) {
            return usernames[i];
         }
      }
      return null;
   };

   $scope._tryAutoConnect = function (data) {
      // If unauthenticatedAccessAccount exists in URL, use it
      if (!!connectionURIModel.params && !!connectionURIModel.params.unauthenticatedAccessAccount) {
         var usernameObj = $scope._verifyUsername(connectionURIModel.params.unauthenticatedAccessAccount, data.content.usernames);

         if (usernameObj !== null) {
            $scope.credential.username = usernameObj;
            $scope._loginWithUsername(usernameObj.value);
         } else {
            var dialog = dialogService.error({
               data: {
                  title: _('ERROR'),
                  errorMessage: _('ANONYMOUS_USERNAME_NOT_FOUND', connectionURIModel.params.unauthenticatedAccessAccount)
               },
               closeByEscape: false,
               closeByDocument: false,
               controller: ['$scope', function ($scope) {
                  $scope.close = function () {
                     viewService.gotoPortal();
                     dialog.close();
                  };
               }]
            });
         }
         return;
      }

      /**
       * If no unauthenticatedAccessAccount exists but there is only
       * one username, use it
       */
      if (data.content.usernames.length === 1) {
         $scope._loginWithUsername(data.content.usernames[0].value);
      }
   };

   $scope._loginWithUsername = function (username) {
      connectionServerModel.username = username;
      jscdkLauncherInvoker.submitUnauthenticated(username);
   };

   // Initialize LoginCtrl controller.
   $scope.init = function () {
      $scope.loadingAllow = true;
      var data = mainService.data;

      // Name of the controller.
      $scope.name = 'Unauthenticated';
      // Error message.
      $scope.error = '';
      // User credentials.
      $scope.credential = {
         username: ''
      };
      // Initialize view. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;

      $scope._renderData(data);
      this.parentController = "Start";
   };

   // Login method.
   $scope.login = function (form) {
      if (form.$valid) {
         $scope._loginWithUsername($scope.credential.username.value);
      }
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      if ($scope.ajaxBusy) {
         jscdkLauncherInvoker.cancelCurrentRequest({
            name: 'Unauthenticated',
            content: {
               usernames: $scope.usernames,
               currentUsername: $scope.credential.username
            }
         });
      } else {
         jscdkLauncherInvoker.cancelAuthentication();
      }
   };

   $scope.keyPress = function (event, form) {
      if (!!event && event.keyCode === 13) {
         // Press enter key.
         $scope.login(form);
      }
   };

   $scope.init();
}

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = WindowsPasswordCtrl;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function WindowsPasswordCtrl($scope, connectionServerModel, mainService, utilService, _, dialogService, viewClientModel, connectionURIModel, viewService, usernameUtil, jscdkLauncherInvoker) {
   var isReauthentication = function isReauthentication(data) {
      if (!data || !data.content) {
         return false;
      }
      return data.content.usernameReadOnly === 'yes' && data.content.domainReadOnly === 'yes';
   };

   var renderData = function renderData(data) {
      var domain = void 0,
          i = void 0;

      if (!!data && !!data.content) {
         // Initialize credential data binding model.
         $scope.credential.username = data.content.username;
         // Set username input editability.
         if (data.content.usernameReadOnly === 'yes') {
            $scope.userNameReadOnly = true;
         } else {
            $scope.userNameReadOnly = false;
         }
         // Set available domains.
         $scope.domains = data.content.domains;
         // Set domainName input editability.
         if (data.content.domainReadOnly === 'yes') {
            $scope.domainReadOnly = true;
         } else {
            $scope.domainReadOnly = false;
         }
         // Set current domain.
         if (!!$scope.domains && $scope.domains.length > 0) {
            if (!!data.content.domainName) {
               domain = data.content.domainName;
            }

            for (i = 0; i < $scope.domains.length; i++) {
               if (utilService.ignoreCaseEquals($scope.domains[i], domain)) {
                  break;
               }
            }
            if (i >= $scope.domains.length) {
               i = 0;
            }

            $scope.credential.domain = $scope.domains[i];
         }
         // Set error message.
         if (!!data.content.error) {
            $scope.error = data.content.error;
         }
         // Check username only when it exists
         if (!!$scope.credential.username) {
            $scope._checkUsername($scope.credential.username);
         }
      }
   };

   var checkSameUser = function checkSameUser() {
      if (!connectionURIModel.reuseSession) {
         return;
      }

      connectionURIModel.isIdenticalUser(connectionServerModel.host, function (isIdentical) {
         if (!isIdentical) {
            /**
             * Current URI connection has different connection
             * info from that of the session. Confirm with the user
             * whether to reuse the present session.
             */
            connectionURIModel.reuseSession = false;
            var dialog = dialogService.confirm({
               data: {
                  title: _('dialog_title_logout'),
                  message: _('dialog_confirm_logout')
               },
               controller: ['$scope', function ($scope) {
                  $scope.confirm = function () {
                     // Logout broker, but with uri info in jscdk and
                     // UI reversed.
                     jscdkLauncherInvoker.logout(false);
                     viewService.logoutToPortal = false;
                     dialog.close();
                  };
               }]
            });
         }
      });
   };

   // Initialize LoginCtrl controller.
   $scope.init = function () {
      $scope.loadingAllow = true;
      var data = mainService.data;
      //check platform to use native select.
      if (viewClientModel.mIsAndroid || viewClientModel.mIsIEMobile || viewClientModel.mIsIOS) {
         $scope.isPhone = true;
      } else {
         $scope.isPhone = false;
      }
      // Name of the controller.
      $scope.name = 'WindowsPassword';
      // Set host address.
      $scope.host = connectionServerModel.host;
      // Error message.
      $scope.error = '';
      // User credentials.
      $scope.credential = {
         username: connectionServerModel.username,
         password: '',
         domain: ''
      };
      // User name input editability.
      $scope.userNameReadOnly = false;
      // Domain select disable
      $scope.domainReadOnly = false;
      // If it is re-authentication
      $scope.isReauthentication = false;
      // Initialize View. Hide header and show strip.
      $scope.initView();
      // Set current controller.
      mainService.currentController = this;

      renderData(data);
      $scope.activeDownlist = false;

      // show logout dialog if is not identical user
      if (isReauthentication(data)) {
         if (viewClientModel.isAnonymousMode) {
            // Don't do re-authentication for anonymous mode
            $scope.enable();
            jscdkLauncherInvoker.logout(false);
            viewService.logoutToPortal = false;
         } else {
            checkSameUser();
            $scope.isReauthentication = true;
         }
      }

      this.parentController = "Start";
   };

   // Login method.
   $scope.login = function (form) {
      var domain = void 0,
          reAuth = false;

      if (form.$valid && $scope._isUsernameAndDomainLegal()) {
         if (usernameUtil.domainInUsername($scope.credential.username)) {
            /**
             * If username contains domain, store that one rather than
             * $scope.credential.domain
             *
             * connectionServerModel is used in storeUserInfo of
             * items-controller.js
             */
            domain = usernameUtil.getDomain($scope.credential.username);
         } else {
            domain = $scope.credential.domain;
         }

         //deal with reauth case
         if ($scope.userNameReadOnly && $scope.domainReadOnly) {
            reAuth = true;
         }

         // Store username and domain
         connectionServerModel.username = $scope.credential.username;
         connectionServerModel.domain = domain;

         jscdkLauncherInvoker.submitWindowsPassword($scope.credential.username, $scope.credential.password, domain, reAuth);
      }
   };

   $scope.cancel = function () {
      $scope.loadingAllow = false;
      // wirte in datas that needed when back to login page
      var backContent = {
         username: $scope.credential.username,
         domains: $scope.domains,
         domainName: $scope.credential.domain
      };
      if ($scope.userNameReadOnly === true) {
         backContent.usernameReadOnly = 'yes';
      }
      if ($scope.domainReadOnly === true) {
         backContent.domainReadOnly = 'yes';
      }
      // cancel current request
      if ($scope.ajaxBusy) {
         jscdkLauncherInvoker.cancelCurrentRequest({
            name: 'WindowsPassword',
            content: backContent
         });
      } else {
         // cancel previous user launch/reset/logoff trial
         utilService.authenticationStatusCheck.clearAction();
         if ($scope.domainReadOnly && $scope.userNameReadOnly) {
            //re-authentication
            // Logout the broker.
            jscdkLauncherInvoker.logout(true);
         } else {
            jscdkLauncherInvoker.cancelAuthentication();
         }
      }
   };

   $scope.keyPress = function (event, form) {
      if (!!event && event.keyCode === 13) {
         // Press enter key.
         $scope.login(form);
      }
   };

   /**
    * Fix Bug 1229360: The sign in button is inactive when Username
    * only contains Non-ASCII characters in IE11 browser.
    *
    * The reason is in IE11, entering non-ASCII codes in the text input
    * doesn't dispatch change event, while AngularJS 1.2.2 library relies
    * on change event to do data-binding.
    *
    * The workaround is at focus out, update binding value if necessary.
    * TODO: Update AngularJS library.
    */
   $scope.updateUsername = function () {
      var value = (0, _jquery2.default)('#username').val();
      if (value !== $scope.credential.username) {
         $scope.credential.username = value;
      }
   };

   // When username changed, detect whether use UPN name
   $scope.usernameChange = function () {
      $scope._checkUsername($scope.credential.username);
   };

   $scope._checkUsername = function (username) {
      // do nothing in the case of re-auth
      if ($scope.userNameReadOnly || !username) {
         return;
      }
      /**
       * 1. UPN. username@domain
       * 2. domain\username
       */
      if (username.indexOf('\\') !== -1 || username.indexOf('@') !== -1) {
         $scope.domainReadOnly = true;
      } else {
         $scope.domainReadOnly = false;
      }
   };

   $scope._isUsernameAndDomainLegal = function () {
      /**
       * Basic username check
       * 1. If username contains both @ and \
       * 2. If hide domain enabled, and username doesn't contain domain
       * Note: we don't need to check #2 if it is re-authentication as
       * user cannot change username at that time
       */
      if (!usernameUtil.isUsernameLegal($scope.credential.username) || viewClientModel.clientHideDomainList && !usernameUtil.domainInUsername($scope.credential.username) && !$scope.isReauthentication) {
         dialogService.error({
            data: {
               title: _('ERROR'),
               errorMessage: _('USERNAME_DOMAIN_ILLEGAL')
            }
         });
         return false;
      }

      // No more check for UPN or normal username
      if (usernameUtil.isUPN($scope.credential.username) || !usernameUtil.domainInUsername($scope.credential.username)) {
         return true;
      }

      /**
       * Begin to check domain\username now!
       * First check if domain is valid
       */
      var domain = usernameUtil.getDomain($scope.credential.username);
      if (!usernameUtil.isDomainLegal(domain)) {
         dialogService.error({
            data: {
               title: _('ERROR'),
               errorMessage: _('USERNAME_DOMAIN_ILLEGAL')
            }
         });
         return false;
      }

      // If domain is not hidden, check if the input domain in domain list
      if (!viewClientModel.clientHideDomainList && !usernameUtil.isDomainInDomainList(domain, $scope.domains)) {
         dialogService.error({
            data: {
               title: _('ERROR'),
               errorMessage: _('DOMAIN_NOT_IN_LIST')
            }
         });
         return false;
      }

      return true;
   };

   $scope.init();
} /*********************************************************
   * Copyright (C) 2015-2017 VMware, Inc. All rights reserved.
   *********************************************************/

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = routeConfig;

var _login = __webpack_require__(273);

var _login2 = _interopRequireDefault(_login);

var _changePassword = __webpack_require__(272);

var _changePassword2 = _interopRequireDefault(_changePassword);

var _securidNexttokencode = __webpack_require__(274);

var _securidNexttokencode2 = _interopRequireDefault(_securidNexttokencode);

var _securidPinchange = __webpack_require__(275);

var _securidPinchange2 = _interopRequireDefault(_securidPinchange);

var _securidWait = __webpack_require__(276);

var _securidWait2 = _interopRequireDefault(_securidWait);

var _launchitems = __webpack_require__(271);

var _launchitems2 = _interopRequireDefault(_launchitems);

var _blastDesktop = __webpack_require__(267);

var _blastDesktop2 = _interopRequireDefault(_blastDesktop);

var _homeWarning = __webpack_require__(269);

var _homeWarning2 = _interopRequireDefault(_homeWarning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2017 VMware, Inc. All rights reserved.
 *********************************************************/

function routeConfig($routeProvider) {
   $routeProvider.when('/', {
      templateUrl: _login2.default,
      controller: 'LoginCtrl'
   }).when('/home', {
      templateUrl: _login2.default,
      controller: 'LoginCtrl'
   }).when('/changepassword', {
      templateUrl: _changePassword2.default,
      controller: 'ChangePasswordCtrl'
   }).when('/securidnexttoken', {
      templateUrl: _securidNexttokencode2.default,
      controller: 'SecuridNextTokenCodeCtrl'
   }).when('/securidpinchange', {
      templateUrl: _securidPinchange2.default,
      controller: 'SecuridPinChangeCtrl'
   }).when('/securidwait', {
      templateUrl: _securidWait2.default,
      controller: 'SecuridWaitCtrl'
   }).when('/launchitems', {
      templateUrl: _launchitems2.default,
      controller: 'LaunchItemsCtrl'
   }).when('/blastdesktop', {
      templateUrl: _blastDesktop2.default,
      controller: 'BlastDesktopCtrl'
   }).when('/warning', {
      templateUrl: _homeWarning2.default,
      controller: 'HomeWarningCtrl'
   }).otherwise({
      redirectTo: '/'
   });
}

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
   value: true
});
exports.default = LauncherSettingsWindowController;

var _jquery = __webpack_require__(1);

var _jquery2 = _interopRequireDefault(_jquery);

var _jscdkLogger = __webpack_require__(0);

var _jscdkLogger2 = _interopRequireDefault(_jscdkLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*********************************************************
 * Copyright (C) 2014-2017 VMware, Inc. All rights reserved.
 *********************************************************/

function LauncherSettingsWindowController($scope, $rootScope, utilService, userGlobalPref, _, dialogService, mainService, viewClientModel, prefData, timezone, $timeout, jscdkLauncherInvoker) {
   $scope.init = function () {
      $scope.setUp();

      /**
       * set the timezone default value in the select menu when
       * dialog is shown. This will make sure select menu has been
       * included. The dialog display time is a later than run inin(),
       * watch on the dialog to show default value.
       */
      $scope.$on('ngDialog.opened', function (e, $dialog) {
         if ($dialog.name === 'SettingsWindowLauncher') {
            $scope.showDefaultTimezone();
            // When the dialog is show, set focus on close button.
            (0, _jquery2.default)('#closeSettingsBtn').focus();
         }
      });

      $scope.$on('$destroy', function () {
         // save timezone setting when controller destroy
         $scope.saveTimezone();
      });
   };

   /**
    * same logic exist in the setting-window-controller.js
    * @return {boolean}
    */
   $scope.supportDPISync = function () {
      return window.devicePixelRatio && window.devicePixelRatio > 1 && window.navigator.userAgent.toLowerCase().indexOf('iphone') === -1;
   };

   $scope.setUp = function () {
      $scope.enableDPISync = prefData.enableDPISync === 'true';
      // OSX key mappings setting is available only on Mac OS.
      $scope.areMacOSXKeyMappingsSupported = viewClientModel.mIsMacOS;
      $scope.areMacOSXKeyMappingsEnabled = prefData.useMacOSXKeyMappings !== 'false';
      // Windows key setting.
      $scope.isWindowsKeyEnabled = prefData.enableWindowsKey === 'true';
      // MP4 setting.
      $scope.isMP4Enabled = prefData.enableMP4 === 'true';
      $scope.isMP4Supported = viewClientModel.mIsChrome && viewClientModel.mVersionChrome >= 45 && !viewClientModel.mIsAndroid;
      if ($scope.isMP4Supported) {
         try {
            var testObject = new window.MediaSource();
            testObject = null;
         } catch (e) {
            $scope.isMP4Supported = false;
         }
      }

      $scope.isAutoTimezoneEnabled = !prefData.timezoneSync;

      $scope.toggleSwitches = [{
         id: 'dpi_sync',
         label: _('DPI_SYNC_M'),
         isSupported: $scope.supportDPISync(),
         isEnabled: $scope.enableDPISync,
         toggle: $scope.toggleDPISync
      }, {
         id: 'osxKeys',
         label: _('use_osx_key_mappings'),
         isSupported: $scope.areMacOSXKeyMappingsSupported,
         isEnabled: $scope.areMacOSXKeyMappingsEnabled,
         toggle: $scope.toggleUseMacOSXKeyMappings
      }, {
         id: 'winKey',
         label: _('enable_windows_key_t'),
         text: _('enable_windows_key_m', viewClientModel.mIsMacOS ? _('cmd_key') : _('win_key')),
         isSupported: !viewClientModel.mIsIOS && !viewClientModel.mIsAndroid,
         isEnabled: $scope.isWindowsKeyEnabled,
         toggle: $scope.toggleWindowsKey
      }, {
         id: 'mp4',
         label: _('allow_mp4_key_t'),
         isSupported: $scope.isMP4Supported,
         isEnabled: $scope.isMP4Enabled,
         toggle: $scope.toggleMP4
      }, {
         id: 'timezone',
         label: _('allow_timezone_key_t'),
         isSupported: !$scope.mIsTouchDevice,
         isEnabled: $scope.isAutoTimezoneEnabled,
         toggle: $scope.toggleTimezone
      }];
   };

   $scope.showDefaultTimezone = function () {
      $timeout(function () {
         var defaultTimezone = timezone.getWindowsTimezone();
         (0, _jquery2.default)("#timezoneList").val(defaultTimezone).change();
      });
   };

   // Reset application.
   $scope.resetApplications = function () {
      var applicationSession = jscdkLauncherInvoker.applicationSessionArray;

      if ($rootScope.applicationCanSet && applicationSession.length > 0) {
         utilService.authenticationStatusCheck.callBackWhenUnlocked(jscdkLauncherInvoker.resetAllApplicationSessions, null, mainService, 'reset-all', 'application');
         $rootScope.applicationCanSet = false;
      }
   };

   $scope.showResetConfirmDialog = function () {
      var resetApplications = $scope.resetApplications;
      if ($rootScope.applicationCanSet) {
         $scope.closeThisDialog();
         var dialog = dialogService.confirm({
            data: {
               title: _('dialog_title_resetapp'),
               message: _('dialog_confirm_resetapp')
            },
            controller: ['$scope', function ($scope) {
               $scope.confirm = function () {
                  resetApplications();
                  dialog.close();
               };
            }]
         });
      }
   };

   $scope.toggleDPISync = function () {
      $scope.enableDPISync = !$scope.enableDPISync;
      userGlobalPref.updatePrefData({
         name: 'enableDPISync',
         text: $scope.enableDPISync ? "true" : "false",
         action: 'enableDPISync'
      });
   };

   // Method for toggling OSX key mappings.
   $scope.toggleUseMacOSXKeyMappings = function () {
      $scope.areMacOSXKeyMappingsEnabled = !$scope.areMacOSXKeyMappingsEnabled;
      userGlobalPref.updatePrefData({
         name: 'useMacOSXKeyMappings',
         text: $scope.areMacOSXKeyMappingsEnabled ? 'true' : 'false',
         action: 'useMacOSXKeyMappings'
      });
   };

   // Method for toggling Windows key simulation functionality.
   $scope.toggleWindowsKey = function () {
      $scope.isWindowsKeyEnabled = !$scope.isWindowsKeyEnabled;

      userGlobalPref.updatePrefData({
         name: 'enableWindowsKey',
         text: $scope.isWindowsKeyEnabled ? 'true' : 'false',
         action: 'enableWindowsKey'
      });
   };

   // Method for toggling MP4 functionality.
   $scope.toggleMP4 = function () {
      $scope.isMP4Enabled = !$scope.isMP4Enabled;

      userGlobalPref.updatePrefData({
         name: 'enableMP4',
         text: $scope.isMP4Enabled ? 'true' : 'false',
         action: 'enableMP4'
      });
   };

   // Method for set timezone automatically functionality.
   $scope.toggleTimezone = function () {
      $scope.isAutoTimezoneEnabled = !$scope.isAutoTimezoneEnabled;
      if (!!$scope.isAutoTimezoneEnabled) {
         // is enable save , need a parameter.
         userGlobalPref.updatePrefData({
            name: 'timezoneSync',
            text: '',
            action: 'timezoneSync'
         });
      }
      $scope.showDefaultTimezone();
   };

   // Save for timezone syncing.
   $scope.saveTimezone = function () {
      var timezoneList = (0, _jquery2.default)("#timezoneList")[0],
          timezone = void 0;
      if ($scope.isAutoTimezoneEnabled) {
         return;
      }

      if (!!timezoneList) {
         timezone = timezoneList.options[timezoneList.selectedIndex].value;
      } else {
         _jscdkLogger2.default.debug('error: cann\'t find timezone list');
      }

      if (!$scope.isAutoTimezoneEnabled && timezone) {
         userGlobalPref.updatePrefData({
            name: 'timezoneSync',
            text: timezone,
            action: 'timezoneSync'
         });
      }
   };

   $scope.onKeypress = function (evt) {
      if (!!evt && evt.keyCode === 32) {
         // Space key is pressed.
         if (evt.target.children && evt.target.children[0]) {
            (0, _jquery2.default)(evt.target.children[0]).trigger('click');
         }
         // Prevent default behavior.
         evt.preventDefault();
      }
   };

   $scope.init();
}

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/Desktop2x.png";

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/attention2x.png";

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/icon-app-202x.png";

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/icon-app-282x.png";

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/shadow-desktop2x.png";

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/spinner-login2x.gif";

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "icons-1/spinner2x.gif";

/***/ }),
/* 256 */
/***/ (function(module, exports) {

var path = 'common/commondialog/dialog_service_cancel_confirm.html';
var html = "<div class=\"dialog-title\">{{ngDialogData.title}}</div>\n<div class=\"dialog-content\">\n   <div class=\"session-ops-window-text\">{{ngDialogData.message}}</div>\n</div>\n<div class=\"dialog-button-row\" dialog-tab-scope>\n   <button class=\"modal-button-base modal-button-right modal-button-grey\" ng-click=\"confirm() || closeThisDialog()\" id=\"okDialogBtn\" dialog-tabindex=\"2\" dialog-prevent-key-up>\n      {{(ngDialogData.buttonLabelConfirm) || ('OK' | i18n)}}\n   </button>\n   <button class=\"modal-button-base modal-button-right modal-button-blue ok-button\" ng-click=\"close() || closeThisDialog()\" id=\"cancelDialogBtn\" dialog-tabindex=\"1\" dialog-prevent-key-up>\n      {{(ngDialogData.buttonLabelCancel) || ('CANCEL' | i18n)}}\n   </button>\n</div>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 257 */,
/* 258 */
/***/ (function(module, exports) {

var path = 'common/timezone/time-zone-list.html';
var html = "<select id=\"timezoneList\" ng-disabled=\"isAutoTimezoneEnabled\" ng-class=\"{disable:isAutoTimezoneEnabled===true}\">\n   <option value=\"Etc/GMT-12\">(UTC -12:00) {{\"Etc/GMT-12\" | i18n}}</option>\n   <option value=\"Etc/GMT-11\">(UTC -11:00) {{\"Etc/GMT-11\" | i18n}}</option>\n   <option value=\"Pacific/Honolulu\">(UTC -10:00) {{\"Pacific/Honolulu\" | i18n}}</option>\n   <option value=\"America/Anchorage\">(UTC -09:00) {{\"America/Anchorage\" | i18n}}</option>\n   <option value=\"America/Tijuana\">(UTC -08:00) {{\"America/Tijuana\" | i18n}}</option>\n   <option value=\"America/Los_Angeles\">(UTC -08:00) {{\"America/Los_Angeles\" | i18n}}</option>\n   <option value=\"America/Chihuahua\">(UTC -07:00) {{\"America/Chihuahua\" | i18n}}</option>\n   <option value=\"America/Denver\">(UTC -07:00) {{\"America/Denver\" | i18n}}</option>\n   <option value=\"America/Phoenix\">(UTC -07:00) {{\"America/Phoenix\" | i18n}}</option>\n   <option value=\"America/Guatemala\">(UTC -06:00) {{\"America/Guatemala\" | i18n}}</option>\n   <option value=\"America/Chicago\">(UTC -06:00) {{\"America/Chicago\" | i18n}}</option>\n   <option value=\"America/Mexico_City\">(UTC -06:00) {{\"America/Mexico_City\" | i18n}}</option>\n   <option value=\"America/Regina\">(UTC -06:00) {{\"America/Regina\" | i18n}}</option>\n   <option value=\"America/Bogota\">(UTC -05:00) {{\"America/Bogota\" | i18n}}</option>\n   <option value=\"America/New_York\">(UTC -05:00) {{\"America/New_York\" | i18n}}</option>\n   <option value=\"America/Indiana/Indianapolis\">(UTC -05:00) {{\"America/Indiana/Indianapolis\" | i18n}}</option>\n   <option value=\"America/Caracas\">(UTC -04:00) {{\"America/Caracas\" | i18n}}</option>\n   <option value=\"America/Cuiaba\">(UTC -04:00) {{\"America/Cuiaba\" | i18n}}</option>\n   <option value=\"America/La_Paz\">(UTC -04:00) {{\"America/La_Paz\" | i18n}}</option>\n   <option value=\"America/Santiago\">(UTC -04:00) {{\"America/Santiago\" | i18n}}</option>\n   <option value=\"America/Asuncion\">(UTC -04:00) {{\"America/Asuncion\" | i18n}}</option>\n   <option value=\"America/Halifax\">(UTC -04:00) {{\"America/Halifax\" | i18n}}</option>\n   <option value=\"America/St_Johns\">(UTC -03:30) {{\"America/St_Johns\" | i18n}}</option>\n   <option value=\"America/Montevideo\">(UTC -03:00) {{\"America/Montevideo\" | i18n}}</option>\n   <option value=\"America/Buenos_Aires\">(UTC -03:00) {{\"America/Buenos_Aires\" | i18n}}</option>\n   <option value=\"America/Cayenne\">(UTC -03:00) {{\"America/Cayenne\" | i18n}}</option>\n   <option value=\"America/Godthab\">(UTC -03:00) {{\"America/Godthab\" | i18n}}</option>\n   <option value=\"America/Sao_Paulo\">(UTC -03:00) {{\"America/Sao_Paulo\" | i18n}}</option>\n   <option value=\"America/Noronha\">(UTC -02:00) {{\"Etc/GMT+2\" | i18n}}</option>\n   <option value=\"Atlantic/Azores\">(UTC -01:00) {{\"Atlantic/Azores\" | i18n}}</option>\n   <option value=\"Atlantic/Cape_Verde\">(UTC -01:00) {{\"Atlantic/Cape_Verde\" | i18n}}</option>\n   <option value=\"DMT\">(UTC) {{\"DMT\" | i18n}}</option>\n   <option value=\"Africa/Casablanca\">(UTC +00:00) {{\"Africa/Casablanca\" | i18n}}</option>\n   <option value=\"Europe/London\">(UTC +00:00) {{\"Europe/London\" | i18n}}</option>\n   <option value=\"Atlantic/Reykjavik\">(UTC +00:00) {{\"Atlantic/Reykjavik\" | i18n}}</option>\n   <option value=\"Europe/Berlin\">(UTC +01:00) {{\"Europe/Berlin\" | i18n}}</option>\n   <option value=\"Europe/Budapest\">(UTC +01:00) {{\"Europe/Budapest\" | i18n}}</option>\n   <option value=\"Europe/Paris\">(UTC +01:00) {{\"Europe/Paris\" | i18n}}</option>\n   <option value=\"Europe/Warsaw\">(UTC +01:00) {{\"Europe/Warsaw\" | i18n}}</option>\n   <option value=\"Africa/Lagos\">(UTC +01:00) {{\"Africa/Lagos\" | i18n}}</option>\n   <option value=\"Africa/Windhoek\">(UTC +01:00) {{\"Africa/Windhoek\" | i18n}}</option>\n   <option value=\"Asia/Amman\">(UTC +02:00) {{\"Asia/Amman\" | i18n}}</option>\n   <option value=\"Europe/Athens\">(UTC +02:00) {{\"Europe/Athens\" | i18n}}</option>\n   <option value=\"Asia/Beirut\">(UTC +02:00) {{\"Asia/Beirut\" | i18n}}</option>\n   <option value=\"Africa/Cairo\">(UTC +02:00) {{\"Africa/Cairo\" | i18n}}</option>\n   <option value=\"Asia/Damascus\">(UTC +02:00) {{\"Asia/Damascus\" | i18n}}</option>\n   <option value=\"Africa/Johannesburg\">(UTC +02:00) {{\"Africa/Johannesburg\" | i18n}}</option>\n   <option value=\"Europe/Kiev\">(UTC +02:00) {{\"Europe/Kiev\" | i18n}}</option>\n   <option value=\"Asia/Jerusalem\">(UTC +02:00) {{\"Asia/Jerusalem\" | i18n}}</option>\n   <option value=\"STAT\">(UTC +03:00) {{\"Europe/Minsk\" | i18n}}</option>\n   <option value=\"Europe/Istanbul\">(UTC +03:00) {{\"Europe/Istanbul\" | i18n}}</option>\n   <option value=\"Asia/Baghdad\">(UTC +03:00) {{\"Asia/Baghdad\" | i18n}}</option>\n   <option value=\"Asia/Riyadh\">(UTC +03:00) {{\"Asia/Riyadh\" | i18n}}</option>\n   <option value=\"Europe/Moscow\">(UTC +03:00) {{\"Europe/Moscow\" | i18n}}</option>\n   <option value=\"Africa/Nairobi\">(UTC +03:00) {{\"Africa/Nairobi\" | i18n}}</option>\n   <option value=\"Asia/Tehran\">(UTC +03:30) {{\"Asia/Tehran\" | i18n}}</option>\n   <option value=\"Asia/Dubai\">(UTC +04:00) {{\"Asia/Dubai\" | i18n}}</option>\n   <option value=\"Asia/Baku\">(UTC +04:00) {{\"Asia/Baku\" | i18n}}</option>\n   <option value=\"Indian/Mauritius\">(UTC +04:00) {{\"Indian/Mauritius\" | i18n}}</option>\n   <option value=\"Asia/Tbilisi\">(UTC +04:00) {{\"Asia/Tbilisi\" | i18n}}</option>\n   <option value=\"Asia/Yerevan\">(UTC +04:00) {{\"Asia/Yerevan\" | i18n}}</option>\n   <option value=\"Asia/Kabul\">(UTC +04:30) {{\"Asia/Kabul\" | i18n}}</option>\n   <option value=\"Asia/Yekaterinburg\">(UTC +05:00) {{\"Asia/Yekaterinburg\" | i18n}}</option>\n   <option value=\"Asia/Karachi\">(UTC +05:00) {{\"Asia/Karachi\" | i18n}}</option>\n   <option value=\"Asia/Tashkent\">(UTC +05:00) {{\"Asia/Tashkent\" | i18n}}</option>\n   <option value=\"Asia/Calcutta\">(UTC +05:30) {{\"Asia/Calcutta\" | i18n}}</option>\n   <option value=\"Asia/Colombo\">(UTC +05:30) {{\"Asia/Colombo\" | i18n}}</option>\n   <option value=\"Asia/Katmandu\">(UTC +05:45) {{\"Asia/Katmandu\" | i18n}}</option>\n   <option value=\"Asia/Almaty\">(UTC +06:00) {{\"Asia/Almaty\" | i18n}}</option>\n   <option value=\"Asia/Dhaka\">(UTC +06:00) {{\"Asia/Dhaka\" | i18n}}</option>\n   <option value=\"Asia/Novosibirsk\">(UTC +06:00) {{\"Asia/Novosibirsk\" | i18n}}</option>\n   <option value=\"Asia/Rangoon\">(UTC +06:30) {{\"Asia/Rangoon\" | i18n}}</option>\n   <option value=\"Asia/Bangkok\">(UTC +07:00) {{\"Asia/Bangkok\" | i18n}}</option>\n   <option value=\"Asia/Krasnoyarsk\">(UTC +07:00) {{\"Asia/Krasnoyarsk\" | i18n}}</option>\n   <option value=\"Asia/Shanghai\">(UTC +08:00) {{\"Asia/Shanghai\" | i18n}}</option>\n   <option value=\"Asia/Irkutsk\">(UTC +08:00) {{\"Asia/Irkutsk\" | i18n}}</option>\n   <option value=\"Asia/Singapore\">(UTC +08:00) {{\"Asia/Singapore\" | i18n}}</option>\n   <option value=\"Australia/Perth\">(UTC +08:00) {{\"Australia/Perth\" | i18n}}</option>\n   <option value=\"Asia/Taipei\">(UTC +08:00) {{\"Asia/Taipei\" | i18n}}</option>\n   <option value=\"Asia/Ulaanbaatar\">(UTC +08:00) {{\"Asia/Ulaanbaatar\" | i18n}}</option>\n   <option value=\"Asia/Tokyo\">(UTC +09:00) {{\"Asia/Tokyo\" | i18n}}</option>\n   <option value=\"Asia/Seoul\">(UTC +09:00) {{\"Asia/Seoul\" | i18n}}</option>\n   <option value=\"Asia/Yakutsk\">(UTC +09:00) {{\"Asia/Yakutsk\" | i18n}}</option>\n   <option value=\"Australia/Adelaide\">(UTC +09:30) {{\"Australia/Adelaide\" | i18n}}</option>\n   <option value=\"Australia/Darwin\">(UTC +09:30) {{\"Australia/Darwin\" | i18n}}</option>\n   <option value=\"Australia/Brisbane\">(UTC +10:00) {{\"Australia/Brisbane\" | i18n}}</option>\n   <option value=\"Australia/Sydney\">(UTC +10:00) {{\"Australia/Sydney\" | i18n}}</option>\n   <option value=\"Pacific/Port_Moresby\">(UTC +10:00) {{\"Pacific/Port_Moresby\" | i18n}}</option>\n   <option value=\"Australia/Hobart\">(UTC +10:00) {{\"Australia/Hobart\" | i18n}}</option>\n   <option value=\"Asia/Vladivostok\">(UTC +10:00) {{\"Asia/Vladivostok\" | i18n}}</option>\n   <option value=\"Australia/Lord_Howe\">(UTC +11:00) {{\"Australia/Lord_Howe\" | i18n}}</option>\n   <option value=\"Etc/GMT+11\">(UTC +11:00) {{\"Asia/Magadan\" | i18n}}</option>\n   <option value=\"PONT\">(UTC +11:00) {{\"Pacific/Guadalcanal\" | i18n}}</option>\n   <option value=\"Pacific/Auckland\">(UTC +12:00) {{\"Pacific/Auckland\" | i18n}}</option>\n   <option value=\"Etc/GMT+12\">(UTC +12:00) {{\"Etc/GMT+12\" | i18n}}</option>\n   <option value=\"Pacific/Fiji\">(UTC +12:00) {{\"Pacific/Fiji\" | i18n}}</option>\n   <option value=\"Asia/Kamchatka\">(UTC +12:00) {{\"Asia/Kamchatka\" | i18n}}</option>\n   <option value=\"Tonga\">(UTC +13:00) {{\"Pacific/Tongatapu\" | i18n}}</option>\n</select>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 259 */
/***/ (function(module, exports) {

var path = 'desktop/clipboard/clipboard_template.html';
var html = "<div class='base-panel clipboard-panel ng-hide' ng-click=\"focusInput()\" ng-controller='clipboardController' ng-show=\"showClipboardPanel\">\n\n   <div ng-class=\"{'clipboard-focused': focused, 'clipboard-unfocused': !focused}\">\n      <div class=\"clipboard-header clipboard-handle\">\n         <div class=\"clipboard-label unselectable\">{{'COPY_PASTE' | i18n}}</div>\n         <div class=\"clipboard-icon close\" ng-click=\"toggleClipboardPanel($event)\" title=\"{{'CLOSE_CLIPBOARD_T' | i18n}}\"></div>\n         <div class=\"clipboard-icon minimize\" ng-if=\"showClipboardText\" ng-click=\"toggleClipboardText()\" title=\"{{'MINIMIZE_CLIPBOARD_T' | i18n}}\"></div>\n         <div class=\"clipboard-icon restore\" ng-if=\"!showClipboardText\" ng-click=\"toggleClipboardText()\" title=\"{{'RESTORE_CLIPBOARD_T' | i18n}}\"></div>\n         <div class=\"clipboard-icon help\" ng-click=\"openClipboardHelp()\" title=\"{{'CLIPBOARD_HELP_T' | i18n}}\"></div>\n      </div>\n      <div class=\"clipboard-input-container\">\n         <label for=\"clipboard-input\">clipboard-input</label>\n         <clipboard-input id=\"clipboard-input\" ng-copy=\"clipboardCopy($event)\" ng-paste=\"clipboardPaste($event)\" ng-focus=\"clipboardFocus()\" ng-blur=\"clipboardBlur()\"></clipboard-input>\n      </div>\n      <div class='clipboard-content' ng-focus=\"focusInput()\" ng-show=\"showClipboardText\">\n         <div class=\"clipboard-area clipboard-handle unselectable\" ng-class=\"{'inactive': !hasClipboardData, 'focused': hasClipboardData && focused}\" ng-show=\"showClipboardText\">\n            <span id=\"clipboard-text-element\" ng-if=\"hasClipboardData\" class=\"text-display\">{{clipboard.text}}</span>\n            <span id=\"clipboard-policy-text-element\" ng-if=\"!hasClipboardData\" class=\"text-display\">{{clipboardPolicy.text}}</span>\n         </div>\n      </div>\n      <div class=\"clipboard-footer clipboard-handle\">\n         <span class=\"clipboard-clear\" ng-click=\"clipboardClear()\" ng-show=\"hasClipboardData && showClipboardText\">{{'CLEAR_CLIPBOARD_T' | i18n}}</span>\n      </div>\n   </div>\n\n   <panel-notification></panel-notification>\n</div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 260 */
/***/ (function(module, exports) {

var path = 'desktop/common/desktop.html';
var html = "<div id=\"desktop-controller-place-holder\"></div>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 261 */
/***/ (function(module, exports) {

var path = 'desktop/filetransfer/file_transfer_template.html';
var html = "<div class='base-panel file-transfer-panel ng-hide' ng-controller='fileTransferController' ng-click=\"focusInput()\" ng-show=\"showFileTransferPanel\">\n   <div file-drop=\"uploadHandler(event)\" ng-class=\"{'file-transfer-focused': focused, 'file-transfer-unfocused': !focused}\">\n      <div class=\"file-transfer-header file-transfer-handle\">\n         <div class=\"file-transfer-title\" >{{'FILE_TRANSFER_TITLE' | i18n}}</div>\n         <div class=\"file-transfer-icon close\" ng-click=\"toggleFileTransferPanel($event)\" title=\"{{'CLOSE_FT_T' | i18n}}\"></div>\n         <div class=\"file-transfer-icon help\" ng-click=\"openFileTransferHelp()\" title=\"{{'FT_HELP_T' | i18n}}\"></div>\n      </div>\n      <div class=\"file-transfer-input-container\">\n         <label for=\"file-transfer-input-container\">file-transfer-container</label>\n         <file-transfer-input id=\"file-transfer-input-container\" ng-focus=\"ftPanelFocus()\" ng-blur=\"ftPanelBlur()\"></file-transfer-input>\n      </div>\n      <div class=\"file-content\">\n         <div class=\"file-area\">\n            <div class=\"file-area-header\">\n               <div ng-if=\"downloadEnabled\" class=\"file-transfer-tab download-tab\" ng-click=\"switchFileTab(PANEL_TAB.DOWNLOAD)\" ng-class=\"{'active': showFileDownload}\">{{'FILE_DOWNLOAD' | i18n}}</div>\n               <div ng-if=\"uploadEnabled\" class=\"file-transfer-tab upload-tab\" ng-click=\"switchFileTab(PANEL_TAB.UPLOAD)\" ng-class=\"{'active': showFileUpload}\">{{'FILE_UPLOAD' | i18n}}</div>\n            </div>\n            <div ng-if=\"downloadEnabled\" ng-show=\"showFileDownload\" class=\"unselectable file-list-container\">\n               <ul id=\"ft-download-list\" class=\"file-content-list\" ng-show=\"downloadFiles.length != 0\">\n                  <li class=\"file-item\" ng-repeat=\"file in downloadFiles\">\n                     <span class=\"file-name\">{{file.relPath}}</span>\n                     <span class=\"readable-file-size\">{{'- ' + file.readableSize}}</span>\n                     <span ng-if=\"file.transferError == false\" ng-style=\"{'width': file.progress + '%'}\" class=\"transfer-progress\" ng-class=\"{'transfer-done': file.progress == 100}\"></span>\n                     <span ng-if=\"file.transferError == true\" class=\"transfer-progress transfer-error\"></span>\n                     <span ng-if=\"file.stopTransfer == true\" class=\"transfer-progress transfer-stop\"><div class=\"file-transfer-file-icon stopped-transfer\"></div></span>\n                     <div ng-if=\"file.transferError == true\" title=\"{{'FT_FAILED_HINT' | i18n}}\" class=\"file-transfer-file-icon transfer-error\"></div>\n                     <div ng-if=\"file.progress == 100\" ng-click=\"saveFile(file)\" class=\"file-transfer-file-icon save-file\"></div>\n                     <div ng-if=\"file.transferError == false && file.stopTransfer == false && file.progress < 100\" ng-click=\"stopFileDownload(file)\" class=\"file-transfer-file-icon cancel-upload\"></div>\n                  </li>\n               </ul>\n               <div id=\"ft-download-step-hint\" class=\"hint-container file-transfer-handle\" ng-show=\"downloadFiles.length == 0 && downloadEnabled == true\">\n                  <p class=\"hint-title\">{{'FT_DOWNLOAD_HINT_TITLE' | i18n}}</p>\n                  <div class=\"hint-step-container\">\n                     <p>{{'FT_DOWNLOAD_HINT1' | i18n}}</p>\n                     <p>{{'FT_DOWNLOAD_HINT2' | i18n : modKey }}</p>\n                     <p>{{'FT_DOWNLOAD_HINT3.1' | i18n}}<span class=\"file-transfer-hint-icon save-file\"></span>{{'FT_DOWNLOAD_HINT3.2' | i18n}}</p>\n                  </div>\n               </div>\n               <div id=\"ft-download-disable-hint\" class=\"hint-container file-transfer-handle\" ng-show=\"downloadEnabled == false\">\n                  <p class=\"hint-disable-title\">{{'FT_DOWNLOAD_DISABLE_HINT_TITLE' | i18n}}</p>\n               </div>\n            </div>\n            <div ng-if=\"uploadEnabled\" ng-show=\"showFileUpload\" class=\"unselectable file-list-container\">\n               <ul id=\"ft-upload-list\" class=\"file-content-list\" ng-show=\"uploadFiles.length != 0\">\n                  <li ng-repeat=\"file in uploadFiles\" class=\"file-item\">\n                     <span class=\"file-name\">{{file.relPath}}</span>\n                     <span class=\"readable-file-size\">{{'- ' + file.readableSize}}</span>\n                     <span ng-if=\"file.transferError == false\" ng-style=\"{'width': file.progress + '%'}\" class=\"transfer-progress\" ng-class=\"{'transfer-done': file.progress == 100}\"></span>\n                     <span ng-if=\"file.transferError == true\" class=\"transfer-progress transfer-error\"></span>\n                     <span ng-if=\"file.stopTransfer == true\" class=\"transfer-progress transfer-stop\"><div class=\"file-transfer-file-icon stopped-transfer\"></div></span>\n                     <div ng-if=\"file.transferError == true\" title=\"{{'FT_FAILED_HINT' | i18n}}\" class=\"file-transfer-file-icon transfer-error\"></div>\n                     <div ng-if=\"file.transferError == false && file.stopTransfer == false && file.progress < 100\" ng-click=\"stopFileUpload(file)\" class=\"file-transfer-file-icon cancel-upload\"></div>\n                  </li>\n                  <div class=\"btn-hint-container\">\n                     <button ng-show=\"uploadFiles.length != 0\" onclick=\"chooseUploadFiles()\" class=\"choose-files-button\">{{'FT_CHOOSE_FILES_BTN2' | i18n}}</button>\n                  </div>\n               </ul>\n               <div id=\"ft-upload-step-hint\" class=\"hint-container file-transfer-handle\" ng-show=\"uploadFiles.length == 0 && uploadEnabled == true\">\n                  <p class=\"hint-title\">{{'FT_UPLOAD_HINT_TITLE' | i18n}}</p>\n                  <form>\n                     <label for=\"upload-file-input\">upload-file-input</label>\n                     <input type=\"file\" multiple=\"multiple\" id=\"upload-file-input\" class=\"upload-file-input\" file-change=\"uploadHandler(event)\"/>\n                  </form>\n                  <div class=\"hint-step-container\">\n                     <p>{{'FT_UPLOAD_HINT1' | i18n}}</p>\n                     <p>{{'FT_UPLOAD_HINT2' | i18n}}</p>\n                     <p>{{'FT_UPLOAD_HINT3' | i18n}}</p>\n                  </div>\n                  <button onclick=\"chooseUploadFiles()\" class=\"choose-files-button\">{{'FT_CHOOSE_FILES_BTN' | i18n}}</button>\n               </div>\n               <div id=\"ft-upload-disable-hint\" class=\"hint-container file-transfer-handle\" ng-show=\"uploadEnabled == false\">\n                  <p class=\"hint-disable-title\">{{'FT_UPLOAD_DISABLE_HINT_TITLE' | i18n}}</p>\n               </div>\n            </div>\n         </div>\n      </div>\n      <div class=\"file-transfer-footer file-transfer-handle\">\n         <span id=\"ft-clear-upload-list-btn\" class=\"file-transfer-clear\" ng-show=\"showFileUpload\" ng-click=\"clearUploadList()\">{{'CLEAR_LIST' | i18n}}</span>\n         <span id=\"ft-clear-download-list-btn\" class=\"file-transfer-clear\" ng-show=\"showFileDownload\" ng-click=\"clearDownloadList()\">{{'CLEAR_LIST' | i18n}}</span>\n      </div>\n   </div>\n\n   <panel-notification></panel-notification>\n</div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 262 */,
/* 263 */
/***/ (function(module, exports) {

var path = 'desktop/multimon/multimon-setting-window/multimon_setting_window_template.html';
var html = "<scrollable-dialog>\n   <div class=\"dialog-title\">{{'MULTIMON' | i18n}}</div>\n\n   <div class=\"dialog-content\" fuzzy-free>\n      <div class=\"about-dialog-content selectable\">\n         {{ 'MM_INTRODUCTION_ADD' | i18n }}\n      </div>\n\n      <div class=\"settings-container\">\n         <div id=\"add-monitor-detector-btn\" class=\"modal-button-base modal-button-blue modal-button-add-display\" ng-class=\"{'disable' : !addButtonEnabled}\" ng-click=\"addButtonEnabled && addMonitor()\" title=\"{{'MM_ADD_MONITOR_T' | i18n}}\">{{'MM_ADD' | i18n}}</div>\n      </div>\n\n      <div class=\"about-dialog-content selectable\">\n         <canvas id=\"topology-preview-canvas\" width=\"380\" height=\"220\" class=\"multimon-preview\"></canvas>\n      </div>\n   </div>\n\n   <div class=\"dialog-button-row\">\n      <div id=\"multimon-setting-cancel\" class=\"modal-button-base modal-button-right modal-button-blue\" ng-click=\"multimonCancelClicked()\">\n         {{'CANCEL' | i18n}}\n      </div>\n      <div id=\"multimon-setting-ok\" class=\"modal-button-base modal-button-right modal-button-blue no-disable-hover\" ng-class=\"{'disable' : !startConfiguring || hasConflictedDetector || !allReady}\" ng-click=\"multimonOkClicked()\">\n         {{ 'OK' | i18n }}\n      </div>\n   </div>\n</scrollable-dialog>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 264 */
/***/ (function(module, exports) {

var path = 'desktop/re-auth/dialog_service_reauth.html';
var html = "<div class=\"ui-center-panel desktop-reauth\" >\n    <div class=\"ui-pattern-logo\"></div>\n    <div ng-controller=\"reAuthCtrl\" class=\"ui-widget-home\" ng-if=\"!$root.reWindowsPasswordExpired\">\n        <div class=\"ui-panel-content \">\n           <div class=\"alert alert-danger\">\n              <span class=\"error\" ng-if=\"error\"></span>{{error}}\n           </div>\n           <form id=\"loginForm\" name=\"loginForm\" role=\"form\" class=\"form-horizontal\" method=\"post\" autocomplete=\"off\" novalidate>\n              <input id=\"username\" name=\"username\" type=\"text\" class=\"form-control\" placeholder=\"{{'dialog_placeholder_username' | i18n}}\" ng-model=\"credential.username\" ng-keypress=\"keyPress($event, loginForm, true)\" ng-trim=\"false\" ng-disabled=\"userNameReadOnly\" required view-autofocus=\"{{!userNameReadOnly}}\">\n              <input id=\"password\" name=\"password\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_password' | i18n}}\" ng-model=\"credential.password\" ng-keypress=\"keyPress($event, loginForm, true)\" ng-trim=\"false\" view-autofocus=\"{{userNameReadOnly}}\">\n              <select id=\"domain\" name=\"domain\" class=\"form-control form-select\" ng-model=\"credential.domain\" ng-keypress=\"keyPress($event, loginForm, true)\"  ng-disabled=\"domainReadOnly\" ng-options=\"domain for domain in domains\" domain-select-menu>\n              </select>\n           </form>\n        </div>\n        <div class=\"ui-panel-footer\">\n           <button id=\"loginButton\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy && loadingAllow}\" ng-click=\"login(loginForm,true)\" ng-disabled=\"(ajaxBusy && loadingAllow) || !loginForm.$valid\">{{ (ajaxBusy && loadingAllow) ? 'dialog_btn_signin_waiting' : 'dialog_btn_signin' | i18n}}<progress-circle></progress-circle></button>\n           <button id=\"cancelLoginBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\" >{{'dialog_quit_cancel' | i18n}}</button>\n        </div>\n    </div>\n    <div ng-controller=\"reAuthChangePasswordCtrl\" class=\"ui-widget-home\" ng-if=\"$root.reWindowsPasswordExpired\">\n        <div class=\"ui-panel-content\">\n            <div ng-if=\"!error\" class=\"ui-login-hint-text\">{{'dialog_prompt_changepwd' | i18n}}</div>\n            <div class=\"alert alert-danger\" ng-if=\"error\">\n                <span class=\"error\"></span>{{error}}\n            </div>\n            <form id=\"changePasswordForm\" name=\"changePasswordForm\" role=\"form\" class=\"change-password-form form-horizontal\" method=\"post\" autocomplete=\"off\" novalidate>\n                <input id=\"username\" name=\"username\" type=\"text\" class=\"form-control\" placeholder=\"{{'dialog_placeholder_username' | i18n}}\" ng-model=\"username\" readonly>\n\n                <input id=\"oldpassword\" name=\"oldpassword\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_oldpwd' | i18n}}\" ng-model=\"credential.oldpassword\" ng-keypress=\"keyPress($event, changePasswordForm)\" ng-trim=\"false\" view-autofocus=\"true\">\n\n\n                <input id=\"newpassword1\" name=\"newpassword1\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_newpwd' | i18n}}\" ng-model=\"credential.newpassword\" ng-keypress=\"keyPress($event, changePasswordForm)\" equal-to=\"{{credential.newpasswordRepeat}}\" ng-trim=\"false\">\n\n                <div class=\"ui-text-left-align\">\n                    <input id=\"newpassword2\" name=\"newpassword2\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_newpwd2' | i18n}}\" ng-model=\"credential.newpasswordRepeat\" ng-keypress=\"keyPress($event, changePasswordForm)\" equal-to=\"{{credential.newpassword}}\" ng-trim=\"false\">\n                    <label for=\"newpassword2\" class=\"ui-password-dismatch-text\" ng-show=\"!changePasswordForm.$valid\">{{'validation_equals' | i18n}}</label>\n                </div>\n            </form>\n        </div>\n        <div class=\"ui-panel-footer\">\n            <button id=\"changePasswordSubmitBtn\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy&& loadingAllow}\" ng-click=\"changePassword(changePasswordForm)\" ng-disabled=\"ajaxBusy&& loadingAllow\">{{ (ajaxBusy && loadingAllow) ? 'dialog_btn_signin_waiting' : 'dialog_btn_signin' | i18n}}<progress-circle></progress-circle></button>\n            <button id=\"changePasswordCancelBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\">{{'dialog_quit_cancel' | i18n}}</button>\n        </div>\n    </div>\n</div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 265 */
/***/ (function(module, exports) {

var path = 'desktop/setting-dialog/settings_window_template.html';
var html = "<scrollable-dialog>\n   <div class=\"dialog-title\">{{'SETTINGS' | i18n}}</div>\n\n   <div class=\"dialog-content\" fuzzy-free>\n      <div ng-repeat=\"switch in toggleSwitches\" ng-if=\"switch.isSupported\">\n         <div class=\"settings-container\">\n            <div class=\"settings-toggle-container\">\n               <div class=\"settings-switch-label\">{{'OFF_CAPS_M' | i18n}}</div>\n               <div class=\"toggle-opt\">\n                  <input class=\"tgl tgl-light\" id=\"{{switch.id}}\" type=\"checkbox\" ng-show=\"false\" ng-model=\"switch.isEnabled\" ng-change=\"switch.toggle()\">\n                  <label class=\"tgl-btn unselectable\" for=\"{{switch.id}}\"></label>\n               </div>\n               <div class=\"settings-switch-label\">{{'ON_CAPS_M' | i18n}}</div>\n            </div>\n            <span class=\"settings-label\">{{switch.label}}</span>\n            <span class=\"settings-text\" ng-show=\"{{!!switch.text}}\">{{switch.text}}</span>\n         </div>\n         <div class=\"settings-separator\" ng-show='switch.isSupported'></div>\n      </div>\n\n      <div class=\"settings-container\">\n         <div class=\"modal-button-base modal-button-blue modal-button-reset\" ng-class=\"{'disable' : !resetButtonEnabled}\" ng-click=\"resetButtonEnabled && resetApplications()\" title=\"{{'RESET_APPS_T' | i18n}}\">{{'RESET_M' | i18n}}</div>\n         <span class=\"settings-label\">{{'RESET_APPS_M' | i18n}}</span>\n         <span class=\"settings-text warning\">{{'UNSAVED_WORK_M' | i18n}}</span>\n      </div>\n   </div>\n\n   <div class=\"dialog-button-row\">\n      <div class=\"modal-button-base modal-button-right modal-button-blue\" ng-click=\"closeThisDialog()\">\n         {{'CLOSE' | i18n}}\n      </div>\n   </div>\n</scrollable-dialog>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

var path = 'desktop/sidebar/sidebar_template.html';
var html = "<div id=\"sidebar\" class=\"sidebar-panel unselectable ng-hide\" ng-show=\"showPanel\">\n   <div class=\"head-panel\">\n      <div class=\"color-bar\"></div>\n      <div>\n         <div class=\"horizon-logo-image\" title=\"{{'ABOUT_T' | i18n}}\" ng-click=\"aboutClicked()\"></div>\n         <div class=\"head-panel-button-bar\">\n            <ul>\n               <li id=\"keyboard\"\n                   class=\"icon-button icon-keyboard-image\"\n                   ng-show=\"isSupportedMobileDevice()\"\n                   ng-click=\"toggleKeyboard()\"\n                   title=\"{{'TOGGLE_KEYBOARD' | i18n}}\"></li>\n               <li id=\"cad\"\n                   class=\"icon-button icon-cad-image icon-button-hover\"\n                   ng-class=\"{'disable': runningItems.length === 0}\"\n                   ng-click=\"runningItems.length !== 0 && ctrlAltDeleteClicked()\"\n                   title=\"{{'CTRL_ALT_DEL' | i18n}}\"></li>\n               <li id=\"fileTransfer\"\n                   class=\"icon-button icon-file-transfer-image icon-button-hover\"\n                   ng-hide=\"isTouchDevice()\"\n                   ng-class=\"{'disable': isCurrentItemApp === true || isRunningDesktopExist() === false || $root.disableFTPanel}\"\n                   ng-click=\"isCurrentItemApp !== true && isRunningDesktopExist() === true && !$root.disableFTPanel && openFileTransferPanel()\"\n                   title=\"{{(isCurrentItemApp === true ? 'DISABLE_FT_FOR_APP' : ($root.disableFTPanel ? 'DISABLE_FT_PANEL' : 'OPEN_FILE_TRANSFER')) | i18n}}\"></li>\n               <li id=\"clipboard\"\n                   class=\"icon-button icon-clipboard-image icon-button-hover\" ng-click=\"openClipboardClicked()\" title=\"{{'OPEN_COPY_PASTE_T' | i18n}}\"\n                   ng-hide=\"isTouchDevice()\"></li>\n               <li id=\"contextMenu\"\n                   class=\"icon-button icon-context-menu-image icon-button-hover\" ng-click=\"globalContextMenuClicked($event)\" title=\"{{'OPEN_MENU_T' | i18n}}\"></li>\n            </ul>\n         </div>\n      </div>\n      <div class=\"search-panel\">\n         <div class=\"search-icon\"></div>\n         <label for=\"search-input\">{{'SEARCH_PH_M' | i18n}}</label>\n         <input id=\"search-input\" class=\"search-input\" ng-model=\"queryText.name\" type=\"search\" placeholder=\"{{'SEARCH_PH_M' | i18n}}\"/>\n      </div>\n      <div class=\"separator\"></div>\n   </div>\n   <div class=\"apps-panel\">\n      <div class=\"running-title-panel\">\n         <div class=\"running-title\">{{'RUNNING_T' | i18n}}</div>\n      </div>\n      <div ng-show=\"!runningItems || runningItems.length === 0\" class=\"no-items-label\">{{'NO_RUNNING_ITEMS_T' | i18n}}</div>\n      <div class=\"running-content-panel\">\n         <div ng-repeat=\"runningItem in runningItems | runningItemsFilter : queryText.name\">\n         <ul class=\"running-app\">\n            <ul class=\"icon-and-name-container\" ng-click=\"activateItem(runningItem)\" title=\"{{'BRING_ITEM_TO_FRONT_T' | i18n : runningItem.name}}\">\n               <li ng-class=\"{'running-app-border': !appHasFocus(runningItem), 'focused-app-border': appHasFocus(runningItem)}\">\n                  <img alt=\"{{runningItem.name}} icon\" ng-class=\"{'running-app-icon': !appHasFocus(runningItem), 'focused-app-icon': appHasFocus(runningItem), 'nonready' : !util.isConnected(runningItem)}\" ng-src=\"{{runningItem.iconSrc}}\" ng-show=\"!util.isDesktop(runningItem)\"/>\n                  <img alt=\"{{runningItem.name}} icon\" ng-class=\"{'running-app-icon': !appHasFocus(runningItem), 'focused-app-icon': appHasFocus(runningItem), 'nonready' : !util.isConnected(runningItem)}\"  src=\"" + __webpack_require__(57) + "\" ng-show=\"util.isDesktop(runningItem) && !runningItem.isShadow\"/>\n                  <img alt=\"{{runningItem.name}} icon\" ng-class=\"{'running-app-icon': !appHasFocus(runningItem), 'focused-app-icon': appHasFocus(runningItem), 'nonready' : !util.isConnected(runningItem)}\"  src=\"" + __webpack_require__(58) + "\" ng-show=\"util.isDesktop(runningItem) && runningItem.isShadow\"/>\n                  <div class=\"running-item-overlay loading\" ng-show=\"util.isConnecting(runningItem)\"></div>\n                  <div class=\"running-item-overlay attention\" ng-show=\"util.isDisconnected(runningItem)\"></div>\n               </li>\n               <li ng-class=\"{'focused-app-name': appHasFocus(runningItem), 'running-app-name': true}\">\n                  {{runningItem.name}}\n               </li>\n            </ul>\n            <li class=\"running-app-window-count-container\" ng-show=\"!util.isDesktop(runningItem) && runningItem.instances.length > 0 && (!queryText || queryText.name ==='')\">\n               <div class=\"running-app-window-count\" ng-click=\"toggleIsCollapsed(runningItem)\">\n                  <div ng-if=\"runningItem.isCollapsed && runningItem.instances.length > 1\" title=\"{{'CLICK_EXPAND_T' | i18n}}\">{{runningItem.instances.length}}</div>\n                  <div ng-if=\"runningItem.isCollapsed && runningItem.instances.length === 1\" class=\"icon-up-arrow-image vertical-flip\" title=\"{{'CLICK_EXPAND_T' | i18n}}\"></div>\n                  <div ng-if=\"!runningItem.isCollapsed\" class=\"icon-up-arrow-image\" title=\"{{'CLICK_COLLAPSE_T' | i18n}}\"></div>\n               </div>\n            </li>\n            <li ng-show=\"util.isDesktop(runningItem)\" class=\"icon-button icon-context-menu-image running-app-context-menu\" ng-click=\"contextMenuClicked(runningItem, $event)\" title=\"{{'OPEN_MENU_T' | i18n}}\" id=\"{{runningItem.name}}-contextMenu\"></li>\n            <li ng-show=\"util.isApp(runningItem)\" class=\"icon-button icon-close-app-image running-app-context-menu\" ng-click=\"closeRunningApp(runningItem)\" title=\"{{'CLOSE' | i18n}}\"></li>\n            <li class=\"running-session-rtav-containner\">\n            <div id=\"rtav-using-microphone-icon\" ng-show=\"util.isUsingMicrophone(runningItem)\" class=\"running-session-using-rtav microphone\" ng-class=\"{'blocked': util.isAskingMicrophone(runningItem)}\" title=\"{{(util.isAskingMicrophone(runningItem) === true? 'ASKING_MICROPHONE' : 'USING_MICROPHONE') | i18n}}\"></div>\n            <div id=\"rtav-using-webcam-icon\" ng-show=\"util.isUsingWebcam(runningItem)\" class=\"running-session-using-rtav webcam\" ng-class=\"{'blocked': util.isAskingWebcam(runningItem)}\" title=\"{{(util.isAskingWebcam(runningItem) === true? 'ASKING_WEBCAM' : 'USING_WEBCAM') | i18n}}\"></div>\n            </li>\n         </ul>\n         <ul class=\"running-window-list\" ng-show=\"!runningItem.isCollapsed || (queryText && queryText.name !== '')\">\n            <li ng-repeat=\"instance in runningItem.queryInstances | orderBy:'name'\" class=\"running-window\">\n               <ul>\n                  <ul class=\"icon-and-name-container\" ng-click=\"activateWindow(instance)\" title=\"{{'BRING_ITEM_TO_FRONT_T' | i18n : instance.name}}\">\n                     <li ng-class=\"{'running-window-border': !unityWindowHasFocused(runningItem, instance), 'focused-window-border': unityWindowHasFocused(runningItem, instance)}\">\n                        <img alt=\"{{instance.name}} icon\" ng-class=\"{'running-window-icon': !unityWindowHasFocused(runningItem, instance), 'focused-window-icon': unityWindowHasFocused(runningItem, instance), 'nonready': !util.isConnected(instance)}\" ng-src=\"{{instance.iconSrc}}\"/>\n                        <div class=\"running-window-overlay loading\" ng-show=\"util.isConnecting(runningItem)\"></div>\n                        <div class=\"running-window-overlay attention\" ng-show=\"util.isDisconnected(runningItem)\"></div>\n                     </li>\n                     <li ng-class=\"{'focused-window-name': unityWindowHasFocused(runningItem, instance), 'running-window-name': true}\">{{instance.name}}</li>\n                  </ul>\n                  <li class=\"icon-button icon-close-image icon-close-running-window\" ng-click=\"closeRunningInstance(instance)\" title=\"{{'CLOSE_WINDOW_T' | i18n}}\" ng-show=\"!util.isLoadingItem(runningItem)\"></li>\n               </ul>\n            </li>\n         </ul>\n      </div>\n      </div>\n      <div ng-show=\"showLaunchPanel\" class=\"separator\"></div>\n      <div ng-show=\"showLaunchPanel\" class=\"available-title-panel\">\n         <span class=\"running-title\">{{'AVAILABLE_T' | i18n}}</span>\n         <div ng-if=\"$root.showPreference\" class=\"available-button-bar\">\n            <div class=\"icon-button all-apps-button\" ng-class=\"{'on': !showOnlyFavorites}\" ng-click=\"disableShowOnlyFavorites()\" title=\"{{'SHOW_ALL_T' | i18n}}\"></div>\n            <div class=\"icon-button favorite-apps-button\" ng-class=\"{'on': showOnlyFavorites}\" ng-click=\"enableShowOnlyFavorites()\" title=\"{{'SHOW_FAVORITES_T' | i18n}}\"></div>\n         </div>\n      </div>\n      <div ng-show=\"showLaunchPanel\" class=\"available-content-panel\">\n         <div ng-repeat =\"entitledItem in filteredEntitledItems = (entitledItems | availableItemsFilter:queryText.name:showOnlyFavorites)\">\n            <ul class=\"running-app\" title=\"Launch {{entitledItem.name}}\">\n               <ul class=\"icon-and-name-container\" ng-click=\"launchItem(entitledItem)\" title=\"{{'LAUNCH_ITEM_T' | i18n : entitledItem.name}}\" id=\"{{'available-'+entitledItem.name}}\">\n                  <li class=\"running-app-border\">\n                     <img alt=\"{{entitledItem.name}} icon\" class=\"running-app-icon\" ng-src=\"{{entitledItem.iconSrc}}\" ng-show=\"util.isApp(entitledItem)\"/>\n                     <img alt=\"{{entitledItem.name}} icon\" class=\"running-app-icon\" src=\"" + __webpack_require__(57) + "\" ng-show=\"util.isDesktop(entitledItem) && !entitledItem.isShadow\" />\n                     <img alt=\"{{entitledItem.name}} icon\" class=\"running-app-icon\" src=\"" + __webpack_require__(58) + "\" ng-show=\"util.isDesktop(entitledItem) && entitledItem.isShadow\" />\n                  </li>\n                  <li class=\"available-app-name\">{{entitledItem.name}}</li>\n               </ul>\n               <li ng-if=\"$root.showPreference && entitledItem.favorite\"\n                   class=\"available-app-favorite-button on\"\n                   title=\"{{'REMOVE_FAVORITE_T' | i18n : entitledItem.name}}\"\n                   ng-click=\"toggleFavorite(entitledItem)\">\n               </li>\n               <li ng-if=\"$root.showPreference && !entitledItem.favorite\"\n                   class=\"available-app-favorite-button off\"\n                   title=\"{{'ADD_FAVORITE_T' | i18n : entitledItem.name}}\"\n                   ng-click=\"toggleFavorite(entitledItem)\">\n               </li>\n            </ul>\n         </div>\n         <div ng-show=\"showOnlyFavorites && filteredEntitledItems.length === 0\">\n            <div class=\"no-items-label\">{{'NO_FAVORITES_T' | i18n}}</div>\n         </div>\n      </div>\n   </div>\n</div>\n<vertical-slider id=\"sidebar-toggler\"\n                class=\"panel-toggle-tab pointer-cursor sidebar-tab-image\"\n                on-click=\"$emit('togglePanel')\"\n                on-move=\"$emit('sliderMoveStart')\"\n                element-drag-styles=\"pointer-cursor resize-cursor\"\n                body-drag-styles=\"resize-cursor\">\n</vertical-slider>\n\n<div ng-show=\"showGlobalContextMenu\" class=\"menu global-context ng-hide\">\n   <div class=\"bubble\">\n      <div class=\"triangle\"></div>\n      <div class=\"triangle-border\"></div>\n      <div class=\"menu-content\">\n         <div class=\"menu-item inactive\" title=\"{{userInfo}}\" ng-click=\"\" id=\"sidebar-user-info\">\n            <div class=\"menu-item-icon icon-user-image\"></div>\n            <div class=\"menu-item-title unselectable\">{{userName}}</div>\n         </div>\n         <div class=\"separator\"></div>\n         <div class=\"menu-item\" ng-click=\"settingsClicked()\" id=\"sidebar-settings-button\">\n            <div class=\"menu-item-icon icon-settings-image\"></div>\n            <div class=\"menu-item-title\">{{'SETTINGS' | i18n}}</div>\n         </div>\n         <div class=\"menu-item\" ng-if=\"multimonOptionVisible && multimonStarted\" ng-click=\"escClicked()\" id=\"sidebar-esc-button\">\n            <div class=\"menu-item-icon icon-esc-image\"></div>\n            <div class=\"menu-item-title\">{{'ESC' | i18n}}</div>\n         </div>\n         <div class=\"menu-item\" ng-if=\"multimonOptionVisible && !multimonStarted\" ng-click=\"multimonClicked()\" id=\"sidebar-multimon-button\">\n            <div class=\"menu-item-icon icon-multimon-image\"></div>\n            <div class=\"menu-item-title\" title=\"{{'MULTIMON' | i18n}}\">{{'MULTIMON' | i18n}}</div>\n         </div>\n         <div class=\"menu-item\" ng-click=\"aboutClicked()\" id=\"sidebar-about-button\">\n            <div class=\"menu-item-icon icon-about-image\"></div>\n            <div class=\"menu-item-title\">{{'ABOUT' | i18n}}</div>\n         </div>\n         <div class=\"menu-item\" ng-click=\"logoutClicked()\" id=\"sidebar-logout-button\">\n            <div class=\"menu-item-icon icon-logoff-desktop-image\"></div>\n            <div class=\"menu-item-title\">{{'LOGOUT_T' | i18n}}</div>\n         </div>\n      </div>\n   </div>\n</div>\n\n<div ng-show=\"showItemContextMenu\" class=\"menu item-context ng-hide\">\n   <div class=\"bubble\">\n      <div class=\"triangle\"></div>\n      <div class=\"triangle-border\"></div>\n      <div class=\"menu-content\">\n         <div class=\"menu-item\" ng-click=\"logOffDesktop()\" ng-show=\"showLogOffDesktop\">\n            <div class=\"menu-item-icon icon-logoff-desktop-image\"></div>\n            <div class=\"menu-item-title\">{{'LOGOFF_T' | i18n}}</div>\n         </div>\n         <div class=\"menu-item\" ng-click=\"resetDesktop()\" ng-show=\"showResetDesktop\">\n            <div class=\"menu-item-icon icon-reset-image\"></div>\n            <div class=\"menu-item-title\">{{'RESET_M' | i18n}}</div>\n         </div>\n         <div class=\"menu-item\" ng-click=\"restartDesktop()\" ng-show=\"showRestartDesktop\">\n            <div class=\"menu-item-icon icon-restart-image\"></div>\n            <div class=\"menu-item-title\">{{'RESTART_M' | i18n}}</div>\n         </div>\n         <div class=\"menu-item\" ng-click=\"closeRunningApp(contextMenuItem)\">\n            <div class=\"menu-item-icon icon-close-desktop-image\"></div>\n            <div class=\"menu-item-title\">{{'CLOSE' | i18n}}</div>\n         </div>\n      </div>\n   </div>\n</div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 267 */
/***/ (function(module, exports) {

var path = 'launcher/common/blast-desktop.html';
var html = "<div class=\"ui-icon-loading\"></div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 268 */
/***/ (function(module, exports) {

var path = 'launcher/common/header-default.html';
var html = "<header ng-if=\"!header.hide\" class=\"navbar ui-navbar\" role=\"banner\" ng-controller=\"HeaderCtrl\">\n   <div class=\"container\" >\n      <div class=\"navbar-header pull-left\">\n         <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\".ui-navbar-links\" tabindex=\"-1\">\n            <span class=\"sr-only\">Toggle navigation</span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n         </button>\n         <a class=\"navbar-brand ui-brand\" tabindex=\"-1\"></a>\n      </div>\n      <div class=\"search-bar\" ng-class=\"{ searchFocus: focus, searchBlur: blur }\" ng-show=\"header.searchbar\">\n         <span class=\"search-icon\"></span>\n         <label for=\"header-search\">{{'Search' | i18n}}</label>\n         <input id=\"header-search\" ng-model=\"header.search\" class=\"search-input\" type=\"search\" placeholder=\"{{'Search' | i18n}}\" ng-focus=\"focus=true;blur=false;\" ng-blur=\"blur=true;focus=false;\" autofocus tabindex=\"0\">\n      </div>\n      <div class=\"navbar-header pull-right ui-navbar-links\">\n         <ul class=\"nav navbar-nav navbar-right\">\n            <li ng-if=\"$root.showPreference\" class=\"all-choice\" tabindex=\"0\" ng-keyup=\"enterKeypress($event, showAll)\">\n               <a id=\"showAllBtn\" ng-click=\"showAll()\" href=\"\" ng-class=\"showAllStyle\" title=\"{{'show_all' | i18n}}\" tabindex=\"-1\">{{'show_all' | i18n}}</a>\n            </li>\n            <li ng-if=\"$root.showPreference\" class=\"favorite-choice\" tabindex=\"0\" ng-keyup=\"enterKeypress($event, showFavorites)\">\n               <a id=\"showFavoritesBtn\" ng-click=\"showFavorites()\" href=\"\" ng-class=\"showFavStyle\" title=\"{{'show_fav' | i18n}}\" tabindex=\"-1\">{{'show_fav' | i18n}}</a>\n            </li>\n            <li tabindex=\"0\" ng-keyup=\"enterKeypress($event, showSetting)\">\n               <a id=\"settingsBtn\" href=\"\" class=\"setting\" title=\"{{'settings' | i18n}}\" ng-click=\"showSetting()\" tabindex=\"-1\">{{'settings' | i18n}}</a>\n            </li>\n            <li tabindex=\"0\" ng-keyup=\"enterKeypress($event, showHelp)\">\n               <a id=\"helpBtn\" href=\"\" ng-click=\"showHelp()\" target=\"_blank\" title=\"{{'header_help_link' | i18n}}\" class=\"help\" tabindex=\"-1\">{{'header_help_link' | i18n}}</a>\n            </li>\n            <li tabindex=\"0\" ng-show=\"header.logout\" ng-keyup=\"enterKeypress($event, logout)\">\n               <a id=\"logoutBtn\" ng-click=\"logout()\" title=\"{{'dialog_title_logout' | i18n}}\" class=\"logout\" tabindex=\"-1\">{{'dialog_title_logout' | i18n}}</a>\n            </li>\n         </ul>\n      </div>\n   </div>\n</header>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 269 */
/***/ (function(module, exports) {

var path = 'launcher/common/home-warning.html';
var html = "<div class=\"ui-content-area login-bg\">\n   <div class=\"container\">\n      <div class=\"ui-center-panel\">\n         <div class=\"ui-pattern-logo\"></div>\n            <div id=\"warningContainer\" ng-class=\"{'ui-browser-mobile': isMobileBrowser}\">\n               <div class=\"ui-browser-warning ui-browser-warning-unsupport\">\n                     <p class=\"top-warning\"><span class=\"ui-warning-logo\"></span>{{\"browser_compatibility_warn\" | i18n}}</p>\n                     <p class=\"top-warning\" id=\"cookieWarning\" ng-show=\"showCookieWarning\">{{\"browser_compatibility_cookie\" | i18n}}</p>\n               </div>\n               <div class=\"portal-ui-list\">\n                  <div class=\"portal-list-item pull-left\">\n                     <a id=\"nativeClient\" ng-href=\"{{nativeInstallerLink}}\" title=\"\">\n                        <div class=\"portal-native-client\"></div>\n                        <div class=\"portal-list-title\">{{\"install_native_client\" | i18n}}</div>\n                     </a>\n                  </div>\n                  <div class=\"middle-line\"></div>\n                  <div class=\"portal-list-item pull-right\" ng-show=\"continueAllowed\">\n                     <a ng-click=\"goNext()\" id=\"browserWarningContinue\">\n                        <div class=\"portal-list-title\">{{\"browser_compatibility_continue\" | i18n}}</div>\n                        <div class=\"portal-list-title\">{{\"browser_compatibility_not_recommended\" | i18n}}</div>\n                     </a>\n                  </div>\n               </div>\n            </div>\n         </div>\n      </div>\n   </div>\n   <div class=\"bottom-logo\"></div>\n</div>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

var path = 'launcher/common/progress-circle.html';
var html = "<span class=\"progress-circle\" ng-if=\"ajaxBusy && loadingAllow\"><img src=\"" + __webpack_require__(254) + "\"></span>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var path = 'launcher/launchitems/launchitems.html';
var html = "<div class=\"container\" ng-class=\"ajaxBusy ? 'ui-fade' : ''\">\n   <ul class=\"ui-desktop-list\" ng-show=\"showLaunchPanel\">\n      <li ng-show=\"show(desktop)\" ng-repeat=\"desktop in desktops | filter:{name:search} | orderBy:'name'\" id=\"{{desktop.id}}\" scroll-top=\"isHighlighted(desktop)\" tabindex=\"0\" ng-click=\"launchDesktop(desktop, $event)\" ng-keypress=\"keypressHandler($event)\" ng-keyup=\"keyboardHandler($event, desktop, true)\" ng-focus=\"highlightItems(desktop, $event)\" ng-blur=\"removeHighlight()\">\n         <div class=\"ui-btn ui-btn-a ui-desktop-corner\" ng-class=\"{highlight:activeItem===desktop}\" id=\"launch-{{desktop.id}}\"  title=\"{{desktop.name}}\">\n            <span class=\"ui-desktop-icon\">\n               <img src=\"" + __webpack_require__(249) + "\" alt=\"{{desktop.name}} icon\"class=\"ui-desktop-icon\" ng-show=\"{{!desktop.isShadow}}\">\n               <img src=\"" + __webpack_require__(253) + "\" alt=\"desktop icon\" class=\"ui-desktop-icon\" ng-show=\"{{desktop.isShadow}}\">\n               <span class=\"desktop-auto-start\" ng-show=\"\"></span>\n            </span>\n            <div class=\"ellipsis\">\n               <p class=\"ui-desktop-name\" title=\"{{desktop.name}}\">{{desktop.name}}</p>\n            </div>\n            <div ng-if=\"$root.showPreference\" class=\"favorite-btn\">\n               <a ng-click=\"makeFavorite(desktop,$event);\" id=\"favorite-{{desktop.id}}\" ng-class=\"desktop.favorite ? 'favorite-on' : 'favorite-off'\"  title=\"{{ desktop.favorite ? unfavTip : favTip}}\"></a>\n            </div>\n         </div>\n      </li>\n   </ul>\n</div>\n<div class=\"ui-desktop-list-line\" ng-show=\"showLaunchPanel && (desktops | filter:{name:search}).length > 0 && (applications  | filter:{name:search}).length > 0 && showline\"></div>\n<div class=\"container\" ng-class=\"ajaxBusy ? 'ui-fade' : ''\">\n   <ul class=\"ui-desktop-list\" ng-show=\"showLaunchPanel\">\n      <li ng-show=\"show(application)\" ng-repeat=\"application in applications  | filter:{name:search} | orderBy:'name'\" id=\"{{application.id}}\" scroll-top=\"isHighlighted(application)\" tabindex=\"0\" ng-click=\"launchCurrentApplication(application, $event)\" ng-keypress=\"keypressHandler($event)\" ng-keyup=\"keyboardHandler($event, application, false)\" ng-focus=\"highlightItems(application, $event)\" ng-blur=\"removeHighlight()\">\n          <div class=\"ui-btn ui-btn-a ui-desktop-corner\" ng-class=\"{highlight:activeItem===application}\" id=\"launch-{{application.id}}\" title=\"{{application.name}}\">\n            <img ng-src=\"{{application.icon.path}}\" alt=\"{{application.name}} icon\" class=\"ui-desktop-icon ui-app-icon\" fallback-src=\"replace-icon\" >\n            <div class=\"ellipsis\">\n               <p class=\"ui-desktop-name\" title=\"{{application.name}}\">{{application.name}}</p>\n            </div>\n            <div ng-if=\"$root.showPreference\" class=\"favorite-btn\">\n               <a ng-click=\"makeFavorite(application,$event);\" id=\"favorite-{{application.id}}\" ng-class=\"application.favorite ? 'favorite-on' : 'favorite-off'\" title=\"{{ application.favorite ? unfavTip : favTip}}\"></a>\n            </div>\n         </div>\n      </li>\n   </ul>\n</div>\n<div class=\"container\" ng-show=\"showNoFavorites(desktops,applications)\">\n   <div class=\"no-favorites\"></div>\n   <div class=\"no-favorites-word\">{{'noFavorites' | i18n}}</div>\n</div>\n<div ng-show=\"ajaxBusy\" class=\"ui-icon-loading\"></div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 272 */
/***/ (function(module, exports) {

var path = 'launcher/login/change-password.html';
var html = "<div class=\"ui-content-area login-bg\">\n   <div class=\"container\">\n      <div class=\"ui-center-panel ui-widget-home\">\n         <div class=\"ui-pattern-logo\"></div>\n         <div class=\"ui-panel-content\">\n            <div ng-if=\"!error\" class=\"ui-login-hint-text\">{{'dialog_prompt_changepwd' | i18n}}</div>\n            <div class=\"alert alert-danger\" ng-if=\"error\">\n               <span class=\"error\"></span>{{error}}\n            </div>\n            <form id=\"changePasswordForm\" name=\"changePasswordForm\" role=\"form\" class=\"change-password-form form-horizontal\" method=\"post\" autocomplete=\"off\" novalidate>\n               <input id=\"username\" name=\"username\" type=\"text\" class=\"form-control\" placeholder=\"{{'dialog_placeholder_username' | i18n}}\" ng-model=\"username\" readonly>\n\n               <input id=\"oldpassword\" name=\"oldpassword\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_oldpwd' | i18n}}\" ng-model=\"credential.oldpassword\" ng-keypress=\"keyPress($event, changePasswordForm)\" ng-trim=\"false\" view-autofocus=\"true\">\n\n\n               <input id=\"newpassword1\" name=\"newpassword1\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_newpwd' | i18n}}\" ng-model=\"credential.newpassword\" ng-keypress=\"keyPress($event, changePasswordForm)\" equal-to=\"{{credential.newpasswordRepeat}}\" ng-trim=\"false\">\n\n               <div class=\"ui-text-left-align\">\n                  <input id=\"newpassword2\" name=\"newpassword2\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_newpwd2' | i18n}}\" ng-model=\"credential.newpasswordRepeat\" ng-keypress=\"keyPress($event, changePasswordForm)\" equal-to=\"{{credential.newpassword}}\" ng-trim=\"false\">\n                  <label for=\"newpassword2\" class=\"ui-password-dismatch-text\" ng-show=\"!changePasswordForm.$valid\">{{'validation_equals' | i18n}}</label>\n               </div>\n            </form>\n         </div>\n         <div class=\"ui-panel-footer\">\n            <button id=\"changePasswordSubmitBtn\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy&& loadingAllow}\" ng-click=\"changePassword(changePasswordForm)\" ng-disabled=\"ajaxBusy&& loadingAllow\">{{ (ajaxBusy && loadingAllow) ? 'dialog_btn_signin_waiting' : 'dialog_btn_signin' | i18n}}<progress-circle></progress-circle></button>\n            <button id=\"changePasswordCancelBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\">{{'dialog_quit_cancel' | i18n}}</button>\n         </div>\n      </div>\n      <help-link></help-link>\n   </div>\n   <div class=\"bottom-logo\"></div>\n</div>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 273 */
/***/ (function(module, exports) {

var path = 'launcher/login/login.html';
var html = "<div class=\"ui-content-area login-bg\">\n   <div class=\"container\">\n      <div class=\"ui-center-panel\">\n         <div class=\"ui-pattern-logo\"></div>\n         <div ng-controller=\"WaitingCtrl\" ng-show=\"showWaiting\" class=\"ui-widget-home ui-icon-loading-container\">\n            <div class=\"ui-panel-content\"></div>\n            <div class=\"ui-icon-loading\"></div>\n         </div>\n         <div ng-controller=\"DisclaimerCtrl\" ng-if=\"showDisclaimer\" class=\"ui-disclaimer-panel\">\n            <div class=\"ui-panel-content\" >\n              <pre class=\"ui-disclaimer-text pre-scrollable\" tabindex=\"0\">{{disclaimerText}}</pre>\n            </div>\n\n            <div class=\"ui-panel-footer\">\n              <button id=\"acceptDisclaimerBtn\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy&& loadingAllow}\" ng-disabled=\"ajaxBusy&& loadingAllow\" ng-click=\"accept()\" view-autofocus=\"true\">{{'dialog_wait_accept' | i18n}}<progress-circle></progress-circle></button>\n              <button id=\"cancelDisclaimerBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\">{{'dialog_quit_cancel' | i18n}}</button>\n            </div>\n         </div>\n         <div ng-controller=\"WindowsPasswordCtrl\" class=\"ui-widget-home\" ng-if=\"showWindowsPassword\">\n            <div class=\"ui-panel-content \">\n               <div class=\"alert alert-danger\">\n                  <span class=\"error\" ng-if=\"error\"></span>{{error}}\n               </div>\n               <form id=\"loginForm\" name=\"loginForm\" role=\"form\" class=\"form-horizontal\" method=\"post\" autocomplete=\"off\" novalidate>\n                  <label for=\"username\">{{'dialog_placeholder_username' | i18n}}</label>\n                  <input id=\"username\" name=\"username\" type=\"text\" class=\"form-control\" placeholder=\"{{'dialog_placeholder_username' | i18n}}\" ng-model=\"credential.username\" ng-keypress=\"keyPress($event, loginForm)\" ng-change=\"usernameChange()\" ng-trim=\"false\" ng-disabled=\"userNameReadOnly\" ng-blur=\"updateUsername()\" required view-autofocus=\"{{!userNameReadOnly}}\">\n                  <label for=\"password\">{{'dialog_placeholder_password' | i18n}}</label>\n                  <input id=\"password\" name=\"password\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_password' | i18n}}\" ng-model=\"credential.password\" ng-keypress=\"keyPress($event, loginForm)\" ng-trim=\"false\" view-autofocus=\"{{userNameReadOnly}}\">\n                  <label for=\"domain\">{{'dialog_label_domain' | i18n}}</label>\n                  <select id=\"domain\" name=\"domain\" class=\"form-control form-select\" ng-model=\"credential.domain\" ng-keypress=\"keyPress($event, loginForm)\"  ng-disabled=\"domainReadOnly\" ng-options=\"domain for domain in domains\" domain-select-menu>\n                  </select>\n               </form>\n            </div>\n            <div class=\"ui-panel-footer\">\n               <button id=\"loginButton\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy && loadingAllow}\" ng-click=\"login(loginForm)\" ng-disabled=\"(ajaxBusy && loadingAllow) || !loginForm.$valid\">{{ (ajaxBusy && loadingAllow) ? 'dialog_btn_signin_waiting' : 'dialog_btn_signin' | i18n}}<progress-circle></progress-circle></button>\n               <button id=\"cancelLoginBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\" >{{'dialog_quit_cancel' | i18n}}</button>\n            </div>\n         </div>\n         <div ng-controller=\"SecuridPasscodeCtrl\" class=\"ui-widget-home\" ng-if=\"showSecurIDPasscode\">\n            <div class=\"ui-panel-content securid-passcode\">\n               <div ng-if=\"!error && (authType !== 'RADIUS')\" class=\"ui-login-hint-text\">\n                  <span class=\"ui-icon-rsa\"></span>\n                  {{'dialog_prompt_passcode' | i18n:'RSA SecurID'}}\n               </div>\n               <div ng-if=\"!error && (authType === 'RADIUS')\" class=\"ui-login-hint-text\">{{titleString}}</div>\n               <div class=\"alert alert-danger\" ng-if=\"error\" >\n                  <span class=\"error\"></span>{{error}}\n               </div>\n               <form id=\"securidPasscodeForm\" name=\"securidPasscodeForm\" role=\"form\" class=\"form-horizontal\" method=\"post\" autocomplete=\"off\" novalidate>\n                  <input id=\"securUsername\" name=\"username\" type=\"text\" class=\"form-control\" placeholder=\"{{'dialog_placeholder_username' | i18n}}\" ng-model=\"credential.username\" ng-keypress=\"keyPress($event, securidPasscodeForm)\" ng-change=\"usernameChange()\" ng-trim=\"false\" ng-blur=\"updateUsername()\" required view-autofocus=\"true\">\n                  <div ng-if=\"authType !== 'RADIUS'\" class=\"ui-input-group\">\n                     <input id=\"passcode\" name=\"passcode\" unstorable-password class=\"form-control ui-input-group-textfield-addon\" placeholder=\"{{'dialog_placeholder_passcode' | i18n}}\" ng-model=\"credential.passcode\" ng-keypress=\"keyPress($event, securidPasscodeForm)\" ng-trim=\"false\" required>\n                  </div>\n                  <input ng-if=\"authType === 'RADIUS'\" id=\"passcode\" name=\"passcode\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_passcode' | i18n}}\" ng-model=\"credential.passcode\" ng-keypress=\"keyPress($event, securidPasscodeForm)\" ng-trim=\"false\">\n               </form>\n            </div>\n            <div class=\"ui-panel-footer\">\n               <button id=\"securLoginButton\" type=\"submit\" class=\"btn btn-primary\" ng-click=\"login(securidPasscodeForm)\" ng-class=\"{btnPrimaryWaiting:ajaxBusy&& loadingAllow}\" ng-disabled=\"(ajaxBusy&& loadingAllow) || !securidPasscodeForm.$valid\">{{ (ajaxBusy && loadingAllow) ? 'dialog_btn_signin_waiting' : 'dialog_btn_signin' | i18n}}<progress-circle></progress-circle></button>\n               <button id=\"securCancelLoginBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\">{{'dialog_quit_cancel' | i18n}}</button>\n            </div>\n         </div>\n         <div ng-controller=\"UnauthenticatedCtrl\" class=\"ui-widget-home\" ng-if=\"showUnauthenticated\">\n            <div class=\"ui-panel-content \">\n               <div class=\"alert alert-danger\">\n                  <span class=\"error\" ng-if=\"error\"></span>{{error}}\n               </div>\n               <form id=\"unauthenticatedForm\" name=\"unauthenticatedForm\" role=\"form\" class=\"form-horizontal\" method=\"post\" autocomplete=\"off\" novalidate>\n                  <select id=\"unauthenticatedUsername\" name=\"unauthenticatedUsername\" class=\"form-control form-select\" ng-model=\"credential.username\" ng-keypress=\"keyPress($event, unauthenticatedForm)\" ng-options=\"username.displayName for username in usernames track by username.value\" view-autofocus=\"true\" anonymous-select>\n                  </select>\n               </form>\n            </div>\n            <div class=\"ui-panel-footer\">\n               <button id=\"unauthenticatedLoginButton\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy && loadingAllow}\" ng-click=\"login(unauthenticatedForm)\" ng-disabled=\"(ajaxBusy && loadingAllow) || !unauthenticatedForm.$valid\">{{ (ajaxBusy && loadingAllow) ? 'dialog_btn_signin_waiting' : 'dialog_btn_signin' | i18n}}<progress-circle></progress-circle></button>\n               <button id=\"unauthenticatedCancelLoginBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\" >{{'dialog_quit_cancel' | i18n}}</button>\n            </div>\n         </div>\n      </div>\n      <help-link></help-link>\n      <download-link></download-link>\n   </div>\n   <div class=\"bottom-logo\"></div>\n</div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 274 */
/***/ (function(module, exports) {

var path = 'launcher/login/securid-nexttokencode.html';
var html = "<div class=\"ui-content-area login-bg\">\n   <div class=\"container\">\n      <div class=\"ui-center-panel ui-widget-home\">\n         <div class=\"ui-pattern-logo\"></div>\n         <div class=\"ui-panel-content next-token\">\n            <div class=\"ui-login-hint-text ui-multi-line-margin ui-multi-line ui-text-left-align selectable\">{{challengeString}}</div>\n            <form id=\"securidNextTokenForm\" name=\"securidNextTokenForm\" role=\"form\" class=\"form-horizontal\" method=\"post\" autocomplete=\"off\" novalidate>\n               <input id=\"passcode\" name=\"passcode\" unstorable-password class=\"form-control\" placeholder=\"{{'dialog_placeholder_nexttoken' | i18n}}\" ng-model=\"credential.passcode\" ng-keypress=\"keyPress($event, securidNextTokenForm)\" ng-trim=\"false\" required view-autofocus=\"true\">\n            </form>\n         </div>\n         <div class=\"ui-panel-footer\">\n            <button id=\"loginButton\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy&& loadingAllow}\" ng-click=\"login(securidNextTokenForm)\" ng-disabled=\"(ajaxBusy&& loadingAllow)||!securidNextTokenForm.$valid\">{{'dialog_wait_continue' | i18n}}<progress-circle></progress-circle></button>\n            <button id=\"cancelLoginBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\">{{'dialog_quit_cancel' | i18n}}</button>\n         </div>\n      </div>\n      <help-link></help-link>\n   </div>\n   <div class=\"bottom-logo\"></div>\n</div>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 275 */
/***/ (function(module, exports) {

var path = 'launcher/login/securid-pinchange.html';
var html = "<div class=\"ui-content-area login-bg\">\n   <div class=\"container\">\n      <div class=\"ui-center-panel ui-widget-home\">\n         <div class=\"ui-pattern-logo\"></div>\n         <div class=\"ui-panel-content\">\n            <div class=\"alert alert-danger\" >\n               <span class=\"error\" ng-if=\"error\"></span>{{error}}\n            </div>\n            <h3 class=\"ui-multi-line ui-text-left-align\" ng-if=\"!!prompt\"><small>{{prompt}}</small></h3>\n            <form id=\"securidPinChangeForm\" name=\"securidPinChangeForm\" role=\"form\" class=\"form-horizontal\" method=\"post\" autocomplete=\"off\" novalidate>\n               <input id=\"pin1\" name=\"pin1\" type=\"{{pin1Type}}\" class=\"form-control\" placeholder=\"{{'dialog_placeholder_pin1' | i18n}}\" ng-model=\"pin1\" ng-readonly=\"pin1ReadOnly\" ng-trim=\"false\" required view-autofocus=\"{{!pin1ReadOnly}}\">\n               <div class=\"ui-text-left-align\">\n                  <input id=\"pin2\" name=\"pin2\" unstorable-password class=\"form-control bottom-input\" placeholder=\"{{'dialog_placeholder_pin2' | i18n}}\" ng-model=\"pin2\" ng-keypress=\"keyPress($event, securidPinChangeForm)\" equal-to=\"{{pin1}}\" ng-trim=\"false\" view-autofocus=\"{{pin1ReadOnly}}\">\n                  <label for=\"pin2\" class=\"ui-password-dismatch-text\" ng-show=\"securidPinChangeForm.pin2.$invalid\">{{'validation_equals' | i18n}}</label>\n               </div>\n            </form>\n         </div>\n         <div class=\"ui-panel-footer\">\n            <button id=\"loginButton\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy && loadingAllow}\" ng-click=\"login(securidPinChangeForm)\" ng-disabled=\"(ajaxBusy && loadingAllow) || !securidPinChangeForm.$valid\">{{ (ajaxBusy && loadingAllow) ? 'dialog_btn_signin_waiting' : 'dialog_btn_signin' | i18n}}<progress-circle></progress-circle></button>\n            <button id=\"cancelLoginBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\">{{'dialog_quit_cancel' | i18n}}</button>\n         </div>\n      </div>\n      <help-link></help-link>\n   </div>\n   <div class=\"bottom-logo\"></div>\n</div>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 276 */
/***/ (function(module, exports) {

var path = 'launcher/login/securid-wait.html';
var html = "<div class=\"ui-content-area login-bg\">\n   <div class=\"container\">\n      <div class=\"ui-center-panel ui-widget-home\">\n         <div class=\"ui-pattern-logo\"></div>\n         <div class=\"ui-panel-content ui-text-left-align panel-text\">\n            <h3 class=\"ui-rsa-title\"><small>{{'dialog_wait_help1' | i18n}}</small></h3>\n            <h3><small>{{'dialog_wait_help2' | i18n}}</small></h3>\n         </div>\n         <div class=\"ui-panel-footer\">\n            <button id=\"loginButton\" type=\"submit\" class=\"btn btn-primary\" ng-class=\"{btnPrimaryWaiting:ajaxBusy&& loadingAllow}\" ng-click=\"login()\" ng-disabled=\"disabled\">{{'dialog_wait_continue' | i18n}}<progress-circle></progress-circle></button>\n            <button id=\"cancelLoginBtn\" type=\"submit\" class=\"btn btn-default\" ng-click=\"cancel()\">{{'dialog_quit_cancel' | i18n}}</button>\n         </div>\n      </div>\n      <help-link></help-link>\n   </div>\n   <div class=\"bottom-logo\"></div>\n</div>\n";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ }),
/* 277 */
/***/ (function(module, exports) {

var path = 'launcher/setting-dialog/setting-dialog-launcher.html';
var html = "<scrollable-dialog>\n   <div class=\"dialog-title\">{{'SETTINGS' | i18n}}</div>\n\n   <div class=\"dialog-content\" fuzzy>\n      <div ng-repeat=\"switch in toggleSwitches\" ng-if='switch.isSupported'>\n         <div class=\"settings-container clearfix\" >\n            <div class=\"settings-toggle-container\">\n               <div class=\"settings-switch-label\">{{'OFF_CAPS_M' | i18n}}</div>\n               <div class=\"toggle-opt\" tabindex=\"0\" ng-keyup=\"onKeypress($event)\">\n                  <input class=\"tgl tgl-light\" id=\"{{switch.id}}\" type=\"checkbox\" ng-show=\"false\" ng-model=\"switch.isEnabled\" ng-change=\"switch.toggle()\">\n                  <label class=\"tgl-btn unselectable\" for=\"{{switch.id}}\"></label>\n               </div>\n               <div class=\"settings-switch-label\">{{'ON_CAPS_M' | i18n}}</div>\n            </div>\n            <span class=\"settings-label\">{{switch.label}}</span>\n            <span class=\"settings-text\" ng-show=\"{{!!switch.text}}\">{{switch.text}}</span>\n            <div ng-if=\"switch.id==='timezone'\" id=\"setTimezone\" class=\"clearfix\">\n               <div id=\"timezone-list-container\">\n                  <timezone-list></timezone-list>\n               </div>\n            </div>\n         </div>\n         <div class=\"settings-separator\" ng-show='switch.isSupported'></div>\n      </div>\n\n      <div class=\"settings-container\">\n         <button class=\"modal-button-base modal-button-blue modal-button-reset\" ng-class=\"{disable:applicationCanSet===false}\" ng-click=\"showResetConfirmDialog()\" title=\"{{'RESET_APPS_T' | i18n}}\">{{'RESET_M' | i18n}}</button>\n         <span class=\"settings-label\">{{'RESET_APPS_M' | i18n}}</span>\n         <span class=\"settings-text warning\">{{'UNSAVED_WORK_M' | i18n}}</span>\n      </div>\n   </div>\n\n   <div class=\"dialog-button-row\">\n      <button id=\"closeSettingsBtn\" class=\"modal-button-base modal-button-right modal-button-blue\" ng-click=\"closeThisDialog()\" dialog-prevent-key-up>\n         {{'CLOSE' | i18n}}\n      </button>\n   </div>\n</scrollable-dialog>";
window.angular.module('com.vmware.vdi.htmlaccess.template').run(['$templateCache', function(c) { c.put(path, html) }]);
module.exports = path;

/***/ })
],[79]);
//# sourceMappingURL=app-htmlaccess.cc050c0b31e6616b259f.js.map